globals
//globals from AddRepeatedString:
constant boolean LIBRARY_AddRepeatedString=true
//endglobals from AddRepeatedString
//globals from AdvancedQuest:
constant boolean LIBRARY_AdvancedQuest=true
constant string AdvancedQuest__titleString= "|cffffcc00Title|r: "
constant string AdvancedQuest__descriptionPrefix= "|cffffcc00Description|r: "
constant string AdvancedQuest__progressPrefix= "|cffffcc00Progress|r: "
constant string AdvancedQuest__rewardPrefix= "|cffffcc00Reward|r: "
constant string AdvancedQuest__newline= "\n"
constant string AdvancedQuest__newline2x= "\n\n"
constant string AdvancedQuest__perProgressPrefix= "  - "
constant string AdvancedQuest__perProgressSuffix= ": "
constant string AdvancedQuest__intseperator= "/"
constant string AdvancedQuest__finishedcolor= "|cffAAAAAA"
integer qur
//endglobals from AdvancedQuest
//globals from Ascii:
constant boolean LIBRARY_Ascii=true
integer array Ascii__i
string array Ascii__c
//endglobals from Ascii
//globals from BaseFunction:
constant boolean LIBRARY_BaseFunction=true
force tempForce
real specific
unit specific2
unit BaseFunction__specific3
timer gameTimer
unit filterHost= null
item globalitem
player applicablePlayer
force applicableForce
constant integer casterDummy= 'h004'
player BaseFunction__red= Player(0)
unit eateverything
constant real BaseFunction__E= 2.718282
constant real BaseFunction__E_INV= 0.3678794
constant real BaseFunction__LN_FACTOR= 1.2840254
constant real BaseFunction__LN_FACTOR_INV= 0.7788008
integer array BaseFunction__powsOfTwo
filterfunc viableTargetFilter1
filterfunc viableTargetFilter2
filterfunc viableTargetFilter3
filterfunc viableTargetFilter4
filterfunc viableTargetFilter5
filterfunc viableTargetFilter6
filterfunc viableTargetFilter7
filterfunc viableTargetFilter8
filterfunc viableTargetFilter9
filterfunc viableTargetFilter10
unit array units
integer index
filterfunc viableTargetFilter11
unit BaseFunction__returnUnit= null
filterfunc viableTargetFilter12
integer tempintdonttouch
integer BaseFunction__attachtable
integer BaseFunction__timers
//endglobals from BaseFunction
//globals from BinaryHeap:
constant boolean LIBRARY_BinaryHeap=true
//endglobals from BinaryHeap
//globals from BoundSentinel:
constant boolean LIBRARY_BoundSentinel=true
constant boolean BoundSentinel___ALLOW_OUTSIDE_PLAYABLE_MAP_AREA= false
real BoundSentinel___maxx
real BoundSentinel___maxy
real BoundSentinel___minx
real BoundSentinel___miny
//endglobals from BoundSentinel
//globals from BountySystem:
constant boolean LIBRARY_BountySystem=true
hashtable BountySystem___BountyHash= InitHashtable()
real BountySystem___radius= 1500.
trigger BountySystem___onComp
//endglobals from BountySystem
//globals from Buffer:
constant boolean LIBRARY_Buffer=true
integer Buffer__s= 0
integer Buffer__p= 0
integer array Buffer__v
//endglobals from Buffer
//globals from CTL:
constant boolean LIBRARY_CTL=true
integer CTL___tgc= 0
integer array CTL___tgr
        
integer CTL___ic=0
integer CTL___tc=0
integer array CTL___rf
integer array CTL___n
integer array CTL___p
integer array CTL___th
integer array CTL___ns
trigger CTL___t=CreateTrigger()
timer CTL___m=CreateTimer()
triggercondition array CTL___ct
conditionfunc array CTL___rc
        
boolean array CTL___e32
integer array CTL___i32r
integer CTL___i32cr= 0
boolean array CTL___ir32
boolean array CTL___id32
//endglobals from CTL
//globals from ColorCodeString:
constant boolean LIBRARY_ColorCodeString=true
//endglobals from ColorCodeString
//globals from CompressInt:
constant boolean LIBRARY_CompressInt=true
//endglobals from CompressInt
//globals from CustomDrop:
constant boolean LIBRARY_CustomDrop=true
hashtable CustomDrop___Hash_t= InitHashtable()
location CustomDrop___SendToItem= Location(0, 0)
//endglobals from CustomDrop
//globals from CustomInventoryTraitHandler:
constant boolean LIBRARY_CustomInventoryTraitHandler=true
//endglobals from CustomInventoryTraitHandler
//globals from Dungeon:
constant boolean LIBRARY_Dungeon=true
boolean Dungeon___occu= false
integer Dungeon___current= - 1
trigger array Dungeon___start
group Dungeon_units
rect lobby
//endglobals from Dungeon
//globals from Event:
constant boolean LIBRARY_Event=true
real Event___q=0
//endglobals from Event
//globals from GetClosestWidget:
constant boolean LIBRARY_GetClosestWidget=true
unit array GetClosestWidget___Q
real array GetClosestWidget___V
integer GetClosestWidget___C=0
//endglobals from GetClosestWidget
//globals from GetPlayerColored:
constant boolean LIBRARY_GetPlayerColored=true
string array GetPlayerColored___PlayerColor
integer array GetPlayerColored___redhex
integer array GetPlayerColored___greenhex
integer array GetPlayerColored___bluehex
//endglobals from GetPlayerColored
//globals from GetRequiredXP:
constant boolean LIBRARY_GetRequiredXP=true
//endglobals from GetRequiredXP
//globals from GroupUtils:
constant boolean LIBRARY_GroupUtils=true
    //* Group for use with all instant enumerations
group ENUM_GROUP= CreateGroup()
    
    //* Temporary references for GroupRefresh
boolean GroupUtils___Flag= false
group GroupUtils___Refr= null
    
    //* Assorted constants
constant integer GroupUtils___MAX_HANDLE_COUNT= 408000
constant integer GroupUtils___MIN_HANDLE_ID= 0x100000
    
    //* Arrays and counter for the group stack
group array GroupUtils___Groups
// processed:     integer array GroupUtils___Status[GroupUtils___MAX_HANDLE_COUNT]
integer GroupUtils___Count= 0
//endglobals from GroupUtils
//globals from HeroImage:
constant boolean LIBRARY_HeroImage=true
//endglobals from HeroImage
//globals from InitSave:
constant boolean LIBRARY_InitSave=true
trigger InitSave__saveTrigger= null
trigger InitSave__loadTrigger= null
//endglobals from InitSave
//globals from ItemGeneration:
constant boolean LIBRARY_ItemGeneration=true
//endglobals from ItemGeneration
//globals from ItemStacker:
constant boolean LIBRARY_ItemStacker=true
//endglobals from ItemStacker
//globals from LinkedListModule:
constant boolean LIBRARY_LinkedListModule=true
//endglobals from LinkedListModule
//globals from Loc:
constant boolean LIBRARY_Loc=true
//endglobals from Loc
//globals from PartyLib:
constant boolean LIBRARY_PartyLib=true
        
//endglobals from PartyLib
//globals from RegisterPlayerUnitEvent:
constant boolean LIBRARY_RegisterPlayerUnitEvent=true
trigger array RegisterPlayerUnitEvent___t
//endglobals from RegisterPlayerUnitEvent
//globals from RemoveString:
constant boolean LIBRARY_RemoveString=true
//endglobals from RemoveString
//globals from SaveCodeToHD:
constant boolean LIBRARY_SaveCodeToHD=true
string array SaveCodeToHD__playerName
boolean SaveCodeToHD__isGameOnline
//endglobals from SaveCodeToHD
//globals from SimError:
constant boolean LIBRARY_SimError=true
sound SimError___error
//endglobals from SimError
//globals from T32:
constant boolean LIBRARY_T32=true
constant real T32_PERIOD=0.03125
constant integer T32_FPS=R2I(1 / T32_PERIOD)
integer T32_Tick=0
        
//==============================================================================
trigger T32___Trig=CreateTrigger()
//endglobals from T32
//globals from T32API:
constant boolean LIBRARY_T32API=true
//endglobals from T32API
//globals from TTDemo:
constant boolean LIBRARY_TTDemo=true
//endglobals from TTDemo
//globals from Table:
constant boolean LIBRARY_Table=true
integer Table___less= 0
integer Table___more= 8190
    //Configure it if you use more than 8190 "key" variables in your map (this will never happen though).
    
hashtable Table___ht= InitHashtable()
constant integer Table___sizeK=10
constant integer Table___listK=11
//endglobals from Table
//globals from TerrainPathability:
constant boolean LIBRARY_TerrainPathability=true
constant real TerrainPathability___MAX_RANGE= 10.
constant integer TerrainPathability___DUMMY_ITEM_ID= 'wolg'
item TerrainPathability___Item= null
rect TerrainPathability___Find= null
item array TerrainPathability___Hid
integer TerrainPathability___HidMax= 0
real TerrainPathability_X= 0.
real TerrainPathability_Y= 0.
//endglobals from TerrainPathability
//globals from TimedLightnings:
constant boolean LIBRARY_TimedLightnings=true
constant real TimedLightnings___TO= 0.03125000
        
integer TimedLightnings___CT= 0
timer TimedLightnings___TMR= CreateTimer()
location TimedLightnings___loc= Location(0, 0)
//endglobals from TimedLightnings
//globals from TimerUtils:
constant boolean LIBRARY_TimerUtils=true
hashtable TimerUtils___hasht
timer array TimerUtils___tT
integer TimerUtils___tN= 0
constant integer TimerUtils___HELD=0x28829022
        //use a totally random number here, the more improbable someone uses it, the better.
//endglobals from TimerUtils
//globals from TraitConstants:
constant boolean LIBRARY_TraitConstants=true
constant integer SLOT_BELT= 1
constant integer SLOT_HELM= 2
constant integer SLOT_GLOVE= 3
constant integer SLOT_ARMOR= 4
constant integer SLOT_MAINHAND= 5
constant integer SLOT_OFFHAND= 6
constant integer SLOT_OFFHANDONLY= 101
constant integer SLOT_RINGLEFT= 7
constant integer SLOT_RINGRIGHT= 8
constant integer SLOT_BOOTS= 9
constant integer SLOT_NECKLACE= 10
constant integer SLOT_PANTS= 11
constant integer SLOT_WING= 12
constant integer TYPE_RECIPE= 50
constant integer TYPE_MATERIAL= 51
        
        //Damage
constant integer TRAIT_TYPE_DAMAGE= 1
constant integer TRAIT_TYPE_FIRE_DAMAGE= 3
constant integer TRAIT_TYPE_LIGHTNING_DAMAGE= 4
constant integer TRAIT_TYPE_STATIC_DAMAGE= 14
constant integer TRAIT_TYPE_COLD_DAMAGE= 9
constant integer TRAIT_TYPE_POISON_DAMAGE= 23
constant integer TRAIT_TYPE_FIRE_MAX_DAMAGE= 8
constant integer TRAIT_TYPE_STATIC_MAX_DAMAGE= 12
constant integer TRAIT_TYPE_LIGHTNING_MAX_DAMAGE= 21
constant integer TRAIT_TYPE_COLD_MAX_DAMAGE= 22
constant integer TRAIT_TYPE_POISON_MAX_DAMAGE= 24
        //Damage Affix
constant integer TRAIT_TYPE_ATTACK_SPEED= 17
constant integer TRAIT_TYPE_LIFE_LEECH= 19
constant integer TRAIT_TYPE_ARMOR_REDUCTION= 37
        //Armor
constant integer TRAIT_TYPE_ARMOR= 2
constant integer TRAIT_TYPE_SPIKE_ARMOR= 40
constant integer TRAIT_TYPE_STATIC_ARMOR= 13
        //Properties
constant integer TRAIT_TYPE_MANA= 10
constant integer TRAIT_TYPE_MANA_REGEN= 11
constant integer TRAIT_TYPE_LIFE= 15
constant integer TRAIT_TYPE_LIFE_REGEN= 16
constant integer TRAIT_TYPE_MOVEMENT_SPEED= 38
        //Stats
constant integer TRAIT_TYPE_STRENGTH= 5
constant integer TRAIT_TYPE_AGILITY= 6
constant integer TRAIT_TYPE_INTELLIGENCE= 7
constant integer TRAIT_TYPE_ALL_STATS= 18
        //Resistances
constant integer TRAIT_TYPE_FIRE_RESISTANCE= 25
constant integer TRAIT_TYPE_LIGHTNING_RESISTANCE= 26
constant integer TRAIT_TYPE_COLD_RESISTANCE= 27
constant integer TRAIT_TYPE_POISON_RESISTANCE= 28
constant integer TRAIT_TYPE_DARKNESS_RESISTANCE= 29
constant integer TRAIT_TYPE_HOLY_RESISTANCE= 30
constant integer TRAIT_TYPE_PHYSICAL_RESISTANCE= 31
constant integer TRAIT_TYPE_ALL_RESISTANCE= 32
constant integer TRAIT_TYPE_SPELL_RESISTANCE= 39
constant integer TRAIT_RESISTANCES= 10
        //Crit
constant integer TRAIT_TYPE_CRIT_POW= 33
constant integer TRAIT_TYPE_CRIT_RATE= 34
constant integer TRAIT_TYPE_SPELL_CRIT_POW= 35
constant integer TRAIT_TYPE_SPELL_CRIT_RATE= 36
constant integer TRAIT_CRITS= 4
        
constant integer TRAIT_AMOUNTS= 41
        
constant integer TRAIT_REQ_LEVEL= 1
constant integer TRAIT_REQ_WARR= 2
constant integer TRAIT_REQ_WIZ_WITCH= 3
        
constant integer TRAIT_REQ_AMOUNTS= 3
//endglobals from TraitConstants
//globals from Type:
constant boolean LIBRARY_Type=true
//endglobals from Type
//globals from VersionCatalog:
constant boolean LIBRARY_VersionCatalog=true
//endglobals from VersionCatalog
//globals from Waypoint:
constant boolean LIBRARY_Waypoint=true
unit array Waypoint__ward
integer array Waypoint__current
integer array Waypoint__currentCont
hashtable Waypoint__waypointHash= InitHashtable()
integer array Waypoint__currentMenu
dialog array Waypoint__main
button array Waypoint__bttn
integer array Waypoint__cont1
integer array Waypoint__cont2
integer array Waypoint__cont3
integer array Waypoint__cont4
integer array Waypoint__currentProgress
//endglobals from Waypoint
//globals from WorldBounds:
constant boolean LIBRARY_WorldBounds=true
//endglobals from WorldBounds
//globals from crit:
constant boolean LIBRARY_crit=true
hashtable crit___critHash= InitHashtable()
real crit___ExternalFactorRate= 20
real crit___ExternalFactorPower= 200
real crit___InternalFactorRate= 20
real crit___InternalFactorPower= 20
real crit___SubtractionFactorRate= 25
real crit___SubtractionFactorPower= 25
//endglobals from crit
//globals from dsf:
constant boolean LIBRARY_dsf=true
//endglobals from dsf
//globals from test:
constant boolean LIBRARY_test=true
//endglobals from test
//globals from xebasic:
constant boolean LIBRARY_xebasic=true
constant integer XE_DUMMY_UNITID= 'e000'
constant integer XE_HEIGHT_ENABLER= 'Amrf'
constant integer XE_TREE_RECOGNITION= 'Aeat'
constant real XE_ANIMATION_PERIOD=  0.025
constant real XE_MAX_COLLISION_SIZE=  197.0
//endglobals from xebasic
//globals from AVL:
constant boolean LIBRARY_AVL=true
//endglobals from AVL
//globals from AdvLoc:
constant boolean LIBRARY_AdvLoc=true
//endglobals from AdvLoc
//globals from Base:
constant boolean LIBRARY_Base=true
integer Base__gt=0
integer array Base__n
string array Base__b
integer array Base__t
integer Base__c=0
integer array Base__s
//endglobals from Base
//globals from Catalog:
constant boolean LIBRARY_Catalog=true
integer Catalog___w=0
integer Catalog___d
integer Catalog___c
integer array Catalog___i
integer array Catalog___r
integer array Catalog___en
integer array Catalog___ep
integer array Catalog___pn
integer array Catalog___pp
        
integer array Catalog___clr
integer Catalog___clic= 0
integer array Catalog___clthv
integer array Catalog___cltv
integer array Catalog___cltvp
integer array Catalog___cltvc
integer array Catalog___clcv
integer array Catalog___clp
integer array Catalog___clvi
integer array Catalog___cntt
integer array Catalog___cntb
//endglobals from Catalog
//globals from FighterFirstSpells:
constant boolean LIBRARY_FighterFirstSpells=true
constant integer FighterFirstSpells__MS_ID= 'A00P'
constant real FighterFirstSpells__MS_STR= 2
constant string MS_FX= "war3mapImported\\DevilSlam.mdl"
constant string FighterFirstSpells__MS_FX2= "war3mapImported\\MoonFireSlash.mdl"
constant real FighterFirstSpells__MS_STR_LVL= 0.2
constant real FighterFirstSpells__MS_DMG= 1
constant real FighterFirstSpells__MS_DMG_LVL= 0.1
constant real FighterFirstSpells__MS_SPLSH= 0.35
constant real FighterFirstSpells__MS_SPLSH_LVL= 0.02
constant real FighterFirstSpells__MS_SPLSH_RNG= 150
constant real FighterFirstSpells__MS_SPLSH_RNG_LVL= 20
            
constant integer WW_ID= 'A04I'
constant integer WW_DUMMY= 'h004'
constant real FighterFirstSpells__WW_TIME= 3
constant real FighterFirstSpells__WW_TICK= 8
constant integer WW_WAVE_ABIL= 'A04U'
            
constant integer FighterFirstSpells__BN_ID= 'A04M'
constant real FighterFirstSpells__BN_KNOCKBACK_RANGE= 350
constant real FighterFirstSpells__BN_STR= 2
constant real FighterFirstSpells__BN_STR_LVL= 0.2
constant real FighterFirstSpells__BN_COLLIDE_DST= 100 * 100
constant real FighterFirstSpells__BN_SPEED= 1000 * ( 1.0 / 32.0 )
constant real FighterFirstSpells__BN_RANGE= 1400
            
constant integer BC_ID= 'A04J'
constant real FighterFirstSpells__BC_DUR= 5
constant real FighterFirstSpells__BC_DUR_LVL= 0.5
constant real FighterFirstSpells__BC_PERCENT= 1
constant real FighterFirstSpells__BC_PERCENT_LVL= 0.1
constant real FighterFirstSpells__BC_CAP_STR= 10
constant real FighterFirstSpells__BC_CAP_STR_LVL= 1
constant real FighterFirstSpells__BC_TEXTTAGHEIGHT= 20 * 0.0023
constant real FighterFirstSpells__BC_HEIGHT= 10
constant real FighterFirstSpells__BC_KABOOM_RADIUS= 450
constant string FighterFirstSpells__BC_FX= "Units\\NightElf\\Wisp\\WispExplode.mdl"
            
//endglobals from FighterFirstSpells
//globals from GetItemOwner:
constant boolean LIBRARY_GetItemOwner=true
integer GetItemOwner___ot
//endglobals from GetItemOwner
//globals from GetUnitCollision:
constant boolean LIBRARY_GetUnitCollision=true
integer GetUnitCollision___uc
//endglobals from GetUnitCollision
//globals from ShadowTrail:
constant boolean LIBRARY_ShadowTrail=true
        // Does it use the team color of the owner of the main unit
constant boolean ShadowTrail___COLOUR_OWNER= true
        // Default player colour for shadows, used if COLOUR_OWNER is false
constant playercolor ShadowTrail___PCOL= GetPlayerColor(Player(15))
       
        // Dummies are created here and then isntantly placed at the hero's position
constant real ShadowTrail___CREATE_X= 0
constant real ShadowTrail___CREATE_Y= 0
       
constant integer TRAIL_TYPE_STATIC= 0
constant integer TRAIL_TYPE_MOTION= 1
       
        // The image to use as shadows for the dummies. No need to change this as the image will be hidden
constant string ShadowTrail___SHADOWPATH= "Textures\\white.blp"
       
integer ShadowTrail___tab
integer ShadowTrail___dc= 0
unit ShadowTrail___u
//endglobals from ShadowTrail
//globals from StatBoard:
constant boolean LIBRARY_StatBoard=true
integer array StatBoard__p
        
constant integer StatBoard__HPMP= 0
constant integer StatBoard__BREA= 1
constant integer StatBoard__STRE= 2
constant integer StatBoard__AGIL= 3
constant integer StatBoard__INTE= 4
constant integer StatBoard__MREG= 5
constant integer StatBoard__HREG= 6
constant integer StatBoard__ASPD= 7
constant integer StatBoard__MSPD= 8
constant integer StatBoard__ARMO= 9
constant integer StatBoard__SPAR= 10
constant integer StatBoard__STAR= 11
constant integer StatBoard__BRE2= 12
constant integer StatBoard__DAMA= 13
constant integer StatBoard__FDMG= 14
constant integer StatBoard__LDMG= 15
constant integer StatBoard__SDMG= 16
constant integer StatBoard__CDMG= 17
constant integer StatBoard__PDMG= 18
constant integer StatBoard__CRAT= 19
constant integer StatBoard__CPOW= 20
constant integer StatBoard__SRAT= 21
constant integer StatBoard__SPOW= 22
constant integer StatBoard__LLEE= 23
constant integer StatBoard__ARED= 24
constant integer StatBoard__BRE3= 25
constant integer StatBoard__PHRE= 26
constant integer StatBoard__SRES= 27
constant integer StatBoard__FRES= 28
constant integer StatBoard__LRES= 29
constant integer StatBoard__CRES= 30
constant integer StatBoard__PRES= 31
        
constant string StatBoard__s_HPMP= "HP/MP"
constant string StatBoard__s_BREA= "- - - - -"
constant string StatBoard__s_STRE= "Strength"
constant string StatBoard__s_AGIL= "Agility"
constant string StatBoard__s_INTE= "Intelligence"
constant string StatBoard__s_MREG= "Mana Regen"
constant string StatBoard__s_HREG= "Hp Regen"
constant string StatBoard__s_ASPD= "Attack Speed"
constant string StatBoard__s_MSPD= "Move Speed"
constant string StatBoard__s_ARMO= "Armor"
constant string StatBoard__s_DAMA= "Damage"
constant string StatBoard__s_SPAR= "Spike Armor"
constant string StatBoard__s_STAR= "Static Armor"
constant string StatBoard__s_LLEE= "Life Leech"
constant string StatBoard__s_ARED= "Armor Reduction"
constant string StatBoard__s_FDMG= "Fire Damage"
constant string StatBoard__s_LDMG= "Lightning Damage"
constant string StatBoard__s_SDMG= "Static Damage"
constant string StatBoard__s_CDMG= "Cold Damage"
constant string StatBoard__s_PDMG= "Poison Damage"
constant string StatBoard__s_CRAT= "Critical Rate"
constant string StatBoard__s_CPOW= "Critical Power"
constant string StatBoard__s_SRAT= "Spell Critical Rate"
constant string StatBoard__s_SPOW= "Spell Critical Power"
constant string StatBoard__s_PHRE= "Physical Resistance"
constant string StatBoard__s_SRES= "Spell Resistance"
constant string StatBoard__s_FRES= "Fire Resistance"
constant string StatBoard__s_LRES= "Lightning Resistance"
constant string StatBoard__s_CRES= "Cold Resistance"
constant string StatBoard__s_PRES= "Poison Resistance"
//endglobals from StatBoard
//globals from StringSize:
constant boolean LIBRARY_StringSize=true
real array StringSize__size
//endglobals from StringSize
//globals from Thread:
constant boolean LIBRARY_Thread=true
    
constant integer Thread__UNIT_SYNC_ID= 'h000'
//endglobals from Thread
//globals from Track:
constant boolean LIBRARY_Track=true
constant integer Track___PLATFORM= 'Otip'
//endglobals from Track
//globals from UnitIndexer:
constant boolean LIBRARY_UnitIndexer=true
constant integer ABILITIES_UNIT_INDEXER= 'A044'
trigger UnitIndexer___q=CreateTrigger()
trigger UnitIndexer___l=CreateTrigger()
unit array UnitIndexer___e
integer UnitIndexer___r=0
integer UnitIndexer___y=0
integer UnitIndexer___o=0
boolean UnitIndexer___a=false
integer array UnitIndexer___n
integer array UnitIndexer___p
integer array UnitIndexer___lc
real UnitIndexer___h=1000
timer UnitIndexer___time=null
real array UnitIndexer___j
boolean array UnitIndexer___k
boolean array UnitIndexer___z
boolean array UnitIndexer___x
boolean array UnitIndexer___v
integer array UnitIndexer___b
timer UnitIndexer___m=CreateTimer()
//endglobals from UnitIndexer
//globals from BigInt:
constant boolean LIBRARY_BigInt=true
constant integer BigInt__BASE= 46340
constant boolean BigInt__DEBUG_MSGS= false
constant boolean BigInt__DOUBLE_FREE_CHECK= false
//endglobals from BigInt
//globals from Bonus:
constant boolean LIBRARY_Bonus=true
    
constant boolean Bonus___PRELOAD= true
integer array Bonus___pm
integer array Bonus___ps
integer array Bonus___bp
integer array Bonus___bo
boolean array Bonus___ir
integer array Bonus___cb
constant integer BONUS_ARMOR=0
constant integer BONUS_DAMAGE=14
constant integer BONUS_AGILITY=38
constant integer BONUS_STRENGTH=57
constant integer BONUS_INTELLIGENCE=76
constant integer BONUS_LIFE=95
constant integer BONUS_LIFE_REGEN=122
constant integer BONUS_MANA=138
constant integer BONUS_MANA_REGEN=141
constant integer BONUS_SIGHT=150
constant integer BONUS_ATTACK_SPEED=161
//endglobals from Bonus
//globals from GameStart:
constant boolean LIBRARY_GameStart=true
boolean GameStart__gameStarted= false
integer GameStart__count= 0
//endglobals from GameStart
//globals from GetLearnedAbilities:
constant boolean LIBRARY_GetLearnedAbilities=true
integer GetLearnedAbilities__abils
integer GetLearnedAbilities__marked
integer array GetLearnedAbilities__c
//endglobals from GetLearnedAbilities
//globals from LevelTree:
constant boolean LIBRARY_LevelTree=true
//endglobals from LevelTree
//globals from LifeSaver:
constant boolean LIBRARY_LifeSaver=true
    
constant integer LIFE_SAVER_ABILITY_ID= 'A001'
real array LifeSaver___currentLife
        
real LifeSaver___life
real LifeSaver___scale
//endglobals from LifeSaver
//globals from MissileRecycler:
constant boolean LIBRARY_MissileRecycler=true
        //-------------------------------------------------------------------
        // You must configure the dummy unit with the one created from the
        // ObjectMerger statement above.
        //
constant integer MissileRecycler___DUMMY_ID= 'e000'
player MissileRecycler___OWNER= Player(15)

constant integer MissileRecycler___ANG_N= 8
constant integer MissileRecycler___ANG_STORAGE_MAX= 12

constant real MissileRecycler___DEATH_TIME= 2.
        //the unit to complete its "death" animation in this timeframe. Must
        //be higher than 0.74 seconds to allow the unit time to turn. This
        //number should not be lower than the maximum death-animation time of
        //your missile-units' effect attachments, just to be safe.
constant integer MissileRecycler___ANG_VAL= 360 / MissileRecycler___ANG_N
constant integer MissileRecycler___ANG_MID= MissileRecycler___ANG_VAL / 2

        //Misc vars
unit array MissileRecycler___stack
integer array MissileRecycler___stackN
real array MissileRecycler___timeStamp
integer array MissileRecycler___queueNext
integer array MissileRecycler___queueLast
integer MissileRecycler___recycle= 0
timer MissileRecycler___gameTime= CreateTimer()
group MissileRecycler___protect= CreateGroup()
//endglobals from MissileRecycler
//globals from PriorityEvent:
constant boolean LIBRARY_PriorityEvent=true
//endglobals from PriorityEvent
//globals from Quest:
constant boolean LIBRARY_Quest=true
constant string Quest__questColor= "ffa07a"
constant string Quest__beforeQuestName= "|cff" + Quest__questColor + "Quest \""
constant string Quest__afterQuestName= "\" completed!|r"
        
constant string Quest__beforeQuestNameAccepted= Quest__beforeQuestName
constant string Quest__afterQuestNameAccepted= "\" is now available"
integer Quest__unitTable
integer Quest__triggerAttachedData
integer Quest__questTable
integer array Quest__interactTable
integer array Quest__interactLevelTable
integer Quest__interactLevelTablePos= 0
integer array Quest__questArray
constant integer Quest__MAX_NUM_QUESTS= 50
constant integer Quest__STAGE_INDICE_INDENT= 8192
constant integer Quest__GLOBAL_FINISH= 1127483638
constant integer Quest__KILL_FINISH= 1147383627
constant integer Quest__STAGE_FINISH= 1147683616
constant integer Quest__EXCLAMATION_POINT_ID= 'h00E'
integer Quest__NUM_PLAYERS= 12
integer Quest__sequenceTable
integer array Quest__listOfQuests
integer array Quest__listeningQuestsArray
integer Quest__listeningQuestsIndex= 0
integer Quest__listOfQuestsIndex= - 1
integer bountyQuest
        
integer Quest_QUESTSYSTEM_GOLDTOADD= 0
integer Quest_QUESTSYSTEM_LUMBTOADD= 0
integer Quest_QUESTSYSTEM_EXPTOADD= 0
integer Quest_QUESTSYSTEM_ITEMTYPE= 0
integer Quest_QUESTSYSTEM_ITEMAMOUNT= 0
player Quest_QUESTSYSTEM_PLAYER
unit Quest_QUESTSYSTEM_LASTUNIT
unit Quest_QUESTSYSTEM_TRIGGERUNIT
unit Quest_QUESTSYSTEM_TEMPUNIT
widget Quest_QUESTSYSTEM_TEMPWIDGET
unit Quest_QUESTSYSTEM_TRIGGERPLAYERUNIT
        
trigger Quest_QUESTSYSTEM_MAINTRIGGER= null
trigger Quest_QUESTSYSTEM_TEMPTRIGGER= null
integer Quest_QUESTSYSTEM_RESPONSETYPE= 0
constant real Quest__MESSAGE_DURATION= 15
trigger Quest__last
        
        
        
//endglobals from Quest
//globals from TempCatalog:
constant boolean LIBRARY_TempCatalog=true
//endglobals from TempCatalog
//globals from TriggerRefresh:
constant boolean LIBRARY_TriggerRefresh=true
//endglobals from TriggerRefresh
//globals from UnitEvent:
constant boolean LIBRARY_UnitEvent=true
constant integer UNITS_UNIT_EVENT= 'n018'
//endglobals from UnitEvent
//globals from WordWrap:
constant boolean LIBRARY_WordWrap=true
//endglobals from WordWrap
//globals from DDS:
constant boolean LIBRARY_DDS=true
    
constant integer DDS___TRIGGER_SIZE= 80
timer DDS_DamageEventModification___afterDamageTimer= CreateTimer()
        
boolean array DDS___saved
integer array DDS_DamageEventModification___id
integer array DDS_DamageEventModification___index
integer DDS_DamageEventModification___stackCount= 0
            
unit DDS_DamageEventModification___killUnit
constant boolean DDS___ENABLED_EXISTS= true
        
real DDS___scale
boolexpr DDS_TriggerRefresh___condition
//endglobals from DDS
//globals from GroupVersionCatalog:
constant boolean LIBRARY_GroupVersionCatalog=true
//endglobals from GroupVersionCatalog
//globals from ItemInventory:
constant boolean LIBRARY_ItemInventory=true
      //  private trigger onRecipe
        
constant integer ItemInventory__INVISIBLE_ICON= 'B010'
constant integer ItemInventory__EMPTY_BAG_SLOT= 'B00X'
constant integer ItemInventory__SELECTION_ID= 'B00Y'
constant string ItemInventory__COLOR= "|cffffcc00"
integer array ItemInventory__tempTable
integer ItemInventory__tpSize= 0
integer array ItemInventory__equipment
integer ItemInventory__eqSize= 0
real ItemInventory__eqwidth= 0
real ItemInventory__eqxbetween= 0
real ItemInventory__eqybetween= 0
real ItemInventory__eqminx= 0
real ItemInventory__eqmaxy= 0
integer array ItemInventory__inventory
integer ItemInventory__inSize= 0
real ItemInventory__inwidth= 0
real ItemInventory__inxbetween= 0
real ItemInventory__inybetween= 0
real ItemInventory__inminx= 0
real ItemInventory__inmaxy= 0
integer array ItemInventory__console
integer ItemInventory__coSize= 0
real ItemInventory__cowidth= 0
real ItemInventory__coxbetween= 0
real ItemInventory__coybetween= 0
real ItemInventory__cominx= 0
real ItemInventory__comaxy= 0
integer array ItemInventory__recipeArea
integer ItemInventory__opSize= 0
real ItemInventory__opwidth= 0
real ItemInventory__opxbetween= 0
real ItemInventory__opybetween= 0
real ItemInventory__opminx= 0
real ItemInventory__opmaxy= 0
            
rect ItemInventory__inRect
rect ItemInventory__eqRect
rect ItemInventory__coRect
rect ItemInventory__opRect
rect ItemInventory__selectedRect
rect ItemInventory__hoverTitleRect
rect ItemInventory__hoverDescRect
destructable ItemInventory__selectionDest= null
integer ItemInventory__selectionButton
            
integer ItemInventory__currentlySelectedItem
destructable ItemInventory__currentlySelectedIcon
real ItemInventory__crntX
real ItemInventory__crntY
texttag ItemInventory__crntTT= null
integer ItemInventory__lastHoveredItem= 0
destructable ItemInventory__lastHoveredIcon
real ItemInventory__lstX
real ItemInventory__lstY
texttag ItemInventory__lstTTtitle= null
texttag ItemInventory__lstTTdesc= null
            
integer ItemInventory__itemLinks
            
integer ItemInventory__unitHashData
integer ItemInventory__nextHash= 1
//endglobals from ItemInventory
//globals from KnuthChecksum:
constant boolean LIBRARY_KnuthChecksum=true
//endglobals from KnuthChecksum
//globals from LevelFilter:
constant boolean LIBRARY_LevelFilter=true
//endglobals from LevelFilter
//globals from Missile:
constant boolean LIBRARY_Missile=true
    //***********************************************************************
    //  This dummy must use Vexorian's dummy model and it's movement type
    //  should be "Hover" if you want to correctly move over water, otherwise
    //  use "None". The dummy must also have Crow Form. If you don't have a
    //  dummy unit in your map then use the one MissileRecycler provides.
constant integer Missile___DUMMY_RAW_CODE= 'e000'
integer Missile___ACTIVE=   0
integer Missile___SIZE=   0
trigger Missile___FIRE=   CreateTrigger()
integer array Missile___STACK
integer array Missile___INSTANCES
integer array Missile___TIMER
integer array Missile___NODE
//endglobals from Missile
//globals from NumberStack:
constant boolean LIBRARY_NumberStack=true
//endglobals from NumberStack
//globals from QuestListener:
constant boolean LIBRARY_QuestListener=true
//endglobals from QuestListener
//globals from Scrambler:
constant boolean LIBRARY_Scrambler=true
    
constant string Scrambler__SALT= ""
integer array Scrambler__ss
boolean array Scrambler__se
integer array Scrambler__d
integer Scrambler__i
integer Scrambler__dc
integer Scrambler__k
integer Scrambler__s1
integer Scrambler__s2
integer Scrambler__s3
integer Scrambler__pid
trigger Scrambler__mt=CreateTrigger()
trigger Scrambler__dt=CreateTrigger()
trigger Scrambler__st=CreateTrigger()
trigger Scrambler__ut=CreateTrigger()
integer Scrambler__bi
integer array Scrambler__bs
integer array Scrambler__so
integer Scrambler__sc=0
//endglobals from Scrambler
//globals from StatHandler:
constant boolean LIBRARY_StatHandler=true
integer StatHandler__attachedTimerData
integer StatHandler__customBonuses
integer StatHandler__resistances
integer StatHandler__crits
integer StatHandler__currentResistances
integer StatHandler__currentResistancePoint
//endglobals from StatHandler
//globals from fuuulibrary:
constant boolean LIBRARY_fuuulibrary=true
destructable fuuulibrary__topLeftAnchor
destructable fuuulibrary__topMidAnchor
destructable fuuulibrary__descriptionAnchor
destructable array fuuulibrary__buttons
            
            //Rects
rect fuuulibrary__treeRect
rect fuuulibrary__menuRect
rect fuuulibrary__titleRect
rect fuuulibrary__descriptionRect
            
            //Integers
constant integer fuuulibrary__NUM_OF_DATA= 35
constant integer fuuulibrary__BUTTON_INDENT= 1000
constant integer fuuulibrary__NUM_BUTTONS= 151
constant integer fuuulibrary__WIDTH= 15
            
            //strings
constant string fuuulibrary__TRACKABLE_PATH= "war3mapImported\\64x64Track.mdl"
string fuuulibrary__LIGHTNING_PATH= "CHNS"
constant string fuuulibrary__TITLE_COLOR= "|cffffcc00"
constant string fuuulibrary__REQUIREMENT_COLOR= "|cffff0000"
            
            // System Variables
real fuuulibrary__distanceBetween
integer fuuulibrary__invisible
integer array fuuulibrary__currentHeroIndex
integer array fuuulibrary__TrackTable
texttag array fuuulibrary__descTextTag
integer fuuulibrary__tree
integer fuuulibrary__staticTree
real array fuuulibrary__X
real array fuuulibrary__Y
integer fuuulibrary__currentHeroArray= - 1
integer array fuuulibrary__currentTalentPoints
integer array fuuulibrary__buttonLevel
rect fuuulibrary__regionLock
            
trigger VJTT_onHoverModule
trigger VJTT_onClickModule
trigger VJTT_onShowModule
trigger VJTT_onHideModule
trigger VJTT_externalRequirementModule
player VJTT_interactingPlayer
integer VJTT_attachedData
integer VJTT_buttonId
boolean VJTT_rejected
integer VJTT_heroIndex
//endglobals from fuuulibrary
//globals from noleavegotum:
constant boolean LIBRARY_noleavegotum=true
//endglobals from noleavegotum
//globals from ApplyChecksum:
constant boolean LIBRARY_ApplyChecksum=true
//endglobals from ApplyChecksum
//globals from DamageEvent:
constant boolean LIBRARY_DamageEvent=true
//endglobals from DamageEvent
//globals from EncryptNumber:
constant boolean LIBRARY_EncryptNumber=true
integer array EncryptNumber__bases
//endglobals from EncryptNumber
//globals from LevelGroupSlotVersionCatalog:
constant boolean LIBRARY_LevelGroupSlotVersionCatalog=true
//endglobals from LevelGroupSlotVersionCatalog
//globals from LevelGroupVersionCatalog:
constant boolean LIBRARY_LevelGroupVersionCatalog=true
//endglobals from LevelGroupVersionCatalog
//globals from ShowInventory:
constant boolean LIBRARY_ShowInventory=true
real ShowInventory__currentX= 0
real ShowInventory__currentY= 0
real ShowInventory__currentAA= 0
real ShowInventory__currentD= 0
boolean array ShowInventory__isInInventory
rect ShowInventory__lock
//endglobals from ShowInventory
//globals from SpellChargedBolt:
constant boolean LIBRARY_SpellChargedBolt=true
//endglobals from SpellChargedBolt
//globals from WitchFirstSpells:
constant boolean LIBRARY_WitchFirstSpells=true
constant integer WitchFirstSpells__SPRITE= 'A04P'
constant integer WitchFirstSpells__RITUAL= 'A04O'
constant integer WitchFirstSpells__CHAMP= 'A04R'
constant integer WitchFirstSpells__SUCKER= 'A04T'
constant integer WitchFirstSpells__BATH= 'A04L'
        
constant real WitchFirstSpells__SP_RANGE= 1000
constant real WitchFirstSpells__SP_SPEED= 600
constant integer WitchFirstSpells__SP_DATA= 1
constant real WitchFirstSpells__SP_INT_FACTOR= 1
constant real WitchFirstSpells__SP_INT_LEVEL_FACTOR= 0
constant real WitchFirstSpells__SP_LEVEL_FLAT_FACTOR= 5
constant real WitchFirstSpells__LIFE_CONSUMED= 0.1
constant real WitchFirstSpells__LIFE_LEECHED_BASE= 23
constant real WitchFirstSpells__LIFE_LEECHED_LEVEL_FACTOR= 2
constant string WitchFirstSpells__SP_EFFECT= "war3mapImported\\Soulfire Missile.mdl"
constant string WitchFirstSpells__SP_ON_HIT= "war3mapImported\\Soulfire Missile.mdl"
        
        
constant real WitchFirstSpells__RI_DURATION= 2
constant real WitchFirstSpells__RI_INT_FACTOR= 1
constant real WitchFirstSpells__RI_INT_LEVEL_FACTOR= 0.1
constant real WitchFirstSpells__RI_RADIUS= 300
constant string WitchFirstSpells__RI_EFFECT= "Objects\\Spawnmodels\\Human\\HumanLargeDeathExplode\\HumanLargeDeathExplode.mdl"
        
constant integer WitchFirstSpells__CHAMP_ID= 'h015'
        
constant real WitchFirstSpells__BA_DURATION=5
constant real WitchFirstSpells__BA_INT_FACTOR= 1
constant real WitchFirstSpells__BA_INT_LEVEL_FACTOR= 0.1
constant real WitchFirstSpells__BA_RADIUS= 500
constant integer WitchFirstSpells__BA_BLOOD_PER_32= 4
      //  private constant string BA_EFFECT1 = "Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodFootman.mdl"
constant string WitchFirstSpells__BA_EFFECT2= "Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodKnight.mdl"
constant string WitchFirstSpells__BA_EFFECT3= "Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodMortarTeam.mdl"
constant string WitchFirstSpells__BA_EFFECT4= "Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodRifleman.mdl"
constant string WitchFirstSpells__BA_EFFECT5= "Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodPriest.mdl"
        
constant real WitchFirstSpells__DAMAGE= 100.00
constant real WitchFirstSpells__SPEED= 800.00
constant real WitchFirstSpells__GRAVITY= 600.00
constant real WitchFirstSpells__RADIUS= 50.00
constant real WitchFirstSpells__MAXDIST= 3000.00
constant string WitchFirstSpells__EFFECT= "Abilities\\Spells\\Undead\\DarkSummoning\\DarkSummonMissile.mdl"
        
location WitchFirstSpells__loc= Location(0.00, 0.00)
//endglobals from WitchFirstSpells
//globals from WizardFireSpells:
constant boolean LIBRARY_WizardFireSpells=true
constant integer WizardFireSpells__BS_ID= 'A009'
constant integer WizardFireSpells__BS_FX= 'A04V'
constant real WizardFireSpells__BS_CHANCE= 10
constant real WizardFireSpells__BS_CHANCE_FACTOR= 0.5
constant real WizardFireSpells__BS_BURN_INT_PS= 1
constant real WizardFireSpells__BS_BURN_INT_PS_FACTOR= 0.0
constant real WizardFireSpells__BS_BURN_DURA= 2
constant real WizardFireSpells__BS_BURN_DURA_FACTOR= 0.1
constant real WizardFireSpells__BS_EXTRA_DMG= 0.00
constant real WizardFireSpells__BS_EXTRA_DMG_FACTOR= 0.02
        
        
       // private constant integer 
        
constant integer WizardFireSpells__FB_ID= 'A051'
constant integer FB_WAVE= 'A004'
constant string WizardFireSpells__FB_FX= "Abilities\\Weapons\\LordofFlameMissile\\LordofFlameMissile.mdl"
constant real WizardFireSpells__FB_DMG_INT= 1
constant real WizardFireSpells__FB_DMG_INT_FACTOR= 0.1
constant real WizardFireSpells__FB_SPEED= 25
constant real WizardFireSpells__FB_MAX_DIST= 1000
constant real WizardFireSpells__FB_MISSILES= 5
constant real WizardFireSpells__FB_MISSILES_FACTOR= 0.5
        
constant integer WizardFireSpells__FW_ID= 'A050'
constant string WizardFireSpells__FW_BRANCH_FX= "Abilities\\Weapons\\Mortar\\MortarMissile.mdl"
constant string WizardFireSpells__FW_FX= "war3mapImported\\FireworksDragonHead.mdx"
constant real WizardFireSpells__FW_CORE_INT= 1
constant real WizardFireSpells__FW_CORE_INT_FACTOR= 0.2
constant integer WizardFireSpells__FW_CORE_RADIUS= 150
constant real WizardFireSpells__FW_BRANCH_INT= 1
constant real WizardFireSpells__FW_BRANCH_INT_FACTOR= 0.1
constant real WizardFireSpells__FW_BRANCH_DST= 100
constant real WizardFireSpells__FW_BRANCH_RADIUS= 75
constant real WizardFireSpells__FW_DIST= 900
constant real WizardFireSpells__FW_SPEED= 25
        
constant integer WizardFireSpells__PR_ID= 'A04Z'
constant string WizardFireSpells__PR_FX= "war3mapImported\\MeteorStrike.mdl"
constant real WizardFireSpells__PR_MISSILE_COUNT= 3
constant real WizardFireSpells__PR_MISSILE_COUNT_FACTOR= 0.2
constant real WizardFireSpells__PR_TIME_BETWEEN_MISSILES= 0.5
constant real WizardFireSpells__PR_DAMAGE_DELAY= 0.75
constant real WizardFireSpells__PR_DAMAGE= 1
constant real WizardFireSpells__PR_DAMAGE_FACTOR= 0.05
constant real WizardFireSpells__PR_AOE= 250
constant real WizardFireSpells__PR_ERROR= 100
        
        
constant integer WizardFireSpells__FC_ID= 'A04W'
constant integer WizardFireSpells__FC_DUMMY= 'h016'
constant real WizardFireSpells__FC_DURATION= 6
constant real WizardFireSpells__FC_DURATION_FACTOR= 0.6
constant real WizardFireSpells__FC_DISTANCE= 100
        
constant integer WizardFireSpells__PB_ID= 'A04G'
constant string WizardFireSpells__PB_FX= "units\\human\\phoenix\\phoenix.mdl"
constant string WizardFireSpells__PB_BOOM= "Abilities\\Spells\\Other\\Doom\\DoomDeath.mdl"
constant real WizardFireSpells__PB_NUM_SPLITS= 6
constant real WizardFireSpells__PB_DMG= 0.5
constant real WizardFireSpells__PB_DMG_FACTOR= 0.1
constant real WizardFireSpells__PB_SEARCH= 500
constant real WizardFireSpells__PB_AOE= 200
constant real WizardFireSpells__PB_ASCEND_SPEED= 50
constant real WizardFireSpells__PB_ATTACK_SPEED= 500
constant real WizardFireSpells__PB_OPTIMAL_TIME= 1
        
constant integer WizardFireSpells__ST_ID= '0000'
        
//endglobals from WizardFireSpells
//globals from WizardForceSpells:
constant boolean LIBRARY_WizardForceSpells=true
    
//endglobals from WizardForceSpells
//globals from qqinit:
constant boolean LIBRARY_qqinit=true
//endglobals from qqinit
//globals from DamageEventModification:
constant boolean LIBRARY_DamageEventModification=true
//endglobals from DamageEventModification
//globals from DamageEventArchetype:
constant boolean LIBRARY_DamageEventArchetype=true
    
constant integer DAMAGE_EVENT_ARCHETYPE_PLUGIN_ABILITY= 'A045'
integer DAMAGE_EVENT_REQUEST_TYPE= - 1
//endglobals from DamageEventArchetype
    // User-defined
hashtable udg_SpellEventHash= null
trigger udg_SpellEventTrigger= null
integer udg_SpellEventAbility= 0
real udg_DamageEventAmountDummy= 0
real udg_DamageEventAmount= 0
location udg_TempLoc= null
unit udg_DamageEventTarget= null
unit udg_DamageEventSource= null
boolean udg_HeatedBladeBool= false
boolean array udg_HeatedBladeAvailable
timer array udg_HeatedBladeTimer
integer udg_DamageEventType= 0
integer udg_Temp_Integer= 0
boolean udg_ShowCriticalText= false
unit udg_TempUnit= null
real udg_DamageModifierEvent= 0
real udg_DamageEvent= 0
integer udg_DamageBlockingAbility= 0
integer udg_DamageTypeSpell= 0
integer udg_DamageTypeDOT= 0
integer udg_DamageTypeRanged= 0
integer udg_DmgEvN= 0
unit array udg_DmgEvStack
damagetype udg_DamageType= null
real udg_DamageEventPrevAmt= 0
boolean udg_DamageEventExplodesUnit= false
boolean udg_DamageEventOverride= false
real udg_DmgEvLife= 0
trigger udg_DamageEventTrigger= null
integer udg_DmgTypPrev= 0
integer udg_UDex= 0
unit array udg_UDexUnits
boolean array udg_UnitDamageRegistered
integer udg_DamageEventsWasted= 0
integer array udg_UDexNext
real udg_UnitIndexEvent= 0
boolean udg_UnitIndexerEnabled= false
timer udg_DmgEvTimer= null
unit array udg_PlayerUnit
location udg_Temp_Point= null
unit array udg_Backpack
timer udg_BackpackTimer= null
rect array udg_BackPackArea
boolean udg_TempBool= false
group udg_Temp_UnitGroup= null
hashtable udg_CreepTable= null
integer array udg_UnitIndexLock
integer array udg_UDexPrev
integer udg_UDexRecycle= 0
integer udg_UDexWasted= 0
integer udg_UDexGen= 0
boolean udg_CreepTableBool= false
location udg_TempLoc2= null
real udg_CurrentGameTime= 0
real array udg_ElectricityLastHit
real array udg_ElectrictyHitCount
integer array udg_TestVariable
timer udg_DumTimer= null
location array udg_PW_TempPoint
integer array udg_PW_Index
integer array udg_PW_WaveInteger
integer array udg_PW_Integer
real array udg_PW_Damage
location array udg_PW_TargetPoint
location array udg_PW_CasterPoint
real array udg_PW_Real
unit array udg_PW_Unit
group array udg_PW_TempGroup
boolean udg_Item_Boolean= false
string udg_TempStr
integer udg_TempItemType= 0
location array udg_Select_HeroCam
location udg_Select_WarCam= null
location udg_Select_WizCam= null
string array udg_Select_HeroName
unit array udg_Select_Hero
string array udg_Select_HeroDescription
string array udg_Select_HeroRole
string array udg_Select_HeroAbilties
string array udg_Select_Evolutions
string udg_Select_Hint
rect array udg_Select_RegionLock
force udg_Select_PlayerGroup= null
integer array udg_Select_HeroActive
integer array udg_Select_Current
unit array udg_Select_HeroCenterDummy
integer udg_TBOOL= 0
integer udg_TASability= 0
unit udg_TASunit= null
real udg_TASduration= 0
boolean udg_TASrefresh= false
integer udg_TASmaxstack= 0
real array udg_TASdur
boolean array udg_TASend
hashtable udg_TAShash= null
integer array udg_TASids
integer udg_TASindex= 0
boolean array udg_TASref
timer udg_TAStimer= null
unit array udg_TASunits
timer udg_BTimerRed= null
timer udg_BTimerBlue= null
timer udg_BTimerTeal= null
timer udg_BTimerPurple= null
timer udg_BTimerYellow= null
timer udg_BTimerOrange= null
timer udg_BTimerGreen= null
timer udg_BTimerPink= null
timer udg_BTimerGray= null
timer udg_BTimerLB= null
trigger udg_KDStart= null
destructable udg_DumDest= null
destructable udg_TempDestructable= null
destructable udg_TempDest= null
unit udg_u= null

    // Generated
rect gg_rct_a1_rain= null
rect gg_rct_Choose_Wizard= null
rect gg_rct_Choose_Warrior= null
rect gg_rct_Choose_Archer= null
rect gg_rct_Create_Starting_Units= null
rect gg_rct_Red_Backpack_Area= null
rect gg_rct_Orange_Backpack_Area= null
rect gg_rct_Teal_Backpack_Area= null
rect gg_rct_Purple_Backpack_Area= null
rect gg_rct_Yellow_Backpack_Area= null
rect gg_rct_Green_Backpack_Area= null
rect gg_rct_Pink_Backpack_Area= null
rect gg_rct_Gray_Backpack_Area= null
rect gg_rct_Light_Blue_Backpack_Area= null
rect gg_rct_Dark_Green_Backpack_Area= null
rect gg_rct_Backpack_Area_All= null
rect gg_rct_DoE_Enter_Start= null
rect gg_rct_DoE_Exit_End= null
rect gg_rct_DoE_Exit_Start= null
rect gg_rct_DoE_Enter_End= null
rect gg_rct_Archer_Region_Lock= null
rect gg_rct_Wizard_Region_Lock= null
rect gg_rct_Warrior_Region_Lock= null
rect gg_rct_Rogue_Warrior_Lock= null
rect gg_rct_Summoner_Region_Lock= null
rect gg_rct_Instance_Room= null
rect gg_rct_Kobold_Dungeon_Enter_Instance= null
rect gg_rct_Tree_Area= null
rect gg_rct_Menu_Area= null
rect gg_rct_TalentTitleRect= null
rect gg_rct_TalentDescRect= null
rect gg_rct_replaceRegion= null
rect gg_rct_Gotum_Fountain= null
rect gg_rct_inventory= null
rect gg_rct_equipment= null
rect gg_rct_operator_console= null
rect gg_rct_equipment_console= null
rect gg_rct_Region_040= null
rect gg_rct_Region_041= null
rect gg_rct_Region_042= null
rect gg_rct_Region_043= null
rect gg_rct_KFrenzyEntrance= null
rect gg_rct_KFWipeA= null
rect gg_rct_KFWipeB= null
rect gg_rct_ExitGotum= null
rect gg_rct_ReturnGotum= null
trigger gg_trg_GameStart_Copy= null
trigger gg_trg_GlobalExpRate= null
trigger gg_trg_Untitled_Trigger_008= null
trigger gg_trg_Inity= null
trigger gg_trg_Thread= null
trigger gg_trg_Revive= null
trigger gg_trg_Ascii= null
trigger gg_trg_Alloc= null
trigger gg_trg_Beta_Test_Buffs= null
trigger gg_trg_Untitled_Trigger_006= null
trigger gg_trg_lvl= null
trigger gg_trg_Aura_demo= null
trigger gg_trg_init= null
trigger gg_trg_right_arrow= null
trigger gg_trg_left_arrow= null
trigger gg_trg_periodic= null
trigger gg_trg_repick= null
trigger gg_trg_esc= null
trigger gg_trg_RootLibrary= null
trigger gg_trg_TraitConstants= null
trigger gg_trg_showinventory= null
trigger gg_trg_mainitemcreation= null
trigger gg_trg_InventoryCoderInterface= null
trigger gg_trg_TraitHandler= null
trigger gg_trg_Recipe= null
trigger gg_trg_Statboard= null
trigger gg_trg_NoLeaveGotum= null
trigger gg_trg_QuestListener= null
trigger gg_trg_AdvancedQuest= null
trigger gg_trg_GotumStarterQuests= null
trigger gg_trg_Quest= null
trigger gg_trg_Party= null
trigger gg_trg_HeroImage= null
trigger gg_trg_StatHandler= null
trigger gg_trg_Simple_SaveLoad_Copy= null
trigger gg_trg_BigInt= null
trigger gg_trg_Scrambler= null
trigger gg_trg_Base= null
trigger gg_trg_GetLearnedAbilities= null
trigger gg_trg_AddRepeatedString= null
trigger gg_trg_Remove_String= null
trigger gg_trg_NumberStack= null
trigger gg_trg_Knuth_Checksum= null
trigger gg_trg_Buffer= null
trigger gg_trg_EncryptNumber= null
trigger gg_trg_ApplyChecksum= null
trigger gg_trg_InitSave= null
trigger gg_trg_Simple_SaveLoad= null
trigger gg_trg_ItemRootsCatalog= null
trigger gg_trg_ItemRootsCatalog_Copy= null
trigger gg_trg_SaveCodeToHD= null
trigger gg_trg_GroupVersionFilter= null
trigger gg_trg_LevelGroupSlotVersionFilter= null
trigger gg_trg_LevelGroupVersionFilter= null
trigger gg_trg_VersionFilter= null
trigger gg_trg_wordwrapstring= null
trigger gg_trg_Untitled_Trigger_005= null
trigger gg_trg_stringsize= null
trigger gg_trg_ButtonDemo= null
trigger gg_trg_VJassTalentTree= null
trigger gg_trg_Borders= null
trigger gg_trg_Button= null
trigger gg_trg_Interact= null
trigger gg_trg_Call_Bag= null
trigger gg_trg_BRP1= null
trigger gg_trg_BRP2= null
trigger gg_trg_BRP3= null
trigger gg_trg_BRP4= null
trigger gg_trg_BRP5= null
trigger gg_trg_BRP6= null
trigger gg_trg_BRP7= null
trigger gg_trg_BRP8= null
trigger gg_trg_BRP9= null
trigger gg_trg_BRP10= null
trigger gg_trg_Commands= null
trigger gg_trg_ChargedBolt= null
trigger gg_trg_DoE_Enter= null
trigger gg_trg_DoE_Exit= null
trigger gg_trg_KDEnter= null
trigger gg_trg_WizardForceSpells= null
trigger gg_trg_T32Interface= null
trigger gg_trg_FunctionAfterTime= null
trigger gg_trg_StructAttach= null
trigger gg_trg_FighterFirstSpells= null
trigger gg_trg_Untitled_Trigger_001= null
trigger gg_trg_WitchFirstSpells= null
trigger gg_trg_WizardFireSpells= null
trigger gg_trg_DamageModification= null
trigger gg_trg_Untitled_Trigger_002= null
trigger gg_trg_No_Autocast_Fierce_Blow= null
trigger gg_trg_Frost_Nova= null
trigger gg_trg_Electricity_Main= null
trigger gg_trg_DiracsTest21= null
trigger gg_trg_Chat= null
trigger gg_trg_Waypoint= null
trigger gg_trg_ItemStacker= null
trigger gg_trg_CritHandler= null
trigger gg_trg_Dungeon= null
trigger gg_trg_Custom_Drop_System= null
trigger gg_trg_UnitRespawn= null
trigger gg_trg_Bounty_System= null
trigger gg_trg_KeepTime= null
trigger gg_trg_Add_Bounty= null
trigger gg_trg_PlayerLeaveGame= null
trigger gg_trg_GUI_SpellEvent= null
trigger gg_trg_GUI_SpellEvent_Init= null
trigger gg_trg_Trigger_Refresh= null
trigger gg_trg_DDS= null
trigger gg_trg_Damage_Event_DDS_Plugin= null
trigger gg_trg_Damage_Event_Modification_DDS_Plugin= null
trigger gg_trg_Damage_Event_Archetype_DDS_Plugin= null
trigger gg_trg_NOT_FINISHED_Damage_Event_Unit_Modification_DDS_Plugin= null
trigger gg_trg_LifeSaver= null
trigger gg_trg_Type= null
trigger gg_trg_ShadowTrail= null
trigger gg_trg_AddShadowTrailTest2= null
trigger gg_trg_GetUnitCollision= null
trigger gg_trg_AdvLoc= null
trigger gg_trg_AVL_Tree= null
trigger gg_trg_BinaryHeap= null
trigger gg_trg_Bonus= null
trigger gg_trg_BoundSentinel= null
trigger gg_trg_Catalog= null
trigger gg_trg_Color_Code_String= null
trigger gg_trg_CompressInt= null
trigger gg_trg_CTL= null
trigger gg_trg_DiracLinkedList= null
trigger gg_trg_Event= null
trigger gg_trg_GetClosestUnit= null
trigger gg_trg_GetItemOwner= null
trigger gg_trg_GetNameColored= null
trigger gg_trg_GetRequiredXP= null
trigger gg_trg_Group_Utils= null
trigger gg_trg_IsTerrainWalkable= null
trigger gg_trg_Loc= null
trigger gg_trg_Missile= null
trigger gg_trg_MissleRecycler= null
trigger gg_trg_PriorityEevent= null
trigger gg_trg_RegisterPlayerUnitEvent= null
trigger gg_trg_SimError= null
trigger gg_trg_Table= null
trigger gg_trg_Table_Copy= null
trigger gg_trg_Track= null
trigger gg_trg_TimedLightning= null
trigger gg_trg_T32= null
trigger gg_trg_TimerUtils= null
trigger gg_trg_Timed_AS= null
trigger gg_trg_UnitEvent= null
trigger gg_trg_Unit_Indexer_Copy= null
trigger gg_trg_xebasic= null
trigger gg_trg_WorldBounds= null
unit gg_unit_ncp3_0027= null
unit gg_unit_h00Y_0515= null
unit gg_unit_h009_0233= null
unit gg_unit_h009_0232= null
unit gg_unit_h009_0231= null
unit gg_unit_h009_0230= null
unit gg_unit_h009_0229= null
unit gg_unit_h009_0228= null
unit gg_unit_h009_0227= null
unit gg_unit_h009_0226= null
unit gg_unit_H013_0499= null
unit gg_unit_h00Y_0526= null
unit gg_unit_h011_0520= null
unit gg_unit_h009_0224= null
unit gg_unit_h009_0225= null
unit gg_unit_h00B_0223= null
unit gg_unit_h00C_0139= null
unit gg_unit_h00P_0566= null
unit gg_unit_h00D_0307= null
unit gg_unit_h00H_0310= null
unit gg_unit_h00L_0367= null
unit gg_unit_H010_0498= null
unit gg_unit_H006_0377= null
unit gg_unit_H003_0496= null
unit gg_unit_H005_0497= null
unit gg_unit_h00Y_0506= null
unit gg_unit_h00Y_0505= null
unit gg_unit_h00Y_0504= null
unit gg_unit_h00P_0470= null
unit gg_unit_h00P_0472= null
unit gg_unit_h00P_0475= null
destructable gg_dest_B010_12893= null
destructable gg_dest_B010_13377= null
destructable gg_dest_B010_12894= null
destructable gg_dest_B010_0883= null
destructable gg_dest_B010_12864= null
trigger gg_trg_Untitled_Trigger_003= null
hashtable NoAutocast__hash= InitHashtable()

trigger l__library_init

//JASSHelper struct globals:
constant integer si__Quest=1
integer si__Quest_F=0
integer si__Quest_I=0
integer array si__Quest_V
quest array s__Quest_q
string array s__Quest_title
string array s__Quest_description
string array s__Quest_reward
integer array s__Quest_progress
integer array s__Quest_progressHashes
integer array s__Quest_progressHashesIndex
string array s__Quest_icon
constant integer si__Ascii__Inits=2
constant integer si__BountySystem=3
constant integer si__Buffer=4
constant integer si__TimerGroup32=5
constant integer si__CDS=6
constant integer si__Trait=7
integer si__Trait_F=0
integer si__Trait_I=0
integer array si__Trait_V
integer array s__Trait_typeOfTrait
real array s__Trait_a
real array s__Trait_b
real array s__Trait_c
real array s__Trait_d
constant integer si__CustomInventoryTraitHandler__SpecificTraitGenerator=8
integer si__CustomInventoryTraitHandler__SpecificTraitGenerator_F=0
integer si__CustomInventoryTraitHandler__SpecificTraitGenerator_I=0
integer array si__CustomInventoryTraitHandler__SpecificTraitGenerator_V
integer array s__CustomInventoryTraitHandler__SpecificTraitGenerator_typeOfTrait
real array s__CustomInventoryTraitHandler__SpecificTraitGenerator_amin
real array s__CustomInventoryTraitHandler__SpecificTraitGenerator_amax
real array s__CustomInventoryTraitHandler__SpecificTraitGenerator_aweight
real array s__CustomInventoryTraitHandler__SpecificTraitGenerator_bmin
real array s__CustomInventoryTraitHandler__SpecificTraitGenerator_bmax
real array s__CustomInventoryTraitHandler__SpecificTraitGenerator_bweight
real array s__CustomInventoryTraitHandler__SpecificTraitGenerator_cmin
real array s__CustomInventoryTraitHandler__SpecificTraitGenerator_cmax
real array s__CustomInventoryTraitHandler__SpecificTraitGenerator_cweight
real array s__CustomInventoryTraitHandler__SpecificTraitGenerator_dmin
real array s__CustomInventoryTraitHandler__SpecificTraitGenerator_dmax
real array s__CustomInventoryTraitHandler__SpecificTraitGenerator_dweight
constant integer si__CustomInventoryTraitHandler__TraitGroup=9
integer si__CustomInventoryTraitHandler__TraitGroup_F=0
integer si__CustomInventoryTraitHandler__TraitGroup_I=0
integer array si__CustomInventoryTraitHandler__TraitGroup_V
integer array s__CustomInventoryTraitHandler__TraitGroup_holder
integer array s__CustomInventoryTraitHandler__TraitGroup_maxHolder
integer array s__CustomInventoryTraitHandler__TraitGroup_combinedWeights
constant integer si__CustomInventoryTraitHandler__ItemGenerator=10
integer si__CustomInventoryTraitHandler__ItemGenerator_F=0
integer si__CustomInventoryTraitHandler__ItemGenerator_I=0
integer array si__CustomInventoryTraitHandler__ItemGenerator_V
integer array s__CustomInventoryTraitHandler__ItemGenerator_holder
integer array s__CustomInventoryTraitHandler__ItemGenerator_maxHolder
constant integer si__FullItemGenerator=11
integer si__FullItemGenerator_F=0
integer si__FullItemGenerator_I=0
integer array si__FullItemGenerator_V
integer array s__FullItemGenerator_i
string array s__FullItemGenerator_title
string array s__FullItemGenerator_desc
integer array s__FullItemGenerator_destructableId
integer array s__FullItemGenerator_slot
integer array s__FullItemGenerator_setv
integer array s__FullItemGenerator_recipes
integer array s__FullItemGenerator_recIndex
integer array s__FullItemGenerator_openGroup
string s__FullItemGenerator_beta= ""
integer array s__FullItemGenerator_registerId
constant integer si__Event=12
integer s__Event_w=0
trigger array s__Event_e
constant integer si__ClosestWidget=13
destructable s__ClosestWidget_cDest=null
item s__ClosestWidget_cItem=null
real s__ClosestWidget_distance=0
real s__ClosestWidget_cX=0
real s__ClosestWidget_cY=0
unit s__ClosestWidget_cUnit=null
boolean s__ClosestWidget_cTree=false
rect s__ClosestWidget_initRect=null
constant integer si__HeroImage=14
integer array s__HeroImage_Alloc___recycler
integer s__HeroImage_Alloc___instanceCount= 0
integer s__HeroImage_originals
integer s__HeroImage_copies
integer array s__HeroImage_images
integer s__HeroImage_imagesCount
integer array s__HeroImage_copyUnits
integer array s__HeroImage_copiesCount
integer array s__HeroImage_unitType
unit array s__HeroImage_original
integer array s__HeroImage_spot
constant integer si__Loc=15
integer array s__Loc_r
integer s__Loc_ic= 0
location s__Loc_global= Location(0, 0)
real array s__Loc_x
real array s__Loc_y
real array s__Loc_z
integer array s__Loc_lc
constant integer si__Party=16
integer array s__Party_Alloc___recycler
integer s__Party_Alloc___instanceCount= 0
integer array s__Party_p_curPlayer
integer array s__Party_p_perPlayer
force array s__Party_playerPool
player array s__Party_captain
integer array s__Party_heroImages
integer array s__Party_quests
integer array s__Party_questsCount
integer array s__Party_pings
integer array s__Party_pingsCount
integer array s__Party_heroImagesCount
constant integer si__PartyInvitationRequest=17
integer array s__PartyInvitationRequest_Alloc___recycler
integer s__PartyInvitationRequest_Alloc___instanceCount= 0
trigger s__PartyInvitationRequest_t_onCha
boolean array s__PartyInvitationRequest_awaitingResponse
integer array s__PartyInvitationRequest_responses
player array s__PartyInvitationRequest_c
player array s__PartyInvitationRequest_a
integer array s__PartyInvitationRequest_t
constant integer si__SaveCodeToHD__InitS=18
constant integer si__Table___dex=19
constant integer si__Table___handles=20
constant integer si__Table___agents=21
constant integer si__Table___reals=22
constant integer si__Table___booleans=23
constant integer si__Table___strings=24
constant integer si__Table___players=25
constant integer si__Table___widgets=26
constant integer si__Table___destructables=27
constant integer si__Table___items=28
constant integer si__Table___units=29
constant integer si__Table___abilitys=30
constant integer si__Table___timers=31
constant integer si__Table___triggers=32
constant integer si__Table___triggerconditions=33
constant integer si__Table___triggeractions=34
constant integer si__Table___events=35
constant integer si__Table___forces=36
constant integer si__Table___groups=37
constant integer si__Table___locations=38
constant integer si__Table___rects=39
constant integer si__Table___boolexprs=40
constant integer si__Table___sounds=41
constant integer si__Table___effects=42
constant integer si__Table___unitpools=43
constant integer si__Table___itempools=44
constant integer si__Table___quests=45
constant integer si__Table___questitems=46
constant integer si__Table___defeatconditions=47
constant integer si__Table___timerdialogs=48
constant integer si__Table___leaderboards=49
constant integer si__Table___multiboards=50
constant integer si__Table___multiboarditems=51
constant integer si__Table___trackables=52
constant integer si__Table___dialogs=53
constant integer si__Table___buttons=54
constant integer si__Table___texttags=55
constant integer si__Table___lightnings=56
constant integer si__Table___images=57
constant integer si__Table___ubersplats=58
constant integer si__Table___regions=59
constant integer si__Table___fogstates=60
constant integer si__Table___fogmodifiers=61
constant integer si__Table___hashtables=62
constant integer si__Table=63
constant integer si__TableArray=64
integer s__TableArray_tempTable
integer s__TableArray_tempEnd
constant integer si__TimedL=65
lightning array s__TimedL_l
real array s__TimedL_av
real array s__TimedL_da
real array s__TimedL_x1
real array s__TimedL_x2
real array s__TimedL_y1
real array s__TimedL_y2
real array s__TimedL_z1
real array s__TimedL_z2
real array s__TimedL_dx1
real array s__TimedL_dy1
real array s__TimedL_dz1
real array s__TimedL_dx2
real array s__TimedL_dy2
real array s__TimedL_dz2
unit array s__TimedL_s
unit array s__TimedL_t
integer array s__TimedL_time
integer array s__TimedL_next
integer array s__TimedL_prev
boolean array s__TimedL_moves
integer s__TimedL_rlast= 0
integer s__TimedL_first
integer s__TimedL_ic= 0
integer s__TimedL_ir= 0
integer array s__TimedL_rn
integer s__TimedL_dat
integer s__TimedL_dat2
integer s__TimedL_dat3
constant integer si__Type=66
integer s__Type_instanceCount= 0
hashtable s__Type_parentTable= InitHashtable()
integer array s__Type_parent
constant integer si__VersionCatalog=67
integer s__VersionCatalog_instanceCount= 0
integer array s__VersionCatalog_catalogs
integer array s__VersionCatalog_catalogCount
constant integer si__WorldBounds=68
integer s__WorldBounds_maxX
integer s__WorldBounds_maxY
integer s__WorldBounds_minX
integer s__WorldBounds_minY
integer s__WorldBounds_centerX
integer s__WorldBounds_centerY
rect s__WorldBounds_world
region s__WorldBounds_worldRegion
constant integer si__AdvLoc=69
integer array s__AdvLoc_ref
real array s__AdvLoc_angle
real array s__AdvLoc_distance
real array s__AdvLoc_slope
integer array s__AdvLoc_lc
constant integer si__Base=70
constant integer si__Catalog___S=71
constant integer si__Catalog=72
constant integer si__CatalogLoop=73
constant integer si__FFS_MightySlash=74
integer si__FFS_MightySlash_F=0
integer si__FFS_MightySlash_I=0
integer array si__FFS_MightySlash_V
constant integer si__FFS_WhirlingWrath=75
integer si__FFS_WhirlingWrath_F=0
integer si__FFS_WhirlingWrath_I=0
integer array si__FFS_WhirlingWrath_V
integer array s__FFS_WhirlingWrath_T32Interface___list
integer s__FFS_WhirlingWrath_T32Interface___count= - 1
integer s__FFS_WhirlingWrath_T32Interface___timers
integer array s__FFS_WhirlingWrath_recyclePosition
integer s__FFS_WhirlingWrath_attachedTimerData= 0
unit array s__FFS_WhirlingWrath_caster
real array s__FFS_WhirlingWrath_startTime
real array s__FFS_WhirlingWrath_startLevel
real array s__FFS_WhirlingWrath_damagePer
real array s__FFS_WhirlingWrath_x
real array s__FFS_WhirlingWrath_y
integer array s__FFS_WhirlingWrath_playerId
integer array s__FFS_WhirlingWrath_tick
constant integer si__FFS_Banish=76
integer si__FFS_Banish_F=0
integer si__FFS_Banish_I=0
integer array si__FFS_Banish_V
integer array s__FFS_Banish_T32Interface___list
integer s__FFS_Banish_T32Interface___count= - 1
integer s__FFS_Banish_T32Interface___timers
integer array s__FFS_Banish_recyclePosition
group array s__FFS_Banish_units
integer array s__FFS_Banish_data
integer array s__FFS_Banish_unitsIndex
integer array s__FFS_Banish_dataIndex
unit array s__FFS_Banish_caster
real array s__FFS_Banish_movementPerX
real array s__FFS_Banish_movementPerY
real array s__FFS_Banish_onHitDamage
integer array s__FFS_Banish_tickCount
boolean array s__FFS_Banish_isCharging
unit array s__FFS_Banish_chargeTarget
integer array s__FFS_Banish_trail
constant integer si__FFS_BurstCounter=77
integer si__FFS_BurstCounter_F=0
integer si__FFS_BurstCounter_I=0
integer array si__FFS_BurstCounter_V
integer array s__FFS_BurstCounter_T32Interface___list
integer s__FFS_BurstCounter_T32Interface___count= - 1
integer s__FFS_BurstCounter_T32Interface___timers
integer array s__FFS_BurstCounter_recyclePosition
integer s__FFS_BurstCounter_currentInstances= 0
unit array s__FFS_BurstCounter_caster
real array s__FFS_BurstCounter_capacity
real array s__FFS_BurstCounter_currentCapacity
texttag array s__FFS_BurstCounter_textTag
real array s__FFS_BurstCounter_tickCount
real array s__FFS_BurstCounter_tickCountTo
constant integer si__FFS_Superbeast=78
integer si__FFS_Superbeast_F=0
integer si__FFS_Superbeast_I=0
integer array si__FFS_Superbeast_V
constant integer si__GetItemOwner___ItemLoc=79
constant integer si__GetUnitCollision___init=80
constant integer si__ShadowTrail___Alpha=81
unit array s__ShadowTrail___Alpha_ShadowTrail___u
unit array s__ShadowTrail___Alpha_hero
integer array s__ShadowTrail___Alpha_aMax
integer array s__ShadowTrail___Alpha_a
integer array s__ShadowTrail___Alpha_r
integer array s__ShadowTrail___Alpha_g
integer array s__ShadowTrail___Alpha_b
integer array s__ShadowTrail___Alpha_rf
real array s__ShadowTrail___Alpha_rs
boolean array s__ShadowTrail___Alpha_bl
boolean array s__ShadowTrail___Alpha_rem
boolean array s__ShadowTrail___Alpha_sync
effect array s__ShadowTrail___Alpha_e
integer s__ShadowTrail___Alpha_rctl32
constant integer si__ShadowTrail=82
unit array s__ShadowTrail_main
real array s__ShadowTrail_dur
real array s__ShadowTrail_xm
real array s__ShadowTrail_ym
real array s__ShadowTrail_ts
real array s__ShadowTrail_fd
real array s__ShadowTrail_fp
real array s__ShadowTrail_time
real array s__ShadowTrail_interval
real array s__ShadowTrail_af
real array s__ShadowTrail_d
integer array s__ShadowTrail_tc
integer array s__ShadowTrail_fr
integer array s__ShadowTrail_r
integer array s__ShadowTrail_g
integer array s__ShadowTrail_b
integer array s__ShadowTrail_a
integer array s__ShadowTrail_uid
integer array s__ShadowTrail_anim
integer array s__ShadowTrail_id
string array s__ShadowTrail_eff
string array s__ShadowTrail_att
boolean array s__ShadowTrail_bo1
boolean array s__ShadowTrail_bo2
boolean array s__ShadowTrail_h
boolean array s__ShadowTrail_perm
integer array s__ShadowTrail_ta
integer array s__ShadowTrail_tb
playercolor array s__ShadowTrail_pc
integer s__ShadowTrail_rctl32
constant integer si__MainBoard=83
integer si__MainBoard_F=0
integer si__MainBoard_I=0
integer array si__MainBoard_V
integer array s__MainBoard_playerId
string array s__MainBoard_nameOfHero
multiboard array s__MainBoard_main
multiboarditem array s__MainBoard_h_HPMP
multiboarditem array s__MainBoard_h_BREA
multiboarditem array s__MainBoard_h_STRE
multiboarditem array s__MainBoard_h_AGIL
multiboarditem array s__MainBoard_h_INTE
multiboarditem array s__MainBoard_h_MREG
multiboarditem array s__MainBoard_h_HREG
multiboarditem array s__MainBoard_h_ASPD
multiboarditem array s__MainBoard_h_MSPD
multiboarditem array s__MainBoard_h_ARMO
multiboarditem array s__MainBoard_h_DAMA
multiboarditem array s__MainBoard_h_SPAR
multiboarditem array s__MainBoard_h_STAR
multiboarditem array s__MainBoard_h_LLEE
multiboarditem array s__MainBoard_h_ARED
multiboarditem array s__MainBoard_h_BRE2
multiboarditem array s__MainBoard_h_FDMG
multiboarditem array s__MainBoard_h_LDMG
multiboarditem array s__MainBoard_h_SDMG
multiboarditem array s__MainBoard_h_CDMG
multiboarditem array s__MainBoard_h_PDMG
multiboarditem array s__MainBoard_h_CRAT
multiboarditem array s__MainBoard_h_CPOW
multiboarditem array s__MainBoard_h_SRAT
multiboarditem array s__MainBoard_h_SPOW
multiboarditem array s__MainBoard_h_BRE3
multiboarditem array s__MainBoard_h_PHRE
multiboarditem array s__MainBoard_h_SRES
multiboarditem array s__MainBoard_h_FRES
multiboarditem array s__MainBoard_h_LRES
multiboarditem array s__MainBoard_h_CRES
multiboarditem array s__MainBoard_h_PRES
multiboarditem array s__MainBoard_m_HPMP
multiboarditem array s__MainBoard_m_BREA
multiboarditem array s__MainBoard_m_STRE
multiboarditem array s__MainBoard_m_AGIL
multiboarditem array s__MainBoard_m_INTE
multiboarditem array s__MainBoard_m_MREG
multiboarditem array s__MainBoard_m_HREG
multiboarditem array s__MainBoard_m_ASPD
multiboarditem array s__MainBoard_m_MSPD
multiboarditem array s__MainBoard_m_ARMO
multiboarditem array s__MainBoard_m_SPAR
multiboarditem array s__MainBoard_m_STAR
multiboarditem array s__MainBoard_m_LLEE
multiboarditem array s__MainBoard_m_ARED
multiboarditem array s__MainBoard_m_BRE2
multiboarditem array s__MainBoard_m_FDMG
multiboarditem array s__MainBoard_m_LDMG
multiboarditem array s__MainBoard_m_SDMG
multiboarditem array s__MainBoard_m_CDMG
multiboarditem array s__MainBoard_m_PDMG
multiboarditem array s__MainBoard_m_CRAT
multiboarditem array s__MainBoard_m_CPOW
multiboarditem array s__MainBoard_m_SRAT
multiboarditem array s__MainBoard_m_SPOW
multiboarditem array s__MainBoard_m_DAMA
multiboarditem array s__MainBoard_m_BRE3
multiboarditem array s__MainBoard_m_PHRE
multiboarditem array s__MainBoard_m_SRES
multiboarditem array s__MainBoard_m_FRES
multiboarditem array s__MainBoard_m_LRES
multiboarditem array s__MainBoard_m_CRES
multiboarditem array s__MainBoard_m_PRES
constant integer si__StatBoard__ConstantLoop=84
integer array s__StatBoard__ConstantLoop_T32Interface___list
integer s__StatBoard__ConstantLoop_T32Interface___count= - 1
integer s__StatBoard__ConstantLoop_T32Interface___timers
integer array s__StatBoard__ConstantLoop_recyclePosition
integer array s__StatBoard__ConstantLoop_Alloc___recycler
integer s__StatBoard__ConstantLoop_Alloc___instanceCount= 0
integer array s__StatBoard__ConstantLoop_i
integer array s__StatBoard__ConstantLoop_c
constant integer si__StringSize=85
constant integer si__Thread=86
integer array s__Thread_Alloc___recycler
integer s__Thread_Alloc___instanceCount= 0
unit array s__Thread_Thread__threadSyncer
trigger s__Thread_syncThreadTrigger
integer array s__Thread_count
integer array s__Thread_playerPower
integer s__Thread_endPower
boolean array s__Thread_synced_p
constant integer si__Track=87
trigger s__Track_anyClick= CreateTrigger()
trigger s__Track_anyHover= CreateTrigger()
integer s__Track_TrackTable= 0
integer s__Track_instance= 0
trackable s__Track_object= null
player s__Track_tracker= null
integer s__Track_ic= 0
integer s__Track_ir= 0
integer array s__Track_rn
real array s__Track_x
real array s__Track_y
real array s__Track_z
real array s__Track_facing
string array s__Track_model
boolean array s__Track_flag
trigger array s__Track_reg
trigger array s__Track_onClick
trigger array s__Track_onHover
constant integer si__UnitIndexer___PreLoader=88
constant integer si__UnitIndex=89
constant integer si__UnitIndexer=90
integer s__UnitIndexer_INDEX
integer s__UnitIndexer_DEINDEX
constant integer si__UnitEvent=91
integer s__UnitEvent_REMOVE
integer s__UnitEvent_DECAY
integer s__UnitEvent_EXPLODE
integer s__UnitEvent_RESURRECT
integer s__UnitEvent_REINCARNATE
integer s__UnitEvent_ANIMATE
integer s__UnitEvent_START_REINCARNATE
constant integer si__BigInt=92
integer array s__BigInt_bm
integer array s__BigInt_next
integer array s__BigInt_prev
integer array s__BigInt_digit
boolean array s__BigInt_head
integer array s__BigInt_size
boolean array s__BigInt_packed
trigger s__BigInt_evalBase
trigger s__BigInt_evalMultBig
trigger s__BigInt_evalDivideBig
trigger s__BigInt_evalSetBase
integer array s__BigInt_packedBase
integer array s__BigInt_packedPower
integer s__BigInt_count= 0
integer s__BigInt_emto
integer s__BigInt_embt
integer s__BigInt_embt2
integer s__BigInt_embm
integer s__BigInt_embb
integer s__BigInt_embs
integer s__BigInt_embc
integer s__BigInt_eDivBigT
integer s__BigInt_eDivBigN
integer s__BigInt_eDivBigD
integer s__BigInt_eDivBigR
integer s__BigInt_eDivBigB
integer s__BigInt_ebs
integer s__BigInt_ebs2
integer s__BigInt_ebt
integer s__BigInt_ebi
integer s__BigInt_em
integer s__BigInt_baseToSet
integer s__BigInt_thisToConvert
constant integer si__Bonus___O=93
constant integer si__GameStart__Init=94
constant integer si__LearnedAbilities=95
constant integer si__LevelTree=96
integer array s__LevelTree_AVL___table
integer s__LevelTree_AVL___c=0
integer array s__LevelTree_AVL___b
integer array s__LevelTree_AVL___l
integer array s__LevelTree_AVL___r
integer array s__LevelTree_AVL___h
integer array s__LevelTree_AVL___p
integer array s__LevelTree_AVL___v
integer array s__LevelTree_AVL___nn
integer array s__LevelTree_AVL___pn
integer array s__LevelTree_AVL___ro
constant integer si__LifeSaver___Index=97
constant integer si__PriorityEvent___PriorityEventTree=98
integer array s__PriorityEvent___PriorityEventTree_AVL___table
integer s__PriorityEvent___PriorityEventTree_AVL___c=0
integer array s__PriorityEvent___PriorityEventTree_AVL___b
integer array s__PriorityEvent___PriorityEventTree_AVL___l
integer array s__PriorityEvent___PriorityEventTree_AVL___r
integer array s__PriorityEvent___PriorityEventTree_AVL___h
integer array s__PriorityEvent___PriorityEventTree_AVL___p
integer array s__PriorityEvent___PriorityEventTree_AVL___v
integer array s__PriorityEvent___PriorityEventTree_AVL___nn
integer array s__PriorityEvent___PriorityEventTree_AVL___pn
integer array s__PriorityEvent___PriorityEventTree_AVL___ro
constant integer si__PriorityEvent=99
integer s__PriorityEvent_PriorityEvent___PriorityEventMod___instanceCount= 0
integer array s__PriorityEvent_PriorityEvent___PriorityEventMod___next_p
integer array s__PriorityEvent_PriorityEvent___PriorityEventMod___last_p
integer array s__PriorityEvent_PriorityEvent___PriorityEventMod___first_p
integer s__PriorityEvent_PriorityEvent___PriorityEventMod___count= 0
integer array s__PriorityEvent_PriorityEvent___PriorityEventMod___tree
trigger array s__PriorityEvent_PriorityEvent___PriorityEventMod___event
boolexpr array s__PriorityEvent_PriorityEvent___PriorityEventMod___code
trigger array s__PriorityEvent_PriorityEvent___PriorityEventMod___allEvent
boolean s__PriorityEvent_PriorityEvent___PriorityEventMod___merged= false
constant integer si__QuestAPI=100
integer array s__QuestAPI_Alloc___recycler
integer s__QuestAPI_Alloc___instanceCount= 0
integer array s__QuestAPI_indice
integer array s__QuestAPI_stageIndice
integer array s__QuestAPI_rewardIndice
integer array s__QuestAPI_interactIndice
boolean array s__QuestAPI_isInInteractTable
integer array s__QuestAPI_interactPosition
integer array s__QuestAPI_instances
string array s__QuestAPI_questName
integer array s__QuestAPI_instancesCount
boolean array s__QuestAPI_active
force array s__QuestAPI_hasFinished
integer array s__QuestAPI_starter
constant integer si__QuestInteractListener=101
integer array s__QuestInteractListener_Alloc___recycler
integer s__QuestInteractListener_Alloc___instanceCount= 0
widget array s__QuestInteractListener_interact
string array s__QuestInteractListener_onInt
string array s__QuestInteractListener_onAcc
integer array s__QuestInteractListener_b
integer array s__QuestInteractListener_interactPosition
integer array s__QuestInteractListener_levelPosition
integer array s__QuestInteractListener_levelPinged
boolean array s__QuestInteractListener_usesLevel
boolean array s__QuestInteractListener_defaultEnabled
string array s__QuestInteractListener_questName
integer array s__QuestInteractListener_level
unit array s__QuestInteractListener_exc
integer array s__QuestInteractListener_root
constant integer si__QuestInstance=102
integer si__QuestInstance_F=0
integer si__QuestInstance_I=0
integer array si__QuestInstance_V
integer array s__QuestInstance_root
integer array s__QuestInstance_party
integer array s__QuestInstance_stage
integer array s__QuestInstance_thisIndex
unit array s__QuestInstance_lastTrigger
unit array s___QuestInstance_lastTriggerUnit
constant integer s___QuestInstance_lastTriggerUnit_size=11
integer array s__QuestInstance_lastTriggerUnit
integer array s___QuestInstance_i
constant integer s___QuestInstance_i_size=11
integer array s__QuestInstance_i
integer array s__QuestInstance_progress
integer array s__QuestInstance_currentProgress
integer array s__QuestInstance_onDestroy
integer array s__QuestInstance_onDestIndex
constant integer si__QuestMain=105
integer si__QuestMain_F=0
integer si__QuestMain_I=0
integer array si__QuestMain_V
constant integer si__TempCatalog=106
timer s__TempCatalog_dest= CreateTimer()
integer array s__TempCatalog_rec
integer s__TempCatalog_recc= 0
constant integer si__WordWrap=107
string array s__WordWrap_line
integer s__WordWrap_count= 0
constant integer si__DDS_DamageEvent___DamageEventPriority=108
constant integer s__DDS_DamageEvent___DamageEventPriority_PRIORITY= 0
constant integer si__DDS_DamageEventModification___OnDeath=109
constant integer si__DDS_DamageEventModification___Deindex=110
constant integer si__DDS_Archetype___DamageEventArchtype=111
constant integer s__DDS_Archetype___DamageEventArchtype_SPELL= 0
constant integer s__DDS_Archetype___DamageEventArchtype_PHYSICAL= 1
constant integer s__DDS_Archetype___DamageEventArchtype_CODE= 2
constant integer s__DDS_Archetype___DamageEventArchtype_DOT= 3
constant integer s__DDS_Archetype___DamageEventArchtype_HEAL= 4
constant integer s__DDS_Archetype___DamageEventArchtype_AGGRO= 5
constant integer si__DDS=112
integer s__DDS_ANY
integer s__DDS_DDS___targetId_p= 0
integer s__DDS_DDS___sourceId_p= 0
real s__DDS_DDS___damage_p= 0
player s__DDS_DDS___sourcePlayer_p= null
real s__DDS_damageOriginal= 0
integer s__DDS_Archetype= 0
integer s__DDS_DDS_Archetype___archetype_p= 0
integer s__DDS_DDS_Archetype___damageCode_p= 0
constant integer si__DDS___Trigger=113
integer s__DDS___Trigger_instanceCount= 0
integer array s__DDS___Trigger_first
integer array s__DDS___Trigger_next
integer array s__DDS___Trigger_prev
integer array s__DDS___Trigger_parent
integer array s__DDS___Trigger_inactiveUnits
integer array s__DDS___Trigger_activeUnits
trigger array s__DDS___Trigger_trigger
constant integer si__DDS_TriggerRefresh___TriggerHeapInner=114
integer s__DDS_TriggerRefresh___TriggerHeapInner_size= 0
integer array s__DDS_TriggerRefresh___TriggerHeapInner_node
integer array s__DDS_TriggerRefresh___TriggerHeapInner_heap
constant integer si__DDS_TriggerRefresh___TriggerHeap=115
constant integer si__DDS_TriggerRefresh___TriggerRefreshInit=116
constant integer si__DDS___DDS_Init=117
constant integer si__GroupVersionCatalog__GroupFilter=118
integer s__GroupVersionCatalog__GroupFilter_instanceCount= 0
integer array s__GroupVersionCatalog__GroupFilter_groupFilterTable
integer s__GroupVersionCatalog__GroupFilter_groupCatalog
integer array s__GroupVersionCatalog__GroupFilter_groupIdTable
constant integer si__GroupVersionCatalog__VersionFilter=119
integer s__GroupVersionCatalog__VersionFilter_instanceCount= 0
integer array s__GroupVersionCatalog__VersionFilter_groupFilterTable
constant integer si__GroupVersionCatalog=120
integer s__GroupVersionCatalog_instanceCount= 0
integer array s__GroupVersionCatalog_versionFilter
integer array s__GroupVersionCatalog_groupTable
integer array s__GroupVersionCatalog_groups
integer array s__GroupVersionCatalog_groupCount
integer array s__GroupVersionCatalog_ver
integer array s__GroupVersionCatalog_groupAddTable
trigger s__GroupVersionCatalog_eUpdate
integer s__GroupVersionCatalog_toUpdate
constant integer si__ICI=121
integer si__ICI_F=0
integer si__ICI_I=0
integer array si__ICI_V
string array s__ICI_opConTitle
string array s__ICI_opConDesc
integer array s__ICI_opIds
constant integer si__Item=122
integer array s__Item_Alloc___recycler
integer s__Item_Alloc___instanceCount= 0
integer array s__Item_buttonId
integer array s__Item_slot
string array s__Item_title
string array s__Item_desc
item array s__Item_link
integer array s__Item_traits
integer array s__Item_reqs
integer array s__Item_reqCount
integer array s__Item_current
integer array s__Item_button
integer array s__Item_setv
integer array s__Item_possibleRecipe
string array s__Item_genDesc
constant integer si__ItemInventory__link2table=123
integer si__ItemInventory__link2table_F=0
integer si__ItemInventory__link2table_I=0
integer array si__ItemInventory__link2table_V
integer array s__ItemInventory__link2table_t
constant integer si__T2InvB=124
integer si__T2InvB_F=0
integer si__T2InvB_I=0
integer array si__T2InvB_V
integer array s__T2InvB_t
constant integer si__InventoryButton=125
integer si__InventoryButton_F=0
integer si__InventoryButton_I=0
integer array si__InventoryButton_V
real array s__InventoryButton_x
real array s__InventoryButton_y
integer array s__InventoryButton_defaultDestPic
destructable array s__InventoryButton_current
integer array s__InventoryButton_button
boolean array s__InventoryButton_occupied
string array s__InventoryButton_info
integer array s__InventoryButton_link
string array s__InventoryButton_title
string array s__InventoryButton_description
boolean array s__InventoryButton_showOnTooltip
constant integer si__Set=126
integer si__Set_F=0
integer si__Set_I=0
integer array si__Set_V
integer array s__Set_itemIds
integer array s__Set_currentItem
integer array s__Set_traitData
integer array s__Set_applied
integer array s__Set_currentTrait
string array s__Set_title
string array s__Set_desc
string array s__Set_starter
constant integer si__InventoryGrouping=127
integer array s__InventoryGrouping_Alloc___recycler
integer s__InventoryGrouping_Alloc___instanceCount= 0
integer array s__InventoryGrouping_buttons
integer array s__InventoryGrouping_count
constant integer si__RecipeGroup=128
integer si__RecipeGroup_F=0
integer si__RecipeGroup_I=0
integer array si__RecipeGroup_V
integer array s__RecipeGroup_recipes
integer array s__RecipeGroup_recIndex
constant integer si__Recipe2=129
integer si__Recipe2_F=0
integer si__Recipe2_I=0
integer array si__Recipe2_V
integer array s__Recipe2_pieces
integer array s__Recipe2_results
integer array s__Recipe2_piecesCount
integer array s__Recipe2_resultsCount
string array s__Recipe2_temp
string s__Recipe2_total= ""
constant integer si__CustomInventory=130
trigger s__CustomInventory_onRecipe
integer s__CustomInventory_t
string s__CustomInventory_debugging= ""
constant integer si__LevelFilter=131
integer array s__LevelFilter_catalogTable
integer array s__LevelFilter_tree
constant integer si__MissileList=132
integer s__MissileList_LinkedListLite___instanceCount= 0
integer array s__MissileList_next
integer array s__MissileList_prev
boolean array s__MissileList_head
constant integer si__Missile=133
integer s__Missile_LinkedListLite___instanceCount= 0
integer array s__Missile_next
integer array s__Missile_prev
boolean array s__Missile_head
boolean array s__Missile_terminated
integer array s__Missile_impact
integer array s__Missile_origin
real array s__Missile_slide
real array s__Missile_damageDealt
real array s__Missile_x
real array s__Missile_y
real array s__Missile_z
real array s__Missile_cA
effect array s__Missile_fx
string array s__Missile_fP
real array s__Missile_dS
unit array s__Missile_dummy
group array s__Missile_unitsHit
boolean array s__Missile_recycle
boolean array s__Missile_wantDestroy
unit array s__Missile_target
unit array s__Missile_source
real array s__Missile_collision
real array s__Missile_height
real array s__Missile_turn
real array s__Missile_open
real array s__Missile_damage
real array s__Missile_speed
real array s__Missile_acceleration
integer array s__Missile_data
integer array s__Missile_data2
constant integer si__NumberStack=134
integer array s__NumberStack_baset
trigger s__NumberStack_epusht
integer s__NumberStack_epushThis
integer s__NumberStack_epushValue
integer s__NumberStack_epushMaxValue
constant integer si__Listener=135
integer si__Listener_F=0
integer si__Listener_I=0
integer array si__Listener_V
constant integer si__Scrambler__Inits=136
constant integer si__StatHandler=137
integer si__StatHandler_F=0
integer si__StatHandler_I=0
integer array si__StatHandler_V
constant integer si__VJassTalentTree=138
integer si__VJassTalentTree_F=0
integer si__VJassTalentTree_I=0
integer array si__VJassTalentTree_V
constant integer si__EncryptNumber__N=139
constant integer si__LevelGroupSlotVersionCatalog__GroupFilter=140
integer s__LevelGroupSlotVersionCatalog__GroupFilter_instanceCount= 0
integer array s__LevelGroupSlotVersionCatalog__GroupFilter_groupFilterTable
integer s__LevelGroupSlotVersionCatalog__GroupFilter_levelFilter
integer array s__LevelGroupSlotVersionCatalog__GroupFilter_groupIdTable
constant integer si__LevelGroupSlotVersionCatalog__VersionFilter=141
integer s__LevelGroupSlotVersionCatalog__VersionFilter_instanceCount= 0
integer array s__LevelGroupSlotVersionCatalog__VersionFilter_groupFilterTable
constant integer si__LevelGroupSlotVersionCatalog__SlotFilter=142
integer array s__LevelGroupSlotVersionCatalog__SlotFilter_slotId
integer s__LevelGroupSlotVersionCatalog__SlotFilter_slotCount= 0
constant integer si__LevelGroupSlotVersionCatalog__GroupHashFilter=143
integer s__LevelGroupSlotVersionCatalog__GroupHashFilter_instanceCount= 0
integer array s__LevelGroupSlotVersionCatalog__GroupHashFilter_groupHash
integer s__LevelGroupSlotVersionCatalog__GroupHashFilter_groupHashCount= 0
constant integer si__LevelGroupSlotVersionCatalog=144
integer s__LevelGroupSlotVersionCatalog_instanceCount= 0
integer array s__LevelGroupSlotVersionCatalog_slotFilter
integer array s__LevelGroupSlotVersionCatalog_versionFilter
integer array s__LevelGroupSlotVersionCatalog_groupTable
integer array s__LevelGroupSlotVersionCatalog_groups
integer array s__LevelGroupSlotVersionCatalog_groupCount
integer array s__LevelGroupSlotVersionCatalog_ver
integer array s__LevelGroupSlotVersionCatalog_groupAddTable
trigger s__LevelGroupSlotVersionCatalog_eUpdate
integer s__LevelGroupSlotVersionCatalog_toUpdate
constant integer si__LevelGroupVersionCatalog__GroupFilter=145
integer s__LevelGroupVersionCatalog__GroupFilter_instanceCount= 0
integer array s__LevelGroupVersionCatalog__GroupFilter_groupFilterTable
integer s__LevelGroupVersionCatalog__GroupFilter_levelFilter
integer array s__LevelGroupVersionCatalog__GroupFilter_groupIdTable
constant integer si__LevelGroupVersionCatalog__VersionFilter=146
integer s__LevelGroupVersionCatalog__VersionFilter_instanceCount= 0
integer array s__LevelGroupVersionCatalog__VersionFilter_groupFilterTable
constant integer si__LevelGroupVersionCatalog=147
integer s__LevelGroupVersionCatalog_instanceCount= 0
integer array s__LevelGroupVersionCatalog_versionFilter
integer array s__LevelGroupVersionCatalog_groupTable
integer array s__LevelGroupVersionCatalog_groups
integer array s__LevelGroupVersionCatalog_groupCount
integer array s__LevelGroupVersionCatalog_ver
integer array s__LevelGroupVersionCatalog_groupAddTable
trigger s__LevelGroupVersionCatalog_eUpdate
integer s__LevelGroupVersionCatalog_toUpdate
constant integer si__SpellChargedBolt__CB=148
integer s__SpellChargedBolt__CB_COUNT= 0
unit s__SpellChargedBolt__CB_FOOTMAN= null
timer s__SpellChargedBolt__CB_t= CreateTimer()
boolean s__SpellChargedBolt__CB_b= false
constant integer si__WitchFirstSpells__MissileHandler=149
integer si__WitchFirstSpells__MissileHandler_F=0
integer si__WitchFirstSpells__MissileHandler_I=0
integer array si__WitchFirstSpells__MissileHandler_V
constant integer si__WitchFirstSpells__ChampTimer=150
integer si__WitchFirstSpells__ChampTimer_F=0
integer si__WitchFirstSpells__ChampTimer_I=0
integer array si__WitchFirstSpells__ChampTimer_V
integer s__WitchFirstSpells__ChampTimer_duration= 5
unit array s__WitchFirstSpells__ChampTimer_toHide
unit array s__WitchFirstSpells__ChampTimer_toShow
real array s__WitchFirstSpells__ChampTimer_startTime
integer array s__WitchFirstSpells__ChampTimer_T32Interface___list
integer s__WitchFirstSpells__ChampTimer_T32Interface___count= - 1
integer s__WitchFirstSpells__ChampTimer_T32Interface___timers
integer array s__WitchFirstSpells__ChampTimer_recyclePosition
constant integer si__WitchFirstSpells__BathMain=151
integer si__WitchFirstSpells__BathMain_F=0
integer si__WitchFirstSpells__BathMain_I=0
integer array si__WitchFirstSpells__BathMain_V
integer array s__WitchFirstSpells__BathMain_list
integer s__WitchFirstSpells__BathMain_count= - 1
integer s__WitchFirstSpells__BathMain_timers
integer array s__WitchFirstSpells__BathMain_recyclePosition
unit array s__WitchFirstSpells__BathMain_caster
real array s__WitchFirstSpells__BathMain_castx
real array s__WitchFirstSpells__BathMain_casty
real array s__WitchFirstSpells__BathMain_damagePer32
real array s__WitchFirstSpells__BathMain_timeOnStart
constant integer si__BurningSoul=152
integer array s__BurningSoul_T32Interface___list
integer s__BurningSoul_T32Interface___count= - 1
integer s__BurningSoul_T32Interface___timers
integer array s__BurningSoul_recyclePosition
integer array s__BurningSoul_Alloc___recycler
integer s__BurningSoul_Alloc___instanceCount= 0
integer s__BurningSoul_perHeroInstances
integer array s__BurningSoul_ticksRemaining
integer array s__BurningSoul_subTick
real array s__BurningSoul_damagePer32
unit array s__BurningSoul_caster
unit array s__BurningSoul_target
constant integer si__Firebomb=153
integer array s__Firebomb_Alloc___recycler
integer s__Firebomb_Alloc___instanceCount= 0
unit array s__Firebomb_casthero
group array s__Firebomb_hitGroup
integer array s__Firebomb_lvl
constant integer si__FlameWave=154
integer array s__FlameWave_Alloc___recycler
integer s__FlameWave_Alloc___instanceCount= 0
integer s__FlameWave_StructAttach___t_v
unit array s__FlameWave_caster
integer array s__FlameWave_lvl
real array s__FlameWave_dmgPerMainHit
real array s__FlameWave_dmgPerSideHit
boolean array s__FlameWave_continue
boolean array s__FlameWave_tick
integer array s__FlameWave_dragon
integer array s__FlameWave_T32Interface___list
integer s__FlameWave_T32Interface___count= - 1
integer s__FlameWave_T32Interface___timers
integer array s__FlameWave_recyclePosition
constant integer si__DamageOverTime=155
integer array s__DamageOverTime_Alloc___recycler
integer s__DamageOverTime_Alloc___instanceCount= 0
real array s__DamageOverTime_x
real array s__DamageOverTime_y
real array s__DamageOverTime_r
real array s__DamageOverTime_d32
integer array s__DamageOverTime_tR
unit array s__DamageOverTime_caster
integer array s__DamageOverTime_t
constant integer si__Pressure=156
integer array s__Pressure_Alloc___recycler
integer s__Pressure_Alloc___instanceCount= 0
real array s__Pressure_fifthX
real array s__Pressure_fifthY
real array s__Pressure_fourthX
real array s__Pressure_fourthY
real array s__Pressure_thirdX
real array s__Pressure_thirdY
real array s__Pressure_secondX
real array s__Pressure_secondY
real array s__Pressure_firstX
real array s__Pressure_firstY
integer array s__Pressure_missileCount
unit array s__Pressure_caster
real array s__Pressure_posX
real array s__Pressure_posY
real array s__Pressure_damagePerHit
player array s__Pressure_castOwner
integer array s__Pressure_lvl
integer array s__Pressure_tick
integer array s__Pressure_onFirstFx
integer array s__Pressure_onFirstDmg
integer array s__Pressure_onSecondFx
integer array s__Pressure_onSecondDmg
integer array s__Pressure_onThirdFx
integer array s__Pressure_onThirdDmg
integer array s__Pressure_onFourthFx
integer array s__Pressure_onFourthDmg
integer array s__Pressure_onFifthFx
integer array s__Pressure_onFifthDmg
boolean array s__Pressure_isPhoenyx
integer array s__Pressure_T32Interface___list
integer s__Pressure_T32Interface___count= - 1
integer s__Pressure_T32Interface___timers
integer array s__Pressure_recyclePosition
constant integer si__FlameConjuration=157
integer array s__FlameConjuration_Alloc___recycler
integer s__FlameConjuration_Alloc___instanceCount= 0
unit array s__FlameConjuration_caster
unit array s__FlameConjuration_dummy
integer array s__FlameConjuration_lvl
integer array s__FlameConjuration_tick
integer array s__FlameConjuration_finalTick
integer array s__FlameConjuration_forUnit
integer array s__FlameConjuration_T32Interface___list
integer s__FlameConjuration_T32Interface___count= - 1
integer s__FlameConjuration_T32Interface___timers
integer array s__FlameConjuration_recyclePosition
constant integer si__PhoenixBarrage=158
integer array s__PhoenixBarrage_Alloc___recycler
integer s__PhoenixBarrage_Alloc___instanceCount= 0
unit array s__PhoenixBarrage_caster
integer array s__PhoenixBarrage_lvl
real array s__PhoenixBarrage_dmg
real array s__PhoenixBarrage_targetX
real array s__PhoenixBarrage_targetY
filterfunc array s__PhoenixBarrage_filter
constant integer si__ForceBall=159
integer array s__ForceBall_Alloc___recycler
integer s__ForceBall_Alloc___instanceCount= 0
constant integer si__ForceWall=160
integer array s__ForceWall_Alloc___recycler
integer s__ForceWall_Alloc___instanceCount= 0
constant integer si__ForceBarrage=161
integer array s__ForceBarrage_Alloc___recycler
integer s__ForceBarrage_Alloc___instanceCount= 0
constant integer si__Powerstone=162
integer array s__Powerstone_Alloc___recycler
integer s__Powerstone_Alloc___instanceCount= 0
constant integer si__EnergyTap=163
integer array s__EnergyTap_Alloc___recycler
integer s__EnergyTap_Alloc___instanceCount= 0
constant integer si__Demo=164
constant string s__Demo_CIPHER= "0123456789<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]abcdefghijklmnopqrstuvwxyz"
constant string s__Demo_SAVE_COMMAND= "-save"
constant string s__Demo_LOAD_COMMAND= "-load"
constant string s__Demo_SECURITY= "262144"
constant integer s__Demo_ENCRYPTION_STRENGTH= 3
integer s__Demo_security
integer s__Demo_encryptionKey
constant integer s__Demo_v03G= 1
constant integer s__Demo_versionMax= 256
constant integer si__ItemRoots=165
integer s__ItemRoots_catalog
constant integer s__ItemRoots_v03G= 1
constant integer s__ItemRoots_gA= 1
constant integer s__ItemRoots_gZA= 2
constant integer s__ItemRoots_gWR= 3
constant integer s__ItemRoots_gAm= 129
constant integer s__ItemRoots_gZ= 128
constant integer s__ItemRoots_gW= 130
constant integer s__ItemRoots_gAn= 131
constant integer s__ItemRoots_gR= 132
constant integer s__ItemRoots_amazon= 'H006'
constant integer s__ItemRoots_zealot= 'H003'
constant integer s__ItemRoots_witch= 'H013'
constant integer s__ItemRoots_anarchist= 'H010'
constant integer s__ItemRoots_runemaster= 'H005'
integer s__ItemRoots_curGroup
constant integer si__Heroes=166
integer s__Heroes_catalog
constant integer si__arrayEnum=167
integer si__arrayEnum_F=0
integer si__arrayEnum_I=0
integer array si__arrayEnum_V
integer array s___arrayEnum_a
constant integer s___arrayEnum_a_size=7
integer array s__arrayEnum_a
constant integer si__DescList=169
integer si__DescList_F=0
integer si__DescList_I=0
integer array si__DescList_V
constant integer s__DescList_D= 0
constant integer s__DescList_DL= 1
constant integer s__DescList_DR= 2
constant integer s__DescList_L= 3
constant integer s__DescList_R= 4
constant integer s__DescList_U= 5
constant integer s__DescList_UL= 6
constant integer s__DescList_UR= 7
integer array s___DescList_bdrs
constant integer s___DescList_bdrs_size=12
integer array s__DescList_bdrs
constant integer si__Borders=171
integer si__Borders_F=0
integer si__Borders_I=0
integer array si__Borders_V
integer s__Borders_current= 0
integer s__Borders_replace= 0
player s__Borders_p
integer array s__Borders_desc
constant integer si__Button=172
integer si__Button_F=0
integer si__Button_I=0
integer array si__Button_V
integer array s__Button_x
integer array s__Button_y
integer array s__Button_heroIndex
integer array s__Button_buttonId
integer array s__Button_disabledButtonId
integer array s__Button_maxLevel
integer array s__Button_initPointReq
integer array s__Button_pointReq
string array s__Button_descName
string array s__Button_descDescription
integer array s___Button_linkx
constant integer s___Button_linkx_size=3
integer array s__Button_linkx
integer array s___Button_linky
constant integer s___Button_linky_size=3
integer array s__Button_linky
integer array s___Button_linkLevel
constant integer s___Button_linkLevel_size=3
integer array s__Button_linkLevel
integer array s__Button_currentLink
integer array s__Button_data
boolean array s__Button_is
constant integer si__vJassTTInteract=176
integer si__vJassTTInteract_F=0
integer si__vJassTTInteract_I=0
integer array si__vJassTTInteract_V
player s__vJassTTInteract_interactingPlayer
integer s__vJassTTInteract_buttonId
integer s__vJassTTInteract_heroIndex
integer s__vJassTTInteract_attachedData
boolean s__vJassTTInteract_rejected
constant integer si__Test=177
integer s__Test_DDS___dds= 0
integer s__Test_DDS___DAMAGE_EVENT_INTERFACE___priority= 0
constant integer si__UnitRespawn=178
integer si__UnitRespawn_F=0
integer si__UnitRespawn_I=0
integer array si__UnitRespawn_V
hashtable s__UnitRespawn_creepTable= InitHashtable()
boolean array s__UnitRespawn_allocated
integer array s__GroupUtils___Status
integer array s__2GroupUtils___Status
integer array s__3GroupUtils___Status
integer array s__4GroupUtils___Status
integer array s__5GroupUtils___Status
integer array s__6GroupUtils___Status
integer array s__7GroupUtils___Status
integer array s__8GroupUtils___Status
integer array s__9GroupUtils___Status
integer array s__10GroupUtils___Status
integer array s__11GroupUtils___Status
integer array s__12GroupUtils___Status
integer array s__13GroupUtils___Status
integer array s__14GroupUtils___Status
integer array s__15GroupUtils___Status
integer array s__16GroupUtils___Status
integer array s__17GroupUtils___Status
integer array s__18GroupUtils___Status
integer array s__19GroupUtils___Status
integer array s__20GroupUtils___Status
integer array s__21GroupUtils___Status
integer array s__22GroupUtils___Status
integer array s__23GroupUtils___Status
integer array s__24GroupUtils___Status
integer array s__25GroupUtils___Status
integer array s__26GroupUtils___Status
integer array s__27GroupUtils___Status
integer array s__28GroupUtils___Status
integer array s__29GroupUtils___Status
integer array s__30GroupUtils___Status
integer array s__31GroupUtils___Status
integer array s__32GroupUtils___Status
integer array s__33GroupUtils___Status
integer array s__34GroupUtils___Status
integer array s__35GroupUtils___Status
integer array s__36GroupUtils___Status
integer array s__37GroupUtils___Status
integer array s__38GroupUtils___Status
integer array s__39GroupUtils___Status
integer array s__40GroupUtils___Status
integer array s__41GroupUtils___Status
integer array s__42GroupUtils___Status
integer array s__43GroupUtils___Status
integer array s__44GroupUtils___Status
integer array s__45GroupUtils___Status
integer array s__46GroupUtils___Status
integer array s__47GroupUtils___Status
integer array s__48GroupUtils___Status
integer array s__49GroupUtils___Status
integer array s__50GroupUtils___Status
trigger st__Quest_refreshDescription
trigger st__HeroImage_destroy
trigger st__Table___reals__getindex
trigger st__Table___reals__setindex
trigger st__Table___booleans__getindex
trigger st__Table___booleans__setindex
trigger st__Table___strings__getindex
trigger st__Table___strings__setindex
trigger st__Table___widgets__getindex
trigger st__Table___units__getindex
trigger st__Table___units__setindex
trigger st__Table___fogstates__setindex
trigger st__Table__get_real
trigger st__Table__get_boolean
trigger st__Table__get_string
trigger st__Table__get_widget
trigger st__Table__get_unit
trigger st__Table__get_fogstate
trigger st__Table__getindex
trigger st__Table__setindex
trigger st__Table_has
trigger st__Table_remove
trigger st__Table_create
trigger st__Table_destroy
trigger st__TableArray__staticgetindex
trigger st__TableArray__getindex
trigger st__Catalog_create
trigger st__Catalog_add
trigger st__Catalog_addCatalog
trigger st__FFS_WhirlingWrath_T32Interface___expire
trigger st__FFS_WhirlingWrath_onLoop
trigger st__FFS_WhirlingWrath_onExpire
trigger st__FFS_Banish_T32Interface___expire
trigger st__FFS_Banish_onLoop
trigger st__FFS_Banish_onExpire
trigger st__FFS_Banish_cancel
trigger st__FFS_Banish_onCollide
trigger st__FFS_BurstCounter_T32Interface___expire
trigger st__FFS_BurstCounter_onLoop
trigger st__FFS_BurstCounter_onExpire
trigger st__ShadowTrail_remove
trigger st__ShadowTrail_setEffect
trigger st__ShadowTrail_setColor
trigger st__ShadowTrail_setAnimationIndex
trigger st__ShadowTrail_setFadeRate
trigger st__ShadowTrail_setupMovingTrail
trigger st__ShadowTrail_add
trigger st__StatBoard__ConstantLoop_T32Interface___expire
trigger st__StatBoard__ConstantLoop_onLoop
trigger st__StatBoard__ConstantLoop_onExpire
trigger st__UnitIndexer__set_enabled
trigger st__GameStart__Init_run
trigger st__QuestAPI_triggerRun
trigger st__QuestInteractListener_create
trigger st__QuestInteractListener_setLevel
trigger st__QuestInteractListener_enable
trigger st__QuestInteractListener_reset
trigger st__QuestInstance_create
trigger st__QuestInstance_containsPlayer
trigger st__QuestInstance_getStage
trigger st__QuestInstance_start
trigger st__QuestInstance_nextStage
trigger st__QuestInstance_notifyClosure
trigger st__QuestInstance_finish
trigger st__QuestInstance_triggerFulfill
trigger st__ICI_getTraitDescription
trigger st__ICI_displaySetData
trigger st__Item_addSet
trigger st__Item_addRecipe
trigger st__Item_addTrait
trigger st__Item_addReq
trigger st__Item_getTrait
trigger st__Item_getReq
trigger st__T2InvB_create
trigger st__InventoryButton_removeItem
trigger st__InventoryButton_noTooltip
trigger st__InventoryButton_desc
trigger st__Set_addItem
trigger st__RecipeGroup_add
trigger st__Recipe2_create
trigger st__Recipe2_check
trigger st__CustomInventory_setOnRecipe
trigger st__CustomInventory_linkItemTraitData
trigger st__CustomInventory_getItemTraitData
trigger st__CustomInventory_doesUnitHaveItemInEq
trigger st__CustomInventory_gather
trigger st__CustomInventory_wipeSelected
trigger st__CustomInventory_wipeHovered
trigger st__CustomInventory_moveFromRecipe
trigger st__CustomInventory_removeEqWithoutAdd
trigger st__CustomInventory_generateNewItem
trigger st__CustomInventory_initsiesss
trigger st__CustomInventory_register
trigger st__Listener_interactCondition
trigger st__StatHandler_addUnitBonus
trigger st__StatHandler_r_compile
trigger st__StatHandler_removeUnitBonus
trigger st__StatHandler_getUnitBonus
trigger st__StatHandler_getUnitResistance
trigger st__VJassTalentTree_hideUI
trigger st__VJassTalentTree_showUI
trigger st__WitchFirstSpells__ChampTimer_T32Interface___expire
trigger st__WitchFirstSpells__ChampTimer_onLoop
trigger st__WitchFirstSpells__ChampTimer_onExpire
trigger st__WitchFirstSpells__BathMain_expire
trigger st__WitchFirstSpells__BathMain_onLoop
trigger st__BurningSoul_T32Interface___expire
trigger st__BurningSoul_onLoop
trigger st__BurningSoul_onExpire
trigger st__BurningSoul_create
trigger st__FlameWave_T32Interface___expire
trigger st__Pressure_T32Interface___expire
trigger st__FlameConjuration_T32Interface___expire
trigger st__PhoenixBarrage_launch
trigger st__ItemRoots_get
trigger st__Heroes__get_raw
trigger st__Heroes__get_count
trigger st__Heroes__get_id
trigger st__Button_create
trigger st__Button_addData
trigger st__Button_isMenu
trigger st__Button_createLink
trigger st__Button_push
trigger st__Button_reCreate
trigger array st___prototype3
integer f__arg_integer1
integer f__arg_integer2
integer f__arg_integer3
integer f__arg_integer4
integer f__arg_integer5
integer f__arg_integer6
integer f__arg_integer7
integer f__arg_integer8
real f__arg_real1
real f__arg_real2
boolean f__arg_boolean1
string f__arg_string1
string f__arg_string2
string f__arg_string3
unit f__arg_unit1
unit f__arg_unit2
fogstate f__arg_fogstate1
trigger f__arg_trigger1
widget f__arg_widget1
player f__arg_player1
item f__arg_item1
integer f__arg_this
integer f__result_integer
real f__result_real
boolean f__result_boolean
string f__result_string
widget f__result_widget
unit f__result_unit

endglobals
    native UnitAlive takes unit id returns boolean


function sg__GroupUtils___Status_get takes integer i returns integer
    if(i<8191) then
        return s__GroupUtils___Status[i]
    elseif(i<204775) then
        if(i<16382) then
            return s__2GroupUtils___Status[i-8191]
        elseif(i<106483) then
            if(i<24573) then
                return s__3GroupUtils___Status[i-16382]
            elseif(i<65528) then
                if(i<32764) then
                    return s__4GroupUtils___Status[i-24573]
                elseif(i<49146) then
                    if(i<40955) then
                        return s__5GroupUtils___Status[i-32764]
                    else
                        return s__6GroupUtils___Status[i-40955]
                    endif
                elseif(i<57337) then
                    return s__7GroupUtils___Status[i-49146]
                else
                    return s__8GroupUtils___Status[i-57337]
                endif
            elseif(i<73719) then
                return s__9GroupUtils___Status[i-65528]
            elseif(i<90101) then
                if(i<81910) then
                    return s__10GroupUtils___Status[i-73719]
                else
                    return s__11GroupUtils___Status[i-81910]
                endif
            elseif(i<98292) then
                return s__12GroupUtils___Status[i-90101]
            else
                return s__13GroupUtils___Status[i-98292]
            endif
        elseif(i<114674) then
            return s__14GroupUtils___Status[i-106483]
        elseif(i<155629) then
            if(i<122865) then
                return s__15GroupUtils___Status[i-114674]
            elseif(i<139247) then
                if(i<131056) then
                    return s__16GroupUtils___Status[i-122865]
                else
                    return s__17GroupUtils___Status[i-131056]
                endif
            elseif(i<147438) then
                return s__18GroupUtils___Status[i-139247]
            else
                return s__19GroupUtils___Status[i-147438]
            endif
        elseif(i<163820) then
            return s__20GroupUtils___Status[i-155629]
        elseif(i<180202) then
            if(i<172011) then
                return s__21GroupUtils___Status[i-163820]
            else
                return s__22GroupUtils___Status[i-172011]
            endif
        elseif(i<188393) then
            return s__23GroupUtils___Status[i-180202]
        elseif(i<196584) then
            return s__24GroupUtils___Status[i-188393]
        else
            return s__25GroupUtils___Status[i-196584]
        endif
    elseif(i<212966) then
        return s__26GroupUtils___Status[i-204775]
    elseif(i<311258) then
        if(i<221157) then
            return s__27GroupUtils___Status[i-212966]
        elseif(i<262112) then
            if(i<229348) then
                return s__28GroupUtils___Status[i-221157]
            elseif(i<245730) then
                if(i<237539) then
                    return s__29GroupUtils___Status[i-229348]
                else
                    return s__30GroupUtils___Status[i-237539]
                endif
            elseif(i<253921) then
                return s__31GroupUtils___Status[i-245730]
            else
                return s__32GroupUtils___Status[i-253921]
            endif
        elseif(i<270303) then
            return s__33GroupUtils___Status[i-262112]
        elseif(i<286685) then
            if(i<278494) then
                return s__34GroupUtils___Status[i-270303]
            else
                return s__35GroupUtils___Status[i-278494]
            endif
        elseif(i<294876) then
            return s__36GroupUtils___Status[i-286685]
        elseif(i<303067) then
            return s__37GroupUtils___Status[i-294876]
        else
            return s__38GroupUtils___Status[i-303067]
        endif
    elseif(i<319449) then
        return s__39GroupUtils___Status[i-311258]
    elseif(i<360404) then
        if(i<327640) then
            return s__40GroupUtils___Status[i-319449]
        elseif(i<344022) then
            if(i<335831) then
                return s__41GroupUtils___Status[i-327640]
            else
                return s__42GroupUtils___Status[i-335831]
            endif
        elseif(i<352213) then
            return s__43GroupUtils___Status[i-344022]
        else
            return s__44GroupUtils___Status[i-352213]
        endif
    elseif(i<368595) then
        return s__45GroupUtils___Status[i-360404]
    elseif(i<384977) then
        if(i<376786) then
            return s__46GroupUtils___Status[i-368595]
        else
            return s__47GroupUtils___Status[i-376786]
        endif
    elseif(i<393168) then
        return s__48GroupUtils___Status[i-384977]
    elseif(i<401359) then
        return s__49GroupUtils___Status[i-393168]
    else
        return s__50GroupUtils___Status[i-401359]
    endif
endfunction

function sg__GroupUtils___Status_set takes integer i,integer v returns nothing
    if(i<8191) then
        set s__GroupUtils___Status[i]=v
    elseif(i<204775) then
        if(i<16382) then
            set s__2GroupUtils___Status[i-8191]=v
        elseif(i<106483) then
            if(i<24573) then
                set s__3GroupUtils___Status[i-16382]=v
            elseif(i<65528) then
                if(i<32764) then
                    set s__4GroupUtils___Status[i-24573]=v
                elseif(i<49146) then
                    if(i<40955) then
                        set s__5GroupUtils___Status[i-32764]=v
                    else
                        set s__6GroupUtils___Status[i-40955]=v
                    endif
                elseif(i<57337) then
                    set s__7GroupUtils___Status[i-49146]=v
                else
                    set s__8GroupUtils___Status[i-57337]=v
                endif
            elseif(i<73719) then
                set s__9GroupUtils___Status[i-65528]=v
            elseif(i<90101) then
                if(i<81910) then
                    set s__10GroupUtils___Status[i-73719]=v
                else
                    set s__11GroupUtils___Status[i-81910]=v
                endif
            elseif(i<98292) then
                set s__12GroupUtils___Status[i-90101]=v
            else
                set s__13GroupUtils___Status[i-98292]=v
            endif
        elseif(i<114674) then
            set s__14GroupUtils___Status[i-106483]=v
        elseif(i<155629) then
            if(i<122865) then
                set s__15GroupUtils___Status[i-114674]=v
            elseif(i<139247) then
                if(i<131056) then
                    set s__16GroupUtils___Status[i-122865]=v
                else
                    set s__17GroupUtils___Status[i-131056]=v
                endif
            elseif(i<147438) then
                set s__18GroupUtils___Status[i-139247]=v
            else
                set s__19GroupUtils___Status[i-147438]=v
            endif
        elseif(i<163820) then
            set s__20GroupUtils___Status[i-155629]=v
        elseif(i<180202) then
            if(i<172011) then
                set s__21GroupUtils___Status[i-163820]=v
            else
                set s__22GroupUtils___Status[i-172011]=v
            endif
        elseif(i<188393) then
            set s__23GroupUtils___Status[i-180202]=v
        elseif(i<196584) then
            set s__24GroupUtils___Status[i-188393]=v
        else
            set s__25GroupUtils___Status[i-196584]=v
        endif
    elseif(i<212966) then
        set s__26GroupUtils___Status[i-204775]=v
    elseif(i<311258) then
        if(i<221157) then
            set s__27GroupUtils___Status[i-212966]=v
        elseif(i<262112) then
            if(i<229348) then
                set s__28GroupUtils___Status[i-221157]=v
            elseif(i<245730) then
                if(i<237539) then
                    set s__29GroupUtils___Status[i-229348]=v
                else
                    set s__30GroupUtils___Status[i-237539]=v
                endif
            elseif(i<253921) then
                set s__31GroupUtils___Status[i-245730]=v
            else
                set s__32GroupUtils___Status[i-253921]=v
            endif
        elseif(i<270303) then
            set s__33GroupUtils___Status[i-262112]=v
        elseif(i<286685) then
            if(i<278494) then
                set s__34GroupUtils___Status[i-270303]=v
            else
                set s__35GroupUtils___Status[i-278494]=v
            endif
        elseif(i<294876) then
            set s__36GroupUtils___Status[i-286685]=v
        elseif(i<303067) then
            set s__37GroupUtils___Status[i-294876]=v
        else
            set s__38GroupUtils___Status[i-303067]=v
        endif
    elseif(i<319449) then
        set s__39GroupUtils___Status[i-311258]=v
    elseif(i<360404) then
        if(i<327640) then
            set s__40GroupUtils___Status[i-319449]=v
        elseif(i<344022) then
            if(i<335831) then
                set s__41GroupUtils___Status[i-327640]=v
            else
                set s__42GroupUtils___Status[i-335831]=v
            endif
        elseif(i<352213) then
            set s__43GroupUtils___Status[i-344022]=v
        else
            set s__44GroupUtils___Status[i-352213]=v
        endif
    elseif(i<368595) then
        set s__45GroupUtils___Status[i-360404]=v
    elseif(i<384977) then
        if(i<376786) then
            set s__46GroupUtils___Status[i-368595]=v
        else
            set s__47GroupUtils___Status[i-376786]=v
        endif
    elseif(i<393168) then
        set s__48GroupUtils___Status[i-384977]=v
    elseif(i<401359) then
        set s__49GroupUtils___Status[i-393168]=v
    else
        set s__50GroupUtils___Status[i-401359]=v
    endif
endfunction

//Generated method caller for Quest.refreshDescription
function sc__Quest_refreshDescription takes integer this returns integer
    set f__arg_this=this
    call TriggerEvaluate(st__Quest_refreshDescription)
 return f__result_integer
endfunction

//Generated allocator of Quest
function s__Quest__allocate takes nothing returns integer
 local integer this=si__Quest_F
    if (this!=0) then
        set si__Quest_F=si__Quest_V[this]
    else
        set si__Quest_I=si__Quest_I+1
        set this=si__Quest_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__Quest_V[this]=-1
 return this
endfunction

//Generated destructor of Quest
function s__Quest_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__Quest_V[this]!=-1) then
        return
    endif
    set si__Quest_V[this]=si__Quest_F
    set si__Quest_F=this
endfunction

//Generated allocator of UnitRespawn
function s__UnitRespawn__allocate takes nothing returns integer
 local integer this=si__UnitRespawn_F
    if (this!=0) then
        set si__UnitRespawn_F=si__UnitRespawn_V[this]
    else
        set si__UnitRespawn_I=si__UnitRespawn_I+1
        set this=si__UnitRespawn_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__UnitRespawn_V[this]=-1
 return this
endfunction

//Generated destructor of UnitRespawn
function s__UnitRespawn_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__UnitRespawn_V[this]!=-1) then
        return
    endif
    set si__UnitRespawn_V[this]=si__UnitRespawn_F
    set si__UnitRespawn_F=this
endfunction

//Generated allocator of vJassTTInteract
function s__vJassTTInteract__allocate takes nothing returns integer
 local integer this=si__vJassTTInteract_F
    if (this!=0) then
        set si__vJassTTInteract_F=si__vJassTTInteract_V[this]
    else
        set si__vJassTTInteract_I=si__vJassTTInteract_I+1
        set this=si__vJassTTInteract_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__vJassTTInteract_V[this]=-1
 return this
endfunction

//Generated destructor of vJassTTInteract
function s__vJassTTInteract_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__vJassTTInteract_V[this]!=-1) then
        return
    endif
    set si__vJassTTInteract_V[this]=si__vJassTTInteract_F
    set si__vJassTTInteract_F=this
endfunction

//Generated method caller for Button.create
function sc__Button_create takes integer x,integer y,integer heroIndex,integer buttonId,integer disabledButtonId,integer maxLevel,integer initPointReq,integer pointReq,string descName,string descDescription returns integer
    set f__arg_integer1=x
    set f__arg_integer2=y
    set f__arg_integer3=heroIndex
    set f__arg_integer4=buttonId
    set f__arg_integer5=disabledButtonId
    set f__arg_integer6=maxLevel
    set f__arg_integer7=initPointReq
    set f__arg_integer8=pointReq
    set f__arg_string1=descName
    set f__arg_string2=descDescription
    call TriggerEvaluate(st__Button_create)
 return f__result_integer
endfunction

//Generated method caller for Button.addData
function sc__Button_addData takes integer this,integer data returns nothing
            set s__Button_data[this]=data
endfunction

//Generated method caller for Button.isMenu
function sc__Button_isMenu takes integer this,boolean is returns nothing
            set s__Button_is[this]=is
endfunction

//Generated method caller for Button.createLink
function sc__Button_createLink takes integer this,integer x,integer y,integer level returns nothing
            set s__Button_currentLink[this]=s__Button_currentLink[this] + 1
            set s___Button_linkx[s__Button_linkx[this]+s__Button_currentLink[this]]=x
            set s___Button_linky[s__Button_linky[this]+s__Button_currentLink[this]]=y
            set s___Button_linkLevel[s__Button_linkLevel[this]+s__Button_currentLink[this]]=level
endfunction

//Generated method caller for Button.push
function sc__Button_push takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__Button_push)
endfunction

//Generated method caller for Button.reCreate
function sc__Button_reCreate takes integer this,integer x,integer y,integer heroIndex,integer buttonId,integer disabledButtonId,integer maxLevel,integer initPointReq,integer pointReq,string descName,string descDescription returns nothing
            set s__Button_x[this]=x
            set s__Button_y[this]=y
            set s__Button_heroIndex[this]=heroIndex
            set s__Button_buttonId[this]=buttonId
            set s__Button_disabledButtonId[this]=disabledButtonId
            set s__Button_maxLevel[this]=maxLevel
            set s__Button_initPointReq[this]=initPointReq
            set s__Button_pointReq[this]=pointReq
            set s__Button_descName[this]=descName
            set s__Button_descDescription[this]=descDescription
            set s__Button_data[this]=- 1
            set s__Button_is[this]=false
            if s__Button_currentLink[this] > - 1 then
                loop
                    set s___Button_linkx[s__Button_linkx[this]+s__Button_currentLink[this]]=- 1
                    set s___Button_linky[s__Button_linky[this]+s__Button_currentLink[this]]=- 1
                    set s___Button_linkLevel[s__Button_linkLevel[this]+s__Button_currentLink[this]]=- 1
                    set s__Button_currentLink[this]=s__Button_currentLink[this] - 1
                    exitwhen s__Button_currentLink[this] == - 1
                endloop
            endif
endfunction

//Generated allocator of Button
function s__Button__allocate takes nothing returns integer
 local integer this=si__Button_F
    if (this!=0) then
        set si__Button_F=si__Button_V[this]
    else
        set si__Button_I=si__Button_I+1
        set this=si__Button_I
    endif
    if (this>2729) then
        return 0
    endif
    set s__Button_linkx[this]=(this-1)*3
    set s__Button_linky[this]=(this-1)*3
    set s__Button_linkLevel[this]=(this-1)*3
    set si__Button_V[this]=-1
 return this
endfunction

//Generated destructor of Button
function s__Button_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__Button_V[this]!=-1) then
        return
    endif
    set si__Button_V[this]=si__Button_F
    set si__Button_F=this
endfunction

//Generated allocator of Borders
function s__Borders__allocate takes nothing returns integer
 local integer this=si__Borders_F
    if (this!=0) then
        set si__Borders_F=si__Borders_V[this]
    else
        set si__Borders_I=si__Borders_I+1
        set this=si__Borders_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__Borders_V[this]=-1
 return this
endfunction

//Generated destructor of Borders
function s__Borders_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__Borders_V[this]!=-1) then
        return
    endif
    set si__Borders_V[this]=si__Borders_F
    set si__Borders_F=this
endfunction

//Generated allocator of DescList
function s__DescList__allocate takes nothing returns integer
 local integer this=si__DescList_F
    if (this!=0) then
        set si__DescList_F=si__DescList_V[this]
    else
        set si__DescList_I=si__DescList_I+1
        set this=si__DescList_I
    endif
    if (this>681) then
        return 0
    endif
    set s__DescList_bdrs[this]=(this-1)*12
    set si__DescList_V[this]=-1
 return this
endfunction

//Generated destructor of DescList
function s__DescList_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__DescList_V[this]!=-1) then
        return
    endif
    set si__DescList_V[this]=si__DescList_F
    set si__DescList_F=this
endfunction

//Generated allocator of arrayEnum
function s__arrayEnum__allocate takes nothing returns integer
 local integer this=si__arrayEnum_F
    if (this!=0) then
        set si__arrayEnum_F=si__arrayEnum_V[this]
    else
        set si__arrayEnum_I=si__arrayEnum_I+1
        set this=si__arrayEnum_I
    endif
    if (this>1169) then
        return 0
    endif
    set s__arrayEnum_a[this]=(this-1)*7
    set si__arrayEnum_V[this]=-1
 return this
endfunction

//Generated destructor of arrayEnum
function s__arrayEnum_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__arrayEnum_V[this]!=-1) then
        return
    endif
    set si__arrayEnum_V[this]=si__arrayEnum_F
    set si__arrayEnum_F=this
endfunction

//Generated method caller for Heroes._get_raw
function sc__Heroes__get_raw takes integer this returns integer
    set f__arg_this=this
    call TriggerEvaluate(st__Heroes__get_raw)
 return f__result_integer
endfunction

//Generated method caller for Heroes._get_count
function sc__Heroes__get_count takes nothing returns integer
    call TriggerEvaluate(st__Heroes__get_count)
 return f__result_integer
endfunction

//Generated method caller for Heroes._get_id
function sc__Heroes__get_id takes integer this returns integer
    set f__arg_this=this
    call TriggerEvaluate(st__Heroes__get_id)
 return f__result_integer
endfunction

//Generated method caller for ItemRoots.get
function sc__ItemRoots_get takes unit u,integer vers returns integer
    set f__arg_unit1=u
    set f__arg_integer1=vers
    call TriggerEvaluate(st__ItemRoots_get)
 return f__result_integer
endfunction

//Generated method caller for PhoenixBarrage.launch
function sc__PhoenixBarrage_launch takes integer this returns nothing
    set f__arg_integer1=this
    call TriggerEvaluate(st__PhoenixBarrage_launch)
endfunction

//Generated method caller for FlameConjuration.T32Interface___expire
function sc__FlameConjuration_T32Interface___expire takes nothing returns nothing
    call TriggerEvaluate(st__FlameConjuration_T32Interface___expire)
endfunction

//Generated method caller for Pressure.T32Interface___expire
function sc__Pressure_T32Interface___expire takes nothing returns nothing
    call TriggerEvaluate(st__Pressure_T32Interface___expire)
endfunction

//Generated method caller for FlameWave.T32Interface___expire
function sc__FlameWave_T32Interface___expire takes nothing returns nothing
    call TriggerEvaluate(st__FlameWave_T32Interface___expire)
endfunction

//Generated method caller for BurningSoul.T32Interface___expire
function sc__BurningSoul_T32Interface___expire takes nothing returns nothing
    call TriggerEvaluate(st__BurningSoul_T32Interface___expire)
endfunction

//Generated method caller for BurningSoul.onLoop
function sc__BurningSoul_onLoop takes integer this returns boolean
    set f__arg_this=this
    call TriggerEvaluate(st__BurningSoul_onLoop)
 return f__result_boolean
endfunction

//Generated method caller for BurningSoul.onExpire
function sc__BurningSoul_onExpire takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__BurningSoul_onExpire)
endfunction

//Generated method caller for BurningSoul.create
function sc__BurningSoul_create takes unit victim,unit source returns integer
    set f__arg_unit1=victim
    set f__arg_unit2=source
    call TriggerEvaluate(st__BurningSoul_create)
 return f__result_integer
endfunction

//Generated method caller for WitchFirstSpells__BathMain.expire
function sc__WitchFirstSpells__BathMain_expire takes nothing returns nothing
    call TriggerEvaluate(st__WitchFirstSpells__BathMain_expire)
endfunction

//Generated method caller for WitchFirstSpells__BathMain.onLoop
function sc__WitchFirstSpells__BathMain_onLoop takes integer this returns boolean
    set f__arg_this=this
    call TriggerEvaluate(st__WitchFirstSpells__BathMain_onLoop)
 return f__result_boolean
endfunction

//Generated allocator of WitchFirstSpells__BathMain
function s__WitchFirstSpells__BathMain__allocate takes nothing returns integer
 local integer this=si__WitchFirstSpells__BathMain_F
    if (this!=0) then
        set si__WitchFirstSpells__BathMain_F=si__WitchFirstSpells__BathMain_V[this]
    else
        set si__WitchFirstSpells__BathMain_I=si__WitchFirstSpells__BathMain_I+1
        set this=si__WitchFirstSpells__BathMain_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__WitchFirstSpells__BathMain_V[this]=-1
 return this
endfunction

//Generated destructor of WitchFirstSpells__BathMain
function s__WitchFirstSpells__BathMain_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__WitchFirstSpells__BathMain_V[this]!=-1) then
        return
    endif
    set si__WitchFirstSpells__BathMain_V[this]=si__WitchFirstSpells__BathMain_F
    set si__WitchFirstSpells__BathMain_F=this
endfunction

//Generated method caller for WitchFirstSpells__ChampTimer.T32Interface___expire
function sc__WitchFirstSpells__ChampTimer_T32Interface___expire takes nothing returns nothing
    call TriggerEvaluate(st__WitchFirstSpells__ChampTimer_T32Interface___expire)
endfunction

//Generated method caller for WitchFirstSpells__ChampTimer.onLoop
function sc__WitchFirstSpells__ChampTimer_onLoop takes integer this returns boolean
    set f__arg_this=this
    call TriggerEvaluate(st__WitchFirstSpells__ChampTimer_onLoop)
 return f__result_boolean
endfunction

//Generated method caller for WitchFirstSpells__ChampTimer.onExpire
function sc__WitchFirstSpells__ChampTimer_onExpire takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__WitchFirstSpells__ChampTimer_onExpire)
endfunction

//Generated allocator of WitchFirstSpells__ChampTimer
function s__WitchFirstSpells__ChampTimer__allocate takes nothing returns integer
 local integer this=si__WitchFirstSpells__ChampTimer_F
    if (this!=0) then
        set si__WitchFirstSpells__ChampTimer_F=si__WitchFirstSpells__ChampTimer_V[this]
    else
        set si__WitchFirstSpells__ChampTimer_I=si__WitchFirstSpells__ChampTimer_I+1
        set this=si__WitchFirstSpells__ChampTimer_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__WitchFirstSpells__ChampTimer_V[this]=-1
 return this
endfunction

//Generated destructor of WitchFirstSpells__ChampTimer
function s__WitchFirstSpells__ChampTimer_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__WitchFirstSpells__ChampTimer_V[this]!=-1) then
        return
    endif
    set si__WitchFirstSpells__ChampTimer_V[this]=si__WitchFirstSpells__ChampTimer_F
    set si__WitchFirstSpells__ChampTimer_F=this
endfunction

//Generated allocator of WitchFirstSpells__MissileHandler
function s__WitchFirstSpells__MissileHandler__allocate takes nothing returns integer
 local integer this=si__WitchFirstSpells__MissileHandler_F
    if (this!=0) then
        set si__WitchFirstSpells__MissileHandler_F=si__WitchFirstSpells__MissileHandler_V[this]
    else
        set si__WitchFirstSpells__MissileHandler_I=si__WitchFirstSpells__MissileHandler_I+1
        set this=si__WitchFirstSpells__MissileHandler_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__WitchFirstSpells__MissileHandler_V[this]=-1
 return this
endfunction

//Generated destructor of WitchFirstSpells__MissileHandler
function s__WitchFirstSpells__MissileHandler_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__WitchFirstSpells__MissileHandler_V[this]!=-1) then
        return
    endif
    set si__WitchFirstSpells__MissileHandler_V[this]=si__WitchFirstSpells__MissileHandler_F
    set si__WitchFirstSpells__MissileHandler_F=this
endfunction

//Generated method caller for VJassTalentTree.hideUI
function sc__VJassTalentTree_hideUI takes player p returns nothing
    set f__arg_player1=p
    call TriggerEvaluate(st__VJassTalentTree_hideUI)
endfunction

//Generated method caller for VJassTalentTree.showUI
function sc__VJassTalentTree_showUI takes player p,integer heroIndex returns nothing
    set f__arg_player1=p
    set f__arg_integer1=heroIndex
    call TriggerEvaluate(st__VJassTalentTree_showUI)
endfunction

//Generated allocator of VJassTalentTree
function s__VJassTalentTree__allocate takes nothing returns integer
 local integer this=si__VJassTalentTree_F
    if (this!=0) then
        set si__VJassTalentTree_F=si__VJassTalentTree_V[this]
    else
        set si__VJassTalentTree_I=si__VJassTalentTree_I+1
        set this=si__VJassTalentTree_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__VJassTalentTree_V[this]=-1
 return this
endfunction

//Generated destructor of VJassTalentTree
function s__VJassTalentTree_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__VJassTalentTree_V[this]!=-1) then
        return
    endif
    set si__VJassTalentTree_V[this]=si__VJassTalentTree_F
    set si__VJassTalentTree_F=this
endfunction

//Generated method caller for StatHandler.addUnitBonus
function sc__StatHandler_addUnitBonus takes unit u,integer t returns nothing
    set f__arg_unit1=u
    set f__arg_integer1=t
    call TriggerEvaluate(st__StatHandler_addUnitBonus)
endfunction

//Generated method caller for StatHandler.r_compile
function sc__StatHandler_r_compile takes unit u,integer r returns nothing
    set f__arg_unit1=u
    set f__arg_integer1=r
    call TriggerEvaluate(st__StatHandler_r_compile)
endfunction

//Generated method caller for StatHandler.removeUnitBonus
function sc__StatHandler_removeUnitBonus takes unit u,integer t returns nothing
    set f__arg_unit1=u
    set f__arg_integer1=t
    call TriggerEvaluate(st__StatHandler_removeUnitBonus)
endfunction

//Generated method caller for StatHandler.getUnitBonus
function sc__StatHandler_getUnitBonus takes unit u,integer bonus returns real
    set f__arg_unit1=u
    set f__arg_integer1=bonus
    call TriggerEvaluate(st__StatHandler_getUnitBonus)
 return f__result_real
endfunction

//Generated method caller for StatHandler.getUnitResistance
function sc__StatHandler_getUnitResistance takes unit u,integer resistance returns real
    set f__arg_unit1=u
    set f__arg_integer1=resistance
    call TriggerEvaluate(st__StatHandler_getUnitResistance)
 return f__result_real
endfunction

//Generated allocator of StatHandler
function s__StatHandler__allocate takes nothing returns integer
 local integer this=si__StatHandler_F
    if (this!=0) then
        set si__StatHandler_F=si__StatHandler_V[this]
    else
        set si__StatHandler_I=si__StatHandler_I+1
        set this=si__StatHandler_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__StatHandler_V[this]=-1
 return this
endfunction

//Generated destructor of StatHandler
function s__StatHandler_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__StatHandler_V[this]!=-1) then
        return
    endif
    set si__StatHandler_V[this]=si__StatHandler_F
    set si__StatHandler_F=this
endfunction

//Generated method caller for Listener.interactCondition
function sc__Listener_interactCondition takes nothing returns boolean
            return RAbsBJ(GetUnitX(GetTriggerUnit()) - GetWidgetX(GetOrderTarget())) < 250 and RAbsBJ(GetUnitY(GetTriggerUnit()) - GetWidgetY(GetOrderTarget())) < 250
endfunction

//Generated allocator of Listener
function s__Listener__allocate takes nothing returns integer
 local integer this=si__Listener_F
    if (this!=0) then
        set si__Listener_F=si__Listener_V[this]
    else
        set si__Listener_I=si__Listener_I+1
        set this=si__Listener_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__Listener_V[this]=-1
 return this
endfunction

//Generated destructor of Listener
function s__Listener_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__Listener_V[this]!=-1) then
        return
    endif
    set si__Listener_V[this]=si__Listener_F
    set si__Listener_F=this
endfunction

//Generated method caller for CustomInventory.setOnRecipe
function sc__CustomInventory_setOnRecipe takes trigger trggah returns nothing
            //local unit u 
            //set UnitIndexer.enabled = FALSE
            //set u = CreateUnit(Player(0), 'H003', 0,0,0)
            //set UnitIndexer.enabled = TRUE
            //call SetUnitUserData(u,GetHandleId(t))
            set s__CustomInventory_onRecipe=trggah
endfunction

//Generated method caller for CustomInventory.linkItemTraitData
function sc__CustomInventory_linkItemTraitData takes integer buttonIdV,integer equipmentSlot,string titleV,string description,item linkedItem returns nothing
    set f__arg_integer1=buttonIdV
    set f__arg_integer2=equipmentSlot
    set f__arg_string1=titleV
    set f__arg_string2=description
    set f__arg_item1=linkedItem
    call TriggerEvaluate(st__CustomInventory_linkItemTraitData)
endfunction

//Generated method caller for CustomInventory.getItemTraitData
function sc__CustomInventory_getItemTraitData takes item i returns integer
    set f__arg_item1=i
    call TriggerEvaluate(st__CustomInventory_getItemTraitData)
 return f__result_integer
endfunction

//Generated method caller for CustomInventory.doesUnitHaveItemInEq
function sc__CustomInventory_doesUnitHaveItemInEq takes integer itemId,unit host returns integer
    set f__arg_integer1=itemId
    set f__arg_unit1=host
    call TriggerEvaluate(st__CustomInventory_doesUnitHaveItemInEq)
 return f__result_integer
endfunction

//Generated method caller for CustomInventory.gather
function sc__CustomInventory_gather takes unit host returns integer
    set f__arg_unit1=host
    call TriggerEvaluate(st__CustomInventory_gather)
 return f__result_integer
endfunction

//Generated method caller for CustomInventory.wipeSelected
function sc__CustomInventory_wipeSelected takes player p returns nothing
    set f__arg_player1=p
    call TriggerEvaluate(st__CustomInventory_wipeSelected)
endfunction

//Generated method caller for CustomInventory.wipeHovered
function sc__CustomInventory_wipeHovered takes player p returns nothing
    set f__arg_player1=p
    call TriggerEvaluate(st__CustomInventory_wipeHovered)
endfunction

//Generated method caller for CustomInventory.moveFromRecipe
function sc__CustomInventory_moveFromRecipe takes integer b,unit host returns nothing
    set f__arg_integer1=b
    set f__arg_unit1=host
    call TriggerEvaluate(st__CustomInventory_moveFromRecipe)
endfunction

//Generated method caller for CustomInventory.removeEqWithoutAdd
function sc__CustomInventory_removeEqWithoutAdd takes integer b,player click returns nothing
    set f__arg_integer1=b
    set f__arg_player1=click
    call TriggerEvaluate(st__CustomInventory_removeEqWithoutAdd)
endfunction

//Generated method caller for CustomInventory.generateNewItem
function sc__CustomInventory_generateNewItem takes item i,unit u returns nothing
    set f__arg_item1=i
    set f__arg_unit1=u
    call TriggerEvaluate(st__CustomInventory_generateNewItem)
endfunction

//Generated method caller for CustomInventory.initsiesss
function sc__CustomInventory_initsiesss takes nothing returns nothing
    call TriggerEvaluate(st__CustomInventory_initsiesss)
endfunction

//Generated method caller for CustomInventory.register
function sc__CustomInventory_register takes integer i,integer itemId returns nothing
    set f__arg_integer1=i
    set f__arg_integer2=itemId
    call TriggerEvaluate(st__CustomInventory_register)
endfunction

//Generated method caller for Recipe2.create
function sc__Recipe2_create takes nothing returns integer
    call TriggerEvaluate(st__Recipe2_create)
 return f__result_integer
endfunction

//Generated method caller for Recipe2.check
function sc__Recipe2_check takes integer this,unit u,integer root,integer g returns boolean
    set f__arg_this=this
    set f__arg_unit1=u
    set f__arg_integer1=root
    set f__arg_integer2=g
    call TriggerEvaluate(st__Recipe2_check)
 return f__result_boolean
endfunction

//Generated allocator of Recipe2
function s__Recipe2__allocate takes nothing returns integer
 local integer this=si__Recipe2_F
    if (this!=0) then
        set si__Recipe2_F=si__Recipe2_V[this]
    else
        set si__Recipe2_I=si__Recipe2_I+1
        set this=si__Recipe2_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__Recipe2_V[this]=-1
 return this
endfunction

//Generated destructor of Recipe2
function s__Recipe2_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__Recipe2_V[this]!=-1) then
        return
    endif
    set si__Recipe2_V[this]=si__Recipe2_F
    set si__Recipe2_F=this
endfunction

//Generated method caller for RecipeGroup.add
function sc__RecipeGroup_add takes integer this,integer rec returns nothing
    set f__arg_this=this
    set f__arg_integer1=rec
    call TriggerEvaluate(st__RecipeGroup_add)
endfunction

//Generated allocator of RecipeGroup
function s__RecipeGroup__allocate takes nothing returns integer
 local integer this=si__RecipeGroup_F
    if (this!=0) then
        set si__RecipeGroup_F=si__RecipeGroup_V[this]
    else
        set si__RecipeGroup_I=si__RecipeGroup_I+1
        set this=si__RecipeGroup_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__RecipeGroup_V[this]=-1
 return this
endfunction

//Generated destructor of RecipeGroup
function s__RecipeGroup_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__RecipeGroup_V[this]!=-1) then
        return
    endif
    set si__RecipeGroup_V[this]=si__RecipeGroup_F
    set si__RecipeGroup_F=this
endfunction

//Generated method caller for Set.addItem
function sc__Set_addItem takes integer this,integer itemId returns nothing
    set f__arg_this=this
    set f__arg_integer1=itemId
    call TriggerEvaluate(st__Set_addItem)
endfunction

//Generated allocator of Set
function s__Set__allocate takes nothing returns integer
 local integer this=si__Set_F
    if (this!=0) then
        set si__Set_F=si__Set_V[this]
    else
        set si__Set_I=si__Set_I+1
        set this=si__Set_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__Set_V[this]=-1
 return this
endfunction

//Generated destructor of Set
function s__Set_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__Set_V[this]!=-1) then
        return
    endif
    set si__Set_V[this]=si__Set_F
    set si__Set_F=this
endfunction

//Generated method caller for InventoryButton.removeItem
function sc__InventoryButton_removeItem takes integer this,unit u returns nothing
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerEvaluate(st__InventoryButton_removeItem)
endfunction

//Generated method caller for InventoryButton.noTooltip
function sc__InventoryButton_noTooltip takes integer this returns nothing
            set s__InventoryButton_title[this]=""
            set s__InventoryButton_description[this]=""
            set s__InventoryButton_showOnTooltip[this]=false
endfunction

//Generated method caller for InventoryButton.desc
function sc__InventoryButton_desc takes integer this,unit u returns string
    set f__arg_this=this
    set f__arg_unit1=u
    call TriggerEvaluate(st__InventoryButton_desc)
 return f__result_string
endfunction

//Generated allocator of InventoryButton
function s__InventoryButton__allocate takes nothing returns integer
 local integer this=si__InventoryButton_F
    if (this!=0) then
        set si__InventoryButton_F=si__InventoryButton_V[this]
    else
        set si__InventoryButton_I=si__InventoryButton_I+1
        set this=si__InventoryButton_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__InventoryButton_V[this]=-1
 return this
endfunction

//Generated destructor of InventoryButton
function s__InventoryButton_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__InventoryButton_V[this]!=-1) then
        return
    endif
    set si__InventoryButton_V[this]=si__InventoryButton_F
    set si__InventoryButton_F=this
endfunction

//Generated method caller for T2InvB.create
function sc__T2InvB_create takes nothing returns integer
    call TriggerEvaluate(st__T2InvB_create)
 return f__result_integer
endfunction

//Generated allocator of T2InvB
function s__T2InvB__allocate takes nothing returns integer
 local integer this=si__T2InvB_F
    if (this!=0) then
        set si__T2InvB_F=si__T2InvB_V[this]
    else
        set si__T2InvB_I=si__T2InvB_I+1
        set this=si__T2InvB_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__T2InvB_V[this]=-1
 return this
endfunction

//Generated destructor of T2InvB
function s__T2InvB_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__T2InvB_V[this]!=-1) then
        return
    endif
    set si__T2InvB_V[this]=si__T2InvB_F
    set si__T2InvB_F=this
endfunction

//Generated allocator of ItemInventory__link2table
function s__ItemInventory__link2table__allocate takes nothing returns integer
 local integer this=si__ItemInventory__link2table_F
    if (this!=0) then
        set si__ItemInventory__link2table_F=si__ItemInventory__link2table_V[this]
    else
        set si__ItemInventory__link2table_I=si__ItemInventory__link2table_I+1
        set this=si__ItemInventory__link2table_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__ItemInventory__link2table_V[this]=-1
 return this
endfunction

//Generated destructor of ItemInventory__link2table
function s__ItemInventory__link2table_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__ItemInventory__link2table_V[this]!=-1) then
        return
    endif
    set si__ItemInventory__link2table_V[this]=si__ItemInventory__link2table_F
    set si__ItemInventory__link2table_F=this
endfunction

//Generated method caller for Item.addSet
function sc__Item_addSet takes integer this,integer s returns nothing
            set s__Item_setv[this]=s
endfunction

//Generated method caller for Item.addRecipe
function sc__Item_addRecipe takes integer this,integer s returns nothing
    set f__arg_this=this
    set f__arg_integer1=s
    call TriggerEvaluate(st__Item_addRecipe)
endfunction

//Generated method caller for Item.addTrait
function sc__Item_addTrait takes integer this,integer trait returns nothing
    set f__arg_this=this
    set f__arg_integer1=trait
    call TriggerEvaluate(st__Item_addTrait)
endfunction

//Generated method caller for Item.addReq
function sc__Item_addReq takes integer this,integer t returns nothing
    set f__arg_this=this
    set f__arg_integer1=t
    call TriggerEvaluate(st__Item_addReq)
endfunction

//Generated method caller for Item.getTrait
function sc__Item_getTrait takes integer this,integer at returns integer
    set f__arg_this=this
    set f__arg_integer1=at
    call TriggerEvaluate(st__Item_getTrait)
 return f__result_integer
endfunction

//Generated method caller for Item.getReq
function sc__Item_getReq takes integer this,integer at returns integer
    set f__arg_this=this
    set f__arg_integer1=at
    call TriggerEvaluate(st__Item_getReq)
 return f__result_integer
endfunction

//Generated method caller for ICI.getTraitDescription
function sc__ICI_getTraitDescription takes string color,integer t returns string
            if s__Trait_typeOfTrait[t] == TRAIT_TYPE_DAMAGE then
                return color + "Damage|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_ARMOR then
                return color + "Armor |r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_STATIC_ARMOR then
                return color + "Static Armor|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_FIRE_DAMAGE then
                return color + "Fire Damage |r: " + I2S(R2I(s__Trait_a[t])) + " - " + I2S(R2I(s__Trait_b[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_LIGHTNING_DAMAGE then
                return color + "Electric Damage |r: 1 - " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_STRENGTH then
                return color + "Strength|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_AGILITY then
                return color + "Agility |r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_INTELLIGENCE then
                return color + "Inteligence |r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_MANA then
                return color + "Mana|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_MANA_REGEN then
                return color + "Mana Regen |r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_SPIKE_ARMOR then
                return color + "Spike Armor |r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_STATIC_DAMAGE then
                return color + "Chaos Damage |r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_LIFE then
                return color + "Life |r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_LIFE_REGEN then
                return color + "Life Regen |r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_ATTACK_SPEED then
                return color + "Attack Speed|r: " + I2S(R2I(s__Trait_a[t])) + "%"
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_ALL_STATS then
                return color + "All Stats|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_LIFE_LEECH then
                return color + "Life Leech|r: " + I2S(R2I(s__Trait_a[t])) + "%"
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_ARMOR_REDUCTION then
                return color + "On-hit Armor Reduction|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_SPELL_CRIT_RATE then
                return color + "Spell Critical Strike Rate|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_CRIT_POW then
                return color + "Critical Strike Power|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_CRIT_RATE then
                return color + "Critical Strike Rate|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_SPELL_CRIT_POW then
                return color + "Spell Critical Strike Power|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_MOVEMENT_SPEED then
                return color + "Movement Speed|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_FIRE_RESISTANCE then
                return color + "Fire Resistance|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_COLD_RESISTANCE then
                return color + "Cold Resistance|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_LIGHTNING_RESISTANCE then
                return color + "Lightning Resistance|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_POISON_RESISTANCE then
                return color + "Poison Resistance|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_DARKNESS_RESISTANCE then
                return color + "Darkness Resistance|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_HOLY_RESISTANCE then
                return color + "Holy Resistance|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_PHYSICAL_RESISTANCE then
                return color + "Physical Resistance|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_ALL_RESISTANCE then
                return color + "All Resistance|r: " + I2S(R2I(s__Trait_a[t]))
            endif
            return ""
endfunction

//Generated method caller for ICI.displaySetData
function sc__ICI_displaySetData takes integer it,integer os,player p returns nothing
            local integer tempid
            local string title
            local string desc
            if s__Item_setv[it] == 0 then
                set title="No Set Data"
                set desc=title
            else
                set title="Set Description : " + s__Set_title[s__Item_setv[it]]
                set desc=s__Set_desc[s__Item_setv[it]]
            endif
            if GetLocalPlayer() == p then
                set tempid='B00I'
            else
                set tempid=GetDestructableTypeId(ItemInventory__lastHoveredIcon)
            endif
            call RemoveDestructable(ItemInventory__lastHoveredIcon)
            set ItemInventory__lastHoveredIcon=CreateDestructable(tempid, ItemInventory__lstX, ItemInventory__lstY, 0, 1, 0)
            if ItemInventory__lstTTtitle == null then
                set ItemInventory__lstTTtitle=CreateTextTag()
                set ItemInventory__lstTTdesc=CreateTextTag()
                call SetTextTagPos(ItemInventory__lstTTtitle, GetRectMinX(ItemInventory__hoverTitleRect), GetRectMinY(ItemInventory__hoverTitleRect), 0)
                call SetTextTagVisibility(ItemInventory__lstTTtitle, true)
                call SetTextTagPos(ItemInventory__lstTTdesc, GetRectMinX(ItemInventory__hoverDescRect), GetRectMinY(ItemInventory__hoverDescRect), 0)
                call SetTextTagVisibility(ItemInventory__lstTTdesc, true)
            endif
            if GetLocalPlayer() == p then
                call SetTextTagTextBJ(ItemInventory__lstTTtitle, title, 10)
                call SetTextTagTextBJ(ItemInventory__lstTTdesc, desc, 10)
            endif
endfunction

//Generated allocator of ICI
function s__ICI__allocate takes nothing returns integer
 local integer this=si__ICI_F
    if (this!=0) then
        set si__ICI_F=si__ICI_V[this]
    else
        set si__ICI_I=si__ICI_I+1
        set this=si__ICI_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__ICI_V[this]=-1
 return this
endfunction

//Generated destructor of ICI
function s__ICI_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__ICI_V[this]!=-1) then
        return
    endif
    set si__ICI_V[this]=si__ICI_F
    set si__ICI_F=this
endfunction

//Generated allocator of QuestMain
function s__QuestMain__allocate takes nothing returns integer
 local integer this=si__QuestMain_F
    if (this!=0) then
        set si__QuestMain_F=si__QuestMain_V[this]
    else
        set si__QuestMain_I=si__QuestMain_I+1
        set this=si__QuestMain_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__QuestMain_V[this]=-1
 return this
endfunction

//Generated destructor of QuestMain
function s__QuestMain_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__QuestMain_V[this]!=-1) then
        return
    endif
    set si__QuestMain_V[this]=si__QuestMain_F
    set si__QuestMain_F=this
endfunction

//Generated method caller for QuestInstance.create
function sc__QuestInstance_create takes integer root returns integer
    set f__arg_integer1=root
    call TriggerEvaluate(st__QuestInstance_create)
 return f__result_integer
endfunction

//Generated method caller for QuestInstance.containsPlayer
function sc__QuestInstance_containsPlayer takes integer this,player p returns boolean
    set f__arg_this=this
    set f__arg_player1=p
    call TriggerEvaluate(st__QuestInstance_containsPlayer)
 return f__result_boolean
endfunction

//Generated method caller for QuestInstance.getStage
function sc__QuestInstance_getStage takes integer this returns integer
            return s__QuestInstance_stage[this]
endfunction

//Generated method caller for QuestInstance.start
function sc__QuestInstance_start takes integer this,integer p returns integer
    set f__arg_this=this
    set f__arg_integer1=p
    call TriggerEvaluate(st__QuestInstance_start)
 return f__result_integer
endfunction

//Generated method caller for QuestInstance.nextStage
function sc__QuestInstance_nextStage takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__QuestInstance_nextStage)
endfunction

//Generated method caller for QuestInstance.notifyClosure
function sc__QuestInstance_notifyClosure takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__QuestInstance_notifyClosure)
endfunction

//Generated method caller for QuestInstance.finish
function sc__QuestInstance_finish takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__QuestInstance_finish)
endfunction

//Generated method caller for QuestInstance.triggerFulfill
function sc__QuestInstance_triggerFulfill takes integer this,trigger t returns boolean
    set f__arg_this=this
    set f__arg_trigger1=t
    call TriggerEvaluate(st__QuestInstance_triggerFulfill)
 return f__result_boolean
endfunction

//Generated allocator of QuestInstance
function s__QuestInstance__allocate takes nothing returns integer
 local integer this=si__QuestInstance_F
    if (this!=0) then
        set si__QuestInstance_F=si__QuestInstance_V[this]
    else
        set si__QuestInstance_I=si__QuestInstance_I+1
        set this=si__QuestInstance_I
    endif
    if (this>743) then
        return 0
    endif
    set s__QuestInstance_lastTriggerUnit[this]=(this-1)*11
    set s__QuestInstance_i[this]=(this-1)*11
    set si__QuestInstance_V[this]=-1
 return this
endfunction

//Generated destructor of QuestInstance
function s__QuestInstance_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__QuestInstance_V[this]!=-1) then
        return
    endif
    set si__QuestInstance_V[this]=si__QuestInstance_F
    set si__QuestInstance_F=this
endfunction

//Generated method caller for QuestInteractListener.create
function sc__QuestInteractListener_create takes integer roott,widget interacter,string name,string onInteract,string onAccept,boolean enable returns integer
    set f__arg_integer1=roott
    set f__arg_widget1=interacter
    set f__arg_string1=name
    set f__arg_string2=onInteract
    set f__arg_string3=onAccept
    set f__arg_boolean1=enable
    call TriggerEvaluate(st__QuestInteractListener_create)
 return f__result_integer
endfunction

//Generated method caller for QuestInteractListener.setLevel
function sc__QuestInteractListener_setLevel takes integer this,integer reqLevel,boolean enableWhenReady returns nothing
    set f__arg_this=this
    set f__arg_integer1=reqLevel
    set f__arg_boolean1=enableWhenReady
    call TriggerEvaluate(st__QuestInteractListener_setLevel)
endfunction

//Generated method caller for QuestInteractListener.enable
function sc__QuestInteractListener_enable takes integer this,player p returns integer
    set f__arg_this=this
    set f__arg_player1=p
    call TriggerEvaluate(st__QuestInteractListener_enable)
 return f__result_integer
endfunction

//Generated method caller for QuestInteractListener.reset
function sc__QuestInteractListener_reset takes integer this,player p returns nothing
    set f__arg_this=this
    set f__arg_player1=p
    call TriggerEvaluate(st__QuestInteractListener_reset)
endfunction

//Generated method caller for QuestAPI.triggerRun
function sc__QuestAPI_triggerRun takes integer this,trigger t returns nothing
    set f__arg_this=this
    set f__arg_trigger1=t
    call TriggerEvaluate(st__QuestAPI_triggerRun)
endfunction

//Generated method caller for GameStart__Init.run
function sc__GameStart__Init_run takes nothing returns nothing
    call TriggerEvaluate(st__GameStart__Init_run)
endfunction

//Generated method executor for GameStart__Init.run
function sx__GameStart__Init_run takes nothing returns nothing
    call TriggerExecute(st__GameStart__Init_run)
endfunction

//Generated method caller for UnitIndexer._set_enabled
function sc__UnitIndexer__set_enabled takes boolean l__UnitIndexer___b returns nothing
    set f__arg_boolean1=l__UnitIndexer___b
    call TriggerEvaluate(st__UnitIndexer__set_enabled)
endfunction

//Generated method caller for StatBoard__ConstantLoop.T32Interface___expire
function sc__StatBoard__ConstantLoop_T32Interface___expire takes nothing returns nothing
    call TriggerEvaluate(st__StatBoard__ConstantLoop_T32Interface___expire)
endfunction

//Generated method caller for StatBoard__ConstantLoop.onLoop
function sc__StatBoard__ConstantLoop_onLoop takes integer this returns boolean
    set f__arg_this=this
    call TriggerEvaluate(st__StatBoard__ConstantLoop_onLoop)
 return f__result_boolean
endfunction

//Generated method caller for StatBoard__ConstantLoop.onExpire
function sc__StatBoard__ConstantLoop_onExpire takes integer this returns nothing
        
endfunction

//Generated allocator of MainBoard
function s__MainBoard__allocate takes nothing returns integer
 local integer this=si__MainBoard_F
    if (this!=0) then
        set si__MainBoard_F=si__MainBoard_V[this]
    else
        set si__MainBoard_I=si__MainBoard_I+1
        set this=si__MainBoard_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__MainBoard_V[this]=-1
 return this
endfunction

//Generated destructor of MainBoard
function s__MainBoard_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__MainBoard_V[this]!=-1) then
        return
    endif
    set si__MainBoard_V[this]=si__MainBoard_F
    set si__MainBoard_F=this
endfunction

//Generated method caller for ShadowTrail.remove
function sc__ShadowTrail_remove takes integer this returns nothing
            set s__ShadowTrail_dur[this]=0
            set s__ShadowTrail_perm[this]=false
endfunction

//Generated method caller for ShadowTrail.setEffect
function sc__ShadowTrail_setEffect takes integer this,string model,string attachPoint,boolean attachToShadows returns nothing
    set f__arg_this=this
    set f__arg_string1=model
    set f__arg_string2=attachPoint
    set f__arg_boolean1=attachToShadows
    call TriggerEvaluate(st__ShadowTrail_setEffect)
endfunction

//Generated method caller for ShadowTrail.setColor
function sc__ShadowTrail_setColor takes integer this,integer red,integer grn,integer blu,integer alpha returns nothing
    set f__arg_this=this
    set f__arg_integer1=red
    set f__arg_integer2=grn
    set f__arg_integer3=blu
    set f__arg_integer4=alpha
    call TriggerEvaluate(st__ShadowTrail_setColor)
endfunction

//Generated method caller for ShadowTrail.setAnimationIndex
function sc__ShadowTrail_setAnimationIndex takes integer this,integer k returns nothing
    set f__arg_this=this
    set f__arg_integer1=k
    call TriggerEvaluate(st__ShadowTrail_setAnimationIndex)
endfunction

//Generated method caller for ShadowTrail.setFadeRate
function sc__ShadowTrail_setFadeRate takes integer this,real rate,boolean flatMode returns nothing
            if flatMode then
                set s__ShadowTrail_fr[this]=R2I(rate)
            else
                set s__ShadowTrail_fp[this]=1 - rate
            endif
            set s__ShadowTrail_bo1[this]=flatMode
endfunction

//Generated method caller for ShadowTrail.setupMovingTrail
function sc__ShadowTrail_setupMovingTrail takes integer this,integer count,real separation,real alphaFactor returns nothing
    set f__arg_this=this
    set f__arg_integer1=count
    set f__arg_real1=separation
    set f__arg_real2=alphaFactor
    call TriggerEvaluate(st__ShadowTrail_setupMovingTrail)
endfunction

//Generated method caller for ShadowTrail.add
function sc__ShadowTrail_add takes unit target,integer trailType,real duration returns integer
    set f__arg_unit1=target
    set f__arg_integer1=trailType
    set f__arg_real1=duration
    call TriggerEvaluate(st__ShadowTrail_add)
 return f__result_integer
endfunction

//Generated allocator of FFS_Superbeast
function s__FFS_Superbeast__allocate takes nothing returns integer
 local integer this=si__FFS_Superbeast_F
    if (this!=0) then
        set si__FFS_Superbeast_F=si__FFS_Superbeast_V[this]
    else
        set si__FFS_Superbeast_I=si__FFS_Superbeast_I+1
        set this=si__FFS_Superbeast_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__FFS_Superbeast_V[this]=-1
 return this
endfunction

//Generated destructor of FFS_Superbeast
function s__FFS_Superbeast_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__FFS_Superbeast_V[this]!=-1) then
        return
    endif
    set si__FFS_Superbeast_V[this]=si__FFS_Superbeast_F
    set si__FFS_Superbeast_F=this
endfunction

//Generated method caller for FFS_BurstCounter.T32Interface___expire
function sc__FFS_BurstCounter_T32Interface___expire takes nothing returns nothing
    call TriggerEvaluate(st__FFS_BurstCounter_T32Interface___expire)
endfunction

//Generated method caller for FFS_BurstCounter.onLoop
function sc__FFS_BurstCounter_onLoop takes integer this returns boolean
            set s__FFS_BurstCounter_tickCount[this]=s__FFS_BurstCounter_tickCount[this] + 1
            if s__FFS_BurstCounter_tickCount[this] >= s__FFS_BurstCounter_tickCountTo[this] then
                return false
            endif
            
            if s__FFS_BurstCounter_tickCount[this] == s__FFS_BurstCounter_tickCountTo[this] - 20 then
                call DestroyEffect(AddSpecialEffect(FighterFirstSpells__BC_FX, GetUnitX(s__FFS_BurstCounter_caster[this]), GetUnitY(s__FFS_BurstCounter_caster[this])))
            endif
                
            
            call SetTextTagPos(s__FFS_BurstCounter_textTag[this], GetUnitX(s__FFS_BurstCounter_caster[this]), GetUnitY(s__FFS_BurstCounter_caster[this]), FighterFirstSpells__BC_HEIGHT)
            
            return true
endfunction

//Generated method caller for FFS_BurstCounter.onExpire
function sc__FFS_BurstCounter_onExpire takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__FFS_BurstCounter_onExpire)
endfunction

//Generated allocator of FFS_BurstCounter
function s__FFS_BurstCounter__allocate takes nothing returns integer
 local integer this=si__FFS_BurstCounter_F
    if (this!=0) then
        set si__FFS_BurstCounter_F=si__FFS_BurstCounter_V[this]
    else
        set si__FFS_BurstCounter_I=si__FFS_BurstCounter_I+1
        set this=si__FFS_BurstCounter_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__FFS_BurstCounter_V[this]=-1
 return this
endfunction

//Generated destructor of FFS_BurstCounter
function s__FFS_BurstCounter_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__FFS_BurstCounter_V[this]!=-1) then
        return
    endif
    set si__FFS_BurstCounter_V[this]=si__FFS_BurstCounter_F
    set si__FFS_BurstCounter_F=this
endfunction

//Generated method caller for FFS_Banish.T32Interface___expire
function sc__FFS_Banish_T32Interface___expire takes nothing returns nothing
    call TriggerEvaluate(st__FFS_Banish_T32Interface___expire)
endfunction

//Generated method caller for FFS_Banish.onLoop
function sc__FFS_Banish_onLoop takes integer this returns boolean
    set f__arg_this=this
    call TriggerEvaluate(st__FFS_Banish_onLoop)
 return f__result_boolean
endfunction

//Generated method caller for FFS_Banish.onExpire
function sc__FFS_Banish_onExpire takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__FFS_Banish_onExpire)
endfunction

//Generated method caller for FFS_Banish.cancel
function sc__FFS_Banish_cancel takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__FFS_Banish_cancel)
endfunction

//Generated method caller for FFS_Banish.onCollide
function sc__FFS_Banish_onCollide takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__FFS_Banish_onCollide)
endfunction

//Generated allocator of FFS_Banish
function s__FFS_Banish__allocate takes nothing returns integer
 local integer this=si__FFS_Banish_F
    if (this!=0) then
        set si__FFS_Banish_F=si__FFS_Banish_V[this]
    else
        set si__FFS_Banish_I=si__FFS_Banish_I+1
        set this=si__FFS_Banish_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__FFS_Banish_V[this]=-1
 return this
endfunction

//Generated destructor of FFS_Banish
function s__FFS_Banish_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__FFS_Banish_V[this]!=-1) then
        return
    endif
    set si__FFS_Banish_V[this]=si__FFS_Banish_F
    set si__FFS_Banish_F=this
endfunction

//Generated method caller for FFS_WhirlingWrath.T32Interface___expire
function sc__FFS_WhirlingWrath_T32Interface___expire takes nothing returns nothing
    call TriggerEvaluate(st__FFS_WhirlingWrath_T32Interface___expire)
endfunction

//Generated method caller for FFS_WhirlingWrath.onLoop
function sc__FFS_WhirlingWrath_onLoop takes integer this returns boolean
    set f__arg_this=this
    call TriggerEvaluate(st__FFS_WhirlingWrath_onLoop)
 return f__result_boolean
endfunction

//Generated method caller for FFS_WhirlingWrath.onExpire
function sc__FFS_WhirlingWrath_onExpire takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__FFS_WhirlingWrath_onExpire)
endfunction

//Generated allocator of FFS_WhirlingWrath
function s__FFS_WhirlingWrath__allocate takes nothing returns integer
 local integer this=si__FFS_WhirlingWrath_F
    if (this!=0) then
        set si__FFS_WhirlingWrath_F=si__FFS_WhirlingWrath_V[this]
    else
        set si__FFS_WhirlingWrath_I=si__FFS_WhirlingWrath_I+1
        set this=si__FFS_WhirlingWrath_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__FFS_WhirlingWrath_V[this]=-1
 return this
endfunction

//Generated destructor of FFS_WhirlingWrath
function s__FFS_WhirlingWrath_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__FFS_WhirlingWrath_V[this]!=-1) then
        return
    endif
    set si__FFS_WhirlingWrath_V[this]=si__FFS_WhirlingWrath_F
    set si__FFS_WhirlingWrath_F=this
endfunction

//Generated allocator of FFS_MightySlash
function s__FFS_MightySlash__allocate takes nothing returns integer
 local integer this=si__FFS_MightySlash_F
    if (this!=0) then
        set si__FFS_MightySlash_F=si__FFS_MightySlash_V[this]
    else
        set si__FFS_MightySlash_I=si__FFS_MightySlash_I+1
        set this=si__FFS_MightySlash_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__FFS_MightySlash_V[this]=-1
 return this
endfunction

//Generated destructor of FFS_MightySlash
function s__FFS_MightySlash_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__FFS_MightySlash_V[this]!=-1) then
        return
    endif
    set si__FFS_MightySlash_V[this]=si__FFS_MightySlash_F
    set si__FFS_MightySlash_F=this
endfunction

//Generated method caller for Catalog.create
function sc__Catalog_create takes nothing returns integer
    call TriggerEvaluate(st__Catalog_create)
 return f__result_integer
endfunction

//Generated method caller for Catalog.add
function sc__Catalog_add takes integer this,integer v returns nothing
    set f__arg_this=this
    set f__arg_integer1=v
    call TriggerEvaluate(st__Catalog_add)
endfunction

//Generated method caller for Catalog.addCatalog
function sc__Catalog_addCatalog takes integer this,integer catalog returns nothing
    set f__arg_this=this
    set f__arg_integer1=catalog
    call TriggerEvaluate(st__Catalog_addCatalog)
endfunction

//Generated method caller for TableArray._staticgetindex
function sc__TableArray__staticgetindex takes integer array_size returns integer
    set f__arg_integer1=array_size
    call TriggerEvaluate(st__TableArray__staticgetindex)
 return f__result_integer
endfunction

//Generated method caller for TableArray._getindex
function sc__TableArray__getindex takes integer this,integer key returns integer
    set f__arg_this=this
    set f__arg_integer1=key
    call TriggerEvaluate(st__TableArray__getindex)
 return f__result_integer
endfunction

//Generated method caller for Table._get_real
function sc__Table__get_real takes integer this returns integer
        return this
endfunction

//Generated method caller for Table._get_boolean
function sc__Table__get_boolean takes integer this returns integer
        return this
endfunction

//Generated method caller for Table._get_string
function sc__Table__get_string takes integer this returns integer
        return this
endfunction

//Generated method caller for Table._get_widget
function sc__Table__get_widget takes integer this returns integer
        return this
endfunction

//Generated method caller for Table._get_unit
function sc__Table__get_unit takes integer this returns integer
        return this
endfunction

//Generated method caller for Table._get_fogstate
function sc__Table__get_fogstate takes integer this returns integer
        return this
endfunction

//Generated method caller for Table._getindex
function sc__Table__getindex takes integer this,integer key returns integer
        return LoadInteger(Table___ht, this, key)
endfunction

//Generated method caller for Table._setindex
function sc__Table__setindex takes integer this,integer key,integer tb returns nothing
        call SaveInteger(Table___ht, this, key, tb)
endfunction

//Generated method caller for Table.has
function sc__Table_has takes integer this,integer key returns boolean
        return HaveSavedInteger(Table___ht, this, key)
endfunction

//Generated method caller for Table.remove
function sc__Table_remove takes integer this,integer key returns nothing
        call RemoveSavedInteger(Table___ht, this, key)
endfunction

//Generated method caller for Table.create
function sc__Table_create takes nothing returns integer
    call TriggerEvaluate(st__Table_create)
 return f__result_integer
endfunction

//Generated method caller for Table.destroy
function sc__Table_destroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__Table_destroy)
endfunction

//Generated method caller for Table___fogstates._setindex
function sc__Table___fogstates__setindex takes integer this,integer key,fogstate value returns nothing
        call SaveFogStateHandle(Table___ht, this, key, value)
endfunction

//Generated method caller for Table___units._getindex
function sc__Table___units__getindex takes integer this,integer key returns unit
        return LoadUnitHandle(Table___ht, this, key)
endfunction

//Generated method caller for Table___units._setindex
function sc__Table___units__setindex takes integer this,integer key,unit value returns nothing
        call SaveUnitHandle(Table___ht, this, key, value)
endfunction

//Generated method caller for Table___widgets._getindex
function sc__Table___widgets__getindex takes integer this,integer key returns widget
        return LoadWidgetHandle(Table___ht, this, key)
endfunction

//Generated method caller for Table___strings._getindex
function sc__Table___strings__getindex takes integer this,integer key returns string
        return LoadStr(Table___ht, this, key)
endfunction

//Generated method caller for Table___strings._setindex
function sc__Table___strings__setindex takes integer this,integer key,string value returns nothing
        call SaveStr(Table___ht, this, key, value)
endfunction

//Generated method caller for Table___booleans._getindex
function sc__Table___booleans__getindex takes integer this,integer key returns boolean
        return LoadBoolean(Table___ht, this, key)
endfunction

//Generated method caller for Table___booleans._setindex
function sc__Table___booleans__setindex takes integer this,integer key,boolean value returns nothing
        call SaveBoolean(Table___ht, this, key, value)
endfunction

//Generated method caller for Table___reals._getindex
function sc__Table___reals__getindex takes integer this,integer key returns real
        return LoadReal(Table___ht, this, key)
endfunction

//Generated method caller for Table___reals._setindex
function sc__Table___reals__setindex takes integer this,integer key,real value returns nothing
        call SaveReal(Table___ht, this, key, value)
endfunction

//Generated method caller for HeroImage.destroy
function sc__HeroImage_destroy takes integer this returns nothing
    set f__arg_this=this
    call TriggerEvaluate(st__HeroImage_destroy)
endfunction

//Generated allocator of FullItemGenerator
function s__FullItemGenerator__allocate takes nothing returns integer
 local integer this=si__FullItemGenerator_F
    if (this!=0) then
        set si__FullItemGenerator_F=si__FullItemGenerator_V[this]
    else
        set si__FullItemGenerator_I=si__FullItemGenerator_I+1
        set this=si__FullItemGenerator_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__FullItemGenerator_V[this]=-1
 return this
endfunction

//Generated destructor of FullItemGenerator
function s__FullItemGenerator_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__FullItemGenerator_V[this]!=-1) then
        return
    endif
    set si__FullItemGenerator_V[this]=si__FullItemGenerator_F
    set si__FullItemGenerator_F=this
endfunction

//Generated allocator of CustomInventoryTraitHandler__ItemGenerator
function s__CustomInventoryTraitHandler__ItemGenerator__allocate takes nothing returns integer
 local integer this=si__CustomInventoryTraitHandler__ItemGenerator_F
    if (this!=0) then
        set si__CustomInventoryTraitHandler__ItemGenerator_F=si__CustomInventoryTraitHandler__ItemGenerator_V[this]
    else
        set si__CustomInventoryTraitHandler__ItemGenerator_I=si__CustomInventoryTraitHandler__ItemGenerator_I+1
        set this=si__CustomInventoryTraitHandler__ItemGenerator_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__CustomInventoryTraitHandler__ItemGenerator_V[this]=-1
 return this
endfunction

//Generated destructor of CustomInventoryTraitHandler__ItemGenerator
function s__CustomInventoryTraitHandler__ItemGenerator_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__CustomInventoryTraitHandler__ItemGenerator_V[this]!=-1) then
        return
    endif
    set si__CustomInventoryTraitHandler__ItemGenerator_V[this]=si__CustomInventoryTraitHandler__ItemGenerator_F
    set si__CustomInventoryTraitHandler__ItemGenerator_F=this
endfunction

//Generated allocator of CustomInventoryTraitHandler__TraitGroup
function s__CustomInventoryTraitHandler__TraitGroup__allocate takes nothing returns integer
 local integer this=si__CustomInventoryTraitHandler__TraitGroup_F
    if (this!=0) then
        set si__CustomInventoryTraitHandler__TraitGroup_F=si__CustomInventoryTraitHandler__TraitGroup_V[this]
    else
        set si__CustomInventoryTraitHandler__TraitGroup_I=si__CustomInventoryTraitHandler__TraitGroup_I+1
        set this=si__CustomInventoryTraitHandler__TraitGroup_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__CustomInventoryTraitHandler__TraitGroup_V[this]=-1
 return this
endfunction

//Generated destructor of CustomInventoryTraitHandler__TraitGroup
function s__CustomInventoryTraitHandler__TraitGroup_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__CustomInventoryTraitHandler__TraitGroup_V[this]!=-1) then
        return
    endif
    set si__CustomInventoryTraitHandler__TraitGroup_V[this]=si__CustomInventoryTraitHandler__TraitGroup_F
    set si__CustomInventoryTraitHandler__TraitGroup_F=this
endfunction

//Generated allocator of CustomInventoryTraitHandler__SpecificTraitGenerator
function s__CustomInventoryTraitHandler__SpecificTraitGenerator__allocate takes nothing returns integer
 local integer this=si__CustomInventoryTraitHandler__SpecificTraitGenerator_F
    if (this!=0) then
        set si__CustomInventoryTraitHandler__SpecificTraitGenerator_F=si__CustomInventoryTraitHandler__SpecificTraitGenerator_V[this]
    else
        set si__CustomInventoryTraitHandler__SpecificTraitGenerator_I=si__CustomInventoryTraitHandler__SpecificTraitGenerator_I+1
        set this=si__CustomInventoryTraitHandler__SpecificTraitGenerator_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__CustomInventoryTraitHandler__SpecificTraitGenerator_V[this]=-1
 return this
endfunction

//Generated destructor of CustomInventoryTraitHandler__SpecificTraitGenerator
function s__CustomInventoryTraitHandler__SpecificTraitGenerator_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__CustomInventoryTraitHandler__SpecificTraitGenerator_V[this]!=-1) then
        return
    endif
    set si__CustomInventoryTraitHandler__SpecificTraitGenerator_V[this]=si__CustomInventoryTraitHandler__SpecificTraitGenerator_F
    set si__CustomInventoryTraitHandler__SpecificTraitGenerator_F=this
endfunction

//Generated allocator of Trait
function s__Trait__allocate takes nothing returns integer
 local integer this=si__Trait_F
    if (this!=0) then
        set si__Trait_F=si__Trait_V[this]
    else
        set si__Trait_I=si__Trait_I+1
        set this=si__Trait_I
    endif
    if (this>8190) then
        return 0
    endif

    set si__Trait_V[this]=-1
 return this
endfunction

//Generated destructor of Trait
function s__Trait_deallocate takes integer this returns nothing
    if this==null then
        return
    elseif (si__Trait_V[this]!=-1) then
        return
    endif
    set si__Trait_V[this]=si__Trait_F
    set si__Trait_F=this
endfunction
function sc___prototype3_execute takes integer i returns nothing

    call TriggerExecute(st___prototype3[i])
endfunction
function sc___prototype3_evaluate takes integer i returns nothing

    call TriggerEvaluate(st___prototype3[i])

endfunction

//library AddRepeatedString:
    //adds a string to another string in spaced intervals
    //call AddRepeatedString(1234567,"-",3,0) -> 123-456-7
    function AddRepeatedString takes string s,string str,integer spacing,integer start returns string
        local integer i= StringLength(s)
        local integer p= 1
        loop
            exitwhen p * spacing + start >= i
            set s=SubString(s, 0, p * spacing + p + start - 1) + str + SubString(s, p * spacing + p + start - 1, StringLength(s))
            set p=p + 1
        endloop
        return s
    endfunction

//library AddRepeatedString ends
//library AdvancedQuest:
        function s__Quest_create takes string title,string description,string reward,string icon,boolean required,boolean enabled,boolean discovered returns integer
            local integer this= s__Quest__allocate()
            set s__Quest_progress[this]=sc__TableArray__staticgetindex(3)
            set s__Quest_progressHashes[this]=sc__Table_create()
            set s__Quest_progressHashesIndex[this]=0
            set s__Quest_title[this]=title
            set s__Quest_description[this]=description
            set s__Quest_reward[this]=reward
            set s__Quest_icon[this]=icon
            set s__Quest_q[this]=CreateQuest()
            call QuestSetEnabled(s__Quest_q[this], enabled)
            call QuestSetDiscovered(s__Quest_q[this], discovered)
            call QuestSetFailed(s__Quest_q[this], false)
            call QuestSetRequired(s__Quest_q[this], required)
            call QuestSetCompleted(s__Quest_q[this], false)
            call QuestSetTitle(s__Quest_q[this], title)
            call QuestSetIconPath(s__Quest_q[this], icon)
            call sc__Quest_refreshDescription(this)
            return this
        endfunction
        function s__Quest_isCompleted takes integer this returns boolean
            return IsQuestCompleted(s__Quest_q[this])
        endfunction
        function s__Quest_setCompleted takes integer this,boolean is returns integer
            call QuestSetCompleted(s__Quest_q[this], is)
            return this
        endfunction
        function s__Quest_isDiscovered takes integer this returns boolean
            return IsQuestDiscovered(s__Quest_q[this])
        endfunction
        function s__Quest_setDiscovered takes integer this,boolean is returns integer
            call QuestSetDiscovered(s__Quest_q[this], is)
            return this
        endfunction
        function s__Quest_isRequired takes integer this returns boolean
            return IsQuestRequired(s__Quest_q[this])
        endfunction
        function s__Quest_setRequired takes integer this,boolean is returns integer
            call QuestSetRequired(s__Quest_q[this], is)
            return this
        endfunction
        function s__Quest_isEnabled takes integer this returns boolean
            return IsQuestEnabled(s__Quest_q[this])
        endfunction
        function s__Quest_setEnabled takes integer this,boolean is returns integer
            call QuestSetEnabled(s__Quest_q[this], is)
            return this
        endfunction
        function s__Quest_isFailed takes integer this returns boolean
            return IsQuestFailed(s__Quest_q[this])
        endfunction
        function s__Quest_setFailed takes integer this,boolean is returns integer
            call QuestSetFailed(s__Quest_q[this], is)
            return this
        endfunction
        function s__Quest_getIntegerMaximum takes integer this,string identifier returns integer
            return (LoadInteger(Table___ht, (sc__TableArray__getindex(s__Quest_progress[this],1)), (StringHash(identifier)))) // INLINED!!
        endfunction
        function s__Quest_getIntegerCurrent takes integer this,string identifier returns integer
            return (LoadInteger(Table___ht, (sc__TableArray__getindex(s__Quest_progress[this],0)), (StringHash(identifier)))) // INLINED!!
        endfunction
        function s__Quest_addIntegerProgress takes integer this,string identifier,integer starting,integer finish returns integer
            call SaveInteger(Table___ht, (sc__TableArray__getindex(s__Quest_progress[this],0)), (StringHash(identifier)), ( starting)) // INLINED!!
            call SaveInteger(Table___ht, (sc__TableArray__getindex(s__Quest_progress[this],1)), (StringHash(identifier)), ( finish)) // INLINED!!
            call SaveStr(Table___ht, (((s__Quest_progressHashes[this]))), (s__Quest_progressHashesIndex[this]), ( identifier)) // INLINED!!
            set s__Quest_progressHashesIndex[this]=s__Quest_progressHashesIndex[this] + 1
            call sc__Quest_refreshDescription(this)
            return this
        endfunction
        function s__Quest_setIntegerProgress takes integer this,string identifier,integer new,boolean checkForFinish returns integer
            local integer i= StringHash(identifier)
            if new >= (LoadInteger(Table___ht, (sc__TableArray__getindex(s__Quest_progress[this],1)), (i))) and checkForFinish then // INLINED!!
                call SaveBoolean(Table___ht, (((sc__TableArray__getindex(s__Quest_progress[this],2)))), (i), ( true)) // INLINED!!
            endif
            call SaveInteger(Table___ht, (sc__TableArray__getindex(s__Quest_progress[this],0)), (i), ( new)) // INLINED!!
            call sc__Quest_refreshDescription(this)
            return this
        endfunction
        function s__Quest_addToIntegerProgress takes integer this,string identifier,integer add,boolean checkForFinish returns integer
            local integer i= StringHash(identifier)
            if add + (LoadInteger(Table___ht, (sc__TableArray__getindex(s__Quest_progress[this],0)), (i))) >= (LoadInteger(Table___ht, (sc__TableArray__getindex(s__Quest_progress[this],1)), (i))) and checkForFinish then // INLINED!!
                call SaveBoolean(Table___ht, (((sc__TableArray__getindex(s__Quest_progress[this],2)))), (i), ( true)) // INLINED!!
            endif
            if add + (LoadInteger(Table___ht, (sc__TableArray__getindex(s__Quest_progress[this],0)), (i))) > ((LoadInteger(Table___ht, (sc__TableArray__getindex(s__Quest_progress[this],1)), (i)))) then // INLINED!!
                call SaveInteger(Table___ht, (sc__TableArray__getindex(s__Quest_progress[this],0)), (i), ( (LoadInteger(Table___ht, (sc__TableArray__getindex(s__Quest_progress[this],1)), (i))))) // INLINED!!
            else
                call SaveInteger(Table___ht, (sc__TableArray__getindex(s__Quest_progress[this],0)), (i), ( add + (LoadInteger(Table___ht, (sc__TableArray__getindex(s__Quest_progress[this],0)), (i))))) // INLINED!!
            endif
            call sc__Quest_refreshDescription(this)
            return this
        endfunction
        function s__Quest_isFinished takes integer this returns boolean
            local integer i= 0
            loop
                if (LoadStr(Table___ht, (((s__Quest_progressHashes[this]))), (i))) != null then // INLINED!!
                    if not (LoadBoolean(Table___ht, (((sc__TableArray__getindex(s__Quest_progress[this],2)))), (StringHash((LoadStr(Table___ht, (((s__Quest_progressHashes[this]))), (i))))))) then // INLINED!!
                        return false
                    endif
                else
                    return true
                endif
                set i=i + 1
            endloop
            return true
        endfunction
        function s__Quest_exists takes integer this,string identifier returns boolean
            local integer i= 0
            local string s
            loop
                set s=(LoadStr(Table___ht, (((s__Quest_progressHashes[this]))), (i))) // INLINED!!
                if s != null then
                    if s == identifier then
                        return true
                    endif
                else
                    return false
                endif
                set i=i + 1
            endloop
            return false
        endfunction
        function s__Quest_isIntFinished takes integer this,string identifier returns boolean
            return (LoadBoolean(Table___ht, (((sc__TableArray__getindex(s__Quest_progress[this],2)))), (StringHash(identifier)))) // INLINED!!
        endfunction
        function s__Quest_refreshDescription takes integer this returns integer
            local integer i= 0
            local string progresses= " "
            local string s
            loop
                if (LoadStr(Table___ht, (((s__Quest_progressHashes[this]))), (i))) != null then // INLINED!!
                    if (LoadBoolean(Table___ht, (((sc__TableArray__getindex(s__Quest_progress[this],2)))), (StringHash((LoadStr(Table___ht, (((s__Quest_progressHashes[this]))), (i))))))) then // INLINED!!
                        set s=AdvancedQuest__finishedcolor + AdvancedQuest__perProgressPrefix + (LoadStr(Table___ht, (((s__Quest_progressHashes[this]))), (i))) + AdvancedQuest__perProgressSuffix + I2S((LoadInteger(Table___ht, (sc__TableArray__getindex(s__Quest_progress[this],0)), (StringHash((LoadStr(Table___ht, (((s__Quest_progressHashes[this]))), (i)))))))) + AdvancedQuest__intseperator + I2S((LoadInteger(Table___ht, (sc__TableArray__getindex(s__Quest_progress[this],1)), (StringHash((LoadStr(Table___ht, (((s__Quest_progressHashes[this]))), (i)))))))) + " (Finished) |r" // INLINED!!
                    else
                        set s=AdvancedQuest__perProgressPrefix + (LoadStr(Table___ht, (((s__Quest_progressHashes[this]))), (i))) + AdvancedQuest__perProgressSuffix + I2S((LoadInteger(Table___ht, (sc__TableArray__getindex(s__Quest_progress[this],0)), (StringHash((LoadStr(Table___ht, (((s__Quest_progressHashes[this]))), (i)))))))) + AdvancedQuest__intseperator + I2S((LoadInteger(Table___ht, (sc__TableArray__getindex(s__Quest_progress[this],1)), (StringHash((LoadStr(Table___ht, (((s__Quest_progressHashes[this]))), (i)))))))) // INLINED!!
                    endif
                    set progresses=progresses + AdvancedQuest__newline + s
                else
                    exitwhen true
                endif
                set i=i + 1
            endloop
            if progresses == " " then
                set progresses="None"
            endif
            call QuestSetDescription(s__Quest_q[this], AdvancedQuest__titleString + s__Quest_title[this] + AdvancedQuest__newline2x + AdvancedQuest__descriptionPrefix + s__Quest_description[this] + AdvancedQuest__newline2x + AdvancedQuest__progressPrefix + progresses + AdvancedQuest__newline2x + AdvancedQuest__rewardPrefix + s__Quest_reward[this])
            return this
        endfunction
    function AdvancedQuest__onUnitDeath takes nothing returns boolean
        if GetUnitTypeId(GetTriggerUnit()) == 'n000' and not (IsQuestCompleted(s__Quest_q[(qur)])) then // INLINED!!
            if s__Quest_isFinished(s__Quest_addToIntegerProgress(qur,"Fail" , 1 , true)) then
                call s__Quest_setCompleted(qur,true)
            endif
        endif
        return false
    endfunction
    function AdvancedQuest__init takes nothing returns nothing
        local trigger t= CreateTrigger()
        call TriggerRegisterAnyUnitEventBJ(t, EVENT_PLAYER_UNIT_DEATH)
        call TriggerAddCondition(t, Filter(function AdvancedQuest__onUnitDeath))
        set qur=s__Quest_create("a" , "b" , "c" , "ReplaceableTextures\\CommandButtons\\BTNAmbush.blp" , true , true , true)
        call s__Quest_addIntegerProgress(qur,"Fail" , 1 , 10)
    endfunction

//library AdvancedQuest ends
//library Ascii:
///////////////////////////////////////////////////////////////////
//      function Char2Ascii takes string s returns integer
//          integer ascii = Char2Ascii("F")
//
//      function Ascii2Char takes integer a returns string
//          string char = Ascii2Char('F')
//
//      function A2S takes integer a returns string
//          string rawcode = A2S('CODE')
//
//      function S2A takes string s returns integer
//          integer rawcode = S2A("CODE")
//
///////////////////////////////////////////////////////////////////
    function Char2Ascii takes string s returns integer
        local integer a
        if ( "\\" == s ) then
            return 92
        endif
        set a=Ascii__i[StringHash(s) / 0x1F0748 + 0x3EA]
        if ( s != Ascii__c[a] ) then
            return a + 32
        endif
        return a
    endfunction
    function Ascii2Char takes integer a returns string
        return Ascii__c[a]
    endfunction
    function A2S takes integer a returns string
        local string s=""
        loop
            set s=Ascii__c[a - a / 256 * 256] + s
            set a=a / 256
            exitwhen 0 == a
        endloop
        return s
    endfunction
    function S2A takes string s returns integer
        local integer a=0
        local integer l=StringLength(s)
        local integer j=0
        local string m
        local integer h
        loop
            exitwhen j == l
            set m=SubString(s, j, j + 1)
            if ( "\\" == m ) then
                set a=a * 256 + 92
            else
                set h=Ascii__i[StringHash(m) / 0x1F0748 + 0x3EA]
                if ( m != Ascii__c[h] ) then
                    set a=a * 256 + h + 32
                else
                    set a=a * 256 + h
                endif
            endif
            set j=j + 1
        endloop
        return a
    endfunction
//Implemented from module Ascii__Init:
        function s__Ascii__Inits_Ascii__Init___onInit takes nothing returns nothing
            set Ascii__i[931]=8
            set Ascii__i[1075]=9
            set Ascii__i[1586]=10
            set Ascii__i[1340]=12
            set Ascii__i[412]=13
            set Ascii__i[198]=32
            set Ascii__i[1979]=33
            set Ascii__i[1313]=34
            set Ascii__i[1003]=35
            set Ascii__i[1264]=36
            set Ascii__i[983]=37
            set Ascii__i[1277]=38
            set Ascii__i[306]=39
            set Ascii__i[904]=40
            set Ascii__i[934]=41
            set Ascii__i[917]=42
            set Ascii__i[1972]=43
            set Ascii__i[1380]=44
            set Ascii__i[1985]=45
            set Ascii__i[869]=46
            set Ascii__i[1906]=47
            set Ascii__i[883]=48
            set Ascii__i[1558]=49
            set Ascii__i[684]=50
            set Ascii__i[582]=51
            set Ascii__i[668]=52
            set Ascii__i[538]=53
            set Ascii__i[672]=54
            set Ascii__i[1173]=55
            set Ascii__i[71]=56
            set Ascii__i[277]=57
            set Ascii__i[89]=58
            set Ascii__i[1141]=59
            set Ascii__i[39]=60
            set Ascii__i[1171]=61
            set Ascii__i[51]=62
            set Ascii__i[305]=63
            set Ascii__i[0]=64
            set Ascii__i[222]=65
            set Ascii__i[178]=66
            set Ascii__i[236]=67
            set Ascii__i[184]=68
            set Ascii__i[1295]=69
            set Ascii__i[1390]=70
            set Ascii__i[1276]=71
            set Ascii__i[203]=72
            set Ascii__i[1314]=73
            set Ascii__i[209]=74
            set Ascii__i[1315]=75
            set Ascii__i[170]=76
            set Ascii__i[1357]=77
            set Ascii__i[1343]=78
            set Ascii__i[1397]=79
            set Ascii__i[1420]=80
            set Ascii__i[1419]=81
            set Ascii__i[1396]=82
            set Ascii__i[1374]=83
            set Ascii__i[1407]=84
            set Ascii__i[499]=85
            set Ascii__i[1465]=86
            set Ascii__i[736]=87
            set Ascii__i[289]=88
            set Ascii__i[986]=89
            set Ascii__i[38]=90
            set Ascii__i[1230]=91
            set Ascii__i[1636]=93
            set Ascii__i[1416]=94
            set Ascii__i[1917]=95
            set Ascii__i[217]=96
            set Ascii__i[833]=123
            set Ascii__i[1219]=124
            set Ascii__i[553]=125
            set Ascii__i[58]=126
            set Ascii__c[8]="\b"
            set Ascii__c[9]="\t"
            set Ascii__c[10]="\n"
            set Ascii__c[12]="\f"
      //      set c[13]="\r"
            set Ascii__c[32]=" "
            set Ascii__c[33]="!"
            set Ascii__c[34]="\""
            set Ascii__c[35]="#"
            set Ascii__c[36]="$"
            set Ascii__c[37]="%"
            set Ascii__c[38]="&"
            set Ascii__c[39]="'"
            set Ascii__c[40]="("
            set Ascii__c[41]=")"
            set Ascii__c[42]="*"
            set Ascii__c[43]="+"
            set Ascii__c[44]=","
            set Ascii__c[45]="-"
            set Ascii__c[46]="."
            set Ascii__c[47]="/"
            set Ascii__c[48]="0"
            set Ascii__c[49]="1"
            set Ascii__c[50]="2"
            set Ascii__c[51]="3"
            set Ascii__c[52]="4"
            set Ascii__c[53]="5"
            set Ascii__c[54]="6"
            set Ascii__c[55]="7"
            set Ascii__c[56]="8"
            set Ascii__c[57]="9"
            set Ascii__c[58]=":"
            set Ascii__c[59]=";"
            set Ascii__c[60]="<"
            set Ascii__c[61]="="
            set Ascii__c[62]=">"
            set Ascii__c[63]="?"
            set Ascii__c[64]="@"
            set Ascii__c[65]="A"
            set Ascii__c[66]="B"
            set Ascii__c[67]="C"
            set Ascii__c[68]="D"
            set Ascii__c[69]="E"
            set Ascii__c[70]="F"
            set Ascii__c[71]="G"
            set Ascii__c[72]="H"
            set Ascii__c[73]="I"
            set Ascii__c[74]="J"
            set Ascii__c[75]="K"
            set Ascii__c[76]="L"
            set Ascii__c[77]="M"
            set Ascii__c[78]="N"
            set Ascii__c[79]="O"
            set Ascii__c[80]="P"
            set Ascii__c[81]="Q"
            set Ascii__c[82]="R"
            set Ascii__c[83]="S"
            set Ascii__c[84]="T"
            set Ascii__c[85]="U"
            set Ascii__c[86]="V"
            set Ascii__c[87]="W"
            set Ascii__c[88]="X"
            set Ascii__c[89]="Y"
            set Ascii__c[90]="Z"
            set Ascii__c[92]="\\"
            set Ascii__c[97]="a"
            set Ascii__c[98]="b"
            set Ascii__c[99]="c"
            set Ascii__c[100]="d"
            set Ascii__c[101]="e"
            set Ascii__c[102]="f"
            set Ascii__c[103]="g"
            set Ascii__c[104]="h"
            set Ascii__c[105]="i"
            set Ascii__c[106]="j"
            set Ascii__c[107]="k"
            set Ascii__c[108]="l"
            set Ascii__c[109]="m"
            set Ascii__c[110]="n"
            set Ascii__c[111]="o"
            set Ascii__c[112]="p"
            set Ascii__c[113]="q"
            set Ascii__c[114]="r"
            set Ascii__c[115]="s"
            set Ascii__c[116]="t"
            set Ascii__c[117]="u"
            set Ascii__c[118]="v"
            set Ascii__c[119]="w"
            set Ascii__c[120]="x"
            set Ascii__c[121]="y"
            set Ascii__c[122]="z"
            set Ascii__c[91]="["
            set Ascii__c[93]="]"
            set Ascii__c[94]="^"
            set Ascii__c[95]="_"
            set Ascii__c[96]="`"
            set Ascii__c[123]="{"
            set Ascii__c[124]="|"
            set Ascii__c[125]="}"
            set Ascii__c[126]="~"
        endfunction

//library Ascii ends
//library BaseFunction:

    function GetTotalItemCharges takes unit u,integer itemId returns integer
        local integer i= 0
        local integer charges= 0
        loop
            exitwhen i == 5
            if GetItemTypeId(UnitItemInSlot(u, i)) == itemId then
                set charges=charges + GetItemCharges(UnitItemInSlot(u, i))
            endif
            set i=i + 1
        endloop
        return charges
    endfunction
    function ReduceItemCharges takes unit u,integer itemId,integer no returns nothing
        local integer i= 0
        local item ite
        loop
            exitwhen i == 5
            set ite=UnitItemInSlot(u, i)
            if GetItemTypeId(ite) == itemId then
                if GetItemCharges(ite) > no then
                    call SetItemCharges(ite, GetItemCharges(ite) - no)
                    set ite=null
                    return
                elseif GetItemCharges(ite) == no then
                    call RemoveItem(ite)
                    set ite=null
                    return
                else
                    set no=no - GetItemCharges(ite)
                    call RemoveItem(ite)
                endif
            endif
            set i=i + 1
        endloop
        return
    endfunction
    function DuplicateForce takes force f returns force
        local integer i= 0
        set tempForce=null
        set tempForce=CreateForce()
        loop
            if IsPlayerInForce(Player(i), f) then
                call ForceAddPlayer(tempForce, Player(i))
            endif
            set i=i + 1
            exitwhen i == 10
        endloop
        return tempForce
    endfunction
    function ForceRemoveForce takes force f2,force f returns nothing
        local integer i= 0
        loop
            exitwhen i == 13
            if IsPlayerInForce(Player(i), f) then
                call ForceRemovePlayer(f2, Player(i))
            endif
            set i=i + 1
        endloop
    endfunction 
    function FirstOfForce takes force f returns player
        local integer i= 0
        loop
            exitwhen i == 16
            if IsPlayerInForce(Player(i), f) then
                return Player(i)
            endif
            set i=i + 1
        endloop
        return null
    endfunction
    function AddForceToForce takes force f1,force f2 returns nothing
        local integer i= 0
        loop
            exitwhen i == 10
            if IsPlayerInForce(Player(i), f1) and not IsPlayerInForce(Player(i), f2) then
                call ForceAddPlayer(f2, Player(i))
            endif
            set i=i + 1
        endloop
    endfunction
        function runTriggerForPlayer takes trigger t,player p returns nothing
            set applicablePlayer=p
            call TriggerExecute(t)
            set applicablePlayer=null
        endfunction
        function runTriggerForForce takes force f,trigger t returns nothing
            set applicableForce=f
            call TriggerEvaluate(t)
            set applicableForce=null
        endfunction
    function B2S takes boolean b returns string
        if b then
            return "true"
        else
            return "false"
        endif
    endfunction
    function setAttach takes unit u,integer data returns nothing
        call SaveInteger(Table___ht, (BaseFunction__attachtable), (GetHandleId(u)), ( data)) // INLINED!!
    endfunction
    function getAttach takes unit u returns integer
        return (LoadInteger(Table___ht, (BaseFunction__attachtable), (GetHandleId(u)))) // INLINED!!
    endfunction
    function GetRandomAngle takes nothing returns real
        return GetRandomReal(- bj_PI, bj_PI)
    endfunction
    function CastSpellAtPoint takes integer id,real sourceX,real sourceY,real destX,real destY returns nothing
    
    endfunction
    function DoesUnitExist takes unit u returns boolean
        return u == null or GetUnitTypeId(u) != 0
    endfunction
    function TimedText takes player p,real time,string text returns nothing
        call DisplayTimedTextToPlayer(p, 0, 0, time, text)
    endfunction
    function TimedTextBoolean takes real time,boolean b,string text returns nothing
        if b then
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, time, text)
        endif
    endfunction
    function TimedTextAll takes real time,string text returns nothing
        call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, time, text)
    endfunction
    
    function GroupCallback takes nothing returns nothing
        set index=index + 1
        set units[index]=GetEnumUnit()
    endfunction

    function RandomUnitFromGroup takes group g returns unit
        set index=0
        call ForGroup(g, function GroupCallback)
        return units[GetRandomInt(1, index)]
    endfunction
    function TimedTextForce takes force f,real time,string text returns nothing
        if IsPlayerInForce(GetLocalPlayer(), f) then
            call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, time, text)
        endif
    endfunction 
    function forceCounterFun takes nothing returns nothing
        set tempintdonttouch=tempintdonttouch + 1
    endfunction
    function ForceCount takes force f returns integer
        local integer i= 0
        set tempintdonttouch=0
        call ForForce(f, function forceCounterFun)
        set i=tempintdonttouch
        set tempintdonttouch=0
        return i
    endfunction
    function color2Number takes string playerColor returns integer
        set playerColor=StringCase(playerColor, false)
        if playerColor == "red" then
            return 0
        elseif playerColor == "blue" then
            return 1
        elseif playerColor == "teal" then
            return 2
        elseif playerColor == "purple" or playerColor == "purp" or playerColor == "violet" then
            return 3
        elseif playerColor == "yellow" then
            return 4
        elseif playerColor == "orange" then
            return 5
        elseif playerColor == "green" then
            return 6
        elseif playerColor == "pink" then
            return 7
        elseif playerColor == "gray" or playerColor == "grey" then
            return 8
        elseif playerColor == "light blue" or playerColor == "lightblue" or playerColor == "lb" or playerColor == "lblue" then
            return 9
        endif
        return 10
    endfunction
    
    function TimerAttach takes timer t,integer d returns nothing
        call SaveInteger(Table___ht, (BaseFunction__timers), (GetHandleId(t)), ( d)) // INLINED!!
    endfunction
    function TimerDetach takes timer t returns integer
        local integer returnv= (LoadInteger(Table___ht, (BaseFunction__timers), (GetHandleId(t)))) // INLINED!!
        call SaveInteger(Table___ht, (BaseFunction__timers), (GetHandleId(t)), ( 0)) // INLINED!!
        return returnv
    endfunction
    function I2W takes integer i returns widget
        call SaveFogStateHandle(Table___ht, (((BaseFunction__timers))), (i), ( ConvertFogState(i))) // INLINED!!
        return (LoadWidgetHandle(Table___ht, (((BaseFunction__timers))), (i))) // INLINED!!
    endfunction
    function UnitAttach takes unit u,integer d returns nothing
        call SaveInteger(Table___ht, (BaseFunction__timers), (GetHandleId(u)), ( d)) // INLINED!!
    endfunction
    function UnitGetAttach takes unit u returns integer
        return (LoadInteger(Table___ht, (BaseFunction__timers), (GetHandleId(u)))) // INLINED!!
    endfunction
    function UnitDetach takes unit u returns nothing
        call SaveInteger(Table___ht, (BaseFunction__timers), (GetHandleId(u)), ( 0)) // INLINED!!
    endfunction
    
    function GetUnitHero takes unit u returns unit
        return udg_PlayerUnit[GetPlayerId(GetOwningPlayer(u)) + 1]
    endfunction
    function GetPlayerHero takes player p returns unit
        return udg_PlayerUnit[GetPlayerId(p) + 1]
    endfunction
    
    function CastSpell takes integer id,real sourceX,real sourceY returns nothing
    
    endfunction
    function CastSpellAtUnit takes integer id,real sourceX,real sourceY,unit target returns nothing
    
    endfunction
    function FireWave takes integer playerId,integer id,real x,real y,real angle,integer this returns nothing
        local unit dummy
        set dummy=CreateUnit(Player(playerId), casterDummy, x - ( Cos(angle) * 200 ), y - Sin(angle) * 200, 0)
        call SaveInteger(Table___ht, (BaseFunction__attachtable), (GetHandleId((dummy ))), ( ( this))) // INLINED!!
        call UnitAddAbility(dummy, id)
        
        call IssuePointOrder(dummy, "carrionswarm", x + Cos(angle) * 100, y + Sin(angle) * 100)
    endfunction
    
    
//textmacro instance: vt("1")
    function BaseFunction__vt1 takes nothing returns boolean
        local unit target= GetFilterUnit()
        local player host= Player(1)
        if not IsUnitAlly(target, host) then
            if GetUnitAbilityLevel(target, 'A00H') > 0 and GetWidgetLife(target) >= 2000000.402 then
                set target=null
                set host=null
                return true
            elseif GetWidgetLife(target) >= 0.402 then
                set target=null
                set host=null
                return true
            endif
        endif
        set target=null
        return false
    endfunction
//end of: vt("1")
//textmacro instance: vt("2")
    function BaseFunction__vt2 takes nothing returns boolean
        local unit target= GetFilterUnit()
        local player host= Player(2)
        if not IsUnitAlly(target, host) then
            if GetUnitAbilityLevel(target, 'A00H') > 0 and GetWidgetLife(target) >= 2000000.402 then
                set target=null
                set host=null
                return true
            elseif GetWidgetLife(target) >= 0.402 then
                set target=null
                set host=null
                return true
            endif
        endif
        set target=null
        return false
    endfunction
//end of: vt("2")
//textmacro instance: vt("3")
    function BaseFunction__vt3 takes nothing returns boolean
        local unit target= GetFilterUnit()
        local player host= Player(3)
        if not IsUnitAlly(target, host) then
            if GetUnitAbilityLevel(target, 'A00H') > 0 and GetWidgetLife(target) >= 2000000.402 then
                set target=null
                set host=null
                return true
            elseif GetWidgetLife(target) >= 0.402 then
                set target=null
                set host=null
                return true
            endif
        endif
        set target=null
        return false
    endfunction
//end of: vt("3")
//textmacro instance: vt("4")
    function BaseFunction__vt4 takes nothing returns boolean
        local unit target= GetFilterUnit()
        local player host= Player(4)
        if not IsUnitAlly(target, host) then
            if GetUnitAbilityLevel(target, 'A00H') > 0 and GetWidgetLife(target) >= 2000000.402 then
                set target=null
                set host=null
                return true
            elseif GetWidgetLife(target) >= 0.402 then
                set target=null
                set host=null
                return true
            endif
        endif
        set target=null
        return false
    endfunction
//end of: vt("4")
//textmacro instance: vt("5")
    function BaseFunction__vt5 takes nothing returns boolean
        local unit target= GetFilterUnit()
        local player host= Player(5)
        if not IsUnitAlly(target, host) then
            if GetUnitAbilityLevel(target, 'A00H') > 0 and GetWidgetLife(target) >= 2000000.402 then
                set target=null
                set host=null
                return true
            elseif GetWidgetLife(target) >= 0.402 then
                set target=null
                set host=null
                return true
            endif
        endif
        set target=null
        return false
    endfunction
//end of: vt("5")
//textmacro instance: vt("6")
    function BaseFunction__vt6 takes nothing returns boolean
        local unit target= GetFilterUnit()
        local player host= Player(6)
        if not IsUnitAlly(target, host) then
            if GetUnitAbilityLevel(target, 'A00H') > 0 and GetWidgetLife(target) >= 2000000.402 then
                set target=null
                set host=null
                return true
            elseif GetWidgetLife(target) >= 0.402 then
                set target=null
                set host=null
                return true
            endif
        endif
        set target=null
        return false
    endfunction
//end of: vt("6")
//textmacro instance: vt("7")
    function BaseFunction__vt7 takes nothing returns boolean
        local unit target= GetFilterUnit()
        local player host= Player(7)
        if not IsUnitAlly(target, host) then
            if GetUnitAbilityLevel(target, 'A00H') > 0 and GetWidgetLife(target) >= 2000000.402 then
                set target=null
                set host=null
                return true
            elseif GetWidgetLife(target) >= 0.402 then
                set target=null
                set host=null
                return true
            endif
        endif
        set target=null
        return false
    endfunction
//end of: vt("7")
//textmacro instance: vt("8")
    function BaseFunction__vt8 takes nothing returns boolean
        local unit target= GetFilterUnit()
        local player host= Player(8)
        if not IsUnitAlly(target, host) then
            if GetUnitAbilityLevel(target, 'A00H') > 0 and GetWidgetLife(target) >= 2000000.402 then
                set target=null
                set host=null
                return true
            elseif GetWidgetLife(target) >= 0.402 then
                set target=null
                set host=null
                return true
            endif
        endif
        set target=null
        return false
    endfunction
//end of: vt("8")
//textmacro instance: vt("9")
    function BaseFunction__vt9 takes nothing returns boolean
        local unit target= GetFilterUnit()
        local player host= Player(9)
        if not IsUnitAlly(target, host) then
            if GetUnitAbilityLevel(target, 'A00H') > 0 and GetWidgetLife(target) >= 2000000.402 then
                set target=null
                set host=null
                return true
            elseif GetWidgetLife(target) >= 0.402 then
                set target=null
                set host=null
                return true
            endif
        endif
        set target=null
        return false
    endfunction
//end of: vt("9")
//textmacro instance: vt("10")
    function BaseFunction__vt10 takes nothing returns boolean
        local unit target= GetFilterUnit()
        local player host= Player(10)
        if not IsUnitAlly(target, host) then
            if GetUnitAbilityLevel(target, 'A00H') > 0 and GetWidgetLife(target) >= 2000000.402 then
                set target=null
                set host=null
                return true
            elseif GetWidgetLife(target) >= 0.402 then
                set target=null
                set host=null
                return true
            endif
        endif
        set target=null
        return false
    endfunction
//end of: vt("10")
//textmacro instance: vt("11")
    function BaseFunction__vt11 takes nothing returns boolean
        local unit target= GetFilterUnit()
        local player host= Player(11)
        if not IsUnitAlly(target, host) then
            if GetUnitAbilityLevel(target, 'A00H') > 0 and GetWidgetLife(target) >= 2000000.402 then
                set target=null
                set host=null
                return true
            elseif GetWidgetLife(target) >= 0.402 then
                set target=null
                set host=null
                return true
            endif
        endif
        set target=null
        return false
    endfunction
//end of: vt("11")
//textmacro instance: vt("12")
    function BaseFunction__vt12 takes nothing returns boolean
        local unit target= GetFilterUnit()
        local player host= Player(12)
        if not IsUnitAlly(target, host) then
            if GetUnitAbilityLevel(target, 'A00H') > 0 and GetWidgetLife(target) >= 2000000.402 then
                set target=null
                set host=null
                return true
            elseif GetWidgetLife(target) >= 0.402 then
                set target=null
                set host=null
                return true
            endif
        endif
        set target=null
        return false
    endfunction
//end of: vt("12")
    
    function isViableTarget takes unit source,unit target returns boolean
        if target != null then
            if source != target and not IsUnitAlly(target, GetOwningPlayer(source)) then
                if GetUnitAbilityLevel(target, 'A00H') > 0 then
                    return GetWidgetLife(target) >= 2000000.402
                else
                    return GetWidgetLife(target) >= 0.402
                endif
            endif
        endif
        return false
    endfunction
    
    function getTargetFilter takes player p returns filterfunc
        local integer i= GetPlayerId(p)
        if i == 0 then
            return viableTargetFilter1
        elseif i == 1 then
            return viableTargetFilter2
        elseif i == 2 then
            return viableTargetFilter3
        elseif i == 3 then
            return viableTargetFilter4
        elseif i == 4 then
            return viableTargetFilter5
        elseif i == 5 then
            return viableTargetFilter6
        elseif i == 6 then
            return viableTargetFilter7
        elseif i == 7 then
            return viableTargetFilter8
        elseif i == 8 then
            return viableTargetFilter9
        elseif i == 9 then
            return viableTargetFilter10
        elseif i == 10 then
            return viableTargetFilter11
        elseif i == 11 then
            return viableTargetFilter12
        endif
        return null
    endfunction
    
    function pureDamage takes unit criminal,unit victim,real amount returns nothing
        set DAMAGE_EVENT_REQUEST_TYPE=5
        call UnitDamageTarget(criminal, victim, amount, true, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_UNIVERSAL, WEAPON_TYPE_WHOKNOWS)
    endfunction
    
    function spellDamage takes unit criminal,unit victim,real amount returns nothing
        set DAMAGE_EVENT_REQUEST_TYPE=0
        call UnitDamageTarget(criminal, victim, amount, true, false, ATTACK_TYPE_MAGIC, DAMAGE_TYPE_NORMAL, WEAPON_TYPE_WHOKNOWS)
    endfunction
    
    function heal takes unit healer,unit patient,real amount returns nothing
        set DAMAGE_EVENT_REQUEST_TYPE=4
        call UnitDamageTarget(healer, patient, amount, true, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_UNIVERSAL, WEAPON_TYPE_WHOKNOWS)
    endfunction
    
    function dotDamage takes unit criminal,unit victim,real amount returns nothing
        set DAMAGE_EVENT_REQUEST_TYPE=3
        call UnitDamageTarget(criminal, victim, amount, true, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_UNIVERSAL, WEAPON_TYPE_WHOKNOWS)
    endfunction
    function aggroDamage takes unit criminal,unit victim returns nothing
        set DAMAGE_EVENT_REQUEST_TYPE=6
        call UnitDamageTarget(criminal, victim, 1, true, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_UNIVERSAL, WEAPON_TYPE_WHOKNOWS)
    endfunction
    function IsInHeightRange takes real height,unit is returns boolean
        return true
    endfunction
    
    function getDiracAngleBetweenPoints takes real x1,real y1,real x2,real y2 returns real
        return Atan2(y2 - y1, x2 - x1)
    endfunction
    function rotateAngle takes real angle,real degrees returns real
        return angle + ( degrees * bj_DEGTORAD )
    endfunction
    function ReplaceString takes string forString,string toReplace,integer start,string replaceWith returns string
        local integer i= 0
        local integer length= StringLength(toReplace)
        local string result= forString
        loop
            exitwhen i > StringLength(result)
            if SubString(result, i, i + length) == toReplace then
                set result=SubString(result, 0, i) + replaceWith + SubString(result, i + length, StringLength(result))
            endif
            set i=i + 1
        endloop
        return result
    endfunction
    function getTimeElapsed takes nothing returns real
        return TimerGetElapsed(gameTimer)
    endfunction
    function getElapsedTime takes nothing returns real
        return TimerGetElapsed(gameTimer)
    endfunction
    function ln takes real r returns real
        local real sum= 0.0
        local real sign= 1.0
        if r < 0.0 then
            call BJDebugMsg("ln with r less than 0")
            return 0.
        endif
        if r < 1.0 then
            set r=1.0 / r
            set sign=- 1.0
        endif
        loop
            exitwhen r < BaseFunction__E
            set r=r * BaseFunction__E_INV
            set sum=sum + 1.0
        endloop
        loop
            exitwhen r < BaseFunction__LN_FACTOR
            set r=r * BaseFunction__LN_FACTOR_INV
            set sum=sum + 0.25
        endloop

        return sign * ( sum + 0.125 * ( r - 1.0 ) * ( 1 + 9.0 / ( 2.0 + r ) + 4.5 / ( 0.5 + r ) + 1.0 / r ) )
    endfunction

    function filterOnlyEnemy takes nothing returns boolean
        return GetPlayerId(GetOwningPlayer(GetFilterUnit())) == 12 or GetPlayerId(GetOwningPlayer(GetFilterUnit())) == 13 and GetFilterUnit() != udg_TempUnit
    endfunction
    function PackInteger takes integer n0,integer n1,integer n2,integer n3,integer n4,integer n5 returns integer
        return n0 + 12 * n1 + 144 * n2 + 144 * 12 * n3 + 144 * 144 * n4 + 144 * 144 * 12 * n5
    endfunction

    function RetrievePackedInteger takes integer packed,integer n returns integer
        local integer count=0
        local integer mod
        loop
            set mod=ModuloInteger(packed, 12)
            if count == n then
                return mod
            endif
            set packed=( packed - mod ) / 12
            set count=count + 1
        endloop
        return 0
    endfunction

    function BaseFunction__ExtendedStun takes nothing returns nothing
        local unit dummy= CreateUnitAtLoc(Player(0), 'H004', GetUnitLoc(BaseFunction__specific3), 0.)
        local real duration= specific
        local unit target= BaseFunction__specific3
        local integer i= 0
        local unit u3
        if duration < 10 then
            call UnitAddAbility(dummy, 'A015')
            call SetUnitAbilityLevel(dummy, 'A015', R2I(duration * 10))
            call IssueInstantTargetOrderById(dummy, 'A015', target, target)
            call UnitApplyTimedLife(dummy, 'BLTF', 3.)
            set dummy=null
            set target=null
            return
        else
            loop
                if duration < 10 then
                    call UnitAddAbility(dummy, 'A015')
                    call SetUnitAbilityLevel(dummy, 'A015', R2I(duration * 10))
                    call IssueInstantTargetOrderById(dummy, 'A015', target, target)
                    call UnitApplyTimedLife(dummy, 'BLTF', 3.)
                    set dummy=null
                    set target=null
                    return
                else
                    call UnitAddAbility(dummy, 'A015')
                    call SetUnitAbilityLevel(dummy, 'A015', 50)
                    call IssueInstantTargetOrderById(dummy, 'A015', target, target)
                    call UnitApplyTimedLife(dummy, 'BLTF', 3.)
                    set dummy=null
                    set target=null
                    set duration=duration - 5
                    return
                endif
            endloop
        endif
        return
                
            
    endfunction

    function StunTarget takes player forPlayer,unit target,real duration returns boolean
        local unit u= CreateUnitAtLoc(forPlayer, 'H004', GetUnitLoc(target), 0.)
        if duration < 10 then
            call UnitAddAbility(u, 'A015')
            call SetUnitAbilityLevel(u, 'A015', R2I(duration * 10))
            call IssueInstantTargetOrderById(u, 'A015', target, target)
            call UnitApplyTimedLife(u, 'BLTF', 3.)
            set u=null
            return false
        else
            call UnitAddAbility(u, 'A015')
            call SetUnitAbilityLevel(u, 'A015', 100)
            call IssueInstantTargetOrderById(u, 'A015', target, target)
            call UnitApplyTimedLife(u, 'BLTF', 3.)
            set specific=duration - 10
            set specific2=u
            set BaseFunction__specific3=target
            set u=null
            call ExecuteFunc("ExtendedStun")
            return false
        endif
        return false
    endfunction
    function print takes string inputText returns nothing
        call DisplayTimedTextToForce(GetPlayersAll(), StringLength(inputText) * 3, inputText)
    endfunction


    function GetUnitArmor takes unit u returns real
        local real tempReal= GetUnitState(u, UNIT_STATE_LIFE)
        local real damage
        local real armor
        local unit u2= CreateUnit(Player(15), 'Hpea', 0, 0, 0)
        set DAMAGE_EVENT_REQUEST_TYPE=7
        call UnitDamageTarget(u2, u, 10., true, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_NORMAL, WEAPON_TYPE_WHOKNOWS)
        set damage=tempReal - GetUnitState(u, UNIT_STATE_LIFE)
        if damage > 10 then
            set armor=( ( - 1.00 * ( 10. - damage ) ) / ( damage * 0.06 ) )
        else
            set armor=( ( 10. - damage ) / ( damage * 0.06 ) )
        endif
        return armor
    endfunction

    function B2I takes boolean b returns integer
        if b then
            return 1
        else
            return 0
        endif
    endfunction
    function If takes integer i,boolean b returns integer
        if b then
            return i
        else
            return 0
        endif
    endfunction
    function If2 takes integer i,integer i2,boolean b returns integer
        if b then
            return i
        else
            return i2
        endif
    endfunction

    function I2B takes integer i returns boolean
        if i == 0 then
            return false
        else
            return true
        endif
    endfunction
    
    
    function BaseFunction__onInit takes nothing returns nothing
        set gameTimer=CreateTimer()
        call TimerStart(gameTimer, 2147483646, false, null)
        set viableTargetFilter1=Filter(function BaseFunction__vt1)
        set viableTargetFilter2=Filter(function BaseFunction__vt2)
        set viableTargetFilter3=Filter(function BaseFunction__vt3)
        set viableTargetFilter4=Filter(function BaseFunction__vt4)
        set viableTargetFilter5=Filter(function BaseFunction__vt5)
        set viableTargetFilter6=Filter(function BaseFunction__vt6)
        set viableTargetFilter7=Filter(function BaseFunction__vt7)
        set viableTargetFilter8=Filter(function BaseFunction__vt8)
        set viableTargetFilter9=Filter(function BaseFunction__vt9)
        set viableTargetFilter10=Filter(function BaseFunction__vt10)
        set BaseFunction__attachtable=sc__Table_create()
        set BaseFunction__timers=sc__Table_create()
    endfunction

//library BaseFunction ends
//library BinaryHeap:

//library BinaryHeap ends
//library BoundSentinel:
//*************************************************
//* BoundSentinel
//* -------------
//*  Don't leave your units unsupervised, naughty
//* them may try to get out of the map bounds and
//* crash your game.
//*
//*  To implement, just get a vJass compiler and
//* copy this library/trigger to your map.
//*
//*************************************************

//==================================================

   //=========================================================================================

   //=======================================================================
   function BoundSentinel___dis takes nothing returns boolean
    local unit u=GetTriggerUnit()
    local real x=GetUnitX(u)
    local real y=GetUnitY(u)

       if ( x > BoundSentinel___maxx ) then
           set x=BoundSentinel___maxx
       elseif ( x < BoundSentinel___minx ) then
           set x=BoundSentinel___minx
       endif
       if ( y > BoundSentinel___maxy ) then
           set y=BoundSentinel___maxy
       elseif ( y < BoundSentinel___miny ) then
           set y=BoundSentinel___miny
       endif
       call SetUnitX(u, x)
       call SetUnitY(u, y)
    set u=null
    return false
   endfunction

   function BoundSentinel___init takes nothing returns nothing
    local trigger t= CreateTrigger()
    local region r= CreateRegion()
    local rect map
    local rect rc

       if BoundSentinel___ALLOW_OUTSIDE_PLAYABLE_MAP_AREA then
          set map=GetWorldBounds()
       else
          set map=bj_mapInitialPlayableArea
       endif

       set BoundSentinel___minx=GetRectMinX(map)
       set BoundSentinel___miny=GetRectMinY(map)
       set BoundSentinel___maxx=GetRectMaxX(map)
       set BoundSentinel___maxy=GetRectMaxY(map)
       set rc=Rect(BoundSentinel___minx, BoundSentinel___miny, BoundSentinel___maxx, BoundSentinel___maxy)
       call RegionAddRect(r, rc)
       call RemoveRect(rc)
       if BoundSentinel___ALLOW_OUTSIDE_PLAYABLE_MAP_AREA then
          call RemoveRect(map)
       endif

       call TriggerRegisterLeaveRegion(t, r, null)
       call TriggerAddCondition(t, Condition(function BoundSentinel___dis))

    set rc=null
    set map=null
   endfunction

//library BoundSentinel ends
//library BountySystem:
    
    
    function BountySystem___Conditions takes nothing returns boolean
        local unit dead= GetDyingUnit()
        local integer deadID= GetUnitTypeId(dead)
        local unit ufilt= GetFilterUnit()
        local player ownplay= GetOwningPlayer(ufilt)
        local integer pnumb= GetPlayerId(ownplay)
        local integer left
        local integer max
        local integer array i3
        if ufilt == udg_PlayerUnit[GetConvertedPlayerId(ownplay)] then
            if LoadInteger(BountySystem___BountyHash, pnumb + 100, deadID) >= 1 then
                set deadID=LoadInteger(BountySystem___BountyHash, pnumb + 100, deadID)
            endif
        else
            return false
        endif
        if LoadBoolean(BountySystem___BountyHash, pnumb + 20, deadID) == true then
            set max=LoadInteger(BountySystem___BountyHash, pnumb + 40, deadID)
            set left=LoadInteger(BountySystem___BountyHash, pnumb, deadID)
            if left + 1 >= max then
                call AddHeroXP(udg_PlayerUnit[GetConvertedPlayerId(ownplay)], LoadInteger(BountySystem___BountyHash, pnumb + 80, deadID), true)
                call SetPlayerState(ownplay, PLAYER_STATE_RESOURCE_GOLD, GetPlayerState(ownplay, PLAYER_STATE_RESOURCE_GOLD) + LoadInteger(BountySystem___BountyHash, pnumb + 60, deadID))
                call SaveInteger(BountySystem___BountyHash, pnumb, deadID, 0)
                call SaveBoolean(BountySystem___BountyHash, pnumb + 20, deadID, false)
                if GetLocalPlayer() == Player(pnumb) then
                    call print(LoadStr(BountySystem___BountyHash, pnumb + 120, deadID) + " Bounty Completed")
                endif
                call TriggerEvaluate(BountySystem___onComp)
            else
                call SaveInteger(BountySystem___BountyHash, pnumb, deadID, left + 1)
                if GetLocalPlayer() == Player(pnumb) then
                    call print(LoadStr(BountySystem___BountyHash, pnumb + 120, deadID) + ": " + I2S(left + 1) + " / " + I2S(max))
                endif
            endif
        else
            set dead=null
            set ufilt=null
            set ownplay=null
            return false
        endif
        return false
                
    endfunction
    function BountySystem___onUnitDeath takes nothing returns nothing
        local unit u= GetDyingUnit()
        local group g= CreateGroup()
        local location l= GetUnitLoc(u)
        call GroupEnumUnitsInRangeOfLoc(g, l, BountySystem___radius, Condition(function BountySystem___Conditions))
        call RemoveLocation(l)
        call DestroyGroup(g)
        set u=null
        set l=null
            
    endfunction
    function AddBounty takes integer unit1,integer unit2,integer unit3,integer unit4,integer unit5,integer unit6,integer count,integer playerFor,integer gold,integer exp,string description returns nothing
        if LoadInteger(BountySystem___BountyHash, playerFor, unit1) <= 0 or LoadInteger(BountySystem___BountyHash, playerFor, unit1) >= 15 then
            call SaveInteger(BountySystem___BountyHash, playerFor, unit1, 0)
        endif
        if GetLocalPlayer() == Player(playerFor) then
            call print("Started Bounty " + description)
        endif
//        This the amount of creeps still left in the bounty. I do not set it so the number killed does not wipe after using the item 
        call SaveBoolean(BountySystem___BountyHash, playerFor + 20, unit1, true)
//        Shows that the bounty for that player is still valid
        call SaveInteger(BountySystem___BountyHash, playerFor + 40, unit1, count)
//        Sets the maximum count of the creep to kill for the bounty
        call SaveInteger(BountySystem___BountyHash, playerFor + 60, unit1, gold)
        call SaveInteger(BountySystem___BountyHash, playerFor + 80, unit1, exp)
        call SaveStr(BountySystem___BountyHash, playerFor + 120, unit1, description)
        if unit2 <= 10 then
            return
        endif
        call SaveBoolean(BountySystem___BountyHash, playerFor + 20, unit2, true)
        call SaveInteger(BountySystem___BountyHash, playerFor + 100, unit2, unit1)
        if unit3 <= 10 then
            return
        endif
        call SaveBoolean(BountySystem___BountyHash, playerFor + 20, unit3, true)
        call SaveInteger(BountySystem___BountyHash, playerFor + 100, unit3, unit1)
        if unit4 <= 10 then
            return
        endif
        call SaveBoolean(BountySystem___BountyHash, playerFor + 20, unit4, true)
        call SaveInteger(BountySystem___BountyHash, playerFor + 100, unit4, unit1)
        if unit5 <= 10 then
            return
        endif
        call SaveBoolean(BountySystem___BountyHash, playerFor + 20, unit5, true)
        call SaveInteger(BountySystem___BountyHash, playerFor + 100, unit5, unit1)
        if unit6 <= 10 then
            return
        endif
        call SaveBoolean(BountySystem___BountyHash, playerFor + 20, unit6, true)
        call SaveInteger(BountySystem___BountyHash, playerFor + 100, unit6, unit1)
    endfunction
    
        function s__BountySystem_setOnBounty takes trigger t returns nothing
            set BountySystem___onComp=t
        endfunction
    
    function BountySystem___init takes nothing returns nothing
        local trigger t= CreateTrigger()
        call TriggerRegisterAnyUnitEventBJ(t, EVENT_PLAYER_UNIT_DEATH)
        call TriggerAddAction(t, function BountySystem___onUnitDeath)
    endfunction

//library BountySystem ends
//library Buffer:
    //LoadToBuffer
    //  loads data from code into buffer (data not created)
    //
    //LoadFromBuffer
    //  loads data from buffer and creates it (data created)
    //
        function s__Buffer_reset takes nothing returns nothing
            set Buffer__s=0
            set Buffer__p=0
        endfunction
        function s__Buffer_write takes integer val returns integer
            set Buffer__s=Buffer__s + 1
            set Buffer__v[Buffer__s]=val
            return Buffer__s
        endfunction
function s__Buffer__staticgetindex takes integer l__index returns integer
            return Buffer__v[l__index]
        endfunction
        function s__Buffer_read takes nothing returns integer
            set Buffer__p=Buffer__p + 1
            return Buffer__v[Buffer__p]
        endfunction

//library Buffer ends
//library CTL:
    function CTL___E takes nothing returns nothing
        local integer i=CTL___ns[0]
        set CTL___ns[0]=0
        loop
            exitwhen 0 == i
            if ( 0 == CTL___p[i] ) then
                if ( 0 == CTL___n[i] ) then
                    call TriggerRemoveCondition(CTL___t, CTL___ct[CTL___th[i]])
                    set CTL___ct[CTL___th[i]]=null
                    set CTL___tc=CTL___tc - 1
                    set CTL___rf[CTL___th[i]]=0
                else
                    set CTL___rf[CTL___th[i]]=CTL___n[i]
                    set CTL___p[CTL___n[i]]=0
                endif
            else
                set CTL___p[CTL___n[i]]=CTL___p[i]
                set CTL___n[CTL___p[i]]=CTL___n[i]
            endif
            set CTL___n[i]=CTL___n[0]
            set CTL___n[0]=i
            set i=CTL___ns[i]
        endloop
        loop
            exitwhen 0 == CTL___i32cr
            set CTL___i32cr=CTL___i32cr - 1
            set i=CTL___i32r[CTL___i32cr]
            if ( not CTL___e32[i] ) then
                call TriggerRemoveCondition(CTL___t, CTL___ct[i])
                set CTL___ct[i]=null
                
                if ( CTL___id32[i] ) then
                    set CTL___tgr[i]=CTL___tgr[0]
                    set CTL___tgr[0]=i
                    set CTL___id32[i]=false
                endif
                
                set CTL___ir32[i]=false
            endif
        endloop
        if ( 0 == CTL___tc ) then
            call PauseTimer(CTL___m)
        else
            call TriggerEvaluate(CTL___t)
        endif
    endfunction
    function CTL___CT takes integer r returns integer
        local integer i
        local integer f
        if ( 0 == CTL___n[0] ) then
            set i=CTL___ic + 1
            set CTL___ic=i
        else
            set i=CTL___n[0]
            set CTL___n[0]=CTL___n[i]
        endif
        set CTL___th[i]=r
        set CTL___ns[i]=- 1
        set f=CTL___rf[r]
        if ( 0 == f ) then
            set CTL___n[i]=0
            set CTL___p[i]=0
            set CTL___rf[r]=i
            set CTL___ct[r]=TriggerAddCondition(CTL___t, CTL___rc[r])
            //set ct[r] = null
            if ( 0 == CTL___tc ) then
                call TimerStart(CTL___m, .031250000, true, function CTL___E)
            endif
            set CTL___tc=CTL___tc + 1
        else
            set CTL___n[i]=f
            set CTL___p[i]=0
            set CTL___p[f]=i
            set CTL___rf[r]=i
        endif
        return i
    endfunction
function CTL___DT takes integer l__CTL___t returns nothing
            set CTL___ns[l__CTL___t]=CTL___ns[0]
            set CTL___ns[0]=l__CTL___t
    endfunction
    function CTL___A takes code c returns integer
        local integer i= CTL___tgr[0]
        if ( 0 == i ) then
            set i=CTL___tgc + 1
            set CTL___tgc=i
        else
            set CTL___tgr[0]=CTL___tgr[i]
        endif
        set CTL___rc[i]=Condition(c)
        return i
    endfunction
    function CTL___A32 takes integer i returns nothing
        if ( not ( CTL___e32[i] or CTL___id32[i] ) ) then
            if ( CTL___ir32[i] ) then
                set CTL___ir32[i]=false
            else
                set CTL___ct[i]=TriggerAddCondition(CTL___t, CTL___rc[i])
            endif
        
            if ( 0 == CTL___tc ) then
                call TimerStart(CTL___m, .031250000, true, function CTL___E)
            endif
            set CTL___tc=CTL___tc + 1
            set CTL___e32[i]=true
        endif
    endfunction
    function CTL___SR32 takes integer i returns nothing
        if ( CTL___e32[i] ) then
            if ( not ( CTL___ir32[i] or CTL___id32[i] ) ) then
                set CTL___i32r[CTL___i32cr]=i
                set CTL___i32cr=CTL___i32cr + 1
                set CTL___ir32[i]=true
            endif
            set CTL___e32[i]=false
            set CTL___tc=CTL___tc - 1
        endif
    endfunction
    function CTL___DT32 takes integer i returns nothing
        if ( not CTL___id32[i] ) then
            if ( not CTL___ir32[i] ) then
                set CTL___ir32[i]=true
                set CTL___tc=CTL___tc - 1
                set CTL___i32r[CTL___i32cr]=i
                set CTL___i32cr=CTL___i32cr + 1
                set CTL___e32[i]=false
            endif
            set CTL___id32[i]=true
        endif
    endfunction
    
        function s__TimerGroup32_create takes code c returns integer
            return CTL___A(c)
        endfunction
        function s__TimerGroup32_destroy takes integer this returns nothing
            call CTL___DT32(this)
        endfunction
        function s__TimerGroup32_start takes integer this returns nothing
            call CTL___A32(this)
        endfunction
        function s__TimerGroup32_stop takes integer this returns nothing
            call CTL___SR32(this)
        endfunction

//library CTL ends
//library ColorCodeString:
    function ColorCodeString takes string s,string numColor,string lowerColor,string upperColor,string specColor,integer start returns string
        local string ns= ""
        local string c
        local integer m= StringLength(s)
        local integer i= start
        local boolean l
        loop
            exitwhen m == i
            
            set c=SubString(s, i, i + 1)
            
            if ( c != " " ) then
                set l=StringCase(c, false) == c
                
                //special or number
                if ( c == StringCase(c, true) and l ) then
                    //number
                    if ( "0" == c or 0 != S2I(c) ) then
                        set ns=ns + "|cff" + numColor + c
                    //special
                    else
                        set ns=ns + "|cff" + specColor + c
                    endif
                //lowercase
                elseif ( l ) then
                    set ns=ns + "|cff" + lowerColor + c
                //uppercase
                else
                    set ns=ns + "|cff" + upperColor + c
                endif
            else
                set ns=ns + " "
            endif
            
            set i=i + 1
        endloop
        return ns
    endfunction

//library ColorCodeString ends
//library CompressInt:
//performs lossy compression on integers
//compressed number = number^(2/3)

//decomperssed number = roundDown(number^1.5+.5)

function CompressInt takes integer n returns integer
    return R2I(Pow(n, 2 / 3.))
endfunction
function DecompressInt takes integer n returns integer
    return R2I(Pow(n, 1.5) + .5)
endfunction


//library CompressInt ends
//library CustomDrop:
    
    function CustomDrop___OnDeath takes nothing returns nothing
        local unit u= GetDyingUnit()
        local integer unitId= GetUnitTypeId(u)
        local integer count= LoadInteger(CustomDrop___Hash_t, unitId, 0)
        local real random
        local integer i
        local item drop
        local integer dummy= 'I01Q'
        local player p= GetOwningPlayer(GetKillingUnit())
        local force f
        loop // loop on all dropable item for unitID
            exitwhen count == 0
            set i=0
            set f=LoadForceHandle(CustomDrop___Hash_t, unitId, count * 4 + 3)
            if f == null or IsPlayerInForce(p, f) then
                loop // player loop
                    exitwhen i == 11 or ( i == 1 and not LoadBoolean(CustomDrop___Hash_t, unitId, count * 4 + 4) )
                    set dummy='I01Q'
                    if ( GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING and GetPlayerController(Player(i)) == MAP_CONTROL_USER ) or not LoadBoolean(CustomDrop___Hash_t, unitId, count * 4 + 4) then
                        set random=GetRandomReal(0, 100)
                        if random < LoadReal(CustomDrop___Hash_t, unitId, count * 4 + 2) then
                            if GetLocalPlayer() == Player(i) or not LoadBoolean(CustomDrop___Hash_t, unitId, count * 4 + 4) then
                                set dummy=LoadInteger(CustomDrop___Hash_t, unitId, count * 4 + 1)
                            endif
                            set drop=CreateItem(dummy, GetUnitX(u), GetUnitY(u))
                            if LoadBoolean(CustomDrop___Hash_t, unitId, count * 4 + 4) then
                                call SetItemUserData(drop, dummy)
                            endif
                        endif
                    endif
                    set i=i + 1
                endloop
            endif
            set count=count - 1
        endloop
        set f=null
        set p=null
        set u=null
        set drop=null
    endfunction
    
    function CustomDrop___RegisterDrop takes integer unitId,integer itemId,real chanceToDrop,boolean perPlayer returns nothing
        local integer n= LoadInteger(CustomDrop___Hash_t, unitId, 0)
        
        set n=n + 1
        call SaveInteger(CustomDrop___Hash_t, unitId, 0, n)
        call SaveInteger(CustomDrop___Hash_t, unitId, n * 4 + 1, itemId)
        call SaveReal(CustomDrop___Hash_t, unitId, n * 4 + 2, chanceToDrop)
        call SaveBoolean(CustomDrop___Hash_t, unitId, n * 4 + 4, perPlayer)
    endfunction
    function CustomDrop___RegisterDropForce takes force add,integer unitId,integer itemId,real chance,boolean perPlayer returns nothing
        local integer n
        local force f
        set n=LoadInteger(CustomDrop___Hash_t, unitId, 0) + 1
        call SaveInteger(CustomDrop___Hash_t, unitId, 0, n)
        call SaveInteger(CustomDrop___Hash_t, unitId, n * 4 + 1, itemId)
        call SaveReal(CustomDrop___Hash_t, unitId, n * 4 + 2, chance)
        call SaveBoolean(CustomDrop___Hash_t, unitId, n * 4 + 4, perPlayer)
        set f=LoadForceHandle(CustomDrop___Hash_t, unitId, n * 4 + 3)
        if f == null then
            call SaveForceHandle(CustomDrop___Hash_t, unitId, n * 4 + 3, DuplicateForce(add))
        else
            call AddForceToForce(add , f)
        endif
        set f=null
        set add=null
    endfunction
    function CustomDrop___RemoveDropForce takes force rem,integer unitId,integer itemId,real chance returns nothing
        local integer count= LoadInteger(CustomDrop___Hash_t, unitId, 0)
        local integer max= 0
        local force f
        loop
            exitwhen count <= 0
            if LoadInteger(CustomDrop___Hash_t, unitId, count * 4 + 1) == itemId and LoadReal(CustomDrop___Hash_t, unitId, count * 4 + 2) == chance then
                call print("force found")
                set f=LoadForceHandle(CustomDrop___Hash_t, unitId, count * 4 + 3)
                call ForceRemoveForce(f , rem)
                if FirstOfForce(f) == null then
                    call print("f")
                    call SaveInteger(CustomDrop___Hash_t, unitId, count * 4 + 1, LoadInteger(CustomDrop___Hash_t, unitId, max))
                    call SaveReal(CustomDrop___Hash_t, unitId, count * 4 + 2, LoadReal(CustomDrop___Hash_t, unitId, max + 2))
                    call SaveForceHandle(CustomDrop___Hash_t, unitId, count * 4 + 3, LoadForceHandle(CustomDrop___Hash_t, unitId, max + 3))
                    call SaveBoolean(CustomDrop___Hash_t, unitId, count * 4 + 4, LoadBoolean(CustomDrop___Hash_t, unitId, max * 4 + 4))
                    call SaveInteger(CustomDrop___Hash_t, unitId, 0, LoadInteger(CustomDrop___Hash_t, unitId, 0) - 1)
                else
                    call print("no")
                endif
                set f=null
                return
            endif
            set count=count - 1
        endloop
        call print("nope")
    endfunction
    function CustomDrop___onItemPickup takes nothing returns nothing
        local item it= GetManipulatedItem()
        local unit u= GetTriggerUnit()
        local boolean b
        local integer i= 0
        local integer i2= 0
        local item dummy
//        set rawcode = GetItemUserData(it)
//        call RemoveItem(it)
//        set it = CreateItem(rawcode, GetUnitX(u), GetUnitY(u))
 //       call SetItemUserData(it,rawcode)
        if GetItemTypeId(it) == GetItemUserData(it) or GetItemTypeId(it) == 'I01Q' then
            set dummy=CreateItem(GetItemUserData(it), GetItemX(it), GetItemY(it))
            call RemoveItem(it)
            call UnitAddItem(u, dummy)
            set it=null
            set u=null
            return
        endif
  
    endfunction
        function s__CDS_StartSpiderVenom takes nothing returns boolean
            call CustomDrop___RegisterDropForce(applicableForce , 'n000' , 'I02G' , 100 , false)
            call CustomDrop___RegisterDropForce(applicableForce , 'n001' , 'I02G' , 100 , false)
            call CustomDrop___RegisterDropForce(applicableForce , 'n002' , 'I02G' , 100 , false)
            call CustomDrop___RegisterDropForce(applicableForce , 'n00H' , 'I02G' , 100 , false)
            call CustomDrop___RegisterDropForce(applicableForce , 'n00G' , 'I02G' , 100 , false)
            return false
        endfunction
        function s__CDS_EndSpiderVenom takes nothing returns boolean
            call print("remforce")
            call CustomDrop___RemoveDropForce(applicableForce , 'n000' , 'I02G' , 100)
            call CustomDrop___RemoveDropForce(applicableForce , 'n001' , 'I02G' , 100)
            call CustomDrop___RemoveDropForce(applicableForce , 'n002' , 'I02G' , 100)
            call CustomDrop___RemoveDropForce(applicableForce , 'n00H' , 'I02G' , 100)
            call CustomDrop___RemoveDropForce(applicableForce , 'n00G' , 'I02G' , 100)
            return false
        endfunction
 //    private function RegisterDrop takes integer unitId , integer itemId, real chanceToDrop returns nothing //
    function CustomDrop___init takes nothing returns nothing
        local trigger trig= CreateTrigger()
        local trigger trig2= CreateTrigger()
        
        call TriggerRegisterAnyUnitEventBJ(trig, EVENT_PLAYER_UNIT_DEATH)
        call TriggerRegisterAnyUnitEventBJ(trig2, EVENT_PLAYER_UNIT_PICKUP_ITEM)
        call TriggerAddAction(trig, function CustomDrop___OnDeath)
        call TriggerAddAction(trig2, function CustomDrop___onItemPickup)
        call CustomDrop___RegisterDrop('n000' , 'I00U' , 10 , true)
        call CustomDrop___RegisterDrop('n001' , 'I00U' , 10 , true)
        call CustomDrop___RegisterDrop('n002' , 'I00U' , 10 , true)
        call CustomDrop___RegisterDrop('n00H' , 'I00U' , 10 , true)
        call CustomDrop___RegisterDrop('n00G' , 'I00U' , 10 , true)
        call CustomDrop___RegisterDrop('n00B' , 'I01M' , 10 , true)
        call CustomDrop___RegisterDrop('n00C' , 'I01M' , 10 , true)
        call CustomDrop___RegisterDrop('n00D' , 'I01M' , 10 , true)
        call CustomDrop___RegisterDrop('n003' , 'I01M' , 10 , true)
        call CustomDrop___RegisterDrop('n005' , 'I01N' , 10 , true)
        call CustomDrop___RegisterDrop('n009' , 'I01N' , 10 , true)
        call CustomDrop___RegisterDrop('n004' , 'I01N' , 10 , true)
        call CustomDrop___RegisterDrop('n007' , 'I01O' , 25 , true)
        
    endfunction
    

//library CustomDrop ends
//library CustomInventoryTraitHandler:
        
        
        function s__Trait_create takes real aV,real bV,real cV,real dV,integer typeOfTraitx returns integer
            local integer this
            set this=s__Trait__allocate()
            set s__Trait_a[this]=aV
            set s__Trait_b[this]=bV
            set s__Trait_c[this]=cV
            set s__Trait_d[this]=dV
            
            set s__Trait_typeOfTrait[this]=typeOfTraitx
            return this
        endfunction
        
        function s__Trait_toString takes integer this returns string
            return sc__ICI_getTraitDescription("|cffffcc00" , this)
        endfunction
        function s__CustomInventoryTraitHandler__SpecificTraitGenerator_createx takes nothing returns integer
            local integer this= s__CustomInventoryTraitHandler__SpecificTraitGenerator__allocate()
            return this
        endfunction
        
        function s__CustomInventoryTraitHandler__SpecificTraitGenerator_setV takes integer this,integer typeOT,real aminx,real amaxx,real aweightx returns integer
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_typeOfTrait[this]=typeOT
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_amin[this]=aminx
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_amax[this]=amaxx
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_aweight[this]=aweightx
            return this
        endfunction
        function s__CustomInventoryTraitHandler__SpecificTraitGenerator_setAll takes integer this,integer typeOfTraitx,real aminx,real amaxx,real aweightx,real bminx,real bmaxx,real bweightx,real cminx,real cmaxx,real cweightx,real dminx,real dmaxx,real dweightx returns nothing
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_typeOfTrait[this]=typeOfTraitx
            
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_amin[this]=aminx
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_amax[this]=amaxx
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_aweight[this]=aweightx
            
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_bmin[this]=bminx
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_bmax[this]=bmaxx
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_bweight[this]=bweightx
            
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_cmin[this]=cminx
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_cmax[this]=cmaxx
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_cweight[this]=cweightx
            
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_dmin[this]=dminx
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_dmax[this]=dmaxx
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_dweight[this]=dweightx
            
        endfunction
        function s__CustomInventoryTraitHandler__SpecificTraitGenerator_create takes integer typeOfTraitx,real aminx,real amaxx,real aweightx,real bminx,real bmaxx,real bweightx,real cminx,real cmaxx,real cweightx,real dminx,real dmaxx,real dweightx returns integer
            local integer this= s__CustomInventoryTraitHandler__SpecificTraitGenerator__allocate()
            
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_typeOfTrait[this]=typeOfTraitx
            
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_amin[this]=aminx
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_amax[this]=amaxx
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_aweight[this]=aweightx
            
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_bmin[this]=bminx
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_bmax[this]=bmaxx
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_bweight[this]=bweightx
            
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_cmin[this]=cminx
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_cmax[this]=cmaxx
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_cweight[this]=cweightx
            
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_dmin[this]=dminx
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_dmax[this]=dmaxx
            set s__CustomInventoryTraitHandler__SpecificTraitGenerator_dweight[this]=dweightx
            
            return this
        endfunction
        
        function s__CustomInventoryTraitHandler__SpecificTraitGenerator_d takes integer this,real min,real max,real weight returns real
        
            local real temp1= 0
            local real temp2= 0
            local real temp3= 0
            
            local real debugv
            if min == 0 and max == 0 then
                return 0.
            endif
            if weight != 0 then
                if weight < 0 then
                    call BJDebugMsg("ERROR INVALID WEIGHT IN TRAIT SYSTEM")
                    return 0. / 0.
                else
                    set temp1=GetRandomReal(min, max)
                    set temp3=GetRandomReal(min, temp1)
                    set debugv=temp1 - ( ( temp1 - temp3 ) * ( ( 100 - ( 100 / ( Pow(2, ( weight / 3 )) ) ) ) / 100 ) )
                    return debugv
                endif
            endif
            return GetRandomReal(min, max)
        endfunction
        function s__CustomInventoryTraitHandler__SpecificTraitGenerator_generate takes integer this returns integer
            local real av= 0
            local real bv= 0
            local real cv= 0
            local real dv= 0
            
//textmacro instance: GENERATE_RUN("a")
            if s__CustomInventoryTraitHandler__SpecificTraitGenerator_amin[this] != 0 and s__CustomInventoryTraitHandler__SpecificTraitGenerator_amax[this] != 0 then
                set av=s__CustomInventoryTraitHandler__SpecificTraitGenerator_d(this,s__CustomInventoryTraitHandler__SpecificTraitGenerator_amin[this] , s__CustomInventoryTraitHandler__SpecificTraitGenerator_amax[this] , s__CustomInventoryTraitHandler__SpecificTraitGenerator_aweight[this])
            else
                set av=0
            endif
//end of: GENERATE_RUN("a")
//textmacro instance: GENERATE_RUN("b")
            if s__CustomInventoryTraitHandler__SpecificTraitGenerator_bmin[this] != 0 and s__CustomInventoryTraitHandler__SpecificTraitGenerator_bmax[this] != 0 then
                set bv=s__CustomInventoryTraitHandler__SpecificTraitGenerator_d(this,s__CustomInventoryTraitHandler__SpecificTraitGenerator_bmin[this] , s__CustomInventoryTraitHandler__SpecificTraitGenerator_bmax[this] , s__CustomInventoryTraitHandler__SpecificTraitGenerator_bweight[this])
            else
                set bv=0
            endif
//end of: GENERATE_RUN("b")
//textmacro instance: GENERATE_RUN("c")
            if s__CustomInventoryTraitHandler__SpecificTraitGenerator_cmin[this] != 0 and s__CustomInventoryTraitHandler__SpecificTraitGenerator_cmax[this] != 0 then
                set cv=s__CustomInventoryTraitHandler__SpecificTraitGenerator_d(this,s__CustomInventoryTraitHandler__SpecificTraitGenerator_cmin[this] , s__CustomInventoryTraitHandler__SpecificTraitGenerator_cmax[this] , s__CustomInventoryTraitHandler__SpecificTraitGenerator_cweight[this])
            else
                set cv=0
            endif
//end of: GENERATE_RUN("c")
//textmacro instance: GENERATE_RUN("d")
            if s__CustomInventoryTraitHandler__SpecificTraitGenerator_dmin[this] != 0 and s__CustomInventoryTraitHandler__SpecificTraitGenerator_dmax[this] != 0 then
                set dv=s__CustomInventoryTraitHandler__SpecificTraitGenerator_d(this,s__CustomInventoryTraitHandler__SpecificTraitGenerator_dmin[this] , s__CustomInventoryTraitHandler__SpecificTraitGenerator_dmax[this] , s__CustomInventoryTraitHandler__SpecificTraitGenerator_dweight[this])
            else
                set dv=0
            endif
//end of: GENERATE_RUN("d")
            
            return s__Trait_create(av , bv , cv , dv , s__CustomInventoryTraitHandler__SpecificTraitGenerator_typeOfTrait[this])
        endfunction
        
        function s__CustomInventoryTraitHandler__TraitGroup_create takes nothing returns integer
            local integer this= s__CustomInventoryTraitHandler__TraitGroup__allocate()
            set s__CustomInventoryTraitHandler__TraitGroup_holder[this]=sc__TableArray__staticgetindex(3)
            set s__CustomInventoryTraitHandler__TraitGroup_maxHolder[this]=0
            set s__CustomInventoryTraitHandler__TraitGroup_combinedWeights[this]=0
            return this
        endfunction
        
        function s__CustomInventoryTraitHandler__TraitGroup_add takes integer this,integer typeOfTraitx,real aminx,real amaxx,real aweightx,real bminx,real bmaxx,real bweightx,real cminx,real cmaxx,real cweightx,real dminx,real dmaxx,real dweightx,integer traitWeight returns nothing
            
            local integer t= s__CustomInventoryTraitHandler__SpecificTraitGenerator_create(typeOfTraitx , aminx , amaxx , aweightx , bminx , bmaxx , bweightx , cminx , cmaxx , cweightx , dminx , dmaxx , dweightx)
            
            call SaveInteger(Table___ht, (sc__TableArray__getindex(s__CustomInventoryTraitHandler__TraitGroup_holder[this],1)), (s__CustomInventoryTraitHandler__TraitGroup_maxHolder[this]), ( s__CustomInventoryTraitHandler__TraitGroup_combinedWeights[this])) // INLINED!!
            set s__CustomInventoryTraitHandler__TraitGroup_combinedWeights[this]=s__CustomInventoryTraitHandler__TraitGroup_combinedWeights[this] + traitWeight
            call SaveInteger(Table___ht, (sc__TableArray__getindex(s__CustomInventoryTraitHandler__TraitGroup_holder[this],0)), (s__CustomInventoryTraitHandler__TraitGroup_maxHolder[this]), ( (t))) // INLINED!!
            set s__CustomInventoryTraitHandler__TraitGroup_maxHolder[this]=s__CustomInventoryTraitHandler__TraitGroup_maxHolder[this] + 1
        endfunction
        
        function s__CustomInventoryTraitHandler__TraitGroup_addA takes integer this,integer typeOfTraitx,real aminx,real amaxx,real aweightx,integer traitWeight returns nothing
            
            local integer t= s__CustomInventoryTraitHandler__SpecificTraitGenerator_create(typeOfTraitx , aminx , amaxx , aweightx , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0)
            
            call SaveInteger(Table___ht, (sc__TableArray__getindex(s__CustomInventoryTraitHandler__TraitGroup_holder[this],1)), (s__CustomInventoryTraitHandler__TraitGroup_maxHolder[this]), ( s__CustomInventoryTraitHandler__TraitGroup_combinedWeights[this])) // INLINED!!
            set s__CustomInventoryTraitHandler__TraitGroup_combinedWeights[this]=s__CustomInventoryTraitHandler__TraitGroup_combinedWeights[this] + traitWeight
            call SaveInteger(Table___ht, (sc__TableArray__getindex(s__CustomInventoryTraitHandler__TraitGroup_holder[this],0)), (s__CustomInventoryTraitHandler__TraitGroup_maxHolder[this]), ( (t))) // INLINED!!
            set s__CustomInventoryTraitHandler__TraitGroup_maxHolder[this]=s__CustomInventoryTraitHandler__TraitGroup_maxHolder[this] + 1
        endfunction
        function s__CustomInventoryTraitHandler__TraitGroup_generate takes integer this returns integer
            local integer i= 0
            local integer prev= 0
            local integer r= GetRandomInt(0, s__CustomInventoryTraitHandler__TraitGroup_combinedWeights[this])
            if r == 0 then
                return s__CustomInventoryTraitHandler__SpecificTraitGenerator_generate(((LoadInteger(Table___ht, (sc__TableArray__getindex(s__CustomInventoryTraitHandler__TraitGroup_holder[this],0)), (0))))) // INLINED!!
            else
                loop
                    if ((LoadInteger(Table___ht, (sc__TableArray__getindex(s__CustomInventoryTraitHandler__TraitGroup_holder[this],1)), (i)))) > r then // INLINED!!
                        return s__CustomInventoryTraitHandler__SpecificTraitGenerator_generate(((LoadInteger(Table___ht, (sc__TableArray__getindex(s__CustomInventoryTraitHandler__TraitGroup_holder[this],0)), (i - 1))))) // INLINED!!
                    endif
                    set i=i + 1
                    exitwhen i == s__CustomInventoryTraitHandler__TraitGroup_maxHolder[this]
                endloop
                return s__CustomInventoryTraitHandler__SpecificTraitGenerator_generate(((LoadInteger(Table___ht, (sc__TableArray__getindex(s__CustomInventoryTraitHandler__TraitGroup_holder[this],0)), (i - 1))))) // INLINED!!
            endif
            return 0
        endfunction
        function s__CustomInventoryTraitHandler__ItemGenerator_create takes nothing returns integer
            local integer this= s__CustomInventoryTraitHandler__ItemGenerator__allocate()
            set s__CustomInventoryTraitHandler__ItemGenerator_holder[this]=sc__TableArray__staticgetindex(4)
            set s__CustomInventoryTraitHandler__ItemGenerator_maxHolder[this]=0
            return this
        endfunction
        
        function s__CustomInventoryTraitHandler__ItemGenerator_addTrait takes integer this,integer t returns nothing
            call SaveInteger(Table___ht, (sc__TableArray__getindex(s__CustomInventoryTraitHandler__ItemGenerator_holder[this],0)), (s__CustomInventoryTraitHandler__ItemGenerator_maxHolder[this]), ( (t))) // INLINED!!
            set s__CustomInventoryTraitHandler__ItemGenerator_maxHolder[this]=s__CustomInventoryTraitHandler__ItemGenerator_maxHolder[this] + 1
        endfunction
        
        
        function s__CustomInventoryTraitHandler__ItemGenerator_addGroup takes integer this,integer t returns nothing
            call SaveInteger(Table___ht, (sc__TableArray__getindex(s__CustomInventoryTraitHandler__ItemGenerator_holder[this],1)), (s__CustomInventoryTraitHandler__ItemGenerator_maxHolder[this]), ( (t))) // INLINED!!
            set s__CustomInventoryTraitHandler__ItemGenerator_maxHolder[this]=s__CustomInventoryTraitHandler__ItemGenerator_maxHolder[this] + 1
        endfunction
        
        function s__CustomInventoryTraitHandler__ItemGenerator_addTraits takes integer this,integer t returns nothing
            call SaveInteger(Table___ht, (sc__TableArray__getindex(s__CustomInventoryTraitHandler__ItemGenerator_holder[this],2)), (s__CustomInventoryTraitHandler__ItemGenerator_maxHolder[this]), ( (t))) // INLINED!!
            set s__CustomInventoryTraitHandler__ItemGenerator_maxHolder[this]=s__CustomInventoryTraitHandler__ItemGenerator_maxHolder[this] + 1
        endfunction
        
        function s__CustomInventoryTraitHandler__ItemGenerator_addReq takes integer this,integer t returns nothing
            call SaveInteger(Table___ht, (sc__TableArray__getindex(s__CustomInventoryTraitHandler__ItemGenerator_holder[this],3)), (s__CustomInventoryTraitHandler__ItemGenerator_maxHolder[this]), ( (t))) // INLINED!!
            set s__CustomInventoryTraitHandler__ItemGenerator_maxHolder[this]=s__CustomInventoryTraitHandler__ItemGenerator_maxHolder[this] + 1
        endfunction
        
        function s__CustomInventoryTraitHandler__ItemGenerator_apply takes integer this,integer i2 returns nothing
            local integer i= 0
            if (LoadInteger(Table___ht, (sc__TableArray__getindex(s__CustomInventoryTraitHandler__ItemGenerator_holder[this],0)), (0))) != 0 or (LoadInteger(Table___ht, (sc__TableArray__getindex(s__CustomInventoryTraitHandler__ItemGenerator_holder[this],1)), (0))) != null or (LoadInteger(Table___ht, (sc__TableArray__getindex(s__CustomInventoryTraitHandler__ItemGenerator_holder[this],2)), (0))) != null then // INLINED!!
                loop
                    if (LoadInteger(Table___ht, (sc__TableArray__getindex(s__CustomInventoryTraitHandler__ItemGenerator_holder[this],0)), (i))) != 0 then // INLINED!!
                        call sc__Item_addTrait(i2,s__CustomInventoryTraitHandler__SpecificTraitGenerator_generate(((LoadInteger(Table___ht, (sc__TableArray__getindex(s__CustomInventoryTraitHandler__ItemGenerator_holder[this],0)), (i)))))) // INLINED!!
                    elseif (LoadInteger(Table___ht, (sc__TableArray__getindex(s__CustomInventoryTraitHandler__ItemGenerator_holder[this],1)), (i))) != 0 then // INLINED!!
                        call sc__Item_addTrait(i2,s__CustomInventoryTraitHandler__TraitGroup_generate(((LoadInteger(Table___ht, (sc__TableArray__getindex(s__CustomInventoryTraitHandler__ItemGenerator_holder[this],1)), (i)))))) // INLINED!!
                    elseif (LoadInteger(Table___ht, (sc__TableArray__getindex(s__CustomInventoryTraitHandler__ItemGenerator_holder[this],2)), (i))) != 0 then // INLINED!!
                        call sc__Item_addTrait(i2,((LoadInteger(Table___ht, (sc__TableArray__getindex(s__CustomInventoryTraitHandler__ItemGenerator_holder[this],2)), (i))))) // INLINED!!
                    elseif (LoadInteger(Table___ht, (sc__TableArray__getindex(s__CustomInventoryTraitHandler__ItemGenerator_holder[this],3)), (i))) != 0 then // INLINED!!
                        call sc__Item_addReq(i2,((LoadInteger(Table___ht, (sc__TableArray__getindex(s__CustomInventoryTraitHandler__ItemGenerator_holder[this],3)), (i))))) // INLINED!!
                    else
                        return
                    endif
                    set i=i + 1
                endloop
            endif
        endfunction
    
        function s__FullItemGenerator_create takes string title2,string desc2,integer destructableId2,integer slot2 returns integer
            local integer this= s__FullItemGenerator__allocate()
            
            set s__FullItemGenerator_i[this]=s__CustomInventoryTraitHandler__ItemGenerator_create()
            set s__FullItemGenerator_title[this]=title2
            set s__FullItemGenerator_desc[this]=desc2
            set s__FullItemGenerator_destructableId[this]=destructableId2
            set s__FullItemGenerator_slot[this]=slot2
            set s__FullItemGenerator_setv[this]=0
            set s__FullItemGenerator_recipes[this]=sc__Table_create()
            set s__FullItemGenerator_recIndex[this]=0
            set s__FullItemGenerator_openGroup[this]=s__CustomInventoryTraitHandler__TraitGroup_create()
            set s__FullItemGenerator_registerId[this]=0
            return this
        endfunction
        
        function s__FullItemGenerator_addSingleChangingTrait takes integer this,integer typ,integer low,integer high,integer weight returns integer
            call s__CustomInventoryTraitHandler__ItemGenerator_addTrait(s__FullItemGenerator_i[this],s__CustomInventoryTraitHandler__SpecificTraitGenerator_setV(s__CustomInventoryTraitHandler__SpecificTraitGenerator_createx(),typ , low , high , weight))
            return this
        endfunction
        
        function s__FullItemGenerator_addSCT takes integer this,integer typ,integer low,integer high,integer weight returns integer
            return s__FullItemGenerator_addSingleChangingTrait(this,typ , low , high , weight)
        endfunction
        
        function s__FullItemGenerator_addTrait takes integer this,integer typ,real a,real b,real c,real d returns integer
            call s__CustomInventoryTraitHandler__ItemGenerator_addTraits(s__FullItemGenerator_i[this],s__Trait_create(a , b , c , d , typ))
            return this
        endfunction
        
        function s__FullItemGenerator_closeGroup takes integer this returns integer
            call s__CustomInventoryTraitHandler__ItemGenerator_addGroup(s__FullItemGenerator_i[this],s__FullItemGenerator_openGroup[this])
            set s__FullItemGenerator_openGroup[this]=s__CustomInventoryTraitHandler__TraitGroup_create()
            return this
        endfunction
        
        function s__FullItemGenerator_addGroupChangingTrait takes integer this,integer typ,integer low,integer high,integer weight,integer grpWeight returns integer
            call s__CustomInventoryTraitHandler__TraitGroup_addA(s__FullItemGenerator_openGroup[this],typ , low , high , weight , grpWeight)
            return this
        endfunction
        
        function s__FullItemGenerator_addGCT takes integer this,integer typ,integer low,integer high,integer weight,integer grpWeight returns integer
            return s__FullItemGenerator_addGroupChangingTrait(this,typ , low , high , weight , grpWeight)
        endfunction
        
        function s__FullItemGenerator_addStaticTrait takes integer this,integer typ,integer val returns integer
            call s__CustomInventoryTraitHandler__ItemGenerator_addTraits(s__FullItemGenerator_i[this],s__Trait_create(val , 0 , 0 , 0 , typ))
            return this
        endfunction
        
        function s__FullItemGenerator_addSet takes integer this,integer s returns integer
            set s__FullItemGenerator_setv[this]=s
            if s__FullItemGenerator_registerId[this] != 0 then
                call sc__Set_addItem(s,s__FullItemGenerator_registerId[this])
            endif
            return this
        endfunction
        
        function s__FullItemGenerator_register takes integer this,integer itemId returns integer
            call sc__CustomInventory_register(this , itemId)
            set s__FullItemGenerator_registerId[this]=itemId
            if s__FullItemGenerator_setv[this] != 0 then
                call sc__Set_addItem(s__FullItemGenerator_setv[this],itemId)
            endif
            return this
        endfunction
        function s__FullItemGenerator_addRecipe takes integer this,integer s returns integer
            call SaveInteger(Table___ht, (s__FullItemGenerator_recipes[this]), (s__FullItemGenerator_recIndex[this]), ( s)) // INLINED!!
            set s__FullItemGenerator_recIndex[this]=s__FullItemGenerator_recIndex[this] + 1
            return this
        endfunction
        function s__FullItemGenerator_addNewRecipe takes integer this returns integer
            local integer r
            set r=sc__Recipe2_create()
            call s__FullItemGenerator_addRecipe(this,r)
            return r
        endfunction
        function s__FullItemGenerator_addReq takes integer this,integer typ,integer val returns integer
            call s__CustomInventoryTraitHandler__ItemGenerator_addReq(s__FullItemGenerator_i[this],s__Trait_create(val , 0 , 0 , 0 , typ))
            return this
        endfunction
        function s__FullItemGenerator_generate takes integer this,item i2 returns nothing
            local integer looper= 0
            local integer ite
            call sc__CustomInventory_linkItemTraitData(s__FullItemGenerator_destructableId[this] , s__FullItemGenerator_slot[this] , s__FullItemGenerator_title[this] , s__FullItemGenerator_desc[this] , i2)
            set ite=sc__CustomInventory_getItemTraitData(i2)
            call s__CustomInventoryTraitHandler__ItemGenerator_apply(s__FullItemGenerator_i[this],ite)
            if (LoadInteger(Table___ht, (s__FullItemGenerator_recipes[this]), (0))) != 0 then // INLINED!!
                set looper=0
                loop
                    exitwhen (LoadInteger(Table___ht, (s__FullItemGenerator_recipes[this]), (looper))) == 0 // INLINED!!
                    call sc__Item_addRecipe(ite,(LoadInteger(Table___ht, (s__FullItemGenerator_recipes[this]), (looper)))) // INLINED!!
                    set looper=looper + 1
                endloop
            endif
            if s__FullItemGenerator_setv[this] != 0 then
                set s__Item_setv[(ite)]=(s__FullItemGenerator_setv[this]) // INLINED!!
            endif
        endfunction
    

//library CustomInventoryTraitHandler ends
//library Dungeon:
    function requestEntrance takes integer dungeonID returns boolean
        if Dungeon___occu == false then
            set Dungeon___current=dungeonID
            set Dungeon___occu=true
            return true
        elseif Dungeon___current == dungeonID then
            return true
        else
            return false
        endif
    endfunction
    function Dungeon_register takes integer dungeonID,trigger startfunc returns nothing
        set Dungeon___start[dungeonID]=startfunc
    endfunction
    
    function Dungeon___onStartCond takes nothing returns boolean
        return GetUnitTypeId(GetOrderTargetUnit()) == 'h00M' and GetTriggerUnit() == udg_PlayerUnit[GetPlayerId(GetTriggerPlayer()) + 1]
    endfunction
    
    function Dungeon___onStart takes nothing returns nothing
        local group g
        local location l
        if Dungeon___current == - 1 then
            call print("Error : No Currently Initialized Dungeon. Please report to mapmaker")
            return
        endif
        set g=CreateGroup()
        call GroupEnumUnitsInRect(g, lobby, null)
        if CountUnitsInGroup(g) <= 0 then
            call DestroyGroup(g)
            set Dungeon___occu=FALSE
            set Dungeon___current=- 1
            return
        endif
        call DestroyGroup(Dungeon_units)
        set Dungeon_units=CreateGroup()
        call GroupAddGroup(Dungeon_units, g)
        call DestroyGroup(g)
        set Dungeon___occu=FALSE
        set Dungeon___current=- 1
        call TriggerExecute(Dungeon___start[Dungeon___current])
    endfunction
    function Dungeon___init takes nothing returns nothing
        local trigger t= CreateTrigger()
        call TriggerRegisterAnyUnitEventBJ(t, EVENT_PLAYER_UNIT_ISSUED_UNIT_ORDER)
        call TriggerAddCondition(t, Condition(function Dungeon___onStartCond))
        set lobby=gg_rct_Instance_Room
    endfunction

//library Dungeon ends
//library Event:
        function s__Event_create takes nothing returns integer
            set s__Event_w=s__Event_w + 1
            set s__Event_e[s__Event_w]=CreateTrigger()
            return s__Event_w
        endfunction
        function s__Event_registerTrigger takes integer this,trigger t returns nothing
            call TriggerRegisterVariableEvent(t, "Event___q", EQUAL, this)
        endfunction
        function s__Event_register takes integer this,boolexpr c returns nothing
            call TriggerAddCondition(s__Event_e[this], c)
        endfunction
        function s__Event_fire takes integer this returns nothing
            set Event___q=0
            set Event___q=this
            call TriggerEvaluate(s__Event_e[this])
        endfunction
    function CreateEvent takes nothing returns integer
        return s__Event_create()
    endfunction
    function TriggerRegisterEvent takes trigger t,integer ev returns nothing
        call s__Event_registerTrigger(ev,t)
    endfunction
    function RegisterEvent takes boolexpr c,integer ev returns nothing
        call TriggerAddCondition(s__Event_e[(ev)], (c)) // INLINED!!
    endfunction
    function FireEvent takes integer ev returns nothing
        call s__Event_fire(ev)
    endfunction

//library Event ends
//library GetClosestWidget:

    
        function s__ClosestWidget_resetData takes real x,real y returns nothing
            set s__ClosestWidget_cDest=null
            set s__ClosestWidget_distance=100000
            set s__ClosestWidget_cItem=null
            set s__ClosestWidget_cUnit=null
            set s__ClosestWidget_cX=x
            set s__ClosestWidget_cY=y
        endfunction
        function s__ClosestWidget_enumItems takes nothing returns nothing
            local item i=GetEnumItem()
            local real dx=GetWidgetX(i) - s__ClosestWidget_cX
            local real dy=GetWidgetY(i) - s__ClosestWidget_cY
            set dx=( dx * dx + dy * dy ) / 10000.
            if dx < s__ClosestWidget_distance then
                set s__ClosestWidget_cItem=i
                set s__ClosestWidget_distance=dx
            endif
            set i=null
        endfunction
        function s__ClosestWidget_enumDestructables takes nothing returns nothing
            local destructable d=GetEnumDestructable()
            local real dx
            local real dy





            set dx=GetWidgetX(d) - s__ClosestWidget_cX
            set dy=GetWidgetY(d) - s__ClosestWidget_cY
            set dx=( dx * dx + dy * dy ) / 10000.
            if dx < s__ClosestWidget_distance then
                set s__ClosestWidget_cDest=d
                set s__ClosestWidget_distance=dx
            endif
            set d=null
        endfunction
        function s__ClosestWidget_enumUnits takes nothing returns nothing
            local unit u=GetEnumUnit()
            local real dx=GetUnitX(u) - s__ClosestWidget_cX
            local real dy=GetUnitY(u) - s__ClosestWidget_cY
            set dx=( dx * dx + dy * dy ) / 10000.
            if dx < s__ClosestWidget_distance then
                set s__ClosestWidget_cUnit=u
                set s__ClosestWidget_distance=dx
            endif
            set u=null
        endfunction
        function s__ClosestWidget_sortUnits takes integer l,integer r returns nothing
            local integer i=l
            local integer j=r
            local real v=GetClosestWidget___V[( l + r ) / 2]
            loop
                loop
                    exitwhen GetClosestWidget___V[i] >= v
                    set i=i + 1
                endloop
                loop
                    exitwhen GetClosestWidget___V[j] <= v
                    set j=j - 1
                endloop
                if i <= j then
                    set GetClosestWidget___V[0]=GetClosestWidget___V[i]
                    set GetClosestWidget___V[i]=GetClosestWidget___V[j]
                    set GetClosestWidget___V[j]=GetClosestWidget___V[0]
                    set GetClosestWidget___Q[0]=GetClosestWidget___Q[i]
                    set GetClosestWidget___Q[i]=GetClosestWidget___Q[j]
                    set GetClosestWidget___Q[j]=GetClosestWidget___Q[0]
                    set i=i + 1
                    set j=j - 1
                endif
                exitwhen i > j
            endloop
            if l < j then
                call s__ClosestWidget_sortUnits(l , j)
            endif
            if r > i then
                call s__ClosestWidget_sortUnits(i , r)
            endif
        endfunction
        function s__ClosestWidget_saveGroup takes nothing returns nothing
            local real dx
            local real dy
            set GetClosestWidget___C=GetClosestWidget___C + 1
            set GetClosestWidget___Q[GetClosestWidget___C]=GetEnumUnit()
            set dx=GetUnitX(GetClosestWidget___Q[GetClosestWidget___C]) - s__ClosestWidget_cX
            set dy=GetUnitY(GetClosestWidget___Q[GetClosestWidget___C]) - s__ClosestWidget_cY
            set GetClosestWidget___V[GetClosestWidget___C]=( dx * dx + dy * dy ) / 10000.
        endfunction
//Implemented from module GetClosestWidget___Init:
        function s__ClosestWidget_GetClosestWidget___Init___onInit takes nothing returns nothing
            set s__ClosestWidget_initRect=Rect(0, 0, 0, 0)
        endfunction

    function GetClosestItem takes real x,real y,boolexpr filter returns item
        local real r=800.
        call s__ClosestWidget_resetData(x , y)
        loop
            if r > 3200. then
                call EnumItemsInRect(bj_mapInitialPlayableArea, filter, function s__ClosestWidget_enumItems)
                exitwhen true
            else
                call SetRect(s__ClosestWidget_initRect, x - r, y - r, x + r, y + r)
                call EnumItemsInRect(s__ClosestWidget_initRect, filter, function s__ClosestWidget_enumItems)
                exitwhen s__ClosestWidget_cItem != null
            endif
            set r=2 * r
        endloop
        return s__ClosestWidget_cItem
    endfunction

    function GetClosestItemInRange takes real x,real y,real radius,boolexpr filter returns item
        call s__ClosestWidget_resetData(x , y)
        if radius >= 0 then
            call SetRect(s__ClosestWidget_initRect, x - radius, y - radius, x + radius, y + radius)
            call EnumItemsInRect(s__ClosestWidget_initRect, filter, function s__ClosestWidget_enumItems)
        endif
        return s__ClosestWidget_cItem
    endfunction

    function GetClosestDestructable takes real x,real y,boolean treeOnly,boolexpr filter returns destructable
        local real r=800.
        call s__ClosestWidget_resetData(x , y)
        set s__ClosestWidget_cTree=treeOnly
        loop
            if r > 3200. then
                call EnumDestructablesInRect(bj_mapInitialPlayableArea, filter, function s__ClosestWidget_enumDestructables)
                exitwhen true
            else
                call SetRect(s__ClosestWidget_initRect, x - r, y - r, x + r, y + r)
                call EnumDestructablesInRect(s__ClosestWidget_initRect, filter, function s__ClosestWidget_enumDestructables)
                exitwhen s__ClosestWidget_cDest != null
            endif
            set r=2 * r
        endloop
        return s__ClosestWidget_cDest
    endfunction

    function GetClosestDestructableInRange takes real x,real y,real radius,boolean treeOnly,boolexpr filter returns destructable
        call s__ClosestWidget_resetData(x , y)
        if radius >= 0 then
            set s__ClosestWidget_cTree=treeOnly
            call SetRect(s__ClosestWidget_initRect, x - radius, y - radius, x + radius, y + radius)
            call EnumDestructablesInRect(s__ClosestWidget_initRect, filter, function s__ClosestWidget_enumDestructables)
        endif
        return s__ClosestWidget_cDest
    endfunction
    
    function GetClosestUnit takes real x,real y,boolexpr filter returns unit
        local real r=800.
        call s__ClosestWidget_resetData(x , y)
        loop
            if r > 3200. then
                call GroupEnumUnitsInRect(bj_lastCreatedGroup, bj_mapInitialPlayableArea, filter)
                exitwhen true
            else
                call GroupEnumUnitsInRange(bj_lastCreatedGroup, x, y, r, filter)
                exitwhen FirstOfGroup(bj_lastCreatedGroup) != null
            endif
            set r=2 * r
        endloop
        call ForGroup(bj_lastCreatedGroup, function s__ClosestWidget_enumUnits)
        return s__ClosestWidget_cUnit
    endfunction
    
    function GetClosestUnitInRange takes real x,real y,real radius,boolexpr filter returns unit
        call s__ClosestWidget_resetData(x , y)
        if radius >= 0 then
            call GroupEnumUnitsInRange(bj_lastCreatedGroup, x, y, radius, filter)
            call ForGroup(bj_lastCreatedGroup, function s__ClosestWidget_enumUnits)
        endif
        return s__ClosestWidget_cUnit
    endfunction

    function GetClosestUnitInGroup takes real x,real y,group g returns unit
        call s__ClosestWidget_resetData(x , y)
        call ForGroup(g, function s__ClosestWidget_enumUnits)
        return s__ClosestWidget_cUnit
    endfunction

    function GetClosestNUnitsInRange takes real x,real y,real radius,integer n,group g,boolexpr filter returns nothing
        local integer q=n + 1
        call s__ClosestWidget_resetData(x , y)
        if radius >= 0 then
            call GroupEnumUnitsInRange(bj_lastCreatedGroup, x, y, radius, filter)
            call ForGroup(bj_lastCreatedGroup, function s__ClosestWidget_saveGroup)
            call s__ClosestWidget_sortUnits(1 , GetClosestWidget___C)
            loop
            exitwhen n == 0 or GetClosestWidget___Q[- n + q] == null
                call GroupAddUnit(g, GetClosestWidget___Q[- n + q])
                set n=n - 1
            endloop
        endif
        set GetClosestWidget___C=0
    endfunction
    
    function GetClosestNUnitsInGroup takes real x,real y,integer n,group sourceGroup,group destGroup returns nothing
        local integer q=n + 1
        call s__ClosestWidget_resetData(x , y)
        call ForGroup(sourceGroup, function s__ClosestWidget_saveGroup)
        call s__ClosestWidget_sortUnits(1 , GetClosestWidget___C)
        loop
            exitwhen n == 0 or GetClosestWidget___Q[- n + q] == null
            call GroupAddUnit(destGroup, GetClosestWidget___Q[- n + q])
            set n=n - 1
        endloop
        set GetClosestWidget___C=0
    endfunction

//library GetClosestWidget ends
//library GetPlayerColored:
    // GetPlayerColored by Ammorth
    // v1.2
    // functions should be self-explanatory
    // Credits to DioD for multiple fixes


    function GetPlayerNameColored takes player p returns string
        return GetPlayerColored___PlayerColor[GetHandleId(GetPlayerColor(p))] + GetPlayerName(p) + "|r"
    endfunction

    function GetPlayerTextColor takes player p returns string
        return GetPlayerColored___PlayerColor[GetHandleId(GetPlayerColor(p))]
    endfunction

    function GetPlayerRedHex takes player p returns integer
        return GetPlayerColored___redhex[GetHandleId(GetPlayerColor(p))]
    endfunction

    function GetPlayerGreenHex takes player p returns integer
        return GetPlayerColored___greenhex[GetHandleId(GetPlayerColor(p))]
    endfunction

    function GetPlayerBlueHex takes player p returns integer
        return GetPlayerColored___bluehex[GetHandleId(GetPlayerColor(p))]
    endfunction

    function GetPlayerColored___init takes nothing returns nothing
        set GetPlayerColored___PlayerColor[0]="|CFFFF0303" // red
        set GetPlayerColored___PlayerColor[1]="|CFF0042FF" // blue
        set GetPlayerColored___PlayerColor[2]="|CFF1CE6B9" // teal
        set GetPlayerColored___PlayerColor[3]="|CFF540081" // purple
        set GetPlayerColored___PlayerColor[4]="|CFFFFFF01" // yellow
        set GetPlayerColored___PlayerColor[5]="|CFFFE8A0E" // orange
        set GetPlayerColored___PlayerColor[6]="|CFF20C000" // green
        set GetPlayerColored___PlayerColor[7]="|CFFE55BB0" // pink
        set GetPlayerColored___PlayerColor[8]="|CFF959697" // grey
        set GetPlayerColored___PlayerColor[9]="|CFF7EBFF1" // light blue
        set GetPlayerColored___PlayerColor[10]="|CFF106246" // dark green
        set GetPlayerColored___PlayerColor[11]="|CFF4E2A04" // brown
        set GetPlayerColored___redhex[0]=255
        set GetPlayerColored___redhex[1]=0
        set GetPlayerColored___redhex[2]=28
        set GetPlayerColored___redhex[3]=84
        set GetPlayerColored___redhex[4]=255
        set GetPlayerColored___redhex[5]=254
        set GetPlayerColored___redhex[6]=32
        set GetPlayerColored___redhex[7]=229
        set GetPlayerColored___redhex[8]=149
        set GetPlayerColored___redhex[9]=126
        set GetPlayerColored___redhex[10]=16
        set GetPlayerColored___redhex[11]=78
        set GetPlayerColored___greenhex[0]=3
        set GetPlayerColored___greenhex[1]=66
        set GetPlayerColored___greenhex[2]=230
        set GetPlayerColored___greenhex[3]=0
        set GetPlayerColored___greenhex[4]=255
        set GetPlayerColored___greenhex[5]=138
        set GetPlayerColored___greenhex[6]=192
        set GetPlayerColored___greenhex[7]=91
        set GetPlayerColored___greenhex[8]=150
        set GetPlayerColored___greenhex[9]=191
        set GetPlayerColored___greenhex[10]=98
        set GetPlayerColored___greenhex[11]=42
        set GetPlayerColored___bluehex[0]=3
        set GetPlayerColored___bluehex[1]=255
        set GetPlayerColored___bluehex[2]=185
        set GetPlayerColored___bluehex[3]=129
        set GetPlayerColored___bluehex[4]=1
        set GetPlayerColored___bluehex[5]=14
        set GetPlayerColored___bluehex[6]=0
        set GetPlayerColored___bluehex[7]=176
        set GetPlayerColored___bluehex[8]=151
        set GetPlayerColored___bluehex[9]=241
        set GetPlayerColored___bluehex[10]=70
        set GetPlayerColored___bluehex[11]=4
    endfunction


//library GetPlayerColored ends
//library GetRequiredXP:
function GetRequiredXP takes integer level returns integer
    local integer xp= 0
    loop
        exitwhen level == 0
        set xp=xp + ( level + 1 ) * 100
        set level=level - 1
    endloop
    return xp
endfunction

//library GetRequiredXP ends
//library GroupUtils:
//******************************************************************************
//* BY: Rising_Dusk
//* 
//* This library is a simple implementation of a stack for groups that need to
//* be in the user's control for greater than an instant of time. Additionally,
//* this library provides a single, global group variable for use with user-end
//* enumerations. It is important to note that users should not be calling
//* DestroyGroup() on the global group, since then it may not exist for when it
//* it is next needed.
//*
//* The group stack removes the need for destroying groups and replaces it with
//* a recycling method.
//*     function NewGroup takes nothing returns group
//*     function ReleaseGroup takes group g returns boolean
//*     function GroupRefresh takes group g returns nothing
//* 
//* NewGroup grabs a currently unused group from the stack or creates one if the
//* stack is empty. You can use this group however you'd like, but always
//* remember to call ReleaseGroup on it when you are done with it. If you don't
//* release it, it will 'leak' and your stack may eventually overflow if you
//* keep doing that.
//* 
//* GroupRefresh cleans a group of any shadow references which may be clogging
//* its hash table. If you remove a unit from the game who is a member of a unit
//* group, it will 'effectively' remove the unit from the group, but leave a
//* shadow in its place. Calling GroupRefresh on a group will clean up any
//* shadow references that may exist within it.
//* 

function GroupUtils___AddEx takes nothing returns nothing
    if GroupUtils___Flag then
        call GroupClear(GroupUtils___Refr)
        set GroupUtils___Flag=false
    endif
    call GroupAddUnit(GroupUtils___Refr, GetEnumUnit())
endfunction
    
function GroupRefresh takes group g returns nothing
    set GroupUtils___Flag=true
    set GroupUtils___Refr=g
    call ForGroup(GroupUtils___Refr, function GroupUtils___AddEx)
    if GroupUtils___Flag then
        call GroupClear(g)
    endif
endfunction

function NewGroup takes nothing returns group
    if GroupUtils___Count == 0 then
        set GroupUtils___Groups[0]=CreateGroup()
    else
        set GroupUtils___Count=GroupUtils___Count - 1
    endif
    call sg__GroupUtils___Status_set(GetHandleId(GroupUtils___Groups[GroupUtils___Count]) - GroupUtils___MIN_HANDLE_ID,1)
    return GroupUtils___Groups[GroupUtils___Count]
endfunction

function ReleaseGroup takes group g returns boolean
    local integer stat= sg__GroupUtils___Status_get(GetHandleId(g) - GroupUtils___MIN_HANDLE_ID)
    local boolean b= true
    if g == null then
        set b=false
    elseif stat == 0 then
        set b=false
    elseif stat == 2 then
        set b=false
    elseif GroupUtils___Count == 8191 then
        call DestroyGroup(g)
        set b=false
    else
        call GroupClear(g)
        set GroupUtils___Groups[GroupUtils___Count]=g
        set GroupUtils___Count=GroupUtils___Count + 1
        call sg__GroupUtils___Status_set(GetHandleId(g) - GroupUtils___MIN_HANDLE_ID,2)
    endif
    return b
endfunction

//library GroupUtils ends
//library HeroImage:
//Implemented from module Alloc:
    
    function s__HeroImage_allocate takes nothing returns integer
        local integer this= s__HeroImage_Alloc___recycler[0]
        
        
        if ( this == 0 ) then
        
            set this=s__HeroImage_Alloc___instanceCount + 1
            set s__HeroImage_Alloc___instanceCount=this
        else
            set s__HeroImage_Alloc___recycler[0]=s__HeroImage_Alloc___recycler[this]
        endif
        
        
        return this
    endfunction
    
    function s__HeroImage_deallocate takes integer this returns nothing
        
        
        set s__HeroImage_Alloc___recycler[this]=s__HeroImage_Alloc___recycler[0]
        set s__HeroImage_Alloc___recycler[0]=this
    endfunction
        
        
        
        function s__HeroImage_storeCopy takes integer this,integer u returns nothing
            call SaveInteger(Table___ht, (s__HeroImage_copies), (u), ( this)) // INLINED!!
        endfunction
        function s__HeroImage_storeOriginal takes integer this,integer u returns nothing
            call SaveInteger(Table___ht, (s__HeroImage_originals), (u), ( this)) // INLINED!!
        endfunction
        function s__HeroImage_retrieveCopy takes integer u returns integer
            return (LoadInteger(Table___ht, (s__HeroImage_copies), (u))) // INLINED!!
        endfunction
        function s__HeroImage_retrieveOriginal takes integer u returns integer
            return (LoadInteger(Table___ht, (s__HeroImage_originals), (u))) // INLINED!!
        endfunction
        function s__HeroImage_isOriginal takes integer u returns boolean
            return (HaveSavedInteger(Table___ht, (s__HeroImage_originals), (u))) // INLINED!!
        endfunction
        function s__HeroImage_isCopy takes integer u returns boolean
            return (HaveSavedInteger(Table___ht, (s__HeroImage_copies), (u))) // INLINED!!
        endfunction
        function s__HeroImage_removeOriginal takes integer u returns nothing
            call RemoveSavedInteger(Table___ht, (s__HeroImage_originals), (u)) // INLINED!!
        endfunction
        function s__HeroImage_removeCopy takes integer u returns nothing
            call RemoveSavedInteger(Table___ht, (s__HeroImage_copies), (u)) // INLINED!!
        endfunction
        
        
        
        function s__HeroImage_onOrder takes nothing returns boolean
            local integer this
            
            if ( not (HaveSavedInteger(Table___ht, (s__HeroImage_copies), ((GetHandleId(GetOrderTargetUnit()))))) ) then // INLINED!!
                return false
            endif
            
            set this=(LoadInteger(Table___ht, (s__HeroImage_copies), ((GetHandleId(GetOrderTargetUnit()))))) // INLINED!!
            
            call IssueTargetOrderById(GetTriggerUnit(), GetIssuedOrderId(), s__HeroImage_original[this])
            
            return false
        endfunction
        
        function s__HeroImage_onSelection takes nothing returns boolean
            local integer this
            
            if ( not (HaveSavedInteger(Table___ht, (s__HeroImage_copies), ((GetHandleId(GetTriggerUnit()))))) ) then // INLINED!!
                return false
            endif
            
            set this=(LoadInteger(Table___ht, (s__HeroImage_copies), ((GetHandleId(GetTriggerUnit()))))) // INLINED!!
            
            if ( GetLocalPlayer() == GetTriggerPlayer() ) then
                call ClearSelection()
                call SelectUnit(s__HeroImage_original[this], true)
                
                call SetCameraPosition(GetUnitX(s__HeroImage_original[this]), GetUnitY(s__HeroImage_original[this]))
            endif
            
            return false
        endfunction
        
        function s__HeroImage_periodic takes nothing returns nothing
            local integer this
            local real originalHp
            local real originalMp
            local real hp
            local real mp
            local real maxHp
            local unit copy
            local integer n= 0
            local integer i= 0
            
            loop
                exitwhen i == s__HeroImage_imagesCount
                
                if s__HeroImage_original[this] == null then
                    call sc__HeroImage_destroy(this)
                else
                    set hp=GetWidgetLife(s__HeroImage_original[this])
                    set maxHp=GetUnitState(s__HeroImage_original[this], UNIT_STATE_MAX_LIFE)
                    set originalHp=hp / maxHp
                    set originalMp=GetUnitState(s__HeroImage_original[this], UNIT_STATE_MANA) / GetUnitState(s__HeroImage_original[this], UNIT_STATE_MAX_MANA)
                    
                    set n=0
                    loop
                        exitwhen (LoadUnitHandle(Table___ht, (((s__HeroImage_copyUnits[this]))), (n))) == null // INLINED!!
                        
                        set copy=(LoadUnitHandle(Table___ht, (((s__HeroImage_copyUnits[this]))), (n))) // INLINED!!
                        
                        // HP
                        if ( hp <= 0.405 ) then
                            call SetWidgetLife(copy, 1)
                        else
                            call SetWidgetLife(copy, GetUnitState(copy, UNIT_STATE_MAX_LIFE) * originalHp)
                        endif
                        
                        call SetUnitState(copy, UNIT_STATE_MANA, GetUnitState(copy, UNIT_STATE_MAX_MANA) * originalMp)
                        
                        set n=n + 1
                    endloop
                endif
                
                set i=i + 1
                set this=s__HeroImage_images[i]
            endloop
            
            set copy=null
        endfunction
        
        function s__HeroImage_addPlayer takes integer this,player p returns nothing
            local unit u= CreateUnit(p, s__HeroImage_unitType[this], s__WorldBounds_maxX, s__WorldBounds_maxY, 0)
            call s__HeroImage_storeCopy(this,GetHandleId(u))
            call PauseUnit(u, true)
            call SaveUnitHandle(Table___ht, (((s__HeroImage_copyUnits[this]))), (s__HeroImage_copiesCount[this]), ( u)) // INLINED!!
            set s__HeroImage_copiesCount[this]=s__HeroImage_copiesCount[this] + 1
        endfunction
        
        function s__HeroImage_removePlayer takes integer this,player p returns nothing
            local integer i= s__HeroImage_copiesCount[this] - 1
            loop
                exitwhen i < 0
                if GetOwningPlayer((LoadUnitHandle(Table___ht, (((s__HeroImage_copyUnits[this]))), (i)))) == p then // INLINED!!
                    call RemoveSavedInteger(Table___ht, (s__HeroImage_copies), ((GetHandleId((LoadUnitHandle(Table___ht, (((s__HeroImage_copyUnits[this]))), (i))))))) // INLINED!!
                    call RemoveUnit((LoadUnitHandle(Table___ht, (((s__HeroImage_copyUnits[this]))), (i)))) // INLINED!!
                    
                    set s__HeroImage_copiesCount[this]=s__HeroImage_copiesCount[this] - 1
                    call SaveUnitHandle(Table___ht, (((s__HeroImage_copyUnits[this]))), (i), ( (LoadUnitHandle(Table___ht, (((s__HeroImage_copyUnits[this]))), (s__HeroImage_copiesCount[this]))))) // INLINED!!
                    call RemoveSavedInteger(Table___ht, (s__HeroImage_copyUnits[this]), (s__HeroImage_copiesCount[this])) // INLINED!!
                    return
                endif
                set i=i - 1
            endloop
            call print("error no remove player")
        endfunction
        
        function s__HeroImage_destroy takes integer this returns nothing
            local integer i= s__HeroImage_copiesCount[this] - 1
            loop
                exitwhen i < 0
                call RemoveSavedInteger(Table___ht, (s__HeroImage_copies), ((GetHandleId((LoadUnitHandle(Table___ht, (((s__HeroImage_copyUnits[this]))), (i))))))) // INLINED!!
                call RemoveUnit((LoadUnitHandle(Table___ht, (((s__HeroImage_copyUnits[this]))), (i)))) // INLINED!!
                call RemoveSavedInteger(Table___ht, (s__HeroImage_copyUnits[this]), (i)) // INLINED!!
                set i=i - 1
            endloop
            call RemoveSavedInteger(Table___ht, (s__HeroImage_originals), ((GetHandleId(s__HeroImage_original[this])))) // INLINED!!
            //call RemoveUnit(original)
            set s__HeroImage_imagesCount=s__HeroImage_imagesCount - 1
            set s__HeroImage_images[s__HeroImage_spot[this]]=s__HeroImage_images[s__HeroImage_imagesCount]
            set s__HeroImage_images[s__HeroImage_imagesCount]=0
        endfunction
        
        function s__HeroImage_isOwner takes integer this,player p returns boolean
            return GetOwningPlayer(s__HeroImage_original[this]) == p
        endfunction
        
        function s__HeroImage_create takes unit orig,force players returns integer
            local integer this
            local integer id= GetHandleId(orig)
            local integer playa= GetPlayerId(GetOwningPlayer(orig))
            local integer i= 0
            local player p
            local unit u
            
            if (HaveSavedInteger(Table___ht, (s__HeroImage_originals), ((id)))) then // INLINED!!
                call print("Error : " + I2S(id) + " already has a copy")
            elseif (HaveSavedInteger(Table___ht, (s__HeroImage_copies), ((id)))) then // INLINED!!
                call print("Error : " + I2S(id) + " is a copy")
            endif
            set this=s__HeroImage_allocate()
            set s__HeroImage_original[this]=orig
            set s__HeroImage_copyUnits[this]=sc__Table_create()
            set s__HeroImage_copiesCount[this]=0
            set s__HeroImage_unitType[this]=GetUnitTypeId(orig)
            call s__HeroImage_storeOriginal(this,id)
            set s__HeroImage_spot[this]=s__HeroImage_imagesCount
            set s__HeroImage_images[s__HeroImage_spot[this]]=this
            set s__HeroImage_imagesCount=s__HeroImage_imagesCount + 1
            loop
                exitwhen i >= 11
                set p=Player(i)
                if i != playa and IsPlayerInForce(p, players) then
                    set u=CreateUnit(p, s__HeroImage_unitType[this], s__WorldBounds_maxX, s__WorldBounds_maxY, 0)
                    call s__HeroImage_storeCopy(this,GetHandleId(u))
                    call PauseUnit(u, true)
                    call SaveUnitHandle(Table___ht, (((s__HeroImage_copyUnits[this]))), (s__HeroImage_copiesCount[this]), ( u)) // INLINED!!
                    set s__HeroImage_copiesCount[this]=s__HeroImage_copiesCount[this] + 1
                endif
                set i=i + 1
            endloop
            
            set p=null
            set u=null
            return this
        endfunction
        
        
    function HeroImage__onInit takes nothing returns nothing
        local trigger onSelect= CreateTrigger()
        local trigger onOrder= CreateTrigger()
        local integer i= 0
        call TriggerAddCondition(onSelect, Filter(function s__HeroImage_onSelection))
        call TriggerAddCondition(onOrder, Filter(function s__HeroImage_onOrder))
        loop
            exitwhen i >= 11
            call TriggerRegisterPlayerUnitEvent(onOrder, Player(i), EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER, null)
            call TriggerRegisterPlayerUnitEvent(onSelect, Player(i), EVENT_PLAYER_UNIT_SELECTED, null)
            set i=i + 1
        endloop
        set s__HeroImage_originals=sc__Table_create()
        set s__HeroImage_copies=sc__Table_create()
        set s__HeroImage_imagesCount=0
    endfunction

//library HeroImage ends
//library InitSave:
    function DisableSave takes nothing returns nothing
        call DisableTrigger(InitSave__saveTrigger)
    endfunction
    function EnableSave takes nothing returns nothing
        call EnableTrigger(InitSave__saveTrigger)
    endfunction
    function DisableLoad takes nothing returns nothing
        call DisableTrigger(InitSave__loadTrigger)
    endfunction
    function EnableLoad takes nothing returns nothing
        call EnableTrigger(InitSave__loadTrigger)
    endfunction
    function InitSave takes string saveCommand,string loadCommand,conditionfunc saveFunc,conditionfunc loadFunc,boolean exact returns nothing
        call DestroyTrigger(InitSave__saveTrigger)
        call DestroyTrigger(InitSave__loadTrigger)
        
        //register save/load commands
        set InitSave__saveTrigger=CreateTrigger()
        set InitSave__loadTrigger=CreateTrigger()
        call TriggerAddCondition(InitSave__saveTrigger, saveFunc)
        
        set loadCommand=loadCommand + " "
        
        call TriggerRegisterPlayerChatEvent(InitSave__saveTrigger, Player(0), saveCommand, exact)
        call TriggerRegisterPlayerChatEvent(InitSave__loadTrigger, Player(0), loadCommand, false)
        
        call TriggerAddCondition(InitSave__loadTrigger, loadFunc)
    endfunction

//library InitSave ends
//library ItemGeneration:

//library ItemGeneration ends
//library ItemStacker:
    
    
    function ItemStacker___onPickup takes nothing returns boolean
        local integer i= 0
        local item ite= GetManipulatedItem()
        local integer id= GetItemTypeId(ite)
        local unit u= GetTriggerUnit()
        if GetItemCharges(ite) != 0 then
            loop
                exitwhen i == 5
                if GetItemTypeId(UnitItemInSlot(u, i)) == id and UnitItemInSlot(u, i) != ite then
                    call SetItemCharges(UnitItemInSlot(u, i), GetItemCharges(UnitItemInSlot(u, i)) + GetItemCharges(ite))
                    call RemoveItem(ite)
                    exitwhen true
                endif
                set i=i + 1
            endloop
        endif
        set u=null
        set ite=null
        return false
    endfunction
    
    function ItemStacker___itemOnInit takes nothing returns nothing
        local trigger t= CreateTrigger()
        
        call TriggerRegisterAnyUnitEventBJ(t, EVENT_PLAYER_UNIT_PICKUP_ITEM)
        
        call TriggerAddCondition(t, Filter(function ItemStacker___onPickup))
        
        set t=null
    endfunction

//library ItemStacker ends
//library LinkedListModule:
    


        
        
        
        



//library LinkedListModule ends
//library Loc:
    
        
        
        
        
        //*********************************************************************
        //  Lock counters: a way to keep track of how many times a Loc has been
        //  locked, starts counting from 1. Unlocking drops the counters by 1,
        //  if it reaches 0 the instance is deallocated.
        
        function s__Loc_move takes integer this,real sx,real sy,real sz returns nothing
            call MoveLocation(s__Loc_global, sx, sy)
            set s__Loc_x[this]=sx
            set s__Loc_y[this]=sy
            set s__Loc_z[this]=sz + GetLocationZ(s__Loc_global)
        endfunction
        
        function s__Loc_create takes real sx,real sy,real sz returns integer
            local integer this= s__Loc_r[0]
            if this == 0 then
                set s__Loc_ic=s__Loc_ic + 1
                set this=s__Loc_ic
            else
                set s__Loc_r[0]=s__Loc_r[this]
            endif
            call s__Loc_move(this,sx , sy , sz)
            set s__Loc_lc[this]=1
            return this
        endfunction
        
        function s__Loc_lock takes integer this returns nothing
            set s__Loc_lc[this]=s__Loc_lc[this] + 1
        endfunction
        
        
        function s__Loc_unlock takes integer this returns nothing
            set s__Loc_lc[this]=s__Loc_lc[this] - 1
            if s__Loc_lc[this] == 0 then
                set s__Loc_r[this]=s__Loc_r[0]
                set s__Loc_r[0]=this
            endif
        endfunction
        
    

//library Loc ends
//library PartyLib:
//Implemented from module Alloc:
    
    function s__Party_allocate takes nothing returns integer
        local integer this= s__Party_Alloc___recycler[0]
        
        
        if ( this == 0 ) then
        
            set this=s__Party_Alloc___instanceCount + 1
            set s__Party_Alloc___instanceCount=this
        else
            set s__Party_Alloc___recycler[0]=s__Party_Alloc___recycler[this]
        endif
        
        
        return this
    endfunction
    
    function s__Party_deallocate takes integer this returns nothing
        
        
        set s__Party_Alloc___recycler[this]=s__Party_Alloc___recycler[0]
        set s__Party_Alloc___recycler[0]=this
    endfunction
        
        
        
        function s__Party_getParty takes player p returns integer
            return s__Party_p_perPlayer[GetPlayerId(p)]
        endfunction
        
        function s__Party_getForce takes integer this returns force
            return s__Party_playerPool[this]
        endfunction
        
        function s__Party_isJoinableParty takes player p returns boolean
            return (s__Party_p_perPlayer[GetPlayerId(p)]) > 9
        endfunction
        
        function s__Party_addImage takes integer this,player p returns nothing
            local integer i= s__Party_heroImagesCount[this] - 1
            loop
                exitwhen i < 0
                call s__HeroImage_addPlayer(((LoadInteger(Table___ht, (s__Party_heroImages[this]), (i)))),p) // INLINED!!
                set i=i - 1
            endloop
            call SaveInteger(Table___ht, (s__Party_heroImages[this]), (s__Party_heroImagesCount[this]), ( s__HeroImage_create(udg_PlayerUnit[GetPlayerId(p) + 1] , s__Party_playerPool[this]))) // INLINED!!
            set s__Party_heroImagesCount[this]=s__Party_heroImagesCount[this] + 1
        endfunction
        
        function s__Party_removeImage takes integer this,player p returns nothing
            local integer i= s__Party_heroImagesCount[this] - 1
            loop
                exitwhen i < 0
                if s__HeroImage_isOwner(((LoadInteger(Table___ht, (s__Party_heroImages[this]), (i)))),p) then // INLINED!!
                    call s__HeroImage_destroy(((LoadInteger(Table___ht, (s__Party_heroImages[this]), (i))))) // INLINED!!
                    set s__Party_heroImagesCount[this]=s__Party_heroImagesCount[this] - 1
                    call SaveInteger(Table___ht, (s__Party_heroImages[this]), (i), ( (LoadInteger(Table___ht, (s__Party_heroImages[this]), (s__Party_heroImagesCount[this]))))) // INLINED!!
                else
                    call s__HeroImage_destroy(((LoadInteger(Table___ht, (s__Party_heroImages[this]), (i))))) // INLINED!!
                endif
                set i=i - 1
            endloop
        endfunction
        
        function s__Party_startQuest takes integer this,integer questThis returns nothing
            call SaveInteger(Table___ht, (s__Party_quests[this]), (s__Party_questsCount[this]), ( questThis)) // INLINED!!
            set s__Party_questsCount[this]=s__Party_questsCount[this] + 1
        endfunction
        function s__Party_getLevelReq takes integer this returns integer
            local integer i= 0
            local integer min= 99999999
            loop
                exitwhen i >= 10
                if IsPlayerInForce(Player(i), s__Party_playerPool[this]) and GetHeroLevel(udg_PlayerUnit[i + 1]) < min then
                    set min=GetHeroLevel(udg_PlayerUnit[i + 1])
                endif
                set i=i + 1
            endloop
            return min
        endfunction
        function s__Party_addPing takes integer this,real x,real y returns nothing
            call SaveReal(Table___ht, (((s__Party_pings[this]))), (s__Party_pingsCount[this] * 2), (( x)*1.0)) // INLINED!!
            call SaveReal(Table___ht, (((s__Party_pings[this]))), (s__Party_pingsCount[this] * 2 + 1), (( y)*1.0)) // INLINED!!
            set s__Party_pingsCount[this]=s__Party_pingsCount[this] + 1
        endfunction
        function s__Party_removePing takes integer this,real x,real y returns nothing
            local integer i= 0
            loop
                exitwhen i >= s__Party_pingsCount[this]
                if (LoadReal(Table___ht, (((s__Party_pings[this]))), (i * 2))) == x and (LoadReal(Table___ht, (((s__Party_pings[this]))), (i * 2 + 1))) == y then // INLINED!!
                    call SaveReal(Table___ht, (((s__Party_pings[this]))), (i * 2), (( (LoadReal(Table___ht, (((s__Party_pings[this]))), (s__Party_pingsCount[this] * 2))))*1.0)) // INLINED!!
                    call SaveReal(Table___ht, (((s__Party_pings[this]))), (i * 2 + 1), (( (LoadReal(Table___ht, (((s__Party_pings[this]))), (s__Party_pingsCount[this] * 2 + 1))))*1.0)) // INLINED!!
                    return
                endif
                set i=i + 1
            endloop
        endfunction
        function s__Party_finishQuest takes integer this,integer questThis returns nothing
            local integer i= 0
            loop
                exitwhen i == s__Party_questsCount[this]
                if (LoadInteger(Table___ht, (s__Party_quests[this]), (i))) == questThis then // INLINED!!
                    if i != s__Party_questsCount[this] - 1 then
                        call SaveInteger(Table___ht, (s__Party_quests[this]), (i), ( (LoadInteger(Table___ht, (s__Party_quests[this]), (s__Party_questsCount[this] - 1))))) // INLINED!!
                    endif
                    set s__Party_questsCount[this]=s__Party_questsCount[this] - 1
                    return
                endif
                set i=i + 1
            endloop
        endfunction
        
        function s__Party_getQuests takes integer this returns integer
            return s__Party_quests[this]
        endfunction
        
        function s__Party_isPlayerCaptain takes player p returns boolean
            return s__Party_captain[s__Party_p_perPlayer[GetPlayerId(p)]] == p
        endfunction
        
        function s__Party_doesContainPlayer takes integer this,player p returns boolean
            return IsPlayerInForce(p, s__Party_playerPool[this])
        endfunction
        
        function s__Party_isJoinable takes integer this returns boolean
            return (this) > 10
        endfunction
        
        function s__Party_isCaptain takes integer this,player p returns boolean
            return s__Party_captain[this] == p
        endfunction
        
        function s__Party_populateForce takes integer this,force f returns nothing
            local integer i= 0
            loop
                exitwhen i == 14
                if IsPlayerInForce(Player(i), s__Party_playerPool[this]) then
                    call ForceAddPlayer(f, Player(i))
                endif
                set i=i + 1
            endloop
        endfunction
        
        function s__Party_add takes integer this,player p returns integer
            local integer i= 0
            if (s__Party_p_perPlayer[GetPlayerId(p)]) > 10 then
                call DisplayTimedTextToPlayer((p ), 0, 0, (( 30 )*1.0), ( "|cff33ff33Party|r : Player " + I2S(GetPlayerId(p) + 1) + " cannot join another party because he/she is already in a party")) // INLINED!!
                return s__Party_p_perPlayer[GetPlayerId(p)]
            endif
            if (this) <= 10 then
                call BJDebugMsg("FATAL ERROR : Attempted to add a player to a default party. Report to illidans911@gmail.com")
                return - 1
            endif
            set s__Party_p_perPlayer[GetPlayerId(p)]=this
            if s__Party_captain[this] != p then
                call TimedTextForce(s__Party_playerPool[this] , 30 , "|cff33ff33Party|r : " + GetPlayerNameColored(p) + " has joined the party")
                set i=s__Party_questsCount[this] - 1
                loop
                    exitwhen i < 0
                    call sc__QuestInstance_notifyClosure(((LoadInteger(Table___ht, (s__Party_quests[this]), (i))))) // INLINED!!
                    set i=i - 1
                endloop
            endif
            call ForceAddPlayer(s__Party_playerPool[this], p)
            
            call s__Party_addImage(this,p)
            return this
        endfunction
        
        
        function s__Party_create takes nothing returns integer
            local integer this= s__Party_allocate()
            
            set s__Party_playerPool[this]=CreateForce()
            set s__Party_heroImages[this]=sc__Table_create()
            set s__Party_heroImagesCount[this]=0
            
            return this
        endfunction
        
        function s__Party_onPartyExit takes player p returns nothing
            local integer this= s__Party_p_perPlayer[GetPlayerId(p)]
            if (this) < 11 then
                call DisplayTimedTextToPlayer((p ), 0, 0, (( 30 )*1.0), ( "|cff33ff33Party|r : You aren't in a party")) // INLINED!!
                return
            endif
            if p == s__Party_captain[this] then
                call DisplayTimedTextToPlayer((p ), 0, 0, (( 30 )*1.0), ( "|cff33ff33Party|r : You are the captain of the party, you cannot exit it. Either use \"#transfer {color}\" to transfer ownership or \"#disband\" to break the party")) // INLINED!!
                return
            endif
            call s__Party_removeImage(this,p)
            call ForceRemovePlayer(s__Party_playerPool[this], p)
            set s__Party_p_perPlayer[GetPlayerId(p)]=s__Party_p_curPlayer[GetPlayerId(p)]
                
        endfunction
        function s__Party_onPartyDisband takes player trig returns nothing
            local integer this= s__Party_p_perPlayer[GetPlayerId(trig)]
            local integer i
            //local player p
            if (this) < 11 then
                call DisplayTimedTextToPlayer((trig ), 0, 0, (( 30 )*1.0), ( "|cff33ff33Party|r : You aren't in a party")) // INLINED!!
                return
            endif
            if trig != s__Party_captain[this] then
                call DisplayTimedTextToPlayer((trig ), 0, 0, (( 30 )*1.0), ( "|cff33ff33Party|r : You aren't the owner of the party")) // INLINED!!
                return
            endif
            set i=0
            loop
                exitwhen i == s__Party_heroImagesCount[this]
                call s__HeroImage_destroy(((LoadInteger(Table___ht, (s__Party_heroImages[this]), (i))))) // INLINED!!
                set i=i + 1
            endloop
            set i=0
            loop
                exitwhen i == s__Party_questsCount[this]
                    call print("closing")
                call sc__QuestInstance_notifyClosure(((LoadInteger(Table___ht, (s__Party_quests[this]), (i))))) // INLINED!!
                set i=i + 1
            endloop
            
            set i=0
            call TimedTextForce(s__Party_playerPool[this] , 30 , "|cff33ff33Party|r : The party has disbanded|r")
            loop
                exitwhen i == 10
                if IsPlayerInForce(Player(i), s__Party_playerPool[this]) then
                    set s__Party_p_perPlayer[i]=s__Party_p_curPlayer[i]
                endif
                set i=i + 1
            endloop
            call DestroyForce(s__Party_playerPool[this])
            set s__Party_captain[this]=null
            call sc__Table_destroy(s__Party_quests[this])
            call sc__Table_destroy(s__Party_heroImages[this])
            call sc__Table_destroy(s__Party_pings[this])
            call s__Party_deallocate(this)
        endfunction
        
        function s__Party_onRepick takes player p returns nothing
            local integer this= s__Party_p_perPlayer[GetPlayerId(p)]
            if this <= 10 then
                return
            endif
            
            if s__Party_captain[this] == p then
                call s__Party_onPartyDisband(p)
            else
                call s__Party_onPartyExit(p)
            endif
        endfunction
        function s__Party_transferOwnership takes player owner,player toplayer returns nothing
            local integer this= s__Party_p_perPlayer[GetPlayerId(owner)]
            if (this) < 11 then
                call DisplayTimedTextToPlayer((owner ), 0, 0, (( 30 )*1.0), ( "|cff33ff33Party|r : You aren't in a party")) // INLINED!!
                return
            endif
            if owner != s__Party_captain[this] then
                call DisplayTimedTextToPlayer((owner ), 0, 0, (( 30 )*1.0), ( "|cff33ff33Party|r : You aren't the owner of the party")) // INLINED!!
                return
            endif
            if not IsPlayerInForce(toplayer, s__Party_playerPool[this]) then
                call DisplayTimedTextToPlayer((owner ), 0, 0, (( 30 )*1.0), ( "|cff33ff33Party|r : " + GetPlayerNameColored(toplayer) + " isn't in the party")) // INLINED!!
                return
            endif
            
            set s__Party_captain[this]=toplayer
        endfunction
            
        function s__Party_onPartyForm takes player p returns integer
            local integer this
            
            if (s__Party_p_perPlayer[GetPlayerId(p)]) > 10 then
                call DisplayTimedTextToPlayer((p ), 0, 0, (( 30 )*1.0), ( "|cff33ff33Party|r : You are already in a party and cannot form one. Type \"#exit\" than \"#form\" to form your own party")) // INLINED!!
                return - 1
            endif
            
            set this=s__Party_allocate()
            
            set s__Party_playerPool[this]=CreateForce()
            set s__Party_heroImages[this]=sc__Table_create()
            set s__Party_heroImagesCount[this]=0
            set s__Party_quests[this]=sc__Table_create()
            set s__Party_questsCount[this]=0
            set s__Party_captain[this]=p
            
            call s__Party_add(this,p)
            set s__Party_p_perPlayer[GetPlayerId(p)]=this
            
                call DisplayTimedTextToPlayer((p ), 0, 0, (( 30 )*1.0), ( "|cff33ff33Party|r : You have successfully formed a party. Have other players type #join {your color} to join your party")) // INLINED!!
            
            return this
        endfunction
        
        
        function s__Party_onExpire takes nothing returns nothing
            local integer this= TimerDetach(GetExpiredTimer())
                
            call DestroyTimer(GetExpiredTimer())
        endfunction
       
        function s__Party_requestInvite takes integer this,player p returns nothing
        endfunction
        
//Implemented from module PartyLib__init:
        function s__Party_PartyLib__init___onInit takes nothing returns nothing
            local integer i= 0
            loop
                exitwhen i == 10
                set s__Party_p_curPlayer[i]=s__Party_add(s__Party_create(),Player(i))
                set s__Party_p_perPlayer[i]=s__Party_p_curPlayer[i]
                set i=i + 1
            endloop
        endfunction
//Implemented from module Alloc:
    
    function s__PartyInvitationRequest_allocate takes nothing returns integer
        local integer this= s__PartyInvitationRequest_Alloc___recycler[0]
        
        
        if ( this == 0 ) then
        
            set this=s__PartyInvitationRequest_Alloc___instanceCount + 1
            set s__PartyInvitationRequest_Alloc___instanceCount=this
        else
            set s__PartyInvitationRequest_Alloc___recycler[0]=s__PartyInvitationRequest_Alloc___recycler[this]
        endif
        
        
        return this
    endfunction
    
    function s__PartyInvitationRequest_deallocate takes integer this returns nothing
        
        
        set s__PartyInvitationRequest_Alloc___recycler[this]=s__PartyInvitationRequest_Alloc___recycler[0]
        set s__PartyInvitationRequest_Alloc___recycler[0]=this
    endfunction
        
        function s__PartyInvitationRequest_destroy takes integer this returns nothing
            set s__PartyInvitationRequest_responses[GetPlayerId(s__PartyInvitationRequest_a[this]) + ( 100 * GetPlayerId(s__PartyInvitationRequest_c[this]) )]=0
            set s__PartyInvitationRequest_c[this]=null
            set s__PartyInvitationRequest_a[this]=null
            set s__PartyInvitationRequest_t[this]=0
            call s__PartyInvitationRequest_deallocate(this)
        endfunction
        
        function s__PartyInvitationRequest_create takes player awaiting,integer target returns integer
            local integer this= s__PartyInvitationRequest_allocate()
            set s__PartyInvitationRequest_responses[GetPlayerId(awaiting) + ( 100 * GetPlayerId(s__Party_captain[target]) )]=this
            set s__PartyInvitationRequest_c[this]=s__Party_captain[target]
            set s__PartyInvitationRequest_a[this]=awaiting
            set s__PartyInvitationRequest_t[this]=target
            call DisplayTimedTextToPlayer((s__PartyInvitationRequest_c[this] ), 0, 0, (( 30 )*1.0), ( "|cff33ff33Party|r : " + GetPlayerNameColored(s__PartyInvitationRequest_a[this]) + " requests entrance to your party. \n         type \"#accept {color}\" to allow him or \"#reject {color}\" to block his requests for 5 minutes")) // INLINED!!
            
            return this
        endfunction
        function s__PartyInvitationRequest_no0 takes nothing returns nothing
            call s__PartyInvitationRequest_allocate()
        endfunction
        
        function s__PartyInvitationRequest_onPlayerLeave takes nothing returns boolean
            local integer p= (s__Party_p_perPlayer[GetPlayerId((GetTriggerPlayer()))]) // INLINED!!
            if ((s__Party_p_perPlayer[GetPlayerId((GetTriggerPlayer()))]) > 9) then // INLINED!!
                if (s__Party_captain[(p)] == (GetTriggerPlayer())) then // INLINED!!
                    call s__Party_onPartyDisband(GetTriggerPlayer())
                else
                    call s__Party_onPartyExit(GetTriggerPlayer())
                endif
            endif
            return false
        endfunction
        function s__PartyInvitationRequest_onChat takes nothing returns boolean
            local integer this
            local string msg= GetEventPlayerChatString()
            set msg=StringCase(msg, false)
            if SubString(msg, 0, 1) != "#" then
                return false
            endif
            if SubString(msg, 0, 7) == "#accept" and StringLength(msg) > 9 then
                set this=s__PartyInvitationRequest_responses[100 * GetPlayerId(GetTriggerPlayer()) + color2Number(SubString(msg, 8, StringLength(msg)))]
                if this == 0 then
                    call DisplayTimedTextToPlayer((GetTriggerPlayer() ), 0, 0, (( 30 )*1.0), ( "|cff33ff33Party|r : That player does not have a pending request to join your party")) // INLINED!!
                    return false
                endif
                if ((s__Party_p_perPlayer[GetPlayerId((Player(color2Number(SubString(msg, 8, StringLength(msg))))))])) > 10 then // INLINED!!
                    call DisplayTimedTextToPlayer((GetTriggerPlayer() ), 0, 0, (( 30 )*1.0), ( "|cff33ff33Party|r : That player has joined another party since the request has been sent")) // INLINED!!
                    call s__PartyInvitationRequest_destroy(this)
                    return false
                endif
                call DisplayTimedTextToPlayer(s__PartyInvitationRequest_a[this], 0, 0, 30, "|cff33ff33Party|r : You have joined " + GetPlayerNameColored(s__PartyInvitationRequest_c[this]) + "'s party")
                call s__Party_add(s__PartyInvitationRequest_t[this],s__PartyInvitationRequest_a[this])
                call s__PartyInvitationRequest_destroy(this)
            elseif SubString(msg, 0, 7) == "#reject" and StringLength(msg) > 10 then
                set this=s__PartyInvitationRequest_responses[100 * GetPlayerId(GetTriggerPlayer()) + color2Number(SubString(msg, 8, StringLength(msg)))]
                if this == 0 then
                    call DisplayTimedTextToPlayer((GetTriggerPlayer() ), 0, 0, (( 30 )*1.0), ( "|cff33ff33Party|r : That player does not have a pending request to join your party")) // INLINED!!
                    return false
                endif
                if ((s__Party_p_perPlayer[GetPlayerId((Player(color2Number(SubString(msg, 8, StringLength(msg))))))])) > 10 then // INLINED!!
                    call DisplayTimedTextToPlayer((GetTriggerPlayer() ), 0, 0, (( 30 )*1.0), ( "|cff33ff33Party|r : That player has joined another party since the request has been sent")) // INLINED!!
                    call s__PartyInvitationRequest_destroy(this)
                    return false
                endif
                call DisplayTimedTextToPlayer(s__PartyInvitationRequest_a[this], 0, 0, 30, "|cff33ff33Party|r : You have been rejected from your party request.")
                call s__PartyInvitationRequest_destroy(this)
            elseif SubString(msg, 0, 5) == "#join" and StringLength(msg) > 7 then
                if ((s__Party_p_perPlayer[GetPlayerId((GetTriggerPlayer()))])) > 10 then // INLINED!!
                    call DisplayTimedTextToPlayer((GetTriggerPlayer() ), 0, 0, (( 30 )*1.0), ( "|cff33ff33Party|r : You are currently in a party and cannot join another. Type \"#exit\" to leave your party")) // INLINED!!
                    return false
                endif
                if GetPlayerId(GetTriggerPlayer()) == color2Number(SubString(msg, 6, StringLength(msg))) then
                    call DisplayTimedTextToPlayer((GetTriggerPlayer() ), 0, 0, (( 30 )*1.0), ( "|cff33ff33Party|r : You cannot join your own party")) // INLINED!!
                    return false
                endif
                if ((s__Party_p_perPlayer[GetPlayerId((Player(color2Number(SubString(msg, 6, StringLength(msg))))))])) < 10 then // INLINED!!
                    call DisplayTimedTextToPlayer((GetTriggerPlayer() ), 0, 0, (( 30 )*1.0), ( "|cff33ff33Party|r : That player is currently not in a party")) // INLINED!!
                    return false
                endif
                call DisplayTimedTextToPlayer((GetTriggerPlayer() ), 0, 0, (( 30 )*1.0), ( "|cff33ff33Party|r : You have requested to join " + GetPlayerNameColored(Player(color2Number(SubString(msg, 6, StringLength(msg))))) + "'s party")) // INLINED!!
                call s__PartyInvitationRequest_create(GetTriggerPlayer() , (s__Party_p_perPlayer[GetPlayerId((Player(color2Number(SubString(msg, 6, StringLength(msg))))))])) // INLINED!!
            elseif SubString(msg, 0, 5) == "#form" then
                call s__Party_onPartyForm(GetTriggerPlayer())
            elseif SubString(msg, 0, 5) == "#exit" then
                call s__Party_onPartyExit(GetTriggerPlayer())
            elseif SubString(msg, 0, 8) == "#disband" then
                call s__Party_onPartyDisband(GetTriggerPlayer())
            endif
            return false
        endfunction
//Implemented from module PartyLib__init2:
        function s__PartyInvitationRequest_PartyLib__init2___onInit takes nothing returns nothing
            local integer i= 0
            local trigger t= CreateTrigger()
            local trigger t2= CreateTrigger()
            call s__PartyInvitationRequest_allocate() // INLINED!!
            loop
                exitwhen i == 10
                call TriggerRegisterPlayerChatEvent(t, Player(i), "#", false)
                call TriggerRegisterPlayerEvent(t2, Player(i), EVENT_PLAYER_LEAVE)
                set i=i + 1
            endloop
            call TriggerAddCondition(t, Filter(function s__PartyInvitationRequest_onChat))
            call TriggerAddCondition(t2, Filter(function s__PartyInvitationRequest_onPlayerLeave))
            set t2=null
            set t=null
        endfunction
    

//library PartyLib ends
//library RegisterPlayerUnitEvent:
    
    function RegisterPlayerUnitEvent takes playerunitevent p,code c returns nothing
        local integer i= GetHandleId(p)
        local integer k= 15
        if RegisterPlayerUnitEvent___t[i] == null then
            set RegisterPlayerUnitEvent___t[i]=CreateTrigger()
            loop
                call TriggerRegisterPlayerUnitEvent(RegisterPlayerUnitEvent___t[i], Player(k), p, null)
                exitwhen k == 0
                set k=k - 1
            endloop
        endif
        call TriggerAddCondition(RegisterPlayerUnitEvent___t[i], Filter(c))
    endfunction

//library RegisterPlayerUnitEvent ends
//library RemoveString:
    //removes all traces of a string from another string
    //0 means remove all
    //call RemoveString("123123","12",0,0) -> 33
    //call RemoveString("123-123","-",0,0) -> 123123
    
    //maxRemove is useful for removing an instance of a string once
    //call RemoveString("-load mau3-load -ffff","-load ",1,0) -> "mau3-load -ffff"
    function RemoveString takes string s,string str,integer maxRemove,integer start returns string
        local integer p= StringLength(str)
        local integer i= StringLength(s)
        local integer m= start
        if ( 0 < i ) then
            if ( 0 == maxRemove ) then
                set maxRemove=- 1
            endif
            loop
                exitwhen m == i or 0 == maxRemove
                if ( str == SubString(s, m, m + p) ) then
                    set maxRemove=maxRemove - 1
                    set s=SubString(s, 0, m) + SubString(s, m + p, StringLength(s))
                    set i=i - 1
                else
                    set m=m + 1
                endif
            endloop
        endif
        return s
    endfunction

//library RemoveString ends
//library SaveCodeToHD:
    function SaveCodeToHD__WriteLine takes string line returns nothing
        call Preload("\")\r\n\t\t" + line + "\r\n\t//(\"")
    endfunction
    constant function GetSaveGameFolder takes nothing returns string
        return "Fables of Elohim RPG"
    endfunction
    function SaveCodeToHD takes string mapver,integer playerId,string filename,string saveCode returns nothing
        local string onlineFolder= ""
        if ( SaveCodeToHD__isGameOnline ) then
            set onlineFolder="Online"
        else
            set onlineFolder="Offline"
        endif
        if GetPlayerId(GetLocalPlayer()) == playerId then
            call PreloadGenClear()
            call PreloadGenStart()
            call Preload("\")\r\n\t\t" + ("-load " + saveCode) + "\r\n\t//(\"") // INLINED!!
            call PreloadGenEnd(("Fables of Elohim RPG") + "\\" + mapver + "\\[" + onlineFolder + "] " + filename + ".txt") // INLINED!!
        endif
    endfunction
//Implemented from module SaveCodeToHD__Init:
        function s__SaveCodeToHD__InitS_SaveCodeToHD__Init___onInit takes nothing returns nothing
            local integer i= 11
            loop
                set SaveCodeToHD__playerName[i]=GetPlayerName(Player(i))
                exitwhen 0 == i
                set i=i - 1
            endloop
            
            set SaveCodeToHD__isGameOnline=not ReloadGameCachesFromDisk()
        endfunction

//library SaveCodeToHD ends
//library SimError:
//**************************************************************************************************
//*
//*  SimError
//*
//*     Mimic an interface error message
//*       call SimError(ForPlayer, msg)
//*         ForPlayer : The player to show the error
//*         msg       : The error
//*    
//*     To implement this function, copy this trigger and paste it in your map.
//* Unless of course you are actually reading the library from wc3c's scripts section, then just
//* paste the contents into some custom text trigger in your map.
//*
//**************************************************************************************************

//==================================================================================================
    //====================================================================================================

    function SimError takes player ForPlayer,string msg returns nothing
        set msg="\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n|cffffcc00" + msg + "|r"
        if ( GetLocalPlayer() == ForPlayer ) then
            call ClearTextMessages()
            call DisplayTimedTextToPlayer(ForPlayer, 0.52, 0.96, 2.00, msg)
            call StartSound(SimError___error)
        endif
    endfunction

    function SimError___init takes nothing returns nothing
         set SimError___error=CreateSoundFromLabel("InterfaceError", false, false, false, 10, 10)
         //call StartSound( error ) //apparently the bug in which you play a sound for the first time
                                    //and it doesn't work is not there anymore in patch 1.22
    endfunction


//library SimError ends
//library T32:
    
    //==============================================================================
    // The standard T32 module, T32x.
    //
    
    //==============================================================================
    // The standard T32 module with added safety checks on .startPeriodic() and
    // .stopPeriodic(), T32xs.
    //
    
    //==============================================================================
    // The original T32 module, for backwards compatability only.
    //
    
    //==============================================================================
    // System Core.
    //
    function T32___OnExpire takes nothing returns nothing
        set T32_Tick=T32_Tick + 1
        call TriggerEvaluate(T32___Trig)
    endfunction
    
    function T32___OnInit takes nothing returns nothing
        call TimerStart(CreateTimer(), T32_PERIOD, true, function T32___OnExpire)
    endfunction

//library T32 ends
//library T32API:

//library T32API ends
//library TTDemo:
    function TTDemo__init takes nothing returns nothing
        local integer a
        set a=sc__Button_create(1 , 1 , 0 , 'B00N' , 'B00N' , 10 , 5 , 2 , "Transformation " , "Transforms the hero into a vampire")
        call sc__Button_push(a)
        call sc__Button_reCreate(a,2 , 2 , 0 , 'B009' , 'B00C' , 10 , 5 , 2 , "Wall of Fire" , "|cffffcc00Description|r : Creates a wall of fire at the point that deals damage to all that stand in it. \n|cffff0000Requires : Level 2 Transformation|r")
        call sc__Button_createLink(a,1 , 1 , 2)
        call sc__Button_push(a)
        call sc__Button_reCreate(a,2 , 3 , 0 , 'B00J' , 'B00K' , 10 , 5 , 2 , "Axe (Passive)" , "|cffffcc00Description|r : Increases your physical damage by 50% \n|cffff0000Requires : Level 3 Wall of Fire|r")
        call sc__Button_createLink(a,2 , 2 , 3)
        call sc__Button_push(a)
        call sc__Button_reCreate(a,2 , 4 , 0 , 'B00D' , 'B00H' , 10 , 5 , 2 , "Finger of Death" , "|cffffcc00Description|r : Eradicate that scum!. \n|cffff0000Requires : Level 4 Axe|r")
        call sc__Button_createLink(a,2 , 3 , 4)
        call sc__Button_push(a)
        call sc__Button_reCreate(a,2 , 5 , 0 , 'B00I' , 'B00L' , 10 , 5 , 2 , "Strength! (Passive)" , "|cffffcc00Description|r : Increases your strength by 25%. \n|cffff0000Requires : Level 5 Finger of Death|r")
        call sc__Button_createLink(a,2 , 4 , 5)
        call sc__Button_push(a)
        call sc__Button_reCreate(a,14 , 7 , 0 , 'B00V' , 'B00W' , 10 , 5 , 2 , "Next Menu" , "|cffffcc00Description|r : The Runemaster creates a ward that periodically releases frost novas")
        set s__Button_is[(a)]=(true) // INLINED!!
        set s__Button_data[(a)]=(1) // INLINED!!
        call sc__Button_push(a)
        call sc__Button_reCreate(a,0 , 0 , 1 , 'B00O' , 'B00M' , 10 , 5 , 2 , "Chilling Revival" , "|cffffcc00Description|r : Explodes a corpse with ice, dealing damage and slowing all nearby enemies. \n|cffffcc00Can be Autocast|r")
        call sc__Button_createLink(a,1 , 0 , 5)
        call sc__Button_push(a)
        call sc__Button_reCreate(a,0 , 1 , 1 , 'B009' , 'B00N' , 10 , 5 , 2 , "Ice Tremor" , "|cffffcc00Description|r : Ice breaks out at random points near the caster, chilling any who stand near it. Targets directly in the path of the ice are frozen for 3 seconds. \n|cffff0000Requires : Level 3 Chilling Revival|r")
        call sc__Button_createLink(a,0 , 0 , 5)
        call sc__Button_push(a)
        call sc__Button_reCreate(a,0 , 2 , 1 , 'B00R' , 'B00S' , 10 , 5 , 2 , "Snowball" , "|cffffcc00Description|r : Shoots a massive ball of ice towards the target, knockbacking any targets in its path and exploding at its end for extra damage. \n|cffff0000Requires : Level 1 Ice Tremor|r")
        call sc__Button_createLink(a,1 , 1 , 5)
        call sc__Button_createLink(a,1 , 3 , 5)
        call sc__Button_push(a)
        call sc__Button_reCreate(a,1 , 0 , 1 , 'B00T' , 'B00U' , 10 , 5 , 2 , "Death by Chocolate" , "|cffffcc00Description|r : The Runemaster conjures an iceicle and sends it to the target.")
        call sc__Button_push(a)
        call sc__Button_reCreate(a,1 , 1 , 1 , 'B00T' , 'B00U' , 10 , 5 , 2 , "Death by Chocolate" , "|cffffcc00Description|r : The Runemaster conjures an iceicle and sends it to the target.")
        call sc__Button_push(a)
        call sc__Button_reCreate(a,1 , 3 , 1 , 'B00V' , 'B00W' , 10 , 5 , 2 , "Frost Ward" , "|cffffcc00Description|r : The Runemaster creates a ward that periodically releases frost novas")
        call sc__Button_createLink(a,0 , 0 , 5)
        call sc__Button_push(a)
        call sc__Button_reCreate(a,14 , 7 , 1 , 'B00V' , 'B00W' , 10 , 5 , 2 , "Next Menu" , "|cffffcc00Description|r : The Runemaster creates a ward that periodically releases frost novas")
        set s__Button_is[(a)]=(true) // INLINED!!
        set s__Button_data[(a)]=(0) // INLINED!!
        call sc__Button_push(a)
    //    call a.reCreate(2,2,1,'B009','B009',10,5,2,"firefirefire","Transforms tfirehe hero into a vampire")
     //   call a.createLink(0,0,0)
      //  call a.push()
 //       call VJassTalentTree.showUI(Player(0),0)*/
    endfunction

//library TTDemo ends
//library Table:
    
    
    function s__Table___dex__get_size takes nothing returns integer
        return Table___sizeK
    endfunction
    function s__Table___dex__get_list takes nothing returns integer
        return Table___listK
    endfunction
    
    function s__Table___handles_has takes integer this,integer key returns boolean
        return HaveSavedHandle(Table___ht, this, key)
    endfunction
    function s__Table___handles_remove takes integer this,integer key returns nothing
        call RemoveSavedHandle(Table___ht, this, key)
    endfunction
    
    function s__Table___agents__setindex takes integer this,integer key,agent value returns nothing
        call SaveAgentHandle(Table___ht, this, key, value)
    endfunction
    
    
    
//Run these textmacros to include the entire hashtable API as wrappers.
//Don't be intimidated by the number of macros - Vexorian's map optimizer is
//supposed to kill functions which inline (all of these functions inline).
//textmacro instance: NEW_ARRAY_BASIC("Real", "Real", "real")
    function s__Table___reals__getindex takes integer this,integer key returns real
        return LoadReal(Table___ht, this, key)
    endfunction
    function s__Table___reals__setindex takes integer this,integer key,real value returns nothing
        call SaveReal(Table___ht, this, key, value)
    endfunction
    function s__Table___reals_has takes integer this,integer key returns boolean
        return HaveSavedReal(Table___ht, this, key)
    endfunction
    function s__Table___reals_remove takes integer this,integer key returns nothing
        call RemoveSavedReal(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY_BASIC("Real", "Real", "real")
//textmacro instance: NEW_ARRAY_BASIC("Boolean", "Boolean", "boolean")
    function s__Table___booleans__getindex takes integer this,integer key returns boolean
        return LoadBoolean(Table___ht, this, key)
    endfunction
    function s__Table___booleans__setindex takes integer this,integer key,boolean value returns nothing
        call SaveBoolean(Table___ht, this, key, value)
    endfunction
    function s__Table___booleans_has takes integer this,integer key returns boolean
        return HaveSavedBoolean(Table___ht, this, key)
    endfunction
    function s__Table___booleans_remove takes integer this,integer key returns nothing
        call RemoveSavedBoolean(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY_BASIC("Boolean", "Boolean", "boolean")
//textmacro instance: NEW_ARRAY_BASIC("String", "Str", "string")
    function s__Table___strings__getindex takes integer this,integer key returns string
        return LoadStr(Table___ht, this, key)
    endfunction
    function s__Table___strings__setindex takes integer this,integer key,string value returns nothing
        call SaveStr(Table___ht, this, key, value)
    endfunction
    function s__Table___strings_has takes integer this,integer key returns boolean
        return HaveSavedString(Table___ht, this, key)
    endfunction
    function s__Table___strings_remove takes integer this,integer key returns nothing
        call RemoveSavedString(Table___ht, this, key)
    endfunction
//end of: NEW_ARRAY_BASIC("String", "Str", "string")
    
//textmacro instance: NEW_ARRAY("Player", "player")
    function s__Table___players__getindex takes integer this,integer key returns player
        return LoadPlayerHandle(Table___ht, this, key)
    endfunction
    function s__Table___players__setindex takes integer this,integer key,player value returns nothing
        call SavePlayerHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Player", "player")
//textmacro instance: NEW_ARRAY("Widget", "widget")
    function s__Table___widgets__getindex takes integer this,integer key returns widget
        return LoadWidgetHandle(Table___ht, this, key)
    endfunction
    function s__Table___widgets__setindex takes integer this,integer key,widget value returns nothing
        call SaveWidgetHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Widget", "widget")
//textmacro instance: NEW_ARRAY("Destructable", "destructable")
    function s__Table___destructables__getindex takes integer this,integer key returns destructable
        return LoadDestructableHandle(Table___ht, this, key)
    endfunction
    function s__Table___destructables__setindex takes integer this,integer key,destructable value returns nothing
        call SaveDestructableHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Destructable", "destructable")
//textmacro instance: NEW_ARRAY("Item", "item")
    function s__Table___items__getindex takes integer this,integer key returns item
        return LoadItemHandle(Table___ht, this, key)
    endfunction
    function s__Table___items__setindex takes integer this,integer key,item value returns nothing
        call SaveItemHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Item", "item")
//textmacro instance: NEW_ARRAY("Unit", "unit")
    function s__Table___units__getindex takes integer this,integer key returns unit
        return LoadUnitHandle(Table___ht, this, key)
    endfunction
    function s__Table___units__setindex takes integer this,integer key,unit value returns nothing
        call SaveUnitHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Unit", "unit")
//textmacro instance: NEW_ARRAY("Ability", "ability")
    function s__Table___abilitys__getindex takes integer this,integer key returns ability
        return LoadAbilityHandle(Table___ht, this, key)
    endfunction
    function s__Table___abilitys__setindex takes integer this,integer key,ability value returns nothing
        call SaveAbilityHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Ability", "ability")
//textmacro instance: NEW_ARRAY("Timer", "timer")
    function s__Table___timers__getindex takes integer this,integer key returns timer
        return LoadTimerHandle(Table___ht, this, key)
    endfunction
    function s__Table___timers__setindex takes integer this,integer key,timer value returns nothing
        call SaveTimerHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Timer", "timer")
//textmacro instance: NEW_ARRAY("Trigger", "trigger")
    function s__Table___triggers__getindex takes integer this,integer key returns trigger
        return LoadTriggerHandle(Table___ht, this, key)
    endfunction
    function s__Table___triggers__setindex takes integer this,integer key,trigger value returns nothing
        call SaveTriggerHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Trigger", "trigger")
//textmacro instance: NEW_ARRAY("TriggerCondition", "triggercondition")
    function s__Table___triggerconditions__getindex takes integer this,integer key returns triggercondition
        return LoadTriggerConditionHandle(Table___ht, this, key)
    endfunction
    function s__Table___triggerconditions__setindex takes integer this,integer key,triggercondition value returns nothing
        call SaveTriggerConditionHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("TriggerCondition", "triggercondition")
//textmacro instance: NEW_ARRAY("TriggerAction", "triggeraction")
    function s__Table___triggeractions__getindex takes integer this,integer key returns triggeraction
        return LoadTriggerActionHandle(Table___ht, this, key)
    endfunction
    function s__Table___triggeractions__setindex takes integer this,integer key,triggeraction value returns nothing
        call SaveTriggerActionHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("TriggerAction", "triggeraction")
//textmacro instance: NEW_ARRAY("TriggerEvent", "event")
    function s__Table___events__getindex takes integer this,integer key returns event
        return LoadTriggerEventHandle(Table___ht, this, key)
    endfunction
    function s__Table___events__setindex takes integer this,integer key,event value returns nothing
        call SaveTriggerEventHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("TriggerEvent", "event")
//textmacro instance: NEW_ARRAY("Force", "force")
    function s__Table___forces__getindex takes integer this,integer key returns force
        return LoadForceHandle(Table___ht, this, key)
    endfunction
    function s__Table___forces__setindex takes integer this,integer key,force value returns nothing
        call SaveForceHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Force", "force")
//textmacro instance: NEW_ARRAY("Group", "group")
    function s__Table___groups__getindex takes integer this,integer key returns group
        return LoadGroupHandle(Table___ht, this, key)
    endfunction
    function s__Table___groups__setindex takes integer this,integer key,group value returns nothing
        call SaveGroupHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Group", "group")
//textmacro instance: NEW_ARRAY("Location", "location")
    function s__Table___locations__getindex takes integer this,integer key returns location
        return LoadLocationHandle(Table___ht, this, key)
    endfunction
    function s__Table___locations__setindex takes integer this,integer key,location value returns nothing
        call SaveLocationHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Location", "location")
//textmacro instance: NEW_ARRAY("Rect", "rect")
    function s__Table___rects__getindex takes integer this,integer key returns rect
        return LoadRectHandle(Table___ht, this, key)
    endfunction
    function s__Table___rects__setindex takes integer this,integer key,rect value returns nothing
        call SaveRectHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Rect", "rect")
//textmacro instance: NEW_ARRAY("BooleanExpr", "boolexpr")
    function s__Table___boolexprs__getindex takes integer this,integer key returns boolexpr
        return LoadBooleanExprHandle(Table___ht, this, key)
    endfunction
    function s__Table___boolexprs__setindex takes integer this,integer key,boolexpr value returns nothing
        call SaveBooleanExprHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("BooleanExpr", "boolexpr")
//textmacro instance: NEW_ARRAY("Sound", "sound")
    function s__Table___sounds__getindex takes integer this,integer key returns sound
        return LoadSoundHandle(Table___ht, this, key)
    endfunction
    function s__Table___sounds__setindex takes integer this,integer key,sound value returns nothing
        call SaveSoundHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Sound", "sound")
//textmacro instance: NEW_ARRAY("Effect", "effect")
    function s__Table___effects__getindex takes integer this,integer key returns effect
        return LoadEffectHandle(Table___ht, this, key)
    endfunction
    function s__Table___effects__setindex takes integer this,integer key,effect value returns nothing
        call SaveEffectHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Effect", "effect")
//textmacro instance: NEW_ARRAY("UnitPool", "unitpool")
    function s__Table___unitpools__getindex takes integer this,integer key returns unitpool
        return LoadUnitPoolHandle(Table___ht, this, key)
    endfunction
    function s__Table___unitpools__setindex takes integer this,integer key,unitpool value returns nothing
        call SaveUnitPoolHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("UnitPool", "unitpool")
//textmacro instance: NEW_ARRAY("ItemPool", "itempool")
    function s__Table___itempools__getindex takes integer this,integer key returns itempool
        return LoadItemPoolHandle(Table___ht, this, key)
    endfunction
    function s__Table___itempools__setindex takes integer this,integer key,itempool value returns nothing
        call SaveItemPoolHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("ItemPool", "itempool")
//textmacro instance: NEW_ARRAY("Quest", "quest")
    function s__Table___quests__getindex takes integer this,integer key returns quest
        return LoadQuestHandle(Table___ht, this, key)
    endfunction
    function s__Table___quests__setindex takes integer this,integer key,quest value returns nothing
        call SaveQuestHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Quest", "quest")
//textmacro instance: NEW_ARRAY("QuestItem", "questitem")
    function s__Table___questitems__getindex takes integer this,integer key returns questitem
        return LoadQuestItemHandle(Table___ht, this, key)
    endfunction
    function s__Table___questitems__setindex takes integer this,integer key,questitem value returns nothing
        call SaveQuestItemHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("QuestItem", "questitem")
//textmacro instance: NEW_ARRAY("DefeatCondition", "defeatcondition")
    function s__Table___defeatconditions__getindex takes integer this,integer key returns defeatcondition
        return LoadDefeatConditionHandle(Table___ht, this, key)
    endfunction
    function s__Table___defeatconditions__setindex takes integer this,integer key,defeatcondition value returns nothing
        call SaveDefeatConditionHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("DefeatCondition", "defeatcondition")
//textmacro instance: NEW_ARRAY("TimerDialog", "timerdialog")
    function s__Table___timerdialogs__getindex takes integer this,integer key returns timerdialog
        return LoadTimerDialogHandle(Table___ht, this, key)
    endfunction
    function s__Table___timerdialogs__setindex takes integer this,integer key,timerdialog value returns nothing
        call SaveTimerDialogHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("TimerDialog", "timerdialog")
//textmacro instance: NEW_ARRAY("Leaderboard", "leaderboard")
    function s__Table___leaderboards__getindex takes integer this,integer key returns leaderboard
        return LoadLeaderboardHandle(Table___ht, this, key)
    endfunction
    function s__Table___leaderboards__setindex takes integer this,integer key,leaderboard value returns nothing
        call SaveLeaderboardHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Leaderboard", "leaderboard")
//textmacro instance: NEW_ARRAY("Multiboard", "multiboard")
    function s__Table___multiboards__getindex takes integer this,integer key returns multiboard
        return LoadMultiboardHandle(Table___ht, this, key)
    endfunction
    function s__Table___multiboards__setindex takes integer this,integer key,multiboard value returns nothing
        call SaveMultiboardHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Multiboard", "multiboard")
//textmacro instance: NEW_ARRAY("MultiboardItem", "multiboarditem")
    function s__Table___multiboarditems__getindex takes integer this,integer key returns multiboarditem
        return LoadMultiboardItemHandle(Table___ht, this, key)
    endfunction
    function s__Table___multiboarditems__setindex takes integer this,integer key,multiboarditem value returns nothing
        call SaveMultiboardItemHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("MultiboardItem", "multiboarditem")
//textmacro instance: NEW_ARRAY("Trackable", "trackable")
    function s__Table___trackables__getindex takes integer this,integer key returns trackable
        return LoadTrackableHandle(Table___ht, this, key)
    endfunction
    function s__Table___trackables__setindex takes integer this,integer key,trackable value returns nothing
        call SaveTrackableHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Trackable", "trackable")
//textmacro instance: NEW_ARRAY("Dialog", "dialog")
    function s__Table___dialogs__getindex takes integer this,integer key returns dialog
        return LoadDialogHandle(Table___ht, this, key)
    endfunction
    function s__Table___dialogs__setindex takes integer this,integer key,dialog value returns nothing
        call SaveDialogHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Dialog", "dialog")
//textmacro instance: NEW_ARRAY("Button", "button")
    function s__Table___buttons__getindex takes integer this,integer key returns button
        return LoadButtonHandle(Table___ht, this, key)
    endfunction
    function s__Table___buttons__setindex takes integer this,integer key,button value returns nothing
        call SaveButtonHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Button", "button")
//textmacro instance: NEW_ARRAY("TextTag", "texttag")
    function s__Table___texttags__getindex takes integer this,integer key returns texttag
        return LoadTextTagHandle(Table___ht, this, key)
    endfunction
    function s__Table___texttags__setindex takes integer this,integer key,texttag value returns nothing
        call SaveTextTagHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("TextTag", "texttag")
//textmacro instance: NEW_ARRAY("Lightning", "lightning")
    function s__Table___lightnings__getindex takes integer this,integer key returns lightning
        return LoadLightningHandle(Table___ht, this, key)
    endfunction
    function s__Table___lightnings__setindex takes integer this,integer key,lightning value returns nothing
        call SaveLightningHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Lightning", "lightning")
//textmacro instance: NEW_ARRAY("Image", "image")
    function s__Table___images__getindex takes integer this,integer key returns image
        return LoadImageHandle(Table___ht, this, key)
    endfunction
    function s__Table___images__setindex takes integer this,integer key,image value returns nothing
        call SaveImageHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Image", "image")
//textmacro instance: NEW_ARRAY("Ubersplat", "ubersplat")
    function s__Table___ubersplats__getindex takes integer this,integer key returns ubersplat
        return LoadUbersplatHandle(Table___ht, this, key)
    endfunction
    function s__Table___ubersplats__setindex takes integer this,integer key,ubersplat value returns nothing
        call SaveUbersplatHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Ubersplat", "ubersplat")
//textmacro instance: NEW_ARRAY("Region", "region")
    function s__Table___regions__getindex takes integer this,integer key returns region
        return LoadRegionHandle(Table___ht, this, key)
    endfunction
    function s__Table___regions__setindex takes integer this,integer key,region value returns nothing
        call SaveRegionHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Region", "region")
//textmacro instance: NEW_ARRAY("FogState", "fogstate")
    function s__Table___fogstates__getindex takes integer this,integer key returns fogstate
        return LoadFogStateHandle(Table___ht, this, key)
    endfunction
    function s__Table___fogstates__setindex takes integer this,integer key,fogstate value returns nothing
        call SaveFogStateHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("FogState", "fogstate")
//textmacro instance: NEW_ARRAY("FogModifier", "fogmodifier")
    function s__Table___fogmodifiers__getindex takes integer this,integer key returns fogmodifier
        return LoadFogModifierHandle(Table___ht, this, key)
    endfunction
    function s__Table___fogmodifiers__setindex takes integer this,integer key,fogmodifier value returns nothing
        call SaveFogModifierHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("FogModifier", "fogmodifier")
//textmacro instance: NEW_ARRAY("Hashtable", "hashtable")
    function s__Table___hashtables__getindex takes integer this,integer key returns hashtable
        return LoadHashtableHandle(Table___ht, this, key)
    endfunction
    function s__Table___hashtables__setindex takes integer this,integer key,hashtable value returns nothing
        call SaveHashtableHandle(Table___ht, this, key, value)
    endfunction
//end of: NEW_ARRAY("Hashtable", "hashtable")
    
    
    // Implement modules for intuitive syntax (tb.handle; tb.unit; etc.)
//Implemented from module Table___realm:
    function s__Table__get_real takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___booleanm:
    function s__Table__get_boolean takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___stringm:
    function s__Table__get_string takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___playerm:
    function s__Table__get_player takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___widgetm:
    function s__Table__get_widget takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___destructablem:
    function s__Table__get_destructable takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___itemm:
    function s__Table__get_item takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___unitm:
    function s__Table__get_unit takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___abilitym:
    function s__Table__get_ability takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___timerm:
    function s__Table__get_timer takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___triggerm:
    function s__Table__get_trigger takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___triggerconditionm:
    function s__Table__get_triggercondition takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___triggeractionm:
    function s__Table__get_triggeraction takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___eventm:
    function s__Table__get_event takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___forcem:
    function s__Table__get_force takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___groupm:
    function s__Table__get_group takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___locationm:
    function s__Table__get_location takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___rectm:
    function s__Table__get_rect takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___boolexprm:
    function s__Table__get_boolexpr takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___soundm:
    function s__Table__get_sound takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___effectm:
    function s__Table__get_effect takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___unitpoolm:
    function s__Table__get_unitpool takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___itempoolm:
    function s__Table__get_itempool takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___questm:
    function s__Table__get_quest takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___questitemm:
    function s__Table__get_questitem takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___defeatconditionm:
    function s__Table__get_defeatcondition takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___timerdialogm:
    function s__Table__get_timerdialog takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___leaderboardm:
    function s__Table__get_leaderboard takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___multiboardm:
    function s__Table__get_multiboard takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___multiboarditemm:
    function s__Table__get_multiboarditem takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___trackablem:
    function s__Table__get_trackable takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___dialogm:
    function s__Table__get_dialog takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___buttonm:
    function s__Table__get_button takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___texttagm:
    function s__Table__get_texttag takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___lightningm:
    function s__Table__get_lightning takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___imagem:
    function s__Table__get_image takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___ubersplatm:
    function s__Table__get_ubersplat takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___regionm:
    function s__Table__get_region takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___fogstatem:
    function s__Table__get_fogstate takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___fogmodifierm:
    function s__Table__get_fogmodifier takes integer this returns integer
        return this
    endfunction
//Implemented from module Table___hashtablem:
    function s__Table__get_hashtable takes integer this returns integer
        return this
    endfunction
    
    function s__Table__get_handle takes integer this returns integer
        return this
    endfunction
    
    function s__Table__get_agent takes integer this returns integer
        return this
    endfunction
    
    //set this = tb[GetSpellAbilityId()]
    function s__Table__getindex takes integer this,integer key returns integer
        return LoadInteger(Table___ht, this, key)
    endfunction
    
    //set tb[389034] = 8192
    function s__Table__setindex takes integer this,integer key,integer tb returns nothing
        call SaveInteger(Table___ht, this, key, tb)
    endfunction
    
    //set b = tb.has(2493223)
    function s__Table_has takes integer this,integer key returns boolean
        return HaveSavedInteger(Table___ht, this, key)
    endfunction
    
    //call tb.remove(294080)
    function s__Table_remove takes integer this,integer key returns nothing
        call RemoveSavedInteger(Table___ht, this, key)
    endfunction
    
    //Remove all data from a Table instance
    function s__Table_flush takes integer this returns nothing
        call FlushChildHashtable(Table___ht, this)
    endfunction
    
    //local Table tb = Table.create()
    function s__Table_create takes nothing returns integer
        local integer this= (LoadInteger(Table___ht, ((Table___listK)), (0))) // INLINED!!
        
        if this == 0 then
            set this=Table___more + 1
            set Table___more=this
        else
            call SaveInteger(Table___ht, ((Table___listK)), (0), ( (LoadInteger(Table___ht, ((Table___listK)), (this))))) // INLINED!!
            call RemoveSavedInteger(Table___ht, ((Table___listK)), (this)) //Clear hashed memory // INLINED!!
        endif
        
        return this
    endfunction
    
    // Removes all data from a Table instance and recycles its index.
    //
    //     call tb.destroy()
    //
    function s__Table_destroy takes integer this returns nothing
        
        call FlushChildHashtable(Table___ht, (this)) // INLINED!!
        
        call SaveInteger(Table___ht, ((Table___listK)), (this), ( (LoadInteger(Table___ht, ((Table___listK)), (0))))) // INLINED!!
        call SaveInteger(Table___ht, ((Table___listK)), (0), ( this)) // INLINED!!
    endfunction
    
//ignored textmacro command: TABLE_BC_METHODS()
    
//ignored textmacro command: TABLE_BC_STRUCTS()
    
    
    //Returns a new TableArray to do your bidding. Simply use:
    //
    //    local TableArray ta = TableArray[array_size]
    //
    function s__TableArray__staticgetindex takes integer array_size returns integer
        local integer tb= (LoadInteger(Table___ht, ((Table___sizeK)), (array_size))) // INLINED!!
        local integer this= (LoadInteger(Table___ht, (tb), (0))) // INLINED!!
        
        if array_size <= 0 then
            call BJDebugMsg("TypeError: Invalid specified TableArray size: " + I2S(array_size))
            return 0
        endif
        
        //if this == 0 then 
            set this=Table___less - array_size
            set Table___less=this
       // else
        //    call print("LastDest was before:"+I2S(tb[0]))
        //    set tb[0] = tb[this]  //Set the last destroyed to the last-last destroyed
        //    call tb.remove(this)  //Clear hashed memory
        //endif
        
        call SaveInteger(Table___ht, ((Table___sizeK)), (this), ( array_size)) //This remembers the array size // INLINED!!
        return this
    endfunction
    
    //Returns the size of the TableArray
    function s__TableArray__get_size takes integer this returns integer
        return (LoadInteger(Table___ht, ((Table___sizeK)), (this))) // INLINED!!
    endfunction
    
    //This magic method enables two-dimensional[array][syntax] for Tables,
    //similar to the two-dimensional utility provided by hashtables them-
    //selves.
    //
    //ta[integer a].unit[integer b] = unit u
    //ta[integer a][integer c] = integer d
    //
    //Inline-friendly when not running in debug mode
    //
    function s__TableArray__getindex takes integer this,integer key returns integer










        return this + key
    endfunction
    
    //Destroys a TableArray without flushing it; I assume you call .flush()
    //if you want it flushed too. This is a public method so that you don't
    //have to loop through all TableArray indices to flush them if you don't
    //need to (ie. if you were flushing all child-keys as you used them).
    //
    function s__TableArray_destroy takes integer this returns nothing
        local integer tb= (LoadInteger(Table___ht, ((Table___sizeK)), ((LoadInteger(Table___ht, ((Table___sizeK)), ((this))))))) // INLINED!!
        
        
        if tb == 0 then
            //Create a Table to index recycled instances with their array size
            set tb=s__Table_create()
            call SaveInteger(Table___ht, ((Table___sizeK)), ((LoadInteger(Table___ht, ((Table___sizeK)), ((this))))), ( tb)) // INLINED!!
        endif
        
        call RemoveSavedInteger(Table___ht, ((Table___sizeK)), (this)) //Clear the array size from hash memory // INLINED!!
        
        call SaveInteger(Table___ht, (tb), (this), ( (LoadInteger(Table___ht, (tb), (0))))) // INLINED!!
        call SaveInteger(Table___ht, (tb), (0), ( this)) // INLINED!!
    endfunction
    
    
    //Avoids hitting the op limit
    function s__TableArray_clean takes nothing returns nothing
        local integer tb= s__TableArray_tempTable
        local integer end= tb + 0x1000
        if end < s__TableArray_tempEnd then
            set s__TableArray_tempTable=end
            call ForForce(bj_FORCE_PLAYER[0], function s__TableArray_clean)
        else
            set end=s__TableArray_tempEnd
        endif
        loop
            call FlushChildHashtable(Table___ht, (tb)) // INLINED!!
            set tb=tb + 1
            exitwhen tb == end
        endloop
    endfunction
    
    //Flushes the TableArray and also destroys it. Doesn't get any more
    //similar to the FlushParentHashtable native than this.
    //
    function s__TableArray_flush takes integer this returns nothing
        set s__TableArray_tempTable=this
        set s__TableArray_tempEnd=this + (LoadInteger(Table___ht, ((Table___sizeK)), ((this)))) // INLINED!!
        call ForForce(bj_FORCE_PLAYER[0], function s__TableArray_clean)
        call s__TableArray_destroy(this)
    endfunction
    
    

//library Table ends
//library TerrainPathability:
//******************************************************************************
//* BY: Rising_Dusk
//* 
//* This script can be used to detect the type of pathing at a specific point.
//* It is valuable to do it this way because the IsTerrainPathable is very
//* counterintuitive and returns in odd ways and aren't always as you would
//* expect. This library, however, facilitates detecting those things reliably
//* and easily.
//* 
//******************************************************************************
//* 
//*    > function IsTerrainDeepWater    takes real x, real y returns boolean
//*    > function IsTerrainShallowWater takes real x, real y returns boolean
//*    > function IsTerrainLand         takes real x, real y returns boolean
//*    > function IsTerrainPlatform     takes real x, real y returns boolean
//*    > function IsTerrainWalkable     takes real x, real y returns boolean
//* 
//* These functions return true if the given point is of the type specified
//* in the function's name and false if it is not. For the IsTerrainWalkable
//* function, the MAX_RANGE constant below is the maximum deviation range from
//* the supplied coordinates that will still return true.
//* 
//* The IsTerrainPlatform works for any preplaced walkable destructable. It will
//* return true over bridges, destructable ramps, elevators, and invisible
//* platforms. Walkable destructables created at runtime do not create the same
//* pathing hole as preplaced ones do, so this will return false for them. All
//* other functions except IsTerrainWalkable return false for platforms, because
//* the platform itself erases their pathing when the map is saved.
//* 
//* After calling IsTerrainWalkable(x, y), the following two global variables
//* gain meaning. They return the X and Y coordinates of the nearest walkable
//* point to the specified coordinates. These will only deviate from the
//* IsTerrainWalkable function arguments if the function returned false.
//* 
//* Variables that can be used from the library:
//*     [real]    TerrainPathability_X
//*     [real]    TerrainPathability_Y
//* 


function IsTerrainDeepWater takes real x,real y returns boolean
    return not IsTerrainPathable(x, y, PATHING_TYPE_FLOATABILITY) and IsTerrainPathable(x, y, PATHING_TYPE_WALKABILITY)
endfunction
function IsTerrainShallowWater takes real x,real y returns boolean
    return not IsTerrainPathable(x, y, PATHING_TYPE_FLOATABILITY) and not IsTerrainPathable(x, y, PATHING_TYPE_WALKABILITY) and IsTerrainPathable(x, y, PATHING_TYPE_BUILDABILITY)
endfunction
function IsTerrainLand takes real x,real y returns boolean
    return IsTerrainPathable(x, y, PATHING_TYPE_FLOATABILITY)
endfunction
function IsTerrainPlatform takes real x,real y returns boolean
    return not IsTerrainPathable(x, y, PATHING_TYPE_FLOATABILITY) and not IsTerrainPathable(x, y, PATHING_TYPE_WALKABILITY) and not IsTerrainPathable(x, y, PATHING_TYPE_BUILDABILITY)
endfunction

function TerrainPathability___HideItem takes nothing returns nothing
    if IsItemVisible(GetEnumItem()) then
        set TerrainPathability___Hid[TerrainPathability___HidMax]=GetEnumItem()
        call SetItemVisible(TerrainPathability___Hid[TerrainPathability___HidMax], false)
        set TerrainPathability___HidMax=TerrainPathability___HidMax + 1
    endif
endfunction
function IsTerrainWalkable takes real x,real y returns boolean
    //Hide any items in the area to avoid conflicts with our item
    call MoveRectTo(TerrainPathability___Find, x, y)
    call EnumItemsInRect(TerrainPathability___Find, null, function TerrainPathability___HideItem)
    //Try to move the test item and get its coords
    call SetItemPosition(TerrainPathability___Item, x, y) //Unhides the item
    set TerrainPathability_X=GetItemX(TerrainPathability___Item)
    set TerrainPathability_Y=GetItemY(TerrainPathability___Item)





    call SetItemVisible(TerrainPathability___Item, false) //Hide it again
    //Unhide any items hidden at the start
    loop
        exitwhen TerrainPathability___HidMax <= 0
        set TerrainPathability___HidMax=TerrainPathability___HidMax - 1
        call SetItemVisible(TerrainPathability___Hid[TerrainPathability___HidMax], true)
        set TerrainPathability___Hid[TerrainPathability___HidMax]=null
    endloop
    //Return walkability
    return ( TerrainPathability_X - x ) * ( TerrainPathability_X - x ) + ( TerrainPathability_Y - y ) * ( TerrainPathability_Y - y ) <= TerrainPathability___MAX_RANGE * TerrainPathability___MAX_RANGE and not IsTerrainPathable(x, y, PATHING_TYPE_WALKABILITY)
endfunction

function TerrainPathability___Init takes nothing returns nothing
    set TerrainPathability___Find=Rect(0., 0., 128., 128.)
    set TerrainPathability___Item=CreateItem(TerrainPathability___DUMMY_ITEM_ID, 0, 0)
    call SetItemVisible(TerrainPathability___Item, false)
endfunction

//library TerrainPathability ends
//library TimedLightnings:

    
    
        
        
        
        
        function s__TimedL_destroyL takes nothing returns nothing
        
            set s__TimedL_dat3=s__TimedL_prev[s__TimedL_dat2]
            set s__TimedL_next[s__TimedL_dat3]=s__TimedL_next[s__TimedL_dat2]
        
            if s__TimedL_dat2 == s__TimedL_rlast then
                set s__TimedL_rlast=s__TimedL_dat3
            endif
        
        
            set s__TimedL_dat3=s__TimedL_next[s__TimedL_dat2]
            set s__TimedL_prev[s__TimedL_dat3]=s__TimedL_prev[s__TimedL_dat2]
        
            if s__TimedL_dat2 == s__TimedL_first then
                set s__TimedL_first=s__TimedL_dat3
            endif
            
            call DestroyLightning(s__TimedL_l[s__TimedL_dat2])
            set TimedLightnings___CT=TimedLightnings___CT - 1
            if TimedLightnings___CT == 0 then
                call PauseTimer(TimedLightnings___TMR)
            endif
            set s__TimedL_rn[s__TimedL_dat2]=s__TimedL_ir
            set s__TimedL_ir=s__TimedL_dat2
        endfunction
        
        function s__TimedL_looping takes nothing returns nothing
            local real z1
            local real z2
            set s__TimedL_dat=s__TimedL_first
            loop
                set z1=0
                set z2=0
                set s__TimedL_time[s__TimedL_dat]=s__TimedL_time[s__TimedL_dat] - 1
                if s__TimedL_da[s__TimedL_dat] != 0 then
                    set s__TimedL_av[s__TimedL_dat]=s__TimedL_av[s__TimedL_dat] - s__TimedL_da[s__TimedL_dat]
                    call SetLightningColor(s__TimedL_l[s__TimedL_dat], 1, 1, 1, s__TimedL_av[s__TimedL_dat])
                endif
                if s__TimedL_s[s__TimedL_dat] == null then
                    if s__TimedL_dx1[s__TimedL_dat] != 0 then
                        set s__TimedL_x1[s__TimedL_dat]=s__TimedL_x1[s__TimedL_dat] + s__TimedL_dx1[s__TimedL_dat]
                    endif
                    if s__TimedL_dy1[s__TimedL_dat] != 0 then
                        set s__TimedL_y1[s__TimedL_dat]=s__TimedL_y1[s__TimedL_dat] + s__TimedL_dy1[s__TimedL_dat]
                    endif
                    if s__TimedL_dz1[s__TimedL_dat] != 0 then
                        set s__TimedL_z1[s__TimedL_dat]=s__TimedL_z1[s__TimedL_dat] + s__TimedL_dz1[s__TimedL_dat]
                    endif
                else
                    set s__TimedL_x1[s__TimedL_dat]=GetUnitX(s__TimedL_s[s__TimedL_dat])
                    set s__TimedL_y1[s__TimedL_dat]=GetUnitY(s__TimedL_s[s__TimedL_dat])
                    set z1=GetUnitFlyHeight(s__TimedL_s[s__TimedL_dat])
                endif
                if s__TimedL_t[s__TimedL_dat] == null then
                    if s__TimedL_dx2[s__TimedL_dat] != 0 then
                        set s__TimedL_x2[s__TimedL_dat]=s__TimedL_x2[s__TimedL_dat] + s__TimedL_dx2[s__TimedL_dat]
                    endif
                    if s__TimedL_dy2[s__TimedL_dat] != 0 then
                        set s__TimedL_y2[s__TimedL_dat]=s__TimedL_y2[s__TimedL_dat] + s__TimedL_dy2[s__TimedL_dat]
                    endif
                    if s__TimedL_dz2[s__TimedL_dat] != 0 then
                        set s__TimedL_z2[s__TimedL_dat]=s__TimedL_z2[s__TimedL_dat] + s__TimedL_dz2[s__TimedL_dat]
                    endif
                else
                    set s__TimedL_x2[s__TimedL_dat]=GetUnitX(s__TimedL_t[s__TimedL_dat])
                    set s__TimedL_y2[s__TimedL_dat]=GetUnitY(s__TimedL_t[s__TimedL_dat])
                    set z2=GetUnitFlyHeight(s__TimedL_t[s__TimedL_dat])
                endif
                if s__TimedL_moves[s__TimedL_dat] then
                    call MoveLocation(TimedLightnings___loc, s__TimedL_x1[s__TimedL_dat], s__TimedL_y1[s__TimedL_dat])
                    set z1=GetLocationZ(TimedLightnings___loc) + s__TimedL_z1[s__TimedL_dat] + z1
                    call MoveLocation(TimedLightnings___loc, s__TimedL_x2[s__TimedL_dat], s__TimedL_y2[s__TimedL_dat])
                    set z2=GetLocationZ(TimedLightnings___loc) + s__TimedL_z2[s__TimedL_dat] + z2
                    call MoveLightningEx(s__TimedL_l[s__TimedL_dat], true, s__TimedL_x1[s__TimedL_dat], s__TimedL_y1[s__TimedL_dat], z1, s__TimedL_x2[s__TimedL_dat], s__TimedL_y2[s__TimedL_dat], z2)
                endif
                if s__TimedL_time[s__TimedL_dat] == 0 then
                    set s__TimedL_dat2=s__TimedL_dat
                    set s__TimedL_dat=s__TimedL_next[s__TimedL_dat]
                    call s__TimedL_destroyL()
                else
                    set s__TimedL_dat=s__TimedL_next[s__TimedL_dat]
                endif
                exitwhen s__TimedL_dat == 0
            endloop
        endfunction
        
        function s__TimedL_InitAdd takes nothing returns nothing
            
            if s__TimedL_rlast != 0 then
                set s__TimedL_dat2=s__TimedL_rlast
                set s__TimedL_next[s__TimedL_dat2]=s__TimedL_dat
            endif
            
            
            set s__TimedL_prev[s__TimedL_dat]=s__TimedL_rlast
            
            set s__TimedL_rlast=s__TimedL_dat
            
            set TimedLightnings___CT=TimedLightnings___CT + 1
            if TimedLightnings___CT == 1 then
                
                set s__TimedL_first=s__TimedL_dat
                call TimerStart(TimedLightnings___TMR, TimedLightnings___TO, true, function s__TimedL_looping)
            endif
        endfunction
        
        function s__TimedL_Recycle takes nothing returns nothing
            if 0 == s__TimedL_ir then
                set s__TimedL_ic=s__TimedL_ic + 1
                set s__TimedL_dat=s__TimedL_ic
            else
                set s__TimedL_dat=s__TimedL_ir
                set s__TimedL_ir=s__TimedL_rn[s__TimedL_dat]
            endif
        endfunction
        
        function s__TimedL_P2U takes lightning l,unit t,real time,real x1,real y1,real z1,real z2,real startAlpha,real endAlpha returns nothing
            local integer this
            
            call s__TimedL_Recycle()
            set this=s__TimedL_dat
            
            set s__TimedL_x1[this]=x1
            set s__TimedL_y1[this]=y1
            set s__TimedL_z1[this]=z1
            set s__TimedL_z2[this]=z2
            set s__TimedL_s[this]=null
            set s__TimedL_t[this]=t
            set s__TimedL_next[this]=0 // Nodes are added to the end of the list, there is no next node
            set s__TimedL_l[this]=l
            set s__TimedL_time[this]=R2I(time / TimedLightnings___TO) // Calculates how many loops does the lightning lasts
            set s__TimedL_av[this]=startAlpha
            set s__TimedL_da[this]=( startAlpha - endAlpha ) * TimedLightnings___TO / time // Transparency change speed
            set s__TimedL_moves[this]=true

            call s__TimedL_InitAdd()
        endfunction
        
        function s__TimedL_U2P takes lightning l,unit s,real t,real x1,real y1,real x2,real y2,real z1,real z2,real startAlpha,real endAlpha returns nothing
            local integer this
            
            call s__TimedL_Recycle()
            set this=s__TimedL_dat
            
            set s__TimedL_x1[this]=x1
            set s__TimedL_y1[this]=y1
            set s__TimedL_x2[this]=x2
            set s__TimedL_y2[this]=y2
            set s__TimedL_z1[this]=z1
            set s__TimedL_z2[this]=z2
            set s__TimedL_s[this]=s
            set s__TimedL_t[this]=null
            set s__TimedL_next[this]=0
            set s__TimedL_l[this]=l
            set s__TimedL_time[this]=R2I(t / TimedLightnings___TO)
            set s__TimedL_av[this]=startAlpha
            set s__TimedL_da[this]=( startAlpha - endAlpha ) * TimedLightnings___TO / t
            set s__TimedL_moves[this]=true

            call s__TimedL_InitAdd()
        endfunction
        
        function s__TimedL_U2U takes lightning l,unit s,unit t,real time,real z1,real z2,real startAlpha,real endAlpha returns nothing
            local integer this
            call s__TimedL_Recycle()
            set this=s__TimedL_dat
            
            set s__TimedL_z1[this]=z1
            set s__TimedL_z2[this]=z2
            set s__TimedL_s[this]=s
            set s__TimedL_t[this]=t
            set s__TimedL_next[this]=0
            set s__TimedL_l[this]=l
            set s__TimedL_time[this]=R2I(time / TimedLightnings___TO)
            set s__TimedL_av[this]=startAlpha
            set s__TimedL_da[this]=( startAlpha - endAlpha ) * TimedLightnings___TO / time
            set s__TimedL_moves[this]=true

            call s__TimedL_InitAdd()
        endfunction
        
        function s__TimedL_P2P takes lightning l,real t,real startAlpha,real endAlpha returns nothing
            local integer this
            
            call s__TimedL_Recycle()
            set this=s__TimedL_dat
            
            set s__TimedL_s[this]=null
            set s__TimedL_t[this]=null
            set s__TimedL_next[this]=0
            set s__TimedL_l[this]=l
            set s__TimedL_time[this]=R2I(t / TimedLightnings___TO)
            set s__TimedL_av[this]=startAlpha
            set s__TimedL_da[this]=( startAlpha - endAlpha ) * TimedLightnings___TO / t
            set s__TimedL_moves[this]=false

            call s__TimedL_InitAdd()
        endfunction
        
        function s__TimedL_P2UEx takes lightning l,unit a,real t,real zu,real x1,real y1,real z1,real x2,real y2,real z2,real startAlpha,real endAlpha returns nothing
            local integer this
            local real n= TimedLightnings___TO / t
            
            call s__TimedL_Recycle()
            set this=s__TimedL_dat
            
            set s__TimedL_x1[this]=x1
            set s__TimedL_dx1[this]=( x2 - x1 ) * n
            set s__TimedL_y1[this]=y1
            set s__TimedL_dy1[this]=( y2 - y1 ) * n
            set s__TimedL_z1[this]=z1
            set s__TimedL_dz1[this]=( z2 - z1 ) * n
            set s__TimedL_z2[this]=zu
            set s__TimedL_s[this]=null
            set s__TimedL_t[this]=a
            set s__TimedL_next[this]=0
            set s__TimedL_l[this]=l
            set s__TimedL_time[this]=R2I(t / TimedLightnings___TO)
            set s__TimedL_av[this]=startAlpha
            set s__TimedL_da[this]=( startAlpha - endAlpha ) * n
            set s__TimedL_moves[this]=true

            call s__TimedL_InitAdd()
        endfunction
        
        function s__TimedL_U2PEx takes lightning l,unit a,real t,real zu,real x1,real y1,real z1,real x2,real y2,real z2,real startAlpha,real endAlpha returns nothing
            local integer this
            local real n= TimedLightnings___TO / t
            
            call s__TimedL_Recycle()
            set this=s__TimedL_dat
            
            set s__TimedL_x2[this]=x1
            set s__TimedL_dx2[this]=( x2 - x1 ) * n
            set s__TimedL_y2[this]=y1
            set s__TimedL_dy2[this]=( y2 - y1 ) * n
            set s__TimedL_z2[this]=z1
            set s__TimedL_dz2[this]=( z2 - z1 ) * n
            set s__TimedL_z1[this]=zu
            set s__TimedL_s[this]=a
            set s__TimedL_t[this]=null
            set s__TimedL_next[this]=0
            set s__TimedL_l[this]=l
            set s__TimedL_time[this]=R2I(t / TimedLightnings___TO)
            set s__TimedL_av[this]=startAlpha
            set s__TimedL_da[this]=( startAlpha - endAlpha ) * n
            set s__TimedL_moves[this]=true

            call s__TimedL_InitAdd()
        endfunction
    
        function s__TimedL_P2PEx takes lightning l,real t,real x1,real y1,real z1,real x2,real y2,real z2,real x3,real y3,real z3,real x4,real y4,real z4,real startAlpha,real endAlpha returns nothing
            local integer this
            local real n= TimedLightnings___TO / t
            
            call s__TimedL_Recycle()
            set this=s__TimedL_dat
            
            set s__TimedL_x1[this]=x1
            set s__TimedL_x2[this]=x3
            set s__TimedL_y1[this]=y1
            set s__TimedL_y2[this]=y3
            set s__TimedL_z1[this]=z1
            set s__TimedL_z2[this]=z3
            set s__TimedL_dx1[this]=( x2 - x1 ) * n
            set s__TimedL_dy1[this]=( y2 - y1 ) * n
            set s__TimedL_dz1[this]=( z2 - z1 ) * n
            set s__TimedL_dx2[this]=( x4 - x3 ) * n
            set s__TimedL_dy2[this]=( y4 - y3 ) * n
            set s__TimedL_dz2[this]=( z4 - z3 ) * n
            set s__TimedL_s[this]=null
            set s__TimedL_t[this]=null
            set s__TimedL_next[this]=0
            set s__TimedL_l[this]=l
            set s__TimedL_time[this]=R2I(t / TimedLightnings___TO)
            set s__TimedL_av[this]=startAlpha
            set s__TimedL_da[this]=( startAlpha - endAlpha ) * n
            set s__TimedL_moves[this]=true

            call s__TimedL_InitAdd()
        endfunction
    

//library TimedLightnings ends
//library TimerUtils:
//*********************************************************************
//* TimerUtils (Blue flavor for 1.23b or later) 
//* ----------
//*
//*  To implement it , create a custom text trigger called TimerUtils
//* and paste the contents of this script there.
//*
//*  To copy from a map to another, copy the trigger holding this
//* library to your map.
//*
//* (requires vJass)   More scripts: htt://www.wc3campaigns.net
//*
//* For your timer needs:
//*  * Attaching
//*  * Recycling (with double-free protection)
//*
//* set t=NewTimer()      : Get a timer (alternative to CreateTimer)
//* ReleaseTimer(t)       : Relese a timer (alt to DestroyTimer)
//* SetTimerData(t,2)     : Attach value 2 to timer
//* GetTimerData(t)       : Get the timer's value.
//*                         You can assume a timer's value is 0
//*                         after NewTimer.
//*
//* Blue Flavor: Slower than the red flavor, it got a 408000 handle id
//*             limit, which means that if more than 408000 handle ids
//*             are used in your map, TimerUtils might fail, this
//*             value is quite big and it is much bigger than the 
//*             timer limit in Red flavor.
//*
//********************************************************************

    //==================================================================================================

    //It is dependent on jasshelper's recent inlining optimization in order to perform correctly.
    function SetTimerData takes timer t,integer value returns nothing
        call SaveInteger(TimerUtils___hasht, 0, GetHandleId(t), value)
    endfunction

    function GetTimerData takes timer t returns integer
        return LoadInteger(TimerUtils___hasht, 0, GetHandleId(t))
    endfunction

    //==========================================================================================

    //==========================================================================================
    function NewTimer takes nothing returns timer
        if ( TimerUtils___tN == 0 ) then
            set TimerUtils___tT[0]=CreateTimer()
        else
            set TimerUtils___tN=TimerUtils___tN - 1
        endif
        call SaveInteger(TimerUtils___hasht, 0, GetHandleId((TimerUtils___tT[TimerUtils___tN] )), ( 0)) // INLINED!!
     return TimerUtils___tT[TimerUtils___tN]
    endfunction

    //==========================================================================================
    function ReleaseTimer takes timer t returns nothing
        if ( t == null ) then
            return
        endif
        if ( TimerUtils___tN == 8191 ) then
            //stack is full, the map already has much more troubles than the chance of bug
            call DestroyTimer(t)
        else
            call PauseTimer(t)
            if ( (LoadInteger(TimerUtils___hasht, 0, GetHandleId((t)))) == TimerUtils___HELD ) then // INLINED!!
                return
            endif
            call SaveInteger(TimerUtils___hasht, 0, GetHandleId((t )), ( TimerUtils___HELD)) // INLINED!!
            set TimerUtils___tT[TimerUtils___tN]=t
            set TimerUtils___tN=TimerUtils___tN + 1
        endif
    endfunction

    function TimerUtils___init takes nothing returns nothing
        set TimerUtils___hasht=InitHashtable()
    endfunction


//library TimerUtils ends
//library TraitConstants:

//library TraitConstants ends
//library Type:
        
        function s__Type_create takes integer parent returns integer
            local integer this= s__Type_instanceCount + 1
            set s__Type_instanceCount=this
            
            call SaveBoolean(s__Type_parentTable, this, this, true)
            call SaveBoolean(s__Type_parentTable, this, 0, true)
            
            set s__Type_parent[this]=parent
            loop
                exitwhen parent == 0
                call SaveBoolean(s__Type_parentTable, this, parent, true)
                set parent=s__Type_parent[(parent)]
            endloop
            
            return s__Type_instanceCount
        endfunction
        
        function s__Type_extends takes integer this,integer t returns boolean
            return HaveSavedBoolean(s__Type_parentTable, this, t)
        endfunction
        function s__Type_isParent takes integer this,integer t returns boolean
            return HaveSavedBoolean(s__Type_parentTable, t, this)
        endfunction

//library Type ends
//library VersionCatalog:
    
        
        function s__VersionCatalog_get takes integer this,integer ver returns integer
            return (LoadInteger(Table___ht, (s__VersionCatalog_catalogs[this]), (ver))) // INLINED!!
        endfunction

        function s__VersionCatalog_add takes integer this,integer id,integer ver returns nothing
            local integer catalog= (LoadInteger(Table___ht, (s__VersionCatalog_catalogs[this]), (ver))) // INLINED!!
            
            if ( 0 == catalog ) then
                set catalog=sc__Catalog_create()
                call SaveInteger(Table___ht, (s__VersionCatalog_catalogs[this]), (ver), ( catalog)) // INLINED!!
                if ( 1 < ver ) then
                    call sc__Catalog_addCatalog(catalog,(LoadInteger(Table___ht, (s__VersionCatalog_catalogs[this]), (ver - 1)))) // INLINED!!
                endif
            endif
            
            call sc__Catalog_add(catalog,id)
        endfunction
        
        function s__VersionCatalog_create takes nothing returns integer
            local integer this= s__VersionCatalog_instanceCount + 1
            set s__VersionCatalog_instanceCount=this
            
            set s__VersionCatalog_catalogs[this]=s__Table_create()
            
            return this
        endfunction

//library VersionCatalog ends
//library Waypoint:

    
function isWaypointDiscovered takes integer l__index,integer continent returns integer
        if continent == 1 then
            return B2I(LoadBoolean(Waypoint__waypointHash, Waypoint__cont1[l__index], 5))
        elseif continent == 2 then
            return B2I(LoadBoolean(Waypoint__waypointHash, Waypoint__cont2[l__index], 5))
        elseif continent == 3 then
            return B2I(LoadBoolean(Waypoint__waypointHash, Waypoint__cont3[l__index], 5))
        elseif continent == 4 then
            return B2I(LoadBoolean(Waypoint__waypointHash, Waypoint__cont4[l__index], 5))
        endif
        return 0
    endfunction
    
    function Waypoint__onWardInteract_Cond takes nothing returns boolean
        local location l= GetUnitLoc(GetOrderTargetUnit())
        local location l2= GetUnitLoc(GetTriggerUnit())
        if ( GetUnitTypeId(GetOrderTargetUnit()) == 'h00P' or GetUnitTypeId(GetTriggerUnit()) == 'h00P' ) and ( DistanceBetweenPoints(l, l2) <= 350 ) and ( GetTriggerUnit() == udg_PlayerUnit[GetPlayerId(GetTriggerPlayer()) + 1] ) then
            return true
        endif
        return false
    endfunction
    
    function onSecondButtonClick takes nothing returns nothing
        local integer play= GetPlayerId(GetTriggerPlayer())
        local button butt= GetClickedButton()
        local integer i= 0
        local location l
        
        call DestroyTrigger(GetTriggeringTrigger())
        
        loop
            
            if butt == LoadButtonHandle(Waypoint__waypointHash, play, i) then
                if isWaypointDiscovered(i , Waypoint__currentCont[play]) == 0 then
                    set butt=null
                    call DialogDestroy(Waypoint__main[play])
                    return
                endif
                call DestroyEffect(AddSpecialEffectTarget("Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTarget.mdl", udg_PlayerUnit[play + 1], "origin"))
                if Waypoint__currentCont[play] == 1 then
                    set l=GetUnitLoc(LoadUnitHandle(Waypoint__waypointHash, Waypoint__cont1[i], 4))
                elseif Waypoint__currentCont[play] == 2 then
                    set l=GetUnitLoc(LoadUnitHandle(Waypoint__waypointHash, Waypoint__cont2[i], 4))
                elseif Waypoint__currentCont[play] == 3 then
                    set l=GetUnitLoc(LoadUnitHandle(Waypoint__waypointHash, Waypoint__cont3[i], 4))
                elseif Waypoint__currentCont[play] == 4 then
                    set l=GetUnitLoc(LoadUnitHandle(Waypoint__waypointHash, Waypoint__cont4[i], 4))
                endif
                call SetUnitPositionLoc(udg_PlayerUnit[play + 1], l)
                exitwhen true
            endif
            set i=i + 1
            exitwhen i > 99
        endloop
        call SetCameraPositionLocForPlayer(Player(play), l)
        call RemoveLocation(l)
        set l=null
        set butt=null
        call DialogDestroy(Waypoint__main[play])
    
    endfunction
    
    function Waypoint__onDialogClick takes nothing returns nothing
        local integer i= 0
        local button butt= GetClickedButton()
        local integer play= GetPlayerId(GetTriggerPlayer())
        local trigger t= CreateTrigger()
        call DestroyTrigger(GetTriggeringTrigger())
        set Waypoint__currentMenu[play]=0
        if butt == LoadButtonHandle(Waypoint__waypointHash, play, 0) then
            set Waypoint__currentCont[play]=1
        
            call DialogDestroy(Waypoint__main[play])
            set Waypoint__main[play]=DialogCreate()
            call DialogSetMessage(Waypoint__main[play], "Choose a Waypoint")
            loop
                if Waypoint__cont1[i] >= 10 then
                    if LoadBoolean(Waypoint__waypointHash, Waypoint__cont1[i], 5) != true then
                        call SaveButtonHandle(Waypoint__waypointHash, play, i, DialogAddButton(Waypoint__main[play], "Not Discovered", i))
                    else
                        call SaveButtonHandle(Waypoint__waypointHash, play, i, DialogAddButton(Waypoint__main[play], LoadStr(Waypoint__waypointHash, Waypoint__cont1[i], 3), i))
                    endif
                else
                    exitwhen true
                endif
                set i=i + 1
            endloop
        elseif butt == LoadButtonHandle(Waypoint__waypointHash, play, 1) then
        
            set Waypoint__currentCont[play]=2
            call DialogDestroy(Waypoint__main[play])
            set Waypoint__main[play]=DialogCreate()
            call DialogSetMessage(Waypoint__main[play], "Choose a Waypoint")
            loop
                if Waypoint__cont2[i] >= 10 then
                    if LoadBoolean(Waypoint__waypointHash, Waypoint__cont2[i], 5) != true then
                        call SaveButtonHandle(Waypoint__waypointHash, play, i, DialogAddButton(Waypoint__main[play], "Not Discovered", i))
                    else
                        call SaveButtonHandle(Waypoint__waypointHash, play, i, DialogAddButton(Waypoint__main[play], LoadStr(Waypoint__waypointHash, Waypoint__cont2[i], 3), i))
                    endif
                else
                    exitwhen true
                endif
                set i=i + 1
            endloop
        elseif butt == LoadButtonHandle(Waypoint__waypointHash, play, 2) then
            set Waypoint__currentCont[play]=3
        
            call DialogDestroy(Waypoint__main[play])
            set Waypoint__main[play]=DialogCreate()
            call DialogSetMessage(Waypoint__main[play], "Choose a Waypoint")
            loop
                if Waypoint__cont3[i] >= 10 then
                    if LoadBoolean(Waypoint__waypointHash, Waypoint__cont3[i], 5) != true then
                        call SaveButtonHandle(Waypoint__waypointHash, play, i, DialogAddButton(Waypoint__main[play], "Not Discovered", i))
                    else
                        call SaveButtonHandle(Waypoint__waypointHash, play, i, DialogAddButton(Waypoint__main[play], LoadStr(Waypoint__waypointHash, Waypoint__cont3[i], 3), i))
                    endif
                else
                    exitwhen true
                endif
                set i=i + 1
            endloop
        elseif butt == LoadButtonHandle(Waypoint__waypointHash, play, 3) then
            set Waypoint__currentCont[play]=4
        
            call DialogDestroy(Waypoint__main[play])
            set Waypoint__main[play]=DialogCreate()
            call DialogSetMessage(Waypoint__main[play], "Choose a Waypoint")

            loop
                if Waypoint__cont4[i] >= 10 then
                    if LoadBoolean(Waypoint__waypointHash, Waypoint__cont4[i], 5) != true then
                        call SaveButtonHandle(Waypoint__waypointHash, play, i, DialogAddButton(Waypoint__main[play], "Not Discovered", i))
                    else
                        call SaveButtonHandle(Waypoint__waypointHash, play, i, DialogAddButton(Waypoint__main[play], LoadStr(Waypoint__waypointHash, Waypoint__cont4[i], 3), i))
                    endif
                else
                    exitwhen true
                endif
                set i=i + 1
            endloop
        endif
        call SaveButtonHandle(Waypoint__waypointHash, play, 234234234, DialogAddButton(Waypoint__main[play], "Exit Menu", 11))
        call DialogDisplay(Player(play), Waypoint__main[play], true)
        call TriggerRegisterDialogEvent(t, Waypoint__main[play])
        call TriggerAddAction(t, function onSecondButtonClick)
        set t=null
    endfunction
    
    function Waypoint__onWardInteract takes nothing returns nothing
        local unit l__Waypoint__ward= GetOrderTargetUnit()
        local unit trig= GetTriggerUnit()
        local integer play= GetPlayerId(GetOwningPlayer(trig))
        local trigger t= CreateTrigger()
        if Waypoint__currentMenu[play] == 0 then
            call DialogDestroy(Waypoint__main[play])
            set Waypoint__main[play]=DialogCreate()
            call TriggerAddAction(t, function Waypoint__onDialogClick)
            call DialogSetMessage(Waypoint__main[play], "Choose your Continent")
            call SaveButtonHandle(Waypoint__waypointHash, play, 0, DialogAddButton(Waypoint__main[play], "1st : Elohim", 1))
            call SaveButtonHandle(Waypoint__waypointHash, play, 1, DialogAddButton(Waypoint__main[play], "2nd : Preka", 2))
            call SaveButtonHandle(Waypoint__waypointHash, play, 2, DialogAddButton(Waypoint__main[play], "3rd : Naraka", 3))
            call SaveButtonHandle(Waypoint__waypointHash, play, 3, DialogAddButton(Waypoint__main[play], "4th : Asura", 4))
            call DialogDisplay(GetOwningPlayer(trig), Waypoint__main[play], true)
            set Waypoint__currentMenu[play]=1
            call TriggerRegisterDialogEvent(t, Waypoint__main[play])
        endif
        if LoadBoolean(Waypoint__waypointHash, GetHandleId(l__Waypoint__ward), 5) != true then
            call SaveBoolean(Waypoint__waypointHash, GetHandleId(l__Waypoint__ward), 5, true)
        endif
        set l__Waypoint__ward=null
        set trig=null
        set t=null
    endfunction
    
    function Waypoint__registerWP takes unit point,integer continent,integer levelReq,integer goldCost,string description returns integer
        local integer i= GetHandleId(point)
        if continent == 0 then
            set Waypoint__current[0]=Waypoint__current[0] + 1
            set Waypoint__cont1[Waypoint__current[0]]=i
        endif
        if continent == 1 then
            set Waypoint__current[1]=Waypoint__current[1] + 1
            set Waypoint__cont2[Waypoint__current[1]]=i
        endif
        if continent == 2 then
            set Waypoint__current[2]=Waypoint__current[2] + 1
            set Waypoint__cont3[Waypoint__current[2]]=i
        endif
        if continent == 3 then
            set Waypoint__current[3]=Waypoint__current[3] + 1
            set Waypoint__cont4[Waypoint__current[3]]=i
        endif
        call SaveInteger(Waypoint__waypointHash, i, 0, continent)
        call SaveInteger(Waypoint__waypointHash, i, 1, levelReq)
        call SaveInteger(Waypoint__waypointHash, i, 2, goldCost)
        call SaveStr(Waypoint__waypointHash, i, 3, description)
        call SaveUnitHandle(Waypoint__waypointHash, i, 4, point)
        return i
    endfunction
    
function discoverManual takes integer l__index returns nothing
        if LoadBoolean(Waypoint__waypointHash, l__index, 5) != true then
            call SaveBoolean(Waypoint__waypointHash, l__index, 5, true)
        endif
    endfunction
    
    function Waypoint__Init takes nothing returns nothing
        local trigger t= CreateTrigger()
        local integer i= 0
        call print("wtf")
        call TriggerRegisterAnyUnitEventBJ(t, EVENT_PLAYER_UNIT_ISSUED_UNIT_ORDER)
        call TriggerAddAction(t, function Waypoint__onWardInteract)
        call TriggerAddCondition(t, Condition(function Waypoint__onWardInteract_Cond))
        loop
            set Waypoint__current[i]=- 1
            set Waypoint__current[i + 10]=- 1
            set Waypoint__current[i + 20]=- 1
            set i=i + 1
            exitwhen i == 11
        endloop
        call Waypoint__registerWP(gg_unit_h00P_0470 , 0 , 0 , 0 , "Rogue Encampment")
       // call registerWP(gg_unit_h00P_0470, 1, 0, 0, "Lut Gholein")
       // call registerWP(gg_unit_h00P_0470, 2, 0, 0, "Harrogath")
       // call registerWP(gg_unit_h00P_0470, 3, 0, 0, "Pandemonium")
        call Waypoint__registerWP(gg_unit_h00P_0566 , 0 , 0 , 0 , "Cold Plains")
        call Waypoint__registerWP(gg_unit_h00P_0472 , 0 , 5 , 0 , "Stony Field")
        call Waypoint__registerWP(gg_unit_h00P_0475 , 0 , 10 , 0 , "Dark Woods")
        call discoverManual(GetHandleId(gg_unit_h00P_0470))
        set t=null
    endfunction
    

//library Waypoint ends
//library WorldBounds:
//Implemented from module WorldBounds___WorldBoundInit:
        function s__WorldBounds_WorldBounds___WorldBoundInit___onInit takes nothing returns nothing
            set s__WorldBounds_world=GetWorldBounds()
            set s__WorldBounds_maxX=R2I(GetRectMaxX(s__WorldBounds_world))
            set s__WorldBounds_maxY=R2I(GetRectMaxY(s__WorldBounds_world))
            set s__WorldBounds_minX=R2I(GetRectMinX(s__WorldBounds_world))
            set s__WorldBounds_minY=R2I(GetRectMinY(s__WorldBounds_world))
            set s__WorldBounds_centerX=R2I(( s__WorldBounds_maxX + s__WorldBounds_minX ) / 2)
            set s__WorldBounds_centerY=R2I(( s__WorldBounds_minY + s__WorldBounds_maxY ) / 2)
            set s__WorldBounds_worldRegion=CreateRegion()
            call RegionAddRect(s__WorldBounds_worldRegion, s__WorldBounds_world)
        endfunction

//library WorldBounds ends
//library crit:
    function registerCritRate takes item i,real critRate returns nothing
        call SaveReal(crit___critHash, GetItemTypeId(i), 0, critRate)
    endfunction
    function registerCritPow takes item i,real critPow returns nothing
        call SaveReal(crit___critHash, GetItemTypeId(i), 1, critPow)
    endfunction
    function getCritRate takes unit u returns real
    
    // c*log(sqrt(x))+k
    
    
        return 5.
    endfunction
    function getCritPow takes unit u returns real
      
        return 2.
    endfunction
    function crit___Init takes nothing returns nothing
    endfunction

//library crit ends
//library dsf:

    function dsf___ot takes nothing returns nothing
        call BJDebugMsg("ORDER : " + I2S(GetIssuedOrderId()))
    endfunction

    function dsf___onInit takes nothing returns nothing
        local trigger t= CreateTrigger()
        call TriggerRegisterAnyUnitEventBJ(t, EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER)
        call TriggerAddAction(t, function dsf___ot)
    endfunction

//library dsf ends
//library test:
function Trig_Untitled_Trigger_005_Actions takes nothing returns nothing
    call sc__VJassTalentTree_showUI(GetTriggerPlayer() , S2I(SubString(GetEventPlayerChatString(), 6, 8)))
endfunction
function tttt1111 takes nothing returns nothing
    call sc__VJassTalentTree_hideUI(GetTriggerPlayer())
endfunction

//===========================================================================
function test__init takes nothing returns nothing
    local trigger t= CreateTrigger()
    set gg_trg_Untitled_Trigger_005=CreateTrigger()
    call TriggerRegisterPlayerChatEvent(gg_trg_Untitled_Trigger_005, Player(0), "-show", false)
    call TriggerRegisterPlayerChatEvent(gg_trg_Untitled_Trigger_005, Player(1), "-show", false)
    call TriggerRegisterPlayerChatEvent(gg_trg_Untitled_Trigger_005, Player(2), "-show", false)
    call TriggerRegisterPlayerChatEvent(t, Player(0), "-hide", true)
    call TriggerRegisterPlayerChatEvent(t, Player(1), "-hide", true)
    call TriggerRegisterPlayerChatEvent(t, Player(2), "-hide", true)
    call TriggerAddAction(gg_trg_Untitled_Trigger_005, function Trig_Untitled_Trigger_005_Actions)
    call TriggerAddAction(t, function tttt1111)
endfunction


//library test ends
//library xebasic:
//**************************************************************************
//
// xebasic 0.4
// =======
// XE_DUMMY_UNITID : Rawcode of the dummy unit in your map. It should
//                   use the dummy.mdx model, so remember to import it as
//                   well, just use copy&paste to copy the dummy from the
//                   xe map to yours, then change the rawcode.
//
// XE_HEIGHT_ENABLER: Medivh's raven form ability, you may need to change
//                    this rawcode to another spell that morphs into a flier
//                    in case you modified medivh's spell in your map.
//
// XE_TREE_RECOGNITION: The ancients' Eat tree ability, same as with medivh
//                      raven form, you might have to change it.
//
// XE_ANIMATION_PERIOD: The global period of animation used by whatever
//                      timer that depends on it, if you put a low value
//                      the movement will look good but it may hurt your
//                      performance, if instead you use a high value it
//                      will not lag but will be fast.
//
// XE_MAX_COLLISION_SIZE: The maximum unit collision size in your map, if
//                        you got a unit bigger than 197.0 it would be
//                        a good idea to update this constant, since some
//                        enums will not find it. Likewise, if none of
//                        your units can go bellow X and X is much smaller
//                        than 197.0, it would be a good idea to update
//                        as well, since it will improve the performance
//                        those enums.
//
// Notice you probably don't have to update this library, unless I specify
// there are new constants which would be unlikely. 
//
//**************************************************************************

//===========================================================================


//library xebasic ends
//library AVL:

//library AVL ends
//library AdvLoc:




        //*********************************************************************
        //  Lock counters: a way to keep track of how many times a Loc has been
        //  locked, starts counting from 1. Unlocking drops the counters by 1,
        //  if it reaches 0 the instance is deallocated.
        
        function s__AdvLoc__get_x takes integer this returns real
            return s__Loc_x[(this)]
        endfunction

        function s__AdvLoc__get_y takes integer this returns real
            return s__Loc_y[(this)]
        endfunction

        function s__AdvLoc__get_z takes integer this returns real
            return s__Loc_z[(this)]
        endfunction

        function s__AdvLoc_create takes real ox,real oy,real oz returns integer
            local integer this= s__Loc_create(ox , oy , oz)
            set s__AdvLoc_ref[this]=this
            return this
        endfunction

        function s__AdvLoc_math takes integer a,integer b returns nothing
            set s__AdvLoc_angle[a]=Atan2((s__Loc_y[((b))]) - (s__Loc_y[((a))]), (s__Loc_x[((b))]) - (s__Loc_x[((a))])) // INLINED!!
            set s__AdvLoc_distance[a]=SquareRoot(( (s__Loc_x[((b))]) - (s__Loc_x[((a))]) ) * ( (s__Loc_x[((b))]) - (s__Loc_x[((a))]) ) + ( (s__Loc_y[((b))]) - (s__Loc_y[((a))]) ) * ( (s__Loc_y[((b))]) - (s__Loc_y[((a))]) )) // INLINED!!
            set s__AdvLoc_slope[a]=( (s__Loc_z[((b))]) - (s__Loc_z[((a))]) ) / s__AdvLoc_distance[a] // INLINED!!
            set s__AdvLoc_angle[b]=s__AdvLoc_angle[a] + bj_PI
            set s__AdvLoc_distance[b]=s__AdvLoc_distance[a]
            set s__AdvLoc_slope[b]=- s__AdvLoc_slope[a]
        endfunction

        function s__AdvLoc_link takes integer a,integer b returns nothing
            set s__AdvLoc_ref[a]=b
            set s__AdvLoc_ref[b]=a
            call s__AdvLoc_math(a , b)
        endfunction

        function s__AdvLoc_unlink takes integer this returns nothing
            if s__AdvLoc_lc[this] == 0 then
                set s__AdvLoc_ref[s__AdvLoc_ref[this]]=s__AdvLoc_ref[this]
                set s__AdvLoc_ref[this]=this
            endif
        endfunction
        
        function s__AdvLoc_lock takes integer this returns nothing
            set s__AdvLoc_lc[this]=s__AdvLoc_lc[this] + 1
            call s__Loc_lock((this))
        endfunction

        function s__AdvLoc_unlock takes integer this returns nothing
            set s__AdvLoc_lc[this]=s__AdvLoc_lc[this] - 1
            if s__AdvLoc_lc[this] == 0 then
                set s__AdvLoc_ref[s__AdvLoc_ref[this]]=s__AdvLoc_ref[this]
                set s__AdvLoc_ref[this]=this
            endif
            call s__Loc_unlock((this))
        endfunction

        function s__AdvLoc_move takes integer this,real nx,real ny,real nz returns nothing
            call s__Loc_move((this),nx , ny , nz)
            if this != s__AdvLoc_ref[this] then
                call s__AdvLoc_math(this , s__AdvLoc_ref[this])
            endif
        endfunction


//library AdvLoc ends
//library Base:


        function s__Base__get_string takes integer this returns string
            return Base__b[this]
        endfunction
        function s__Base__get_size takes integer this returns integer
            return Base__s[this]
        endfunction
        function s__Base__staticgetindex takes string base returns integer
            local integer value
            local string char
            local integer i=0
            local integer v
            local integer dv
            local integer hv
                set value=StringHash(base) //first get the hash
                set i=(LoadInteger(Table___ht, (Base__gt), (value))) //get first node of hash table // INLINED!!
                set v=i //copy
                if ( 0 != i ) then //if stack exists, then loop through
                    loop
                        exitwhen 0 == i or base == Base__b[i]
                        set i=Base__n[i]
                    endloop
                endif
                //if this still doesn't exist, create it
                if ( 0 == i ) then
                    //allocate
                    set Base__c=Base__c + 1
                    set i=Base__c
                    set dv=v
                    set hv=value
                    set Base__t[i]=s__Table_create() //character table
                    set Base__b[i]=base //base string
                    //value is now used for iterating through the base string
                    set value=StringLength(base)
                    set Base__s[i]=value
                    loop
                        set value=value - 1
                        set char=SubString(base, value, value + 1)
                        set v=Char2Ascii(char)
                        //if the character already exists, stop
                        //and deallocate (invalid base)
                        //character doesn't exist
                            call SaveInteger(Table___ht, (Base__t[i]), (v), ( value)) // INLINED!!
                            call SaveStr(Table___ht, (((Base__t[i]))), (- value), ( char)) // INLINED!!
                        exitwhen 0 == value
                    endloop
                    //if dv is 0, then allocate dv
                    if ( 0 == dv ) then
                        call SaveInteger(Table___ht, (Base__gt), (hv), ( i)) // INLINED!!
                    //otherwise add i to hash stack
                    else
                        set Base__n[i]=Base__n[dv]
                        set Base__n[dv]=i
                    endif
                endif
                return i
        endfunction
        function s__Base_convertToString takes integer this,integer i returns string
            local integer k=Base__s[this]
            local string l__Base__n=""
                    loop
                        exitwhen i < k
                        set l__Base__n=(LoadStr(Table___ht, (((Base__t[this]))), (- ( i - i / k * k )))) + l__Base__n // INLINED!!
                        set i=i / k
                    endloop
                    return (LoadStr(Table___ht, (((Base__t[this]))), (- i))) + l__Base__n // INLINED!!
        endfunction
        function s__Base_convertToInteger takes integer this,string i returns integer
            local integer l__Base__n=0
            local integer p=StringLength(i)
            local integer l=0
            local integer k=Base__s[this]
            local string char
                loop
                    exitwhen 0 == p
                    set p=p - 1
                    set l=l + 1
                    set char=SubString(i, l - 1, l)
                        set l__Base__n=l__Base__n + (LoadInteger(Table___ht, (Base__t[this]), (Char2Ascii(char)))) * R2I(Pow(k, p)) // INLINED!!
                endloop
                return l__Base__n
        endfunction
function s__Base_ord takes integer this,string l__Base__c returns integer
                return (LoadInteger(Table___ht, (Base__t[this]), (Char2Ascii(l__Base__c)))) // INLINED!!
        endfunction
        function s__Base_char takes integer this,integer i returns string
                    return (LoadStr(Table___ht, (((Base__t[this]))), (- i))) // INLINED!!
        endfunction
function s__Base_isValid takes integer this,string l__Base__s returns boolean
            local integer i=StringLength(l__Base__s)
            local string l__Base__c
            if ( 0 < i ) then
                loop
                    set l__Base__c=SubString(l__Base__s, i - 1, i)
                    if ( not (HaveSavedInteger(Table___ht, (Base__t[this]), (Char2Ascii(l__Base__c)))) ) then // INLINED!!
                        return false
                    endif
                    set i=i - 1
                    exitwhen 0 == i
                endloop
            else
                return false
            endif
            return true
        endfunction
//Implemented from module Base__Init:
        function s__Base_Base__Init___onInit takes nothing returns nothing
            set Base__gt=s__Table_create()
        endfunction

//library Base ends
//library Catalog:
//Implemented from module Catalog___N:
        function s__Catalog___S_Catalog___N___onInit takes nothing returns nothing
            set Catalog___d=s__Table_create()
            set Catalog___c=s__Table_create()
        endfunction
    function CatalogCreate takes nothing returns integer
        local integer t
        
        //allocate catalog
        if ( 0 == (LoadInteger(Table___ht, (Catalog___d), (0))) ) then // INLINED!!
            set t=Catalog___w + 1
            set Catalog___w=t
        else
            set t=(LoadInteger(Table___ht, (Catalog___d), (0))) // INLINED!!
            call SaveInteger(Table___ht, (Catalog___d), (0), ( (LoadInteger(Table___ht, (Catalog___d), (t))))) // INLINED!!
        endif
        
        //generate tables
        set Catalog___i[t]=s__Table_create() //id table
        set Catalog___r[t]=s__Table_create() //rawcode id table
        
        //catalog lists
        set Catalog___pn[t]=s__Table_create() //point back
        set Catalog___pp[t]=s__Table_create() //point back
        set Catalog___en[t]=s__Table_create() //table extensions
        set Catalog___ep[t]=s__Table_create() //table extensions
        
        //initialize lists
        call SaveInteger(Table___ht, (Catalog___pn[t]), (t), ( t)) // INLINED!!
        call SaveInteger(Table___ht, (Catalog___pp[t]), (t), ( t)) // INLINED!!
        call SaveInteger(Table___ht, (Catalog___en[t]), (t), ( t)) // INLINED!!
        call SaveInteger(Table___ht, (Catalog___ep[t]), (t), ( t)) // INLINED!!
        
        return t
    endfunction
    function CatalogDestroy takes integer t returns nothing
        //loop through all lists catalog is on and remove it
        local integer b=(LoadInteger(Table___ht, (Catalog___pn[t]), (t))) // INLINED!!
        loop
            exitwhen t == b
            call SaveInteger(Table___ht, (Catalog___ep[b]), ((LoadInteger(Table___ht, (Catalog___en[b]), (t)))), ( (LoadInteger(Table___ht, (Catalog___ep[b]), (t))))) // INLINED!!
            call SaveInteger(Table___ht, (Catalog___en[b]), ((LoadInteger(Table___ht, (Catalog___ep[b]), (t)))), ( (LoadInteger(Table___ht, (Catalog___en[b]), (t))))) // INLINED!!
            call RemoveSavedInteger(Table___ht, (Catalog___en[b]), (t)) // INLINED!!
            call RemoveSavedInteger(Table___ht, (Catalog___ep[b]), (t)) // INLINED!!
            set b=(LoadInteger(Table___ht, (Catalog___pn[t]), (b))) // INLINED!!
        endloop
        
        //loop through all lists of catalog and remove point backs
        set b=(LoadInteger(Table___ht, (Catalog___en[t]), (t))) // INLINED!!
        loop
            exitwhen t == b
            call SaveInteger(Table___ht, (Catalog___pp[b]), ((LoadInteger(Table___ht, (Catalog___pn[b]), (t)))), ( (LoadInteger(Table___ht, (Catalog___pp[b]), (t))))) // INLINED!!
            call SaveInteger(Table___ht, (Catalog___pn[b]), ((LoadInteger(Table___ht, (Catalog___pp[b]), (t)))), ( (LoadInteger(Table___ht, (Catalog___pn[b]), (t))))) // INLINED!!
            call RemoveSavedInteger(Table___ht, (Catalog___pn[b]), (t)) // INLINED!!
            call RemoveSavedInteger(Table___ht, (Catalog___pp[b]), (t)) // INLINED!!
            set b=(LoadInteger(Table___ht, (Catalog___en[t]), (b))) // INLINED!!
        endloop
        
        //destroy list tables
        call s__Table_destroy(Catalog___en[t])
        call s__Table_destroy(Catalog___ep[t])
        call s__Table_destroy(Catalog___pp[t])
        call s__Table_destroy(Catalog___pn[t])
        
        //destroy id tables
        call s__Table_destroy(Catalog___i[t])
        call s__Table_destroy(Catalog___r[t])
        
        //delete count
        call RemoveSavedInteger(Table___ht, (Catalog___c), (t)) // INLINED!!
        
        //recycle
        call SaveInteger(Table___ht, (Catalog___d), (t), ( (LoadInteger(Table___ht, (Catalog___d), (0))))) // INLINED!!
        call SaveInteger(Table___ht, (Catalog___d), (0), ( t)) // INLINED!!
    endfunction
    function CatalogCount takes integer t returns integer
        local integer cs=s__Table_create()
        local integer v=0
        local integer b=t
        local integer e
        local integer cntd=0
        loop
            if ( not (HaveSavedBoolean(Table___ht, (((cs))), (b))) ) then // INLINED!!
                set e=(LoadInteger(Table___ht, (Catalog___en[b]), (b))) // INLINED!!
                if ( e != b ) then
                    set Catalog___cntt[cntd]=b
                    set Catalog___cntb[cntd]=e
                    set cntd=cntd + 1
                endif
            
                call SaveBoolean(Table___ht, (((cs))), (b), ( true)) // INLINED!!
                set v=v + (LoadInteger(Table___ht, (Catalog___c), (b))) // INLINED!!
            endif
            
            set b=(LoadInteger(Table___ht, (Catalog___en[t]), (b))) // INLINED!!
            
            if ( b == t ) then
                exitwhen 0 == cntd
                set cntd=cntd - 1
                set t=Catalog___cntt[cntd]
                set b=Catalog___cntb[cntd]
            endif
        endloop
        
        call s__Table_destroy(cs)
        
        return v
    endfunction
    function CatalogRaw takes integer t,integer v returns integer
        local integer cs=s__Table_create()
        local integer b=t
        local integer e
        local integer cntd=0
        local integer y
        
        loop
            if ( not (HaveSavedBoolean(Table___ht, (((cs))), (b))) ) then // INLINED!!
                set y=(LoadInteger(Table___ht, (Catalog___c), (b))) // INLINED!!
            
                if ( v <= y ) then
                    call s__Table_destroy(cs)
                    return (LoadInteger(Table___ht, (Catalog___r[b]), (v))) // INLINED!!
                endif
                
                set e=(LoadInteger(Table___ht, (Catalog___en[b]), (b))) // INLINED!!
                if ( e != b ) then
                    set Catalog___cntt[cntd]=b
                    set Catalog___cntb[cntd]=e
                    set cntd=cntd + 1
                endif
            
                call SaveBoolean(Table___ht, (((cs))), (b), ( true)) // INLINED!!
                
                set v=v - y
            endif
            
            set b=(LoadInteger(Table___ht, (Catalog___en[t]), (b))) // INLINED!!
            
            if ( b == t ) then
                if ( 0 == cntd ) then
                    call s__Table_destroy(cs)
                    return 0
                endif
                
                set cntd=cntd - 1
                set t=Catalog___cntt[cntd]
                set b=Catalog___cntb[cntd]
            endif
        endloop
        
        return 0
    endfunction
    function CatalogId takes integer t,integer v returns integer
        local integer cs=s__Table_create()
        local integer b=t
        local integer e
        local integer cntd=0
        local integer l= 0
        
        loop
            if ( not (HaveSavedBoolean(Table___ht, (((cs))), (b))) ) then // INLINED!!
                if ( (HaveSavedInteger(Table___ht, (Catalog___i[b]), (v))) ) then // INLINED!!
                    call s__Table_destroy(cs)
                    return (LoadInteger(Table___ht, (Catalog___i[b]), (v))) + l // INLINED!!
                endif
                
                set l=l + (LoadInteger(Table___ht, (Catalog___c), (b))) // INLINED!!
            
                set e=(LoadInteger(Table___ht, (Catalog___en[b]), (b))) // INLINED!!
                if ( e != b ) then
                    set Catalog___cntt[cntd]=b
                    set Catalog___cntb[cntd]=e
                    set cntd=cntd + 1
                endif
            
                call SaveBoolean(Table___ht, (((cs))), (b), ( true)) // INLINED!!
            endif
            
            set b=(LoadInteger(Table___ht, (Catalog___en[t]), (b))) // INLINED!!
            
            if ( b == t ) then
                if ( 0 == cntd ) then
                    call s__Table_destroy(cs)
                    return 0
                endif
                
                set cntd=cntd - 1
                set t=Catalog___cntt[cntd]
                set b=Catalog___cntb[cntd]
            endif
        endloop
        
        return 0
    endfunction
    
    function CatalogAdd takes integer t,integer v returns nothing
        if ( not (HaveSavedInteger(Table___ht, (Catalog___i[t]), (v))) ) then //if catalog doesn't have value // INLINED!!
            call SaveInteger(Table___ht, (Catalog___c), (t), ( (LoadInteger(Table___ht, (Catalog___c), (t))) + 1)) //increase catalog count // INLINED!!
            call SaveInteger(Table___ht, (Catalog___i[t]), (v), ( (LoadInteger(Table___ht, (Catalog___c), (t))))) //raw->id // INLINED!!
            call SaveInteger(Table___ht, (Catalog___r[t]), ((LoadInteger(Table___ht, (Catalog___c), (t)))), ( v)) //id->raw // INLINED!!
        endif
    endfunction
    function CatalogAddCatalog takes integer t,integer b returns nothing
        
            //add to catalog list
            call SaveInteger(Table___ht, (Catalog___ep[t]), (b), ( (LoadInteger(Table___ht, (Catalog___ep[t]), (t))))) // INLINED!!
            call SaveInteger(Table___ht, (Catalog___en[t]), (b), ( t)) // INLINED!!
            call SaveInteger(Table___ht, (Catalog___en[t]), ((LoadInteger(Table___ht, (Catalog___ep[t]), (t)))), ( b)) // INLINED!!
            call SaveInteger(Table___ht, (Catalog___ep[t]), (t), ( b)) // INLINED!!
            
            //add to point back list of catalog 2
            call SaveInteger(Table___ht, (Catalog___pp[b]), (t), ( (LoadInteger(Table___ht, (Catalog___pp[b]), (b))))) // INLINED!!
            call SaveInteger(Table___ht, (Catalog___pn[b]), (t), ( b)) // INLINED!!
            call SaveInteger(Table___ht, (Catalog___pn[b]), ((LoadInteger(Table___ht, (Catalog___pp[b]), (b)))), ( t)) // INLINED!!
            call SaveInteger(Table___ht, (Catalog___pp[b]), (b), ( t)) // INLINED!!
    endfunction
    
    function CatalogLoopDestroy takes integer cl returns nothing
        set Catalog___clr[cl]=Catalog___clr[0]
        set Catalog___clr[0]=cl
        
        call s__Table_destroy(Catalog___cltv[cl])
        call s__Table_destroy(Catalog___cltvp[cl])
        call s__Table_destroy(Catalog___clthv[cl])
    endfunction
    
    function CatalogLoopNext takes integer cl,integer id returns integer
        local integer cs=Catalog___clthv[cl]
        local integer b=Catalog___clcv[cl]
        local integer t=Catalog___clp[cl]
        local integer e
        local integer cntd=Catalog___cltvc[cl]
        local integer y=(LoadInteger(Table___ht, (Catalog___c), (b))) // INLINED!!
        local integer v=Catalog___clvi[cl]
        
        if ( 0 >= id ) then
            set id=1
        endif
        
        loop
            set v=v + 1
            loop
                exitwhen v > y
                set id=id - 1
                if ( 0 == id ) then
                    set Catalog___clvi[cl]=v
                    return (LoadInteger(Table___ht, (Catalog___r[b]), (v))) // INLINED!!
                endif
            endloop
            
            if ( not (HaveSavedBoolean(Table___ht, (((cs))), (b))) ) then // INLINED!!
                call SaveBoolean(Table___ht, (((cs))), (b), ( true)) // INLINED!!
                set Catalog___clcv[cl]=b
                
                set e=(LoadInteger(Table___ht, (Catalog___en[b]), (b))) // INLINED!!
                if ( e != b ) then
                    call SaveInteger(Table___ht, (Catalog___cltvp[cl]), (Catalog___cltvc[cl]), ( b)) // INLINED!!
                    call SaveInteger(Table___ht, (Catalog___cltv[cl]), (Catalog___cltvc[cl]), ( e)) // INLINED!!
                    set Catalog___cltvc[cl]=Catalog___cltvc[cl] + 1
                endif
            endif
            
            set b=(LoadInteger(Table___ht, (Catalog___en[t]), (b))) // INLINED!!
            set Catalog___clcv[cl]=b
            set y=(LoadInteger(Table___ht, (Catalog___c), (b))) // INLINED!!
            set v=0
            
            if ( b == t ) then
                if ( 0 == Catalog___cltvc[cl] ) then
                    call CatalogLoopDestroy(cl)
                    return 0
                endif
                
                set Catalog___cltvc[cl]=Catalog___cltvc[cl] - 1
                set t=(LoadInteger(Table___ht, (Catalog___cltvp[cl]), (Catalog___cltvc[cl]))) // INLINED!!
                set b=(LoadInteger(Table___ht, (Catalog___cltv[cl]), (Catalog___cltvc[cl]))) // INLINED!!
                set y=(LoadInteger(Table___ht, (Catalog___c), (b))) // INLINED!!
                set v=0
                
                set Catalog___clp[cl]=t
                set Catalog___clcv[cl]=b
            endif
        endloop
        
        return 0
    endfunction
    
    function CatalogLoopCreate takes integer t,integer si returns integer
        local integer cl
        
        if ( 0 == Catalog___clr[0] ) then
            set cl=Catalog___clic + 1
            set Catalog___clic=cl
        else
            set cl=Catalog___clr[0]
            set Catalog___clr[0]=Catalog___clr[cl]
            
            set Catalog___cltvc[cl]=0
            set Catalog___clvi[cl]=0
        endif
        
        set Catalog___cltv[cl]=s__Table_create()
        set Catalog___cltvp[cl]=s__Table_create()
        set Catalog___clthv[cl]=s__Table_create()
        set Catalog___clcv[cl]=t
        set Catalog___clp[cl]=t
        call SaveBoolean(Table___ht, (((Catalog___clthv[cl]))), (t), ( true)) // INLINED!!
        
        if ( 1 < si ) then
            call CatalogLoopNext(cl , si - 1)
        endif
        
        return cl
    endfunction
        function s__Catalog_create takes nothing returns integer
            return CatalogCreate()
        endfunction
        function s__Catalog_destroy takes integer this returns nothing
            call CatalogDestroy(this)
        endfunction
        function s__Catalog_raw takes integer this,integer id returns integer
            return CatalogRaw(this , id)
        endfunction
        function s__Catalog_id takes integer this,integer raw returns integer
            return CatalogId(this , raw)
        endfunction
        function s__Catalog_add takes integer this,integer v returns nothing
            call CatalogAdd(this , v)
        endfunction
        function s__Catalog_addCatalog takes integer this,integer catalog returns nothing
            call CatalogAddCatalog(this , catalog)
        endfunction
        function s__Catalog__get_count takes integer this returns integer
            return CatalogCount(this)
        endfunction
        function s__CatalogLoop_create takes integer catalog,integer startIndex returns integer
            return CatalogLoopCreate(catalog , startIndex)
        endfunction
        function s__CatalogLoop_destroy takes integer this returns nothing
            call CatalogLoopDestroy(this)
        endfunction
        function s__CatalogLoop__get_next takes integer this returns integer
            return CatalogLoopNext(this , 1)
        endfunction
        function s__CatalogLoop_skip takes integer this,integer toSkip returns integer
            return CatalogLoopNext(this , toSkip + 1)
        endfunction

//library Catalog ends
//library FighterFirstSpells:
        function s__FFS_MightySlash_onHit takes unit attacker,unit victim,real applicableDamage returns real
            local real factor= GetUnitAbilityLevel(attacker, FighterFirstSpells__MS_ID)
            local real damage= ( applicableDamage * ( FighterFirstSpells__MS_DMG + ( FighterFirstSpells__MS_DMG_LVL * factor ) ) ) + ( GetHeroStr(attacker, true) * ( FighterFirstSpells__MS_STR + ( FighterFirstSpells__MS_STR_LVL * factor ) ) )
            local real splashDamage= damage * ( FighterFirstSpells__MS_SPLSH + ( FighterFirstSpells__MS_SPLSH_LVL * factor ) )
            local group splashed= CreateGroup()
            local unit u
            call GroupEnumUnitsInRange(splashed, GetUnitX(victim), GetUnitY(victim), ( FighterFirstSpells__MS_SPLSH_RNG + ( FighterFirstSpells__MS_SPLSH_RNG_LVL * factor ) ), getTargetFilter(GetOwningPlayer(attacker)))
            call GroupRemoveUnit(splashed, victim)
            call DestroyEffect(AddSpecialEffect(MS_FX, GetUnitX(victim), GetUnitY(victim)))
            loop
                set u=FirstOfGroup(splashed)
                exitwhen u == null
                call DestroyEffect(AddSpecialEffect(FighterFirstSpells__MS_FX2, GetUnitX(u), GetUnitY(u)))
                call pureDamage(attacker , u , splashDamage)
            
                call GroupRemoveUnit(splashed, u)
            endloop
            
            set u=null
            call DestroyGroup(splashed)
            set splashed=null
            
            return damage
        endfunction
//Implemented from module T32Interface:
        
        function s__FFS_WhirlingWrath_T32Interface___onInit takes nothing returns nothing
            set s__FFS_WhirlingWrath_T32Interface___timers=(CTL___A((function sc__FFS_WhirlingWrath_T32Interface___expire))) // INLINED!!
        endfunction
        
        function s__FFS_WhirlingWrath_T32Interface___expire takes nothing returns nothing
            local integer i= 0
            local integer array recycle
            local integer recycleCount= 0
            local integer temp
            local boolean running= false
            loop
                exitwhen s__FFS_WhirlingWrath_T32Interface___list[i] == 0
                if not sc__FFS_WhirlingWrath_onLoop(s__FFS_WhirlingWrath_T32Interface___list[i]) then
                   set recycle[recycleCount]=s__FFS_WhirlingWrath_T32Interface___list[i]
                   set recycleCount=recycleCount + 1
                   call sc__FFS_WhirlingWrath_onExpire(s__FFS_WhirlingWrath_T32Interface___list[i])
                else
                    set running=true
                endif
                set i=i + 1
            endloop
            if recycleCount != 0 then
                set i=0
                loop
                    exitwhen recycle[i] == 0
                    set temp=recycle[i]
                    set s__FFS_WhirlingWrath_recyclePosition[s__FFS_WhirlingWrath_T32Interface___list[s__FFS_WhirlingWrath_T32Interface___count]]=s__FFS_WhirlingWrath_recyclePosition[temp]
                    set s__FFS_WhirlingWrath_T32Interface___list[s__FFS_WhirlingWrath_recyclePosition[temp]]=s__FFS_WhirlingWrath_T32Interface___list[s__FFS_WhirlingWrath_T32Interface___count]
                    set s__FFS_WhirlingWrath_T32Interface___list[s__FFS_WhirlingWrath_T32Interface___count]=0
                    //call temp.deallocate()
                    set s__FFS_WhirlingWrath_T32Interface___count=s__FFS_WhirlingWrath_T32Interface___count - 1
                    set i=i + 1
                endloop
            endif
            if not running then
                call CTL___SR32((s__FFS_WhirlingWrath_T32Interface___timers)) // INLINED!!
            endif
        endfunction
        
        function s__FFS_WhirlingWrath_add takes integer this returns nothing
            local integer i= 0
            loop
                exitwhen s__FFS_WhirlingWrath_T32Interface___list[i] == 0
                set i=i + 1
            endloop
            set s__FFS_WhirlingWrath_T32Interface___list[i]=this
            set s__FFS_WhirlingWrath_recyclePosition[this]=i
            set s__FFS_WhirlingWrath_T32Interface___count=s__FFS_WhirlingWrath_T32Interface___count + 1
            call CTL___A32((s__FFS_WhirlingWrath_T32Interface___timers)) // INLINED!!
        endfunction
        
        
        function s__FFS_WhirlingWrath_onLoop takes integer this returns boolean
            local real angle= (GetRandomReal(- bj_PI, bj_PI)) // INLINED!!
            
            set s__FFS_WhirlingWrath_tick[this]=s__FFS_WhirlingWrath_tick[this] + 1
            if s__FFS_WhirlingWrath_tick[this] == FighterFirstSpells__WW_TICK then
                set s__FFS_WhirlingWrath_tick[this]=0
            else
                return true
            endif
            
            if (TimerGetElapsed(gameTimer)) - s__FFS_WhirlingWrath_startTime[this] > FighterFirstSpells__WW_TIME then // INLINED!!
                return false
            endif
            call FireWave(s__FFS_WhirlingWrath_playerId[this] , WW_WAVE_ABIL , s__FFS_WhirlingWrath_x[this] , s__FFS_WhirlingWrath_y[this] , angle , this)
            call SetUnitFacingTimed(s__FFS_WhirlingWrath_caster[this], angle * bj_RADTODEG, 0)
            call SetUnitAnimation(s__FFS_WhirlingWrath_caster[this], "attack")
            return true
        endfunction
        
        function s__FFS_WhirlingWrath_onHit takes unit caster,unit victim returns real
            local integer this= (LoadInteger(Table___ht, (BaseFunction__attachtable), (GetHandleId((caster))))) // INLINED!!
            call aggroDamage(caster , victim)
            return s__FFS_WhirlingWrath_damagePer[this]
        endfunction
        function s__FFS_WhirlingWrath_onFinalExpire takes nothing returns nothing
            local integer this= (LoadInteger(Table___ht, (s__FFS_WhirlingWrath_attachedTimerData), (GetHandleId(GetExpiredTimer())))) // INLINED!!
            call DestroyTimer(GetExpiredTimer())
            set s__FFS_WhirlingWrath_caster[this]=null
            call s__FFS_WhirlingWrath_deallocate(this)
        endfunction
        function s__FFS_WhirlingWrath_onExpire takes integer this returns nothing
            local timer t= CreateTimer()
            call SaveInteger(Table___ht, (s__FFS_WhirlingWrath_attachedTimerData), (GetHandleId(t)), ( this)) // INLINED!!
            if s__FFS_WhirlingWrath_caster[this] == null then
            endif
            call PauseUnit(s__FFS_WhirlingWrath_caster[this], false)
            call TimerStart(t, 15, false, function s__FFS_WhirlingWrath_onFinalExpire)
        endfunction
        function s__FFS_WhirlingWrath_create takes unit casterv returns integer
            local integer this= s__FFS_WhirlingWrath__allocate()
            if s__FFS_WhirlingWrath_attachedTimerData == 0 then
                set s__FFS_WhirlingWrath_attachedTimerData=s__Table_create()
            endif
            call PauseUnit(casterv, true)
            set s__FFS_WhirlingWrath_tick[this]=0
            set s__FFS_WhirlingWrath_x[this]=GetUnitX(casterv)
            set s__FFS_WhirlingWrath_y[this]=GetUnitY(casterv)
            set s__FFS_WhirlingWrath_caster[this]=casterv
            set s__FFS_WhirlingWrath_startTime[this]=(TimerGetElapsed(gameTimer)) // INLINED!!
            set s__FFS_WhirlingWrath_damagePer[this]=( 2 + ( 0.25 * GetUnitAbilityLevel(casterv, WW_ID) ) ) * GetHeroStr(casterv, true)
            set s__FFS_WhirlingWrath_startLevel[this]=GetUnitAbilityLevel(casterv, WW_ID)
            set s__FFS_WhirlingWrath_playerId[this]=GetPlayerId(GetOwningPlayer(casterv))
            call s__FFS_WhirlingWrath_add(this)
            return this
        endfunction
        
//Implemented from module T32Interface:
        
        function s__FFS_Banish_T32Interface___onInit takes nothing returns nothing
            set s__FFS_Banish_T32Interface___timers=(CTL___A((function sc__FFS_Banish_T32Interface___expire))) // INLINED!!
        endfunction
        
        function s__FFS_Banish_T32Interface___expire takes nothing returns nothing
            local integer i= 0
            local integer array recycle
            local integer recycleCount= 0
            local integer temp
            local boolean running= false
            loop
                exitwhen s__FFS_Banish_T32Interface___list[i] == 0
                if not sc__FFS_Banish_onLoop(s__FFS_Banish_T32Interface___list[i]) then
                   set recycle[recycleCount]=s__FFS_Banish_T32Interface___list[i]
                   set recycleCount=recycleCount + 1
                   call sc__FFS_Banish_onExpire(s__FFS_Banish_T32Interface___list[i])
                else
                    set running=true
                endif
                set i=i + 1
            endloop
            if recycleCount != 0 then
                set i=0
                loop
                    exitwhen recycle[i] == 0
                    set temp=recycle[i]
                    set s__FFS_Banish_recyclePosition[s__FFS_Banish_T32Interface___list[s__FFS_Banish_T32Interface___count]]=s__FFS_Banish_recyclePosition[temp]
                    set s__FFS_Banish_T32Interface___list[s__FFS_Banish_recyclePosition[temp]]=s__FFS_Banish_T32Interface___list[s__FFS_Banish_T32Interface___count]
                    set s__FFS_Banish_T32Interface___list[s__FFS_Banish_T32Interface___count]=0
                    //call temp.deallocate()
                    set s__FFS_Banish_T32Interface___count=s__FFS_Banish_T32Interface___count - 1
                    set i=i + 1
                endloop
            endif
            if not running then
                call CTL___SR32((s__FFS_Banish_T32Interface___timers)) // INLINED!!
            endif
        endfunction
        
        function s__FFS_Banish_add takes integer this returns nothing
            local integer i= 0
            loop
                exitwhen s__FFS_Banish_T32Interface___list[i] == 0
                set i=i + 1
            endloop
            set s__FFS_Banish_T32Interface___list[i]=this
            set s__FFS_Banish_recyclePosition[this]=i
            set s__FFS_Banish_T32Interface___count=s__FFS_Banish_T32Interface___count + 1
            call CTL___A32((s__FFS_Banish_T32Interface___timers)) // INLINED!!
        endfunction
        
        
        
        
        
        function s__FFS_Banish_onLoop takes integer this returns boolean
            local unit u
            local group g= CreateGroup()
            local real x
            local real y
            local real angle
            
            local real xdiff
            local real ydiff
            
            if s__FFS_Banish_isCharging[this] then
                
                set s__FFS_Banish_tickCount[this]=s__FFS_Banish_tickCount[this] + 1
                
                call IssueImmediateOrder(s__FFS_Banish_caster[this], "stop")
                
                if s__FFS_Banish_tickCount[this] > 5 * 32 then
                    call sc__FFS_Banish_cancel(this)
                        call DestroyGroup(g)
                        set u=null
                    return false
                else
                    set xdiff=GetUnitX(s__FFS_Banish_chargeTarget[this]) - GetUnitX(s__FFS_Banish_caster[this])
                    set ydiff=GetUnitY(s__FFS_Banish_chargeTarget[this]) - GetUnitY(s__FFS_Banish_caster[this])
                    
                    if ( xdiff * xdiff ) + ( ydiff * ydiff ) > ( FighterFirstSpells__BN_RANGE * FighterFirstSpells__BN_RANGE ) then
                        call sc__FFS_Banish_cancel(this)
                        call DestroyGroup(g)
                        set u=null
                        return false
                    endif
                        
                    
                    set angle=Atan2(GetUnitY(s__FFS_Banish_chargeTarget[this]) - GetUnitY(s__FFS_Banish_caster[this]), GetUnitX(s__FFS_Banish_chargeTarget[this]) - GetUnitX(s__FFS_Banish_caster[this]))
                    
                    call SetUnitX(s__FFS_Banish_caster[this], GetUnitX(s__FFS_Banish_caster[this]) + ( FighterFirstSpells__BN_SPEED * Cos(angle) ))
                    call SetUnitY(s__FFS_Banish_caster[this], GetUnitY(s__FFS_Banish_caster[this]) + ( FighterFirstSpells__BN_SPEED * Sin(angle) ))
                    
                    set xdiff=GetUnitX(s__FFS_Banish_chargeTarget[this]) - GetUnitX(s__FFS_Banish_caster[this])
                    set ydiff=GetUnitY(s__FFS_Banish_chargeTarget[this]) - GetUnitY(s__FFS_Banish_caster[this])
                    
                    
                    if ( xdiff * xdiff ) + ( ydiff * ydiff ) < ( FighterFirstSpells__BN_COLLIDE_DST ) then
                        set s__FFS_Banish_tickCount[this]=0
                        call sc__FFS_Banish_onCollide(this)
                    endif
                endif
                
            else
                set s__FFS_Banish_tickCount[this]=s__FFS_Banish_tickCount[this] + 1
                if s__FFS_Banish_tickCount[this] >= 17 then
                    call DestroyGroup(g)
                    set u=null
                    return false
                endif
                
                call GroupAddGroup(s__FFS_Banish_units[this], g)
                
                loop
                    set u=FirstOfGroup(g)
                    exitwhen u == null
                    set x=GetUnitX(u) + (LoadReal(Table___ht, (((s__FFS_Banish_data[this]))), (GetUnitUserData(u)))) // INLINED!!
                    set y=GetUnitY(u) + (LoadReal(Table___ht, (((s__FFS_Banish_data[this]))), (GetUnitUserData(u) + 100000))) // INLINED!!
                    
                    if IsTerrainWalkable(x , y) then
                    
                        call SetUnitX(u, GetUnitX(u) + (LoadReal(Table___ht, (((s__FFS_Banish_data[this]))), (GetUnitUserData(u))))) // INLINED!!
                        call SetUnitY(u, GetUnitY(u) + (LoadReal(Table___ht, (((s__FFS_Banish_data[this]))), (GetUnitUserData(u) + 100000)))) // INLINED!!
                        
                    endif
                    
                    call GroupRemoveUnit(g, u)
                endloop
            endif
            call DestroyGroup(g)
            set u=null
            
            return true
        endfunction
        
        function s__FFS_Banish_onExpire takes integer this returns nothing
            local unit u
            call sc__ShadowTrail_remove(s__FFS_Banish_trail[this])
            call PauseUnit(s__FFS_Banish_caster[this], false)
            call SetUnitInvulnerable(s__FFS_Banish_caster[this], false)
            loop
                set u=FirstOfGroup(s__FFS_Banish_units[this])
                exitwhen u == null
                call PauseUnit(u, false)
                call pureDamage(s__FFS_Banish_caster[this] , u , 1)
                call GroupRemoveUnit(s__FFS_Banish_units[this], u)
            endloop
            call DestroyGroup(s__FFS_Banish_units[this])
            set s__FFS_Banish_caster[this]=null
            call FlushChildHashtable(Table___ht, (s__FFS_Banish_data[this])) // INLINED!!
            call s__Table_destroy(s__FFS_Banish_data[this])
            call s__FFS_Banish_deallocate(this)
            set u=null
        endfunction
        
        function s__FFS_Banish_cancel takes integer this returns nothing
            call DestroyEffect(AddSpecialEffect(MS_FX, GetUnitX(s__FFS_Banish_caster[this]), GetUnitY(s__FFS_Banish_caster[this])))
            call sc__ShadowTrail_remove(s__FFS_Banish_trail[this])
            call PauseUnit(s__FFS_Banish_caster[this], false)
        endfunction
        
        function s__FFS_Banish_onCollide takes integer this returns nothing
            local group g= CreateGroup()
            local unit u
            local real casterx= GetUnitX(s__FFS_Banish_caster[this])
            local real castery= GetUnitY(s__FFS_Banish_caster[this])
            local real angle
            local real damage= s__FFS_Banish_onHitDamage[this]
            call DestroyEffect(AddSpecialEffect(MS_FX, casterx, castery))
            call sc__ShadowTrail_remove(s__FFS_Banish_trail[this])
            call PauseUnit(s__FFS_Banish_caster[this], false)
            call SetUnitInvulnerable(s__FFS_Banish_caster[this], false)
            set s__FFS_Banish_isCharging[this]=false
            set s__FFS_Banish_tickCount[this]=0
            call GroupEnumUnitsInRange(g, GetUnitX(s__FFS_Banish_chargeTarget[this]), GetUnitY(s__FFS_Banish_chargeTarget[this]), 200, getTargetFilter(GetOwningPlayer(s__FFS_Banish_caster[this])))
            
            loop
                set u=FirstOfGroup(g)
                exitwhen u == null
                
                set angle=Atan2(GetUnitY(u) - castery, GetUnitX(u) - casterx)
                call SaveReal(Table___ht, (((s__FFS_Banish_data[this]))), (GetUnitUserData(u)), (( ( 1.0 / 16.0 ) * ( FighterFirstSpells__BN_KNOCKBACK_RANGE * Cos(angle) ))*1.0)) // INLINED!!
                call SaveReal(Table___ht, (((s__FFS_Banish_data[this]))), (GetUnitUserData(u) + 100000), (( ( 1.0 / 16.0 ) * ( FighterFirstSpells__BN_KNOCKBACK_RANGE * Sin(angle) ))*1.0)) // INLINED!!
                call GroupAddUnit(s__FFS_Banish_units[this], u)
                set s__FFS_Banish_dataIndex[this]=s__FFS_Banish_dataIndex[this] + 1
                call PauseUnit(u, true)
                call pureDamage(s__FFS_Banish_caster[this] , u , damage)
                
                
                call GroupRemoveUnit(g, u)
            endloop
        endfunction
        
        function s__FFS_Banish_create takes unit casterv,unit target returns integer
            local integer this= s__FFS_Banish__allocate()
            local real angle
            local real targetx= GetUnitX(target)
            local real targety= GetUnitY(target)
            local real casterx= GetUnitX(casterv)
            local real castery= GetUnitY(casterv)
            local real damage= ( FighterFirstSpells__BN_STR + ( FighterFirstSpells__BN_STR_LVL * GetUnitAbilityLevel(casterv, FighterFirstSpells__BN_ID) ) ) * GetHeroStr(casterv, true)
            set s__FFS_Banish_trail[this]=sc__ShadowTrail_add(casterv , TRAIL_TYPE_MOTION , 999)
            call sc__ShadowTrail_setupMovingTrail(s__FFS_Banish_trail[this],5 , 16 , 0.7)
            call sc__ShadowTrail_setColor(s__FFS_Banish_trail[this],150 , 150 , 150 , 200)
            call sc__ShadowTrail_setAnimationIndex(s__FFS_Banish_trail[this],9)
            call sc__ShadowTrail_setFadeRate(s__FFS_Banish_trail[this],10 , true)
            call sc__ShadowTrail_setEffect(s__FFS_Banish_trail[this],"Abilities\\Weapons\\ZigguratMissile\\ZigguratMissile.mdl" , "chest" , false)
            // ----------------------------------------
            
            
            //call PauseUnit(casterv, true)
            call SetUnitInvulnerable(casterv, false)
            
            call SetUnitAnimationByIndex(casterv, 9)
            
            set s__FFS_Banish_data[this]=s__Table_create()
            set s__FFS_Banish_units[this]=CreateGroup()
            set s__FFS_Banish_caster[this]=casterv
            set s__FFS_Banish_chargeTarget[this]=target
            set s__FFS_Banish_onHitDamage[this]=damage
            set s__FFS_Banish_unitsIndex[this]=0
            set s__FFS_Banish_dataIndex[this]=0
            set s__FFS_Banish_tickCount[this]=0
            set s__FFS_Banish_isCharging[this]=true
            
            call s__FFS_Banish_add(this)
            
            return this
        endfunction
//Implemented from module T32Interface:
        
        function s__FFS_BurstCounter_T32Interface___onInit takes nothing returns nothing
            set s__FFS_BurstCounter_T32Interface___timers=(CTL___A((function sc__FFS_BurstCounter_T32Interface___expire))) // INLINED!!
        endfunction
        
        function s__FFS_BurstCounter_T32Interface___expire takes nothing returns nothing
            local integer i= 0
            local integer array recycle
            local integer recycleCount= 0
            local integer temp
            local boolean running= false
            loop
                exitwhen s__FFS_BurstCounter_T32Interface___list[i] == 0
                if not sc__FFS_BurstCounter_onLoop(s__FFS_BurstCounter_T32Interface___list[i]) then
                   set recycle[recycleCount]=s__FFS_BurstCounter_T32Interface___list[i]
                   set recycleCount=recycleCount + 1
                   call sc__FFS_BurstCounter_onExpire(s__FFS_BurstCounter_T32Interface___list[i])
                else
                    set running=true
                endif
                set i=i + 1
            endloop
            if recycleCount != 0 then
                set i=0
                loop
                    exitwhen recycle[i] == 0
                    set temp=recycle[i]
                    set s__FFS_BurstCounter_recyclePosition[s__FFS_BurstCounter_T32Interface___list[s__FFS_BurstCounter_T32Interface___count]]=s__FFS_BurstCounter_recyclePosition[temp]
                    set s__FFS_BurstCounter_T32Interface___list[s__FFS_BurstCounter_recyclePosition[temp]]=s__FFS_BurstCounter_T32Interface___list[s__FFS_BurstCounter_T32Interface___count]
                    set s__FFS_BurstCounter_T32Interface___list[s__FFS_BurstCounter_T32Interface___count]=0
                    //call temp.deallocate()
                    set s__FFS_BurstCounter_T32Interface___count=s__FFS_BurstCounter_T32Interface___count - 1
                    set i=i + 1
                endloop
            endif
            if not running then
                call CTL___SR32((s__FFS_BurstCounter_T32Interface___timers)) // INLINED!!
            endif
        endfunction
        
        function s__FFS_BurstCounter_add takes integer this returns nothing
            local integer i= 0
            loop
                exitwhen s__FFS_BurstCounter_T32Interface___list[i] == 0
                set i=i + 1
            endloop
            set s__FFS_BurstCounter_T32Interface___list[i]=this
            set s__FFS_BurstCounter_recyclePosition[this]=i
            set s__FFS_BurstCounter_T32Interface___count=s__FFS_BurstCounter_T32Interface___count + 1
            call CTL___A32((s__FFS_BurstCounter_T32Interface___timers)) // INLINED!!
        endfunction
        
        
        function s__FFS_BurstCounter_onLoop takes integer this returns boolean
            set s__FFS_BurstCounter_tickCount[this]=s__FFS_BurstCounter_tickCount[this] + 1
            if s__FFS_BurstCounter_tickCount[this] >= s__FFS_BurstCounter_tickCountTo[this] then
                return false
            endif
            
            if s__FFS_BurstCounter_tickCount[this] == s__FFS_BurstCounter_tickCountTo[this] - 20 then
                call DestroyEffect(AddSpecialEffect(FighterFirstSpells__BC_FX, GetUnitX(s__FFS_BurstCounter_caster[this]), GetUnitY(s__FFS_BurstCounter_caster[this])))
            endif
                
            
            call SetTextTagPos(s__FFS_BurstCounter_textTag[this], GetUnitX(s__FFS_BurstCounter_caster[this]), GetUnitY(s__FFS_BurstCounter_caster[this]), FighterFirstSpells__BC_HEIGHT)
            
            return true
        endfunction
        
        function s__FFS_BurstCounter_isUnitInBC takes unit target,real damageDealt,boolean crit returns boolean
            local integer this= (LoadInteger(Table___ht, (s__FFS_BurstCounter_currentInstances), (GetUnitTypeId(target)))) // INLINED!!
            local real factor
            local integer lvl
            
            
            if this == 0 then
                return false
            endif
            
            if crit then
                set damageDealt=damageDealt * getCritPow(s__FFS_BurstCounter_caster[this])
            endif
            
            set lvl=GetUnitAbilityLevel(s__FFS_BurstCounter_caster[this], BC_ID)
            set factor=1
            if s__FFS_BurstCounter_capacity[this] == s__FFS_BurstCounter_currentCapacity[this] then
            elseif damageDealt * factor + s__FFS_BurstCounter_currentCapacity[this] > s__FFS_BurstCounter_capacity[this] then
                set s__FFS_BurstCounter_currentCapacity[this]=s__FFS_BurstCounter_capacity[this]
                call SetTextTagColor(s__FFS_BurstCounter_textTag[this], 255, 55, 55, 255)
                call SetTextTagText(s__FFS_BurstCounter_textTag[this], I2S(R2I(s__FFS_BurstCounter_capacity[this])) + "!", FighterFirstSpells__BC_TEXTTAGHEIGHT)
            else
                set s__FFS_BurstCounter_currentCapacity[this]=s__FFS_BurstCounter_currentCapacity[this] + damageDealt * factor
                call SetTextTagText(s__FFS_BurstCounter_textTag[this], I2S(R2I(s__FFS_BurstCounter_currentCapacity[this])), FighterFirstSpells__BC_TEXTTAGHEIGHT)
            endif
            
            return true
        endfunction
        
        function s__FFS_BurstCounter_onExpire takes integer this returns nothing
            local group g= CreateGroup()
            local unit u
            local real lvl= GetUnitAbilityLevel(s__FFS_BurstCounter_caster[this], BC_ID)
            local real damage= s__FFS_BurstCounter_currentCapacity[this] * ( FighterFirstSpells__BC_PERCENT + ( FighterFirstSpells__BC_PERCENT_LVL * lvl ) )
            
            
            //todo: kaboom
            
            call GroupEnumUnitsInRange(g, GetUnitX(s__FFS_BurstCounter_caster[this]), GetUnitY(s__FFS_BurstCounter_caster[this]), FighterFirstSpells__BC_KABOOM_RADIUS, getTargetFilter(GetOwningPlayer(s__FFS_BurstCounter_caster[this])))
            
            loop
                set u=FirstOfGroup(g)
                exitwhen u == null
                
                call spellDamage(s__FFS_BurstCounter_caster[this] , u , damage)
                
                call GroupRemoveUnit(g, u)
            endloop
            
            call DestroyTextTag(s__FFS_BurstCounter_textTag[this])
            call SaveInteger(Table___ht, (s__FFS_BurstCounter_currentInstances), (GetUnitTypeId(s__FFS_BurstCounter_caster[this])), ( 0)) // INLINED!!
            set s__FFS_BurstCounter_caster[this]=null
            call s__FFS_BurstCounter_deallocate(this)
        endfunction
        
        function s__FFS_BurstCounter_create takes unit casterv returns integer
            local integer this= s__FFS_BurstCounter__allocate()
            local integer lvl= GetUnitAbilityLevel(casterv, BC_ID)
            
            if s__FFS_BurstCounter_currentInstances == 0 then
                set s__FFS_BurstCounter_currentInstances=s__Table_create()
            endif
            
            set s__FFS_BurstCounter_caster[this]=casterv
            set s__FFS_BurstCounter_capacity[this]=( FighterFirstSpells__BC_CAP_STR + ( FighterFirstSpells__BC_CAP_STR_LVL * lvl ) ) * GetHeroStr(s__FFS_BurstCounter_caster[this], true)
            set s__FFS_BurstCounter_tickCountTo[this]=( FighterFirstSpells__BC_DUR + ( FighterFirstSpells__BC_DUR_LVL * lvl ) ) * 32 + 1
            set s__FFS_BurstCounter_currentCapacity[this]=0
            set s__FFS_BurstCounter_tickCount[this]=0
            
            set s__FFS_BurstCounter_textTag[this]=CreateTextTag()
            call SetTextTagColor(s__FFS_BurstCounter_textTag[this], 155, 155, 255, 255)
            call SetTextTagPos(s__FFS_BurstCounter_textTag[this], GetUnitX(s__FFS_BurstCounter_caster[this]), GetUnitY(s__FFS_BurstCounter_caster[this]), FighterFirstSpells__BC_HEIGHT)
            call SetTextTagVisibility(s__FFS_BurstCounter_textTag[this], true)
            call SaveInteger(Table___ht, (s__FFS_BurstCounter_currentInstances), (GetUnitTypeId(s__FFS_BurstCounter_caster[this])), ( this)) // INLINED!!
            call s__FFS_BurstCounter_add(this)
            
            return this
        endfunction
        
    function FighterFirstSpells__OnSpell takes nothing returns boolean
        if GetSpellAbilityId() == WW_ID then
            call s__FFS_WhirlingWrath_create(GetTriggerUnit())
        elseif GetSpellAbilityId() == FighterFirstSpells__BN_ID then
            call s__FFS_Banish_create(GetTriggerUnit() , GetSpellTargetUnit())
        elseif GetSpellAbilityId() == BC_ID then
            call s__FFS_BurstCounter_create(GetTriggerUnit())
        endif
        return false
    endfunction

    function FighterFirstSpells__onInit takes nothing returns nothing
        local trigger trig= CreateTrigger()
        
        call TriggerRegisterAnyUnitEventBJ(trig, EVENT_PLAYER_UNIT_SPELL_EFFECT)
        call TriggerAddCondition(trig, Condition(function FighterFirstSpells__OnSpell))
        
        set trig=null
    endfunction

//library FighterFirstSpells ends
//library GetItemOwner:
    function GetItemOwnerId takes item i returns integer
        //if the item is owned, the owner is in the hashtable
        if ( IsItemOwned(i) ) then
            return (LoadInteger(Table___ht, (GetItemOwner___ot), (GetHandleId(i)))) // INLINED!!
        endif
        return 0
    endfunction
    function GetItemOwner takes item i returns unit
        return udg_UDexUnits[GetItemOwnerId(i)]
    endfunction
//Implemented from module GetItemOwner___init:
        //when a unit picks up an item, update the owner
        function s__GetItemOwner___ItemLoc_GetItemOwner___init___op takes nothing returns nothing
            call SaveInteger(Table___ht, (GetItemOwner___ot), (GetHandleId(GetManipulatedItem())), ( GetUnitUserData(GetTriggerUnit()))) // INLINED!!
        endfunction
        function s__GetItemOwner___ItemLoc_GetItemOwner___init___onInit takes nothing returns nothing
            set GetItemOwner___ot=s__Table_create()
            call RegisterPlayerUnitEvent(EVENT_PLAYER_UNIT_PICKUP_ITEM , function s__GetItemOwner___ItemLoc_GetItemOwner___init___op)
        endfunction

//library GetItemOwner ends
//library GetUnitCollision:
   
    function GetUnitCollision___C takes unit u,real x,real y,integer i returns real
        local real l= 0
        local real h= 300
        local real m= 150
        local real nm
       
        loop
            if ( IsUnitInRangeXY(u, x + m, y, 0) ) then
                set l=m
            else
                set h=m
            endif
            set nm=( l + h ) / 2
            exitwhen nm + .001 > m and nm - .001 < m
            set m=nm
        endloop
       
        set m=R2I(m * 10) / 10.
       
        call SaveReal(Table___ht, (((GetUnitCollision___uc))), (i), (( m)*1.0)) // INLINED!!
       
        return m
    endfunction
    function GetUnitCollision takes unit u returns real
        local integer i= GetUnitTypeId(u)
       
        if ( (HaveSavedReal(Table___ht, (((GetUnitCollision___uc))), (i))) ) then // INLINED!!
            return (LoadReal(Table___ht, (((GetUnitCollision___uc))), (i))) // INLINED!!
        endif
       
        return GetUnitCollision___C(u , GetUnitX(u) , GetUnitY(u) , i)
    endfunction
   
   
//Implemented from module GetUnitCollision___Initializer:
        function s__GetUnitCollision___init_GetUnitCollision___Initializer___onInit takes nothing returns nothing
            set GetUnitCollision___uc=s__Table_create()
        endfunction

//library GetUnitCollision ends
//library ShadowTrail:
   
    // Credit to Deaod, edited by Maker
    function ShadowTrail___CreateUnitWithoutShadow takes player owner,integer uid,real facing,string shadowfile returns unit
        local image i= CreateImage(shadowfile, 1, 1, 0, 0, 0, 0, 1, 1, 0, 3)
        if GetHandleId(i) == - 1 then // if the new shadow is invalid, abort, it can screw up the game
            return null // since the image is invalid, we dont need to destroy it
        endif
        call DestroyImage(i) // destroy the dummy.
        set ShadowTrail___u=CreateUnit(owner, uid, ShadowTrail___CREATE_X, ShadowTrail___CREATE_Y, facing) // create the unit. this also creates a new image which functions as the shadow of the unit. The shadow will use the ID of the dummy image.
        call DestroyImage(i) // destroy the shadow of the unit
        call CreateImage(shadowfile, 1, 1, 0, 0, 0, 0, 1, 1, 0, 3) // this creates the new shadow for the unit, note that i dont need to overwrite "i" as the id this image will get is predictable
        call SetImageRenderAlways(i, false) // Hides the shadow
        call SetImageColor(i, 0, 0, 0, 0) // Makes the shadow invisible
        // no need to null "i", as images dont use ref-counting
        return ShadowTrail___u
    endfunction

    // Fades out units over time

//Implemented from module CTLExpire:
        function s__ShadowTrail___Alpha_create takes nothing returns integer
            return CTL___CT(s__ShadowTrail___Alpha_rctl32)
        endfunction
        function s__ShadowTrail___Alpha_destroy takes integer this returns nothing
            call CTL___DT(this)
        endfunction
        function s__ShadowTrail___Alpha_ectl32 takes nothing returns boolean
            local integer this=CTL___rf[s__ShadowTrail___Alpha_rctl32]
            loop
                exitwhen 0 == this
            if (LoadBoolean(Table___ht, (((ShadowTrail___tab))), (GetHandleId(s__ShadowTrail___Alpha_ShadowTrail___u[this])))) == s__ShadowTrail___Alpha_sync[this] then // INLINED!!
                if s__ShadowTrail___Alpha_bl[this] then
                    set s__ShadowTrail___Alpha_a[this]=s__ShadowTrail___Alpha_a[this] + s__ShadowTrail___Alpha_rf[this]
                else
                    set s__ShadowTrail___Alpha_a[this]=R2I(s__ShadowTrail___Alpha_a[this] + s__ShadowTrail___Alpha_rs[this] * 50 + ( s__ShadowTrail___Alpha_aMax[this] - s__ShadowTrail___Alpha_a[this] ) * s__ShadowTrail___Alpha_rs[this])
                endif
                if s__ShadowTrail___Alpha_a[this] > 0 and s__ShadowTrail___Alpha_a[this] < s__ShadowTrail___Alpha_aMax[this] then
                    if IsUnitInvisible(s__ShadowTrail___Alpha_hero[this], GetLocalPlayer()) then
                        call SetUnitVertexColor(s__ShadowTrail___Alpha_ShadowTrail___u[this], s__ShadowTrail___Alpha_r[this], s__ShadowTrail___Alpha_g[this], s__ShadowTrail___Alpha_b[this], 0)
                    else
                        call SetUnitVertexColor(s__ShadowTrail___Alpha_ShadowTrail___u[this], s__ShadowTrail___Alpha_r[this], s__ShadowTrail___Alpha_g[this], s__ShadowTrail___Alpha_b[this], s__ShadowTrail___Alpha_a[this])
                    endif
                else
                    if s__ShadowTrail___Alpha_rem[this] then
                        if s__ShadowTrail___Alpha_e[this] != null then
                            call DestroyEffect(s__ShadowTrail___Alpha_e[this])
                            set s__ShadowTrail___Alpha_e[this]=null
                        endif
                        call RemoveUnit(s__ShadowTrail___Alpha_ShadowTrail___u[this])
                        set ShadowTrail___dc=ShadowTrail___dc - 1
                        if ShadowTrail___dc == 0 then
                            call FlushChildHashtable(Table___ht, (ShadowTrail___tab)) // INLINED!!
                        endif
                    elseif s__ShadowTrail___Alpha_a[this] <= 0 then
                        call SetUnitVertexColor(s__ShadowTrail___Alpha_ShadowTrail___u[this], s__ShadowTrail___Alpha_r[this], s__ShadowTrail___Alpha_g[this], s__ShadowTrail___Alpha_b[this], 0)
                        call ShowUnit(s__ShadowTrail___Alpha_ShadowTrail___u[this], false)
                    else
                        if IsUnitInvisible(s__ShadowTrail___Alpha_hero[this], GetLocalPlayer()) then
                            call SetUnitVertexColor(s__ShadowTrail___Alpha_ShadowTrail___u[this], s__ShadowTrail___Alpha_r[this], s__ShadowTrail___Alpha_g[this], s__ShadowTrail___Alpha_b[this], 0)
                        else
                            call SetUnitVertexColor(s__ShadowTrail___Alpha_ShadowTrail___u[this], s__ShadowTrail___Alpha_r[this], s__ShadowTrail___Alpha_g[this], s__ShadowTrail___Alpha_b[this], s__ShadowTrail___Alpha_aMax[this])
                        endif
                    endif
                    set s__ShadowTrail___Alpha_e[this]=null
                    set s__ShadowTrail___Alpha_ShadowTrail___u[this]=null
                    set s__ShadowTrail___Alpha_hero[this]=null
                    call CTL___DT((this)) // INLINED!!
                endif
            else
                set s__ShadowTrail___Alpha_e[this]=null
                set s__ShadowTrail___Alpha_ShadowTrail___u[this]=null
                set s__ShadowTrail___Alpha_hero[this]=null
                call CTL___DT((this)) // INLINED!!
            endif
//Implemented from module CTLEnd:
                set this=CTL___n[this]
            endloop
            return false
        endfunction
        function s__ShadowTrail___Alpha_CTLEnd___onInit takes nothing returns nothing
            set s__ShadowTrail___Alpha_rctl32=CTL___A(function s__ShadowTrail___Alpha_ectl32)
        endfunction
       
        function s__ShadowTrail___Alpha_start takes unit un,unit caster,integer rate1,real rate2,integer maxAlpha,integer red,integer grn,integer blu,integer alpha,boolean flatFade,boolean remove,boolean synch,effect eff returns nothing
            local integer this= (CTL___CT(s__ShadowTrail___Alpha_rctl32)) // INLINED!!
            set s__ShadowTrail___Alpha_ShadowTrail___u[this]=un
            set s__ShadowTrail___Alpha_hero[this]=caster
            set s__ShadowTrail___Alpha_a[this]=alpha
            set s__ShadowTrail___Alpha_aMax[this]=maxAlpha
            set s__ShadowTrail___Alpha_r[this]=red
            set s__ShadowTrail___Alpha_g[this]=grn
            set s__ShadowTrail___Alpha_b[this]=blu
            set s__ShadowTrail___Alpha_rf[this]=rate1
            set s__ShadowTrail___Alpha_rs[this]=rate2
            set s__ShadowTrail___Alpha_bl[this]=flatFade
            set s__ShadowTrail___Alpha_rem[this]=remove
            set s__ShadowTrail___Alpha_sync[this]=synch
            set s__ShadowTrail___Alpha_e[this]=eff
        endfunction

       
//Implemented from module CTL:
        function s__ShadowTrail_create takes nothing returns integer
            return CTL___CT(s__ShadowTrail_rctl32)
        endfunction
        function s__ShadowTrail_destroy takes integer this returns nothing
            call CTL___DT(this)
        endfunction
        function s__ShadowTrail_ectl32 takes nothing returns boolean
            local integer this=CTL___rf[s__ShadowTrail_rctl32]
            local real x
            local real y
            local real an
            local real f
            local unit l__ShadowTrail___u
            local unit s
            local effect e= null
            local integer i
            local integer j
//Implemented from module CTLExpire:
            loop
                exitwhen 0 == this
            if not IsUnitType(s__ShadowTrail_main[this], UNIT_TYPE_DEAD) and ( s__ShadowTrail_dur[this] >= 0 or s__ShadowTrail_perm[this] ) and GetUnitTypeId(s__ShadowTrail_main[this]) != 0 then
                if not s__ShadowTrail_perm[this] then
                    set s__ShadowTrail_dur[this]=s__ShadowTrail_dur[this] - 0.031250
                endif
                set x=GetUnitX(s__ShadowTrail_main[this])
                set y=GetUnitY(s__ShadowTrail_main[this])
                if x != s__ShadowTrail_xm[this] or y != s__ShadowTrail_ym[this] then
                    if s__ShadowTrail_id[this] == TRAIL_TYPE_STATIC then // Is moving, static trail
                        set s__ShadowTrail_time[this]=s__ShadowTrail_time[this] + 0.031250
                        if s__ShadowTrail_time[this] >= s__ShadowTrail_interval[this] then
                            set l__ShadowTrail___u=ShadowTrail___CreateUnitWithoutShadow(Player(15) , s__ShadowTrail_uid[this] , GetUnitFacing(s__ShadowTrail_main[this]) , ShadowTrail___SHADOWPATH)
                            set ShadowTrail___dc=ShadowTrail___dc + 1
                            call SetUnitTurnSpeed(l__ShadowTrail___u, 1000)
                            call UnitAddAbility(l__ShadowTrail___u, 'Arav')
                            call UnitAddAbility(l__ShadowTrail___u, 'Aloc')
                            call PauseUnit(l__ShadowTrail___u, true)
                            call SetUnitUseFood(l__ShadowTrail___u, false)
                            call SetUnitX(l__ShadowTrail___u, x)
                            call SetUnitY(l__ShadowTrail___u, y)
                            call SetUnitTimeScale(l__ShadowTrail___u, s__ShadowTrail_ts[this])
                            call SetUnitColor(l__ShadowTrail___u, s__ShadowTrail_pc[this])
                            call SetUnitVertexColor(l__ShadowTrail___u, s__ShadowTrail_r[this], s__ShadowTrail_g[this], s__ShadowTrail_b[this], 0)
                            call SetUnitAnimationByIndex(l__ShadowTrail___u, s__ShadowTrail_anim[this])
                            call SetUnitFlyHeight(l__ShadowTrail___u, GetUnitFlyHeight(s__ShadowTrail_main[this]), 0)
                            if s__ShadowTrail_bo2[this] then
                                set e=AddSpecialEffectTarget(s__ShadowTrail_eff[this], l__ShadowTrail___u, s__ShadowTrail_att[this])
                            endif
                            call SaveBoolean(Table___ht, (((ShadowTrail___tab))), (GetHandleId(l__ShadowTrail___u)), ( false)) // INLINED!!
                            call s__ShadowTrail___Alpha_start(l__ShadowTrail___u , s__ShadowTrail_main[this] , - s__ShadowTrail_fr[this] , - s__ShadowTrail_fp[this] , 255 , s__ShadowTrail_r[this] , s__ShadowTrail_g[this] , s__ShadowTrail_b[this] , s__ShadowTrail_a[this] , s__ShadowTrail_bo1[this] , true , false , e)
                            set s__ShadowTrail_time[this]=0
                            set l__ShadowTrail___u=null
                            set e=null
                        endif
                    else // Is moving, moving trail (type 1)
                        set i=s__ShadowTrail_tc[this]
                        loop
                            exitwhen i == 0
                            set s=(LoadUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i))) // INLINED!!
                            set l__ShadowTrail___u=(LoadUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i - 1))) // INLINED!!
                            set f=GetUnitFacing(l__ShadowTrail___u)
                            set an=( f + 180 ) * bj_DEGTORAD
                            if IsUnitHidden(s) then // If units are hidden, they should be set to visible
                                call SaveBoolean(Table___ht, (((ShadowTrail___tab))), (GetHandleId(s)), ( true)) // INLINED!!
                                call s__ShadowTrail___Alpha_start(s , s__ShadowTrail_main[this] , s__ShadowTrail_fr[this] , s__ShadowTrail_fp[this] , R2I(s__ShadowTrail_a[this] * Pow(s__ShadowTrail_af[this], i - 1)) , s__ShadowTrail_r[this] , s__ShadowTrail_g[this] , s__ShadowTrail_b[this] , 0 , s__ShadowTrail_bo1[this] , false , true , e)
                                call ShowUnit(s, true)
                                call UnitRemoveAbility(s, 'Aloc') // Showing unit makes units with Locust selectable
                                call UnitAddAbility(s, 'Aloc') // Must apply Locust again
                                call SetUnitAnimationByIndex(s, s__ShadowTrail_anim[this])
                            endif
                            call SetUnitX(s, GetUnitX(l__ShadowTrail___u) + s__ShadowTrail_d[this] * Cos(an))
                            call SetUnitY(s, GetUnitY(l__ShadowTrail___u) + s__ShadowTrail_d[this] * Sin(an))
                            call SetUnitFacing(s, f)
                            call SetUnitFlyHeight(s, GetUnitFlyHeight(l__ShadowTrail___u), 0)
                            set i=i - 1
                        endloop
                        if s__ShadowTrail_h[this] then
                            set s__ShadowTrail_h[this]=false
                        endif
                        set s=null
                        set l__ShadowTrail___u=null
                    endif
                elseif not s__ShadowTrail_h[this] and s__ShadowTrail_id[this] == TRAIL_TYPE_MOTION then // Is not moving, trail is visible, trail type 1
                    set i=s__ShadowTrail_tc[this]
                    loop
                        exitwhen i == 0
                        set j=R2I(s__ShadowTrail_a[this] * Pow(s__ShadowTrail_af[this], i - 1))
                        call SaveBoolean(Table___ht, (((ShadowTrail___tab))), (GetHandleId((LoadUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i))))), ( false)) // INLINED!!
                        call s__ShadowTrail___Alpha_start((LoadUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i))) , s__ShadowTrail_main[this] , - s__ShadowTrail_fr[this] , - s__ShadowTrail_fp[this] , j , s__ShadowTrail_r[this] , s__ShadowTrail_g[this] , s__ShadowTrail_b[this] , j , s__ShadowTrail_bo1[this] , false , false , null) // INLINED!!
                        set i=i - 1
                    endloop
                    set s__ShadowTrail_h[this]=true
                endif
                set s__ShadowTrail_xm[this]=x
                set s__ShadowTrail_ym[this]=y
            else
                set i=s__ShadowTrail_tc[this]
                loop
                    exitwhen i == 0
                    if (LoadEffectHandle(Table___ht, (((s__ShadowTrail_tb[this]))), (i))) != null then // INLINED!!
                        call DestroyEffect((LoadEffectHandle(Table___ht, (((s__ShadowTrail_tb[this]))), (i)))) // INLINED!!
                    endif
                    set j=R2I(s__ShadowTrail_a[this] * Pow(s__ShadowTrail_af[this], i - 1)) - 1
                    call SaveBoolean(Table___ht, (((ShadowTrail___tab))), (GetHandleId((LoadUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i))))), ( false)) // INLINED!!
                    call s__ShadowTrail___Alpha_start((LoadUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i))) , s__ShadowTrail_main[this] , - s__ShadowTrail_fr[this] , - s__ShadowTrail_fp[this] , j , s__ShadowTrail_r[this] , s__ShadowTrail_g[this] , s__ShadowTrail_b[this] , j , s__ShadowTrail_bo1[this] , true , false , null) // INLINED!!
                    set i=i - 1
                endloop
                if (LoadEffectHandle(Table___ht, (((s__ShadowTrail_tb[this]))), (0))) != null then // INLINED!!
                    call DestroyEffect((LoadEffectHandle(Table___ht, (((s__ShadowTrail_tb[this]))), (0)))) // INLINED!!
                endif
                set s__ShadowTrail_main[this]=null
                call FlushChildHashtable(Table___ht, (s__ShadowTrail_ta[this])) // INLINED!!
                call FlushChildHashtable(Table___ht, (s__ShadowTrail_tb[this])) // INLINED!!
                call CTL___DT((this)) // INLINED!!
            endif
//Implemented from module CTLEnd:
                set this=CTL___n[this]
            endloop
            return false
        endfunction
        function s__ShadowTrail_CTLEnd___onInit takes nothing returns nothing
            set s__ShadowTrail_rctl32=CTL___A(function s__ShadowTrail_ectl32)
        endfunction
       
        function s__ShadowTrail_remove takes integer this returns nothing
            set s__ShadowTrail_dur[this]=0
            set s__ShadowTrail_perm[this]=false
        endfunction
       
        function s__ShadowTrail_setEffect takes integer this,string model,string attachPoint,boolean attachToShadows returns nothing
            local integer i= 1
            set s__ShadowTrail_eff[this]=model
            set s__ShadowTrail_att[this]=attachPoint
            set s__ShadowTrail_bo2[this]=attachToShadows
            if attachToShadows then
                loop
                    exitwhen (LoadUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i))) == null // INLINED!!
                    if (LoadEffectHandle(Table___ht, (((s__ShadowTrail_tb[this]))), (i))) != null then // INLINED!!
                        call DestroyEffect((LoadEffectHandle(Table___ht, (((s__ShadowTrail_tb[this]))), (i)))) // INLINED!!
                    endif
                    call SaveEffectHandle(Table___ht, (((s__ShadowTrail_tb[this]))), (i), ( AddSpecialEffectTarget(model, (LoadUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i))), attachPoint))) // INLINED!!
                    set i=i + 1
                endloop
            endif
            if (LoadEffectHandle(Table___ht, (((s__ShadowTrail_tb[this]))), (i))) != null then // INLINED!!
                call DestroyEffect((LoadEffectHandle(Table___ht, (((s__ShadowTrail_tb[this]))), (i)))) // INLINED!!
            endif
            call SaveEffectHandle(Table___ht, (((s__ShadowTrail_tb[this]))), (0), ( AddSpecialEffectTarget(model, s__ShadowTrail_main[this], attachPoint))) // INLINED!!
        endfunction
       
        function s__ShadowTrail_setPlayerColor takes integer this,playercolor pColor returns nothing
            local integer i= 1
            set s__ShadowTrail_pc[this]=pColor
            loop
                exitwhen (LoadUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i))) == null // INLINED!!
                call SetUnitColor((LoadUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i))), s__ShadowTrail_pc[this]) // INLINED!!
                set i=i + 1
            endloop
        endfunction
       
        function s__ShadowTrail_setColor takes integer this,integer red,integer grn,integer blu,integer alpha returns nothing
            local integer i= 1
            set s__ShadowTrail_r[this]=red
            set s__ShadowTrail_g[this]=grn
            set s__ShadowTrail_b[this]=blu
            set s__ShadowTrail_a[this]=alpha
            loop
                exitwhen (LoadUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i))) == null // INLINED!!
                if s__ShadowTrail_id[this] == TRAIL_TYPE_STATIC or not s__ShadowTrail_h[this] then
                    call SetUnitVertexColor((LoadUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i))), red, grn, blu, R2I(s__ShadowTrail_a[this] * Pow(s__ShadowTrail_af[this], i - 1))) // INLINED!!
                else
                    call SetUnitVertexColor((LoadUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i))), red, grn, blu, 0) // INLINED!!
                endif
                set i=i + 1
            endloop
        endfunction
       
        function s__ShadowTrail_setAnimationIndex takes integer this,integer k returns nothing
            local integer i= 1
            set s__ShadowTrail_anim[this]=k
            loop
                exitwhen (LoadUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i))) == null // INLINED!!
                call SetUnitAnimationByIndex((LoadUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i))), k) // INLINED!!
                set i=i + 1
            endloop
        endfunction
       
        function s__ShadowTrail_setAnimationSpeed takes integer this,real r returns nothing
            local integer i= 1
            set s__ShadowTrail_ts[this]=r
            loop
                exitwhen (LoadUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i))) == null // INLINED!!
                call SetUnitTimeScale((LoadUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i))), r) // INLINED!!
                set i=i + 1
            endloop
        endfunction
       
        function s__ShadowTrail_setFadeRate takes integer this,real rate,boolean flatMode returns nothing
            if flatMode then
                set s__ShadowTrail_fr[this]=R2I(rate)
            else
                set s__ShadowTrail_fp[this]=1 - rate
            endif
            set s__ShadowTrail_bo1[this]=flatMode
        endfunction
       
        function s__ShadowTrail_setInterval takes integer this,real timee returns nothing
            set s__ShadowTrail_time[this]=0
            set s__ShadowTrail_interval[this]=timee
        endfunction
       
        function s__ShadowTrail_setupMovingTrail takes integer this,integer count,real separation,real alphaFactor returns nothing
            local integer i
            local unit l__ShadowTrail___u
            local real x= GetUnitX(s__ShadowTrail_main[this])
            local real y= GetUnitY(s__ShadowTrail_main[this])
            local real f= GetUnitFacing(s__ShadowTrail_main[this])
            if s__ShadowTrail_id[this] == TRAIL_TYPE_MOTION then
                if count > 0 then
                    set s__ShadowTrail_d[this]=separation
                    set s__ShadowTrail_tc[this]=count
                    set s__ShadowTrail_h[this]=false
                    set s__ShadowTrail_af[this]=alphaFactor
                    set s__ShadowTrail_xm[this]=GetUnitX(s__ShadowTrail_main[this])
                    set s__ShadowTrail_ym[this]=GetUnitY(s__ShadowTrail_main[this])
                    set s__ShadowTrail_ta[this]=s__Table_create()
                    set i=1
                    loop
                        set l__ShadowTrail___u=ShadowTrail___CreateUnitWithoutShadow(Player(15) , s__ShadowTrail_uid[this] , f , ShadowTrail___SHADOWPATH)
                        call ShowUnit(l__ShadowTrail___u, false)
                        call SetUnitVertexColor(l__ShadowTrail___u, s__ShadowTrail_r[this], s__ShadowTrail_g[this], s__ShadowTrail_b[this], 0)
                        set ShadowTrail___dc=ShadowTrail___dc + 1
                        call SetUnitColor(l__ShadowTrail___u, s__ShadowTrail_pc[this])
                        call UnitAddAbility(l__ShadowTrail___u, 'Arav')
                        call UnitAddAbility(l__ShadowTrail___u, 'Aloc')
                        call SetUnitUseFood(l__ShadowTrail___u, false)
                        call SetUnitX(l__ShadowTrail___u, x)
                        call SetUnitY(l__ShadowTrail___u, y)
                        call PauseUnit(l__ShadowTrail___u, true)
                        call SaveUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i), ( l__ShadowTrail___u)) // INLINED!!
                        exitwhen i == count
                        set i=i + 1
                    endloop
                    set s__ShadowTrail_h[this]=true
                    call SaveUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (0), ( s__ShadowTrail_main[this])) // INLINED!!
                    set l__ShadowTrail___u=null
                else
                endif
            endif
        endfunction
       
        function s__ShadowTrail_add takes unit target,integer trailType,real duration returns integer
            local integer this= 0
           
            if trailType == TRAIL_TYPE_MOTION or trailType == TRAIL_TYPE_STATIC then
                set this=(CTL___CT(s__ShadowTrail_rctl32)) // INLINED!!
                set s__ShadowTrail_main[this]=target
                set s__ShadowTrail_uid[this]=GetUnitTypeId(target)
                set s__ShadowTrail_id[this]=trailType
                set s__ShadowTrail_dur[this]=duration
               
                set s__ShadowTrail_tc[this]=0
                set s__ShadowTrail_perm[this]=duration == 0
               
                call s__ShadowTrail_setColor(this,255 , 255 , 255 , 255)
                call s__ShadowTrail_setAnimationIndex(this,0)
                call s__ShadowTrail_setAnimationSpeed(this,1)
                call s__ShadowTrail_setFadeRate(this,0 , true)
                call s__ShadowTrail_setFadeRate(this,0 , false)
                call s__ShadowTrail_setInterval(this,0.2)
                call s__ShadowTrail_setEffect(this,null , null , false)

                    set s__ShadowTrail_pc[this]=GetPlayerColor(GetOwningPlayer(target))



            endif
            return this
        endfunction
       
        function s__ShadowTrail_onInit takes nothing returns nothing
            set ShadowTrail___tab=s__Table_create()
        endfunction

//library ShadowTrail ends
//library StatBoard:
    
    
        
        //unit hero
        
        
        
        
        
        function s__MainBoard_update takes integer this,unit hero returns nothing
            call MultiboardSetTitleText(s__MainBoard_main[this], "Level " + I2S(GetHeroLevel(hero)) + " " + GetUnitName(hero))
            call MultiboardSetItemValue(s__MainBoard_h_HPMP[this], I2S(R2I(GetUnitState(hero, UNIT_STATE_LIFE))) + " / " + I2S(R2I(GetUnitState(hero, UNIT_STATE_MANA))))
            call MultiboardSetItemValue(s__MainBoard_h_BREA[this], "- - - - -")
            call MultiboardSetItemValue(s__MainBoard_h_STRE[this], I2S(R2I(GetHeroStr(hero, true))))
            call MultiboardSetItemValue(s__MainBoard_h_AGIL[this], I2S(R2I(GetHeroAgi(hero, true))))
            call MultiboardSetItemValue(s__MainBoard_h_INTE[this], I2S(R2I(GetHeroInt(hero, true))))
            call MultiboardSetItemValue(s__MainBoard_h_MREG[this], I2S(R2I(sc__StatHandler_getUnitBonus(hero , TRAIT_TYPE_MANA_REGEN))))
            call MultiboardSetItemValue(s__MainBoard_h_HREG[this], I2S(R2I(sc__StatHandler_getUnitBonus(hero , TRAIT_TYPE_LIFE_REGEN))))
            call MultiboardSetItemValue(s__MainBoard_h_ASPD[this], I2S(R2I(sc__StatHandler_getUnitBonus(hero , TRAIT_TYPE_ATTACK_SPEED))))
            call MultiboardSetItemValue(s__MainBoard_h_MSPD[this], I2S(R2I(sc__StatHandler_getUnitBonus(hero , TRAIT_TYPE_MOVEMENT_SPEED) + GetUnitDefaultMoveSpeed(hero))))
            call MultiboardSetItemValue(s__MainBoard_h_ARMO[this], I2S(R2I(sc__StatHandler_getUnitBonus(hero , TRAIT_TYPE_ARMOR))))
            call MultiboardSetItemValue(s__MainBoard_h_DAMA[this], I2S(R2I(sc__StatHandler_getUnitBonus(hero , TRAIT_TYPE_DAMAGE))))
            call MultiboardSetItemValue(s__MainBoard_h_SPAR[this], I2S(R2I(sc__StatHandler_getUnitBonus(hero , TRAIT_TYPE_SPIKE_ARMOR))))
            call MultiboardSetItemValue(s__MainBoard_h_STAR[this], I2S(R2I(sc__StatHandler_getUnitBonus(hero , TRAIT_TYPE_STATIC_ARMOR))))
            call MultiboardSetItemValue(s__MainBoard_h_LLEE[this], I2S(R2I(sc__StatHandler_getUnitBonus(hero , TRAIT_TYPE_LIFE_LEECH))))
            call MultiboardSetItemValue(s__MainBoard_h_ARED[this], I2S(R2I(sc__StatHandler_getUnitBonus(hero , TRAIT_TYPE_ARMOR_REDUCTION))))
            call MultiboardSetItemValue(s__MainBoard_h_FDMG[this], I2S(R2I(sc__StatHandler_getUnitBonus(hero , TRAIT_TYPE_FIRE_DAMAGE))) + " - " + I2S(R2I(sc__StatHandler_getUnitBonus(hero , TRAIT_TYPE_FIRE_MAX_DAMAGE))))
            call MultiboardSetItemValue(s__MainBoard_h_LDMG[this], I2S(R2I(sc__StatHandler_getUnitBonus(hero , TRAIT_TYPE_LIGHTNING_DAMAGE))) + " - " + I2S(R2I(sc__StatHandler_getUnitBonus(hero , TRAIT_TYPE_LIGHTNING_MAX_DAMAGE))))
            call MultiboardSetItemValue(s__MainBoard_h_SDMG[this], I2S(R2I(sc__StatHandler_getUnitBonus(hero , TRAIT_TYPE_STATIC_DAMAGE))) + " - " + I2S(R2I(sc__StatHandler_getUnitBonus(hero , TRAIT_TYPE_STATIC_MAX_DAMAGE))))
            call MultiboardSetItemValue(s__MainBoard_h_CDMG[this], I2S(R2I(sc__StatHandler_getUnitBonus(hero , TRAIT_TYPE_COLD_DAMAGE))) + " - " + I2S(R2I(sc__StatHandler_getUnitBonus(hero , TRAIT_TYPE_COLD_MAX_DAMAGE))))
            call MultiboardSetItemValue(s__MainBoard_h_PDMG[this], I2S(R2I(sc__StatHandler_getUnitBonus(hero , TRAIT_TYPE_POISON_DAMAGE))) + " - " + I2S(R2I(sc__StatHandler_getUnitBonus(hero , TRAIT_TYPE_POISON_MAX_DAMAGE))))
            call MultiboardSetItemValue(s__MainBoard_h_CRAT[this], I2S(R2I(sc__StatHandler_getUnitBonus(hero , TRAIT_TYPE_CRIT_RATE))))
            call MultiboardSetItemValue(s__MainBoard_h_CPOW[this], I2S(R2I(sc__StatHandler_getUnitBonus(hero , TRAIT_TYPE_CRIT_POW))))
            call MultiboardSetItemValue(s__MainBoard_h_SRAT[this], I2S(R2I(sc__StatHandler_getUnitBonus(hero , TRAIT_TYPE_SPELL_CRIT_RATE))))
            call MultiboardSetItemValue(s__MainBoard_h_SPOW[this], I2S(R2I(sc__StatHandler_getUnitBonus(hero , TRAIT_TYPE_SPELL_CRIT_POW))))
            call MultiboardSetItemValue(s__MainBoard_h_PHRE[this], I2S(R2I(sc__StatHandler_getUnitResistance(hero , TRAIT_TYPE_PHYSICAL_RESISTANCE))))
            call MultiboardSetItemValue(s__MainBoard_h_SRES[this], I2S(R2I(sc__StatHandler_getUnitResistance(hero , TRAIT_TYPE_SPELL_RESISTANCE))))
            call MultiboardSetItemValue(s__MainBoard_h_FRES[this], I2S(R2I(sc__StatHandler_getUnitResistance(hero , TRAIT_TYPE_FIRE_RESISTANCE))))
            call MultiboardSetItemValue(s__MainBoard_h_LRES[this], I2S(R2I(sc__StatHandler_getUnitResistance(hero , TRAIT_TYPE_LIGHTNING_RESISTANCE))))
            call MultiboardSetItemValue(s__MainBoard_h_CRES[this], I2S(R2I(sc__StatHandler_getUnitResistance(hero , TRAIT_TYPE_COLD_RESISTANCE))))
            call MultiboardSetItemValue(s__MainBoard_h_PRES[this], I2S(R2I(sc__StatHandler_getUnitResistance(hero , TRAIT_TYPE_POISON_RESISTANCE))))
            //call MultiboardSetItemValue(h_BRE2, " ")
            //call MultiboardSetItemValue(h_BRE3, " ")
            //call MultiboardMinimize(main,false)
        endfunction
        function s__MainBoard_create takes integer playerV returns integer
            local integer this= s__MainBoard__allocate()
            set s__MainBoard_playerId[this]=playerV
            set s__MainBoard_main[this]=CreateMultiboard()
            call MultiboardSetTitleText(s__MainBoard_main[this], "Level")
            call MultiboardSetColumnCount(s__MainBoard_main[this], 2)
            call MultiboardSetRowCount(s__MainBoard_main[this], 32)
            
            call MultiboardSetItemStyleBJ(s__MainBoard_main[this], 0, 0, true, false)
            call MultiboardSetItemWidthBJ(s__MainBoard_main[this], 1, 0, 10.00)
            call MultiboardSetItemWidthBJ(s__MainBoard_main[this], 2, 0, 10.00)
            
            set s__MainBoard_h_HPMP[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__HPMP, 1)
            set s__MainBoard_h_BREA[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__BREA, 1)
            set s__MainBoard_h_STRE[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__STRE, 1)
            set s__MainBoard_h_AGIL[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__AGIL, 1)
            set s__MainBoard_h_INTE[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__INTE, 1)
            set s__MainBoard_h_MREG[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__MREG, 1)
            set s__MainBoard_h_HREG[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__HREG, 1)
            set s__MainBoard_h_ASPD[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__ASPD, 1)
            set s__MainBoard_h_MSPD[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__MSPD, 1)
            set s__MainBoard_h_ARMO[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__ARMO, 1)
            set s__MainBoard_h_SPAR[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__SPAR, 1)
            set s__MainBoard_h_STAR[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__STAR, 1)
            set s__MainBoard_h_LLEE[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__LLEE, 1)
            set s__MainBoard_h_ARED[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__ARED, 1)
            //set  h_BRE1 = MultiboardGetItem(main,BRE1,1)
            set s__MainBoard_h_FDMG[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__FDMG, 1)
            set s__MainBoard_h_LDMG[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__LDMG, 1)
            set s__MainBoard_h_SDMG[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__SDMG, 1)
            set s__MainBoard_h_CDMG[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__CDMG, 1)
            set s__MainBoard_h_PDMG[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__PDMG, 1)
            set s__MainBoard_h_CRAT[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__CRAT, 1)
            set s__MainBoard_h_CPOW[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__CPOW, 1)
            set s__MainBoard_h_SRAT[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__SRAT, 1)
            set s__MainBoard_h_SPOW[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__SPOW, 1)
            set s__MainBoard_h_BRE3[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__BRE3, 1)
            set s__MainBoard_h_PHRE[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__PHRE, 1)
            set s__MainBoard_h_SRES[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__SRES, 1)
            set s__MainBoard_h_FRES[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__FRES, 1)
            set s__MainBoard_h_LRES[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__LRES, 1)
            set s__MainBoard_h_CRES[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__CRES, 1)
            set s__MainBoard_h_PRES[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__PRES, 1)
            set s__MainBoard_h_DAMA[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__DAMA, 1)
        
            set s__MainBoard_m_HPMP[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__HPMP, 0)
            call MultiboardSetItemValue(s__MainBoard_m_HPMP[this], StatBoard__s_HPMP)
            set s__MainBoard_m_DAMA[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__DAMA, 0)
            call MultiboardSetItemValue(s__MainBoard_m_DAMA[this], StatBoard__s_DAMA)
            set s__MainBoard_m_BREA[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__BREA, 0)
            call MultiboardSetItemValue(s__MainBoard_m_BREA[this], StatBoard__s_BREA)
            set s__MainBoard_m_STRE[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__STRE, 0)
            call MultiboardSetItemValue(s__MainBoard_m_STRE[this], StatBoard__s_STRE)
            set s__MainBoard_m_AGIL[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__AGIL, 0)
            call MultiboardSetItemValue(s__MainBoard_m_AGIL[this], StatBoard__s_AGIL)
            set s__MainBoard_m_INTE[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__INTE, 0)
            call MultiboardSetItemValue(s__MainBoard_m_INTE[this], StatBoard__s_INTE)
            set s__MainBoard_m_MREG[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__MREG, 0)
            call MultiboardSetItemValue(s__MainBoard_m_MREG[this], StatBoard__s_MREG)
            set s__MainBoard_m_HREG[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__HREG, 0)
            call MultiboardSetItemValue(s__MainBoard_m_HREG[this], StatBoard__s_HREG)
            set s__MainBoard_m_ASPD[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__ASPD, 0)
            call MultiboardSetItemValue(s__MainBoard_m_ASPD[this], StatBoard__s_ASPD)
            set s__MainBoard_m_MSPD[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__MSPD, 0)
            call MultiboardSetItemValue(s__MainBoard_m_MSPD[this], StatBoard__s_MSPD)
            set s__MainBoard_m_ARMO[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__ARMO, 0)
            call MultiboardSetItemValue(s__MainBoard_m_ARMO[this], StatBoard__s_ARMO)
            set s__MainBoard_m_SPAR[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__SPAR, 0)
            call MultiboardSetItemValue(s__MainBoard_m_SPAR[this], StatBoard__s_SPAR)
            set s__MainBoard_m_STAR[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__STAR, 0)
            call MultiboardSetItemValue(s__MainBoard_m_STAR[this], StatBoard__s_STAR)
            set s__MainBoard_m_LLEE[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__LLEE, 0)
            call MultiboardSetItemValue(s__MainBoard_m_LLEE[this], StatBoard__s_LLEE)
            set s__MainBoard_m_ARED[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__ARED, 0)
            call MultiboardSetItemValue(s__MainBoard_m_ARED[this], StatBoard__s_ARED)
            set s__MainBoard_m_FDMG[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__FDMG, 0)
            call MultiboardSetItemValue(s__MainBoard_m_FDMG[this], StatBoard__s_FDMG)
            set s__MainBoard_m_LDMG[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__LDMG, 0)
            call MultiboardSetItemValue(s__MainBoard_m_LDMG[this], StatBoard__s_LDMG)
            set s__MainBoard_m_SDMG[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__SDMG, 0)
            call MultiboardSetItemValue(s__MainBoard_m_SDMG[this], StatBoard__s_SDMG)
            set s__MainBoard_m_CDMG[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__CDMG, 0)
            call MultiboardSetItemValue(s__MainBoard_m_CDMG[this], StatBoard__s_CDMG)
            set s__MainBoard_m_PDMG[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__PDMG, 0)
            call MultiboardSetItemValue(s__MainBoard_m_PDMG[this], StatBoard__s_PDMG)
            set s__MainBoard_m_CRAT[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__CRAT, 0)
            call MultiboardSetItemValue(s__MainBoard_m_CRAT[this], StatBoard__s_CRAT)
            set s__MainBoard_m_CPOW[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__CPOW, 0)
            call MultiboardSetItemValue(s__MainBoard_m_CPOW[this], StatBoard__s_CPOW)
            set s__MainBoard_m_SRAT[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__SRAT, 0)
            call MultiboardSetItemValue(s__MainBoard_m_SRAT[this], StatBoard__s_SRAT)
            set s__MainBoard_m_SPOW[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__SPOW, 0)
            call MultiboardSetItemValue(s__MainBoard_m_SPOW[this], StatBoard__s_SPOW)
            set s__MainBoard_m_PHRE[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__PHRE, 0)
            call MultiboardSetItemValue(s__MainBoard_m_PHRE[this], StatBoard__s_PHRE)
            set s__MainBoard_m_SRES[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__SRES, 0)
            call MultiboardSetItemValue(s__MainBoard_m_SRES[this], StatBoard__s_SRES)
            set s__MainBoard_m_FRES[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__FRES, 0)
            call MultiboardSetItemValue(s__MainBoard_m_FRES[this], StatBoard__s_FRES)
            set s__MainBoard_m_LRES[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__LRES, 0)
            call MultiboardSetItemValue(s__MainBoard_m_LRES[this], StatBoard__s_LRES)
            set s__MainBoard_m_CRES[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__CRES, 0)
            call MultiboardSetItemValue(s__MainBoard_m_CRES[this], StatBoard__s_CRES)
            set s__MainBoard_m_PRES[this]=MultiboardGetItem(s__MainBoard_main[this], StatBoard__PRES, 0)
            call MultiboardSetItemValue(s__MainBoard_m_PRES[this], StatBoard__s_PRES)
            
            if GetPlayerId(GetLocalPlayer()) == s__MainBoard_playerId[this] then
                call MultiboardDisplay(s__MainBoard_main[this], true)
            endif
            
            return this
        endfunction
    
//Implemented from module T32Interface:
        
        function s__StatBoard__ConstantLoop_T32Interface___onInit takes nothing returns nothing
            set s__StatBoard__ConstantLoop_T32Interface___timers=(CTL___A((function sc__StatBoard__ConstantLoop_T32Interface___expire))) // INLINED!!
        endfunction
        
        function s__StatBoard__ConstantLoop_T32Interface___expire takes nothing returns nothing
            local integer i= 0
            local integer array recycle
            local integer recycleCount= 0
            local integer temp
            local boolean running= false
            loop
                exitwhen s__StatBoard__ConstantLoop_T32Interface___list[i] == 0
                if not sc__StatBoard__ConstantLoop_onLoop(s__StatBoard__ConstantLoop_T32Interface___list[i]) then
                   set recycle[recycleCount]=s__StatBoard__ConstantLoop_T32Interface___list[i]
                   set recycleCount=recycleCount + 1
                   call sc__StatBoard__ConstantLoop_onExpire(s__StatBoard__ConstantLoop_T32Interface___list[i])
                else
                    set running=true
                endif
                set i=i + 1
            endloop
            if recycleCount != 0 then
                set i=0
                loop
                    exitwhen recycle[i] == 0
                    set temp=recycle[i]
                    set s__StatBoard__ConstantLoop_recyclePosition[s__StatBoard__ConstantLoop_T32Interface___list[s__StatBoard__ConstantLoop_T32Interface___count]]=s__StatBoard__ConstantLoop_recyclePosition[temp]
                    set s__StatBoard__ConstantLoop_T32Interface___list[s__StatBoard__ConstantLoop_recyclePosition[temp]]=s__StatBoard__ConstantLoop_T32Interface___list[s__StatBoard__ConstantLoop_T32Interface___count]
                    set s__StatBoard__ConstantLoop_T32Interface___list[s__StatBoard__ConstantLoop_T32Interface___count]=0
                    //call temp.deallocate()
                    set s__StatBoard__ConstantLoop_T32Interface___count=s__StatBoard__ConstantLoop_T32Interface___count - 1
                    set i=i + 1
                endloop
            endif
            if not running then
                call CTL___SR32((s__StatBoard__ConstantLoop_T32Interface___timers)) // INLINED!!
            endif
        endfunction
        
        function s__StatBoard__ConstantLoop_add takes integer this returns nothing
            local integer i= 0
            loop
                exitwhen s__StatBoard__ConstantLoop_T32Interface___list[i] == 0
                set i=i + 1
            endloop
            set s__StatBoard__ConstantLoop_T32Interface___list[i]=this
            set s__StatBoard__ConstantLoop_recyclePosition[this]=i
            set s__StatBoard__ConstantLoop_T32Interface___count=s__StatBoard__ConstantLoop_T32Interface___count + 1
            call CTL___A32((s__StatBoard__ConstantLoop_T32Interface___timers)) // INLINED!!
        endfunction
        
        
//Implemented from module Alloc:
    
    function s__StatBoard__ConstantLoop_allocate takes nothing returns integer
        local integer this= s__StatBoard__ConstantLoop_Alloc___recycler[0]
        
        
        if ( this == 0 ) then
        
            set this=s__StatBoard__ConstantLoop_Alloc___instanceCount + 1
            set s__StatBoard__ConstantLoop_Alloc___instanceCount=this
        else
            set s__StatBoard__ConstantLoop_Alloc___recycler[0]=s__StatBoard__ConstantLoop_Alloc___recycler[this]
        endif
        
        
        return this
    endfunction
    
    function s__StatBoard__ConstantLoop_deallocate takes integer this returns nothing
        
        
        set s__StatBoard__ConstantLoop_Alloc___recycler[this]=s__StatBoard__ConstantLoop_Alloc___recycler[0]
        set s__StatBoard__ConstantLoop_Alloc___recycler[0]=this
    endfunction
        
        function s__StatBoard__ConstantLoop_onLoop takes integer this returns boolean
            set s__StatBoard__ConstantLoop_i[this]=s__StatBoard__ConstantLoop_i[this] + 1
            if s__StatBoard__ConstantLoop_i[this] == 5 then
                set s__StatBoard__ConstantLoop_i[this]=0
                set s__StatBoard__ConstantLoop_c[this]=s__StatBoard__ConstantLoop_c[this] + 1
                if s__StatBoard__ConstantLoop_c[this] > 9 then
                    set s__StatBoard__ConstantLoop_c[this]=0
                endif
                if s__StatBoard__ConstantLoop_c[this] == 0 and DoesUnitExist(udg_PlayerUnit[s__StatBoard__ConstantLoop_c[this] + 1]) then
                    call s__MainBoard_update(StatBoard__p[s__StatBoard__ConstantLoop_c[this]],udg_PlayerUnit[s__StatBoard__ConstantLoop_c[this] + 1])
                endif
            endif
            return true
        endfunction
        
        function s__StatBoard__ConstantLoop_onExpire takes integer this returns nothing
        
        endfunction
        function s__StatBoard__ConstantLoop_start takes nothing returns nothing
            local integer this= s__StatBoard__ConstantLoop_allocate()
            set s__StatBoard__ConstantLoop_i[this]=0
            set s__StatBoard__ConstantLoop_c[this]=0
            call s__StatBoard__ConstantLoop_add(this)
        endfunction
    
    function StatBoard__onTimer takes nothing returns nothing
        local integer i
        call DestroyTimer(GetExpiredTimer())
        set i=0
        loop
            exitwhen i == 10
            set StatBoard__p[i]=s__MainBoard_create(i)
            set i=i + 1
        endloop
        call s__StatBoard__ConstantLoop_start()
    endfunction
    
    function StatBoard__onInit takes nothing returns nothing
        call TimerStart(CreateTimer(), 1.00, false, function StatBoard__onTimer)
        
    endfunction

//library StatBoard ends
//library StringSize:
 
    
 
        function s__StringSize_measureChar takes string char returns real
            return StringSize__size[Char2Ascii(char)]
        endfunction
        
        function s__StringSize_measure takes string s returns real
            local integer i= 0
            local integer l= StringLength(s)
            local real result= 0
            local string sub= ""
            if l == 0 then
                return 0.
            elseif l == 1 then
                return StringSize__size[Char2Ascii(s)]
            endif
            loop
                exitwhen i >= l
                set sub=SubString(s, i, i + 1)
                if sub == "|" then
                    set sub=SubString(s, i + 1, i + 2)
                    if sub == "c" then
                        set i=i + 9
                    elseif sub == "r" then
                        set i=i + 1
                    else
                        set result=result + StringSize__size[124]
                    endif
                else
                    set result=result + StringSize__size[Char2Ascii(sub)]
                endif
                set i=i + 1
            endloop
            return result
        endfunction
        
//Implemented from module StringSize__StringSizeModule:
        function s__StringSize_onInit takes nothing returns nothing
            set StringSize__size[124]=3
            set StringSize__size[39]=4
            set StringSize__size[58]=4
            set StringSize__size[59]=4
            set StringSize__size[46]=4
            set StringSize__size[44]=4
            set StringSize__size[49]=5
            set StringSize__size[105]=5
            set StringSize__size[33]=5
            set StringSize__size[108]=6
            set StringSize__size[73]=6
            set StringSize__size[106]=6
            set StringSize__size[40]=6
            set StringSize__size[91]=6
            set StringSize__size[93]=6
            set StringSize__size[123]=6
            set StringSize__size[125]=6
            set StringSize__size[32]=7
            set StringSize__size[34]=7
            set StringSize__size[41]=7
            set StringSize__size[74]=7
            set StringSize__size[114]=8
            set StringSize__size[102]=8
            set StringSize__size[96]=8
            set StringSize__size[116]=9
            set StringSize__size[45]=9
            set StringSize__size[92]=9
            set StringSize__size[42]=9
            set StringSize__size[70]=10
            set StringSize__size[115]=11
            set StringSize__size[47]=11
            set StringSize__size[63]=11
            set StringSize__size[69]=12
            set StringSize__size[76]=12
            set StringSize__size[55]=12
            set StringSize__size[43]=12
            set StringSize__size[61]=12
            set StringSize__size[60]=12
            set StringSize__size[62]=12
            set StringSize__size[36]=12
            set StringSize__size[97]=12
            set StringSize__size[107]=13
            set StringSize__size[84]=13
            set StringSize__size[99]=13
            set StringSize__size[83]=13
            set StringSize__size[110]=13
            set StringSize__size[122]=13
            set StringSize__size[80]=13
            set StringSize__size[51]=13
            set StringSize__size[53]=13
            set StringSize__size[95]=13
            set StringSize__size[126]=13
            set StringSize__size[94]=13
            set StringSize__size[98]=14
            set StringSize__size[66]=14
            set StringSize__size[54]=14
            set StringSize__size[118]=14
            set StringSize__size[101]=14
            set StringSize__size[120]=14
            set StringSize__size[121]=14
            set StringSize__size[50]=14
            set StringSize__size[57]=14
            set StringSize__size[104]=14
            set StringSize__size[117]=14
            set StringSize__size[111]=15
            set StringSize__size[100]=15
            set StringSize__size[48]=15
            set StringSize__size[103]=15
            set StringSize__size[56]=15
            set StringSize__size[52]=15
            set StringSize__size[113]=15
            set StringSize__size[112]=15
            set StringSize__size[115]=15
            set StringSize__size[67]=16
            set StringSize__size[82]=16
            set StringSize__size[90]=16
            set StringSize__size[86]=16
            set StringSize__size[89]=16
            set StringSize__size[68]=16
            set StringSize__size[75]=16
            set StringSize__size[85]=16
            set StringSize__size[35]=16
            set StringSize__size[78]=17
            set StringSize__size[72]=17
            set StringSize__size[37]=17
            set StringSize__size[71]=18
            set StringSize__size[88]=18
            set StringSize__size[64]=18
            set StringSize__size[65]=19
            set StringSize__size[119]=20
            set StringSize__size[79]=20
            set StringSize__size[109]=21
            set StringSize__size[81]=21
            set StringSize__size[38]=21
            set StringSize__size[77]=25
            set StringSize__size[87]=26
        endfunction
 
    function MeasureString takes string s returns real
        return s__StringSize_measure(s)
    endfunction
 
    function MeasureCharacter takes string s returns real
        return (StringSize__size[Char2Ascii((s))]) // INLINED!!
    endfunction
 

//library StringSize ends
//library Thread:

//Implemented from module Alloc:
    
    function s__Thread_allocate takes nothing returns integer
        local integer this= s__Thread_Alloc___recycler[0]
        
        
        if ( this == 0 ) then
        
            set this=s__Thread_Alloc___instanceCount + 1
            set s__Thread_Alloc___instanceCount=this
        else
            set s__Thread_Alloc___recycler[0]=s__Thread_Alloc___recycler[this]
        endif
        
        
        return this
    endfunction
    
    function s__Thread_deallocate takes integer this returns nothing
        
        
        set s__Thread_Alloc___recycler[this]=s__Thread_Alloc___recycler[0]
        set s__Thread_Alloc___recycler[0]=this
    endfunction
        
        
        
        function s__Thread__get_synced takes integer this returns boolean
            local integer val
            local integer playerId= 11
            
            if ( s__Thread_synced_p[this] ) then
                return true
            endif
            
            loop
                if ( GetPlayerSlotState(Player(playerId)) != PLAYER_SLOT_STATE_PLAYING or GetPlayerController(Player(playerId)) != MAP_CONTROL_USER ) then
                    set val=s__Thread_count[this] / s__Thread_playerPower[playerId]
                    if ( val - val / 2 * 2 == 0 ) then
                        set s__Thread_count[this]=s__Thread_count[this] + s__Thread_playerPower[playerId]
                    endif
                endif
                
                exitwhen 0 == playerId
                set playerId=playerId - 1
            endloop
            
            set s__Thread_synced_p[this]=s__Thread_count[this] == s__Thread_endPower
            
            return s__Thread_synced_p[this]
        endfunction
        
        function s__Thread_create takes nothing returns integer
            local integer this= s__Thread_allocate()
            
            if ( null == s__Thread_Thread__threadSyncer[this] ) then

                    call sc__UnitIndexer__set_enabled(false)

                
                set s__Thread_Thread__threadSyncer[this]=CreateUnit(Player(0), Thread__UNIT_SYNC_ID, s__WorldBounds_maxX, s__WorldBounds_maxY, 0)
                call SetUnitUserData(s__Thread_Thread__threadSyncer[this], this)
                call PauseUnit(s__Thread_Thread__threadSyncer[this], true)
                call SetUnitX(s__Thread_Thread__threadSyncer[this], s__WorldBounds_maxX)
                call SetUnitY(s__Thread_Thread__threadSyncer[this], s__WorldBounds_maxY)
                

                    call sc__UnitIndexer__set_enabled(true)

            endif
            
            return this
        endfunction
        
        function s__Thread_destroy takes integer this returns nothing
            set s__Thread_count[this]=0
            set s__Thread_synced_p[this]=false
            call s__Thread_deallocate(this)
        endfunction
        
        
        function s__Thread_sync takes integer this returns nothing
            call SelectUnit(s__Thread_Thread__threadSyncer[this], true)
            call SelectUnit(s__Thread_Thread__threadSyncer[this], false)
        endfunction
        
        function s__Thread_wait takes integer this returns nothing
            loop
                call TriggerSyncStart()
                exitwhen s__Thread_synced_p[this]
                call TriggerSyncReady()
            endloop
        endfunction
        
        function s__Thread_syncThread takes nothing returns boolean
            local integer this= GetUnitUserData(GetTriggerUnit())
            local integer playerId= GetPlayerId(GetTriggerPlayer())
            local integer val
            
            if ( s__Thread_Thread__threadSyncer[this] != GetTriggerUnit() ) then
                return false
            endif
            
            set val=s__Thread_count[this] / s__Thread_playerPower[playerId]
            if ( val - val / 2 * 2 == 0 ) then
                set s__Thread_count[this]=s__Thread_count[this] + s__Thread_playerPower[playerId]
            endif
            
            set playerId=11
            loop
                if ( GetPlayerSlotState(Player(playerId)) != PLAYER_SLOT_STATE_PLAYING or GetPlayerController(Player(playerId)) != MAP_CONTROL_USER ) then
                    set val=s__Thread_count[this] / s__Thread_playerPower[playerId]
                    if ( val - val / 2 * 2 == 0 ) then
                        set s__Thread_count[this]=s__Thread_count[this] + s__Thread_playerPower[playerId]
                    endif
                endif
                
                exitwhen 0 == playerId
                set playerId=playerId - 1
            endloop
            
            set s__Thread_synced_p[this]=s__Thread_count[this] == s__Thread_endPower
            
            return false
        endfunction
        
        
        function s__Thread_onInit takes nothing returns nothing
            local integer playerId= 11
            local integer power= 2048
            set s__Thread_endPower=0
            
            set s__Thread_syncThreadTrigger=CreateTrigger()
            call TriggerAddCondition(s__Thread_syncThreadTrigger, Condition(function s__Thread_syncThread))
            
            loop
                if ( GetPlayerSlotState(Player(playerId)) == PLAYER_SLOT_STATE_PLAYING and GetPlayerController(Player(playerId)) == MAP_CONTROL_USER ) then
                    call TriggerRegisterPlayerUnitEvent(s__Thread_syncThreadTrigger, Player(playerId), EVENT_PLAYER_UNIT_SELECTED, null)
                endif
                set s__Thread_playerPower[playerId]=power
                set s__Thread_endPower=s__Thread_endPower + power
                set power=power / 2
                exitwhen 0 == playerId
                set playerId=playerId - 1
            endloop
        endfunction
    
    function SynchronizeThread takes nothing returns nothing
        local integer thread= s__Thread_create()
        call s__Thread_sync(thread)
        call s__Thread_wait(thread)
        call s__Thread_destroy(thread)
    endfunction

//library Thread ends
//library Track:

    

        
        
        
        
        
        function s__Track_registerAnyClick takes code c returns nothing
            call TriggerAddCondition(s__Track_anyClick, Filter(c))
        endfunction
        function s__Track_registerAnyHover takes code c returns nothing
            call TriggerAddCondition(s__Track_anyHover, Filter(c))
        endfunction
        
        function s__Track_registerClick takes integer this,code c returns nothing
            if s__Track_onClick[this] == null then
                set s__Track_onClick[this]=CreateTrigger()
            endif
            call TriggerAddCondition(s__Track_onClick[this], Filter(c))
        endfunction
        function s__Track_registerHover takes integer this,code c returns nothing
            if s__Track_onHover[this] == null then
                set s__Track_onHover[this]=CreateTrigger()
            endif
            call TriggerAddCondition(s__Track_onHover[this], Filter(c))
        endfunction
        
        function s__Track_destroy takes integer this returns nothing
            call RemoveSavedInteger(Table___ht, (s__Track_TrackTable), (GetHandleId(s__Track_reg[this]))) // INLINED!!
            call RemoveSavedInteger(Table___ht, (s__Track_TrackTable), (GetHandleId(s__Track_object))) // INLINED!!
            call DestroyTrigger(s__Track_reg[this])
            call DestroyTrigger(s__Track_onClick[this])
            call DestroyTrigger(s__Track_onHover[this])
            set s__Track_rn[this]=s__Track_ir
            set s__Track_ir=this
        endfunction
        
        function s__Track_enable takes integer this returns nothing
            set s__Track_flag[this]=true
        endfunction
        function s__Track_disable takes integer this returns nothing
            set s__Track_flag[this]=false
        endfunction
        function s__Track__get_enabled takes integer this returns boolean
            return s__Track_flag[this]
        endfunction
        
        function s__Track_onInteract takes nothing returns boolean
            local integer temp= s__Track_instance
            local trackable tr= s__Track_object
            local player p= s__Track_tracker
            
            set s__Track_instance=(LoadInteger(Table___ht, (s__Track_TrackTable), (GetHandleId(GetTriggeringTrigger())))) // INLINED!!
            set s__Track_object=GetTriggeringTrackable()
            set s__Track_tracker=Player((LoadInteger(Table___ht, (s__Track_TrackTable), (GetHandleId(s__Track_object))))) // INLINED!!
            
            if s__Track_flag[s__Track_instance] then
                if GetTriggerEventId() == EVENT_GAME_TRACKABLE_TRACK then
                    call TriggerEvaluate(s__Track_onHover[s__Track_instance])
                    call TriggerEvaluate(s__Track_anyHover)
                else
                    call TriggerEvaluate(s__Track_onClick[s__Track_instance])
                    call TriggerEvaluate(s__Track_anyClick)
                endif
            endif
            
            set s__Track_instance=temp
            set s__Track_tracker=p
            set s__Track_object=tr
            set tr=null
            set p=null
            return false
        endfunction
        
        function s__Track_createTrack takes string modelPath,real x,real y,real z,real facing,player j returns integer
            local destructable dest= null
            local integer this= s__Track_ir
            local integer i= 11
            local trackable tr
            local player p
            local string s
            if this == 0 then
                set s__Track_ic=s__Track_ic + 1
                set this=s__Track_ic
            else
                set s__Track_ir=s__Track_rn[this]
            endif
            if z != 0 then
                set dest=CreateDestructableZ(Track___PLATFORM, x, y, z, 0, 1, 0)
            endif
            if j != null then
                set i=GetPlayerId(j)
            endif
            set s__Track_x[this]=x
            set s__Track_y[this]=y
            set s__Track_z[this]=z
            set s__Track_flag[this]=true
            set s__Track_facing[this]=facing
            set s__Track_model[this]=modelPath
            set s__Track_reg[this]=CreateTrigger()
            set s__Track_onClick[this]=null
            set s__Track_onHover[this]=null
            call SaveInteger(Table___ht, (s__Track_TrackTable), (GetHandleId(s__Track_reg[this])), ( this)) // INLINED!!
            call TriggerAddCondition(s__Track_reg[this], Condition(function s__Track_onInteract))
            loop
                set p=Player(i)
                if GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING and GetPlayerController(p) == MAP_CONTROL_USER then
                    if GetLocalPlayer() == p then
                        set s=modelPath
                    else
                        set s=""
                    endif
                    set tr=CreateTrackable(s, s__Track_x[this], s__Track_y[this], s__Track_facing[this])
                    call TriggerRegisterTrackableHitEvent(s__Track_reg[this], tr)
                    call TriggerRegisterTrackableTrackEvent(s__Track_reg[this], tr)
                    call SaveInteger(Table___ht, (s__Track_TrackTable), (GetHandleId(tr)), ( i)) // INLINED!!
                    if j != null then
                        exitwhen true
                    endif
                endif
                exitwhen i == 0
                set i=i - 1
            endloop
            if dest != null then
                call RemoveDestructable(dest)
                set dest=null
            endif
            set p=null
            set tr=null
            return this
        endfunction
        
        function s__Track_create takes string modelPath,real x,real y,real z,real facing returns integer
            return s__Track_createTrack(modelPath , x , y , z , facing , null)
        endfunction 
        
        function s__Track_createForPlayer takes string modelPath,real x,real y,real z,real facing,player p returns integer
            if not ( GetPlayerSlotState(p) == PLAYER_SLOT_STATE_PLAYING and GetPlayerController(p) == MAP_CONTROL_USER ) then
                return 0
            endif
            return s__Track_createTrack(modelPath , x , y , z , facing , p)
        endfunction
        
//Implemented from module Track___Init:
        function s__Track_Track___Init___onInit takes nothing returns nothing
            set s__Track_TrackTable=s__Table_create()
        endfunction
    
    function CreateTrack takes string modelPath,real x,real y,real z,real facing returns integer
        return (s__Track_createTrack((modelPath ) , (( x )*1.0) , (( y )*1.0) , (( z )*1.0) , (( facing)*1.0) , null)) // INLINED!!
    endfunction
    
    function CreateTrackForPlayer takes string modelPath,real x,real y,real z,real facing,player who returns integer
        return s__Track_createForPlayer(modelPath , x , y , z , facing , who)
    endfunction
    
    function EnableTrackInstance takes integer instance,boolean flag returns nothing
        if flag then
            set s__Track_flag[(instance)]=true // INLINED!!
        else
            set s__Track_flag[(instance)]=false // INLINED!!
        endif
    endfunction
    
    function IsTrackInstanceEnabled takes integer instance returns boolean
        return (s__Track_flag[(instance)]) // INLINED!!
    endfunction
    
    function RegisterAnyClickEvent takes code c returns nothing
        call TriggerAddCondition(s__Track_anyClick, Filter((c))) // INLINED!!
    endfunction
    
    function RegisterAnyHoverEvent takes code c returns nothing
        call TriggerAddCondition(s__Track_anyHover, Filter((c))) // INLINED!!
    endfunction
    
    function RegisterClickEvent takes integer obj,code c returns nothing
        call s__Track_registerClick(obj,c)
    endfunction
    
    function RegisterHoverEvent takes integer obj,code c returns nothing
        call s__Track_registerHover(obj,c)
    endfunction
    
    function GetTriggerTrackInstance takes nothing returns integer
        return s__Track_instance
    endfunction
    
    function GetTriggerTrackable takes nothing returns trackable
        return s__Track_object
    endfunction
    
    function GetTriggerTrackablePlayer takes nothing returns player
        return s__Track_tracker
    endfunction

//library Track ends
//library UnitIndexer:

    function GetIndexedUnitId takes nothing returns integer
        return UnitIndexer___o
    endfunction
    function GetIndexedUnit takes nothing returns unit
        return UnitIndexer___e[UnitIndexer___o]
    endfunction
//ignored textmacro command: UNIT_LIST_LIB()
        function s__UnitIndexer___PreLoader_run takes nothing returns nothing
            call DestroyTimer(GetExpiredTimer())
            set UnitIndexer___a=true
        endfunction
        function s__UnitIndexer___PreLoader_eval takes trigger t returns nothing
            local integer f=UnitIndexer___n[0]
            local integer d=UnitIndexer___o
            loop
                exitwhen 0 == f
                if ( IsTriggerEnabled(t) ) then
                    set UnitIndexer___o=f
                    if ( TriggerEvaluate(t) ) then
                        call TriggerExecute(t)
                    endif
                else
                    exitwhen true
                endif
                set f=UnitIndexer___n[f]
            endloop
            set UnitIndexer___o=d
        endfunction
        function s__UnitIndexer___PreLoader_evalb takes boolexpr c returns nothing
            local trigger t=CreateTrigger()
            local integer f=UnitIndexer___n[0]
            local integer d=UnitIndexer___o
            call TriggerAddCondition(t, c)
            loop
                exitwhen 0 == f
                set UnitIndexer___o=f
                call TriggerEvaluate(t)
                set f=UnitIndexer___n[f]
            endloop
            call DestroyTrigger(t)
            set t=null
            set UnitIndexer___o=d
        endfunction
//textmacro instance: UNIT_EVENT_MACRO()
    
    function GetEventUnitId takes nothing returns integer
        return UnitIndexer___o
    endfunction
    function GetEventUnit takes nothing returns unit
        return UnitIndexer___e[UnitIndexer___o]
    endfunction
function IsUnitDead takes integer l__index returns boolean
        return UnitIndexer___z[l__index]
    endfunction
function IsUnitReincarnating takes integer l__index returns boolean
        return UnitIndexer___x[l__index]
    endfunction
function IsUnitAnimated takes integer l__index returns boolean
        return UnitIndexer___k[l__index]
    endfunction
    function UnitIndexer___OnReincarnateStart takes nothing returns nothing
        local integer i=UnitIndexer___o
        set UnitIndexer___o=UnitIndexer___b[0]
        loop
            if ( UnitIndexer___x[UnitIndexer___o] ) then
                call s__Event_fire((s__UnitEvent_START_REINCARNATE)) // INLINED!!
            endif
            set UnitIndexer___o=UnitIndexer___b[UnitIndexer___o]
            exitwhen 0 == UnitIndexer___o
        endloop
        set UnitIndexer___b[0]=0
        set UnitIndexer___o=i
    endfunction
    function UnitIndexer___OnDeath takes nothing returns boolean
        local unit u=GetTriggerUnit()
        local integer i=GetUnitUserData(u)
        local integer d=UnitIndexer___o
        if ( u == UnitIndexer___e[i] ) then
            set UnitIndexer___z[i]=true
            set UnitIndexer___x[i]=false
            if ( not UnitIndexer___k[i] ) then
                set UnitIndexer___j[i]=TimerGetElapsed(UnitIndexer___time)
            else
                set UnitIndexer___v[i]=true
                set UnitIndexer___k[i]=false
                set UnitIndexer___o=i
                call s__Event_fire((s__UnitEvent_EXPLODE)) // INLINED!!
                set UnitIndexer___o=d
            endif
        endif
        set u=null
        return false
    endfunction
//end of: UNIT_EVENT_MACRO()
        function s__UnitIndex_lock takes integer this returns nothing
                set UnitIndexer___lc[this]=UnitIndexer___lc[this] + 1
        endfunction
        function s__UnitIndex_unlock takes integer this returns nothing
                set UnitIndexer___lc[this]=UnitIndexer___lc[this] - 1
                if ( 0 == UnitIndexer___lc[this] and null == UnitIndexer___e[this] ) then
                    set UnitIndexer___n[this]=UnitIndexer___y
                    set UnitIndexer___y=this
                endif
        endfunction
        function s__UnitIndex__get_unit takes integer this returns unit
            return UnitIndexer___e[this]
        endfunction
        function s__UnitIndex__staticgetindex takes unit whichUnit returns integer
            return GetUnitUserData(whichUnit)
        endfunction
        function s__UnitIndexer__get_enabled takes nothing returns boolean
            return IsTriggerEnabled(UnitIndexer___q)
        endfunction
function s__UnitIndexer__set_enabled takes boolean l__UnitIndexer___b returns nothing
            if ( l__UnitIndexer___b ) then
                call DisableTrigger(UnitIndexer___q)
                call DisableTrigger(UnitIndexer___l)
            else
                call EnableTrigger(UnitIndexer___q)
                call EnableTrigger(UnitIndexer___l)
            endif
        endfunction
        function s__UnitIndexer_onEnter takes nothing returns boolean
            local unit Q=GetFilterUnit()
            local integer i
            local integer d=UnitIndexer___o
            if ( Q != UnitIndexer___e[GetUnitUserData(Q)] and 0 == GetUnitUserData(Q) ) then
                if ( 0 == UnitIndexer___y ) then
                    set UnitIndexer___r=UnitIndexer___r + 1
                    set i=UnitIndexer___r
                else
                    set i=UnitIndexer___y
                    set UnitIndexer___y=UnitIndexer___n[UnitIndexer___y]
                endif
                call UnitAddAbility(Q, ABILITIES_UNIT_INDEXER)
                call UnitMakeAbilityPermanent(Q, true, ABILITIES_UNIT_INDEXER)
                call SetUnitUserData(Q, i)
                set UnitIndexer___e[i]=Q

                    if ( not UnitIndexer___a ) then
                        set UnitIndexer___p[i]=UnitIndexer___p[0]
                        set UnitIndexer___n[UnitIndexer___p[0]]=i
                        set UnitIndexer___n[i]=0
                        set UnitIndexer___p[0]=i
                    endif







                set UnitIndexer___o=i
                call s__Event_fire((s__UnitIndexer_INDEX)) // INLINED!!
                set UnitIndexer___o=d
            endif
            set Q=null
            return false
        endfunction
        function s__UnitIndexer_onLeave takes nothing returns boolean

//Implemented from module UnitIndexer___UnitEventModule:
        local unit u=GetFilterUnit()
        local integer s=GetUnitUserData(u)
        local integer d=UnitIndexer___o
        if ( u == UnitIndexer___e[s] ) then
            set UnitIndexer___o=s
            if ( 0 == GetUnitAbilityLevel(u, ABILITIES_UNIT_INDEXER) ) then
                set UnitIndexer___x[s]=false
                set UnitIndexer___k[s]=false
                if ( not UnitIndexer___v[s] ) then
                    if ( UnitIndexer___z[s] and UnitIndexer___h <= TimerGetElapsed(UnitIndexer___time) - UnitIndexer___j[s] ) then
                        set UnitIndexer___z[s]=false
                        call s__Event_fire((s__UnitEvent_DECAY)) // INLINED!!
                    else
                        set UnitIndexer___z[s]=false
                        call s__Event_fire((s__UnitEvent_REMOVE)) // INLINED!!
                    endif
                else
                    set UnitIndexer___z[s]=false
                    set UnitIndexer___v[s]=false
                endif

                    if ( not UnitIndexer___a ) then
                        set UnitIndexer___n[UnitIndexer___p[s]]=UnitIndexer___n[s]
                        set UnitIndexer___p[UnitIndexer___n[s]]=UnitIndexer___p[s]
                    endif





                call s__Event_fire((s__UnitIndexer_DEINDEX)) // INLINED!!
                if ( 0 == UnitIndexer___lc[s] ) then
                    set UnitIndexer___n[s]=UnitIndexer___y
                    set UnitIndexer___y=s
                endif
                set UnitIndexer___e[s]=null
            elseif ( .405 < GetWidgetLife(u) and 0 != GetUnitTypeId(u) ) then
                if ( UnitIndexer___x[s] ) then
                    call s__Event_fire((s__UnitEvent_REINCARNATE)) // INLINED!!
                    set UnitIndexer___x[s]=false
                elseif ( UnitIndexer___z[s] ) then
                    set UnitIndexer___z[s]=false
                    if ( IsUnitType(u, UNIT_TYPE_SUMMONED) ) then
                        set UnitIndexer___k[s]=true
                        call s__Event_fire((s__UnitEvent_ANIMATE)) // INLINED!!
                    else
                        call s__Event_fire((s__UnitEvent_RESURRECT)) // INLINED!!
                    endif
                endif
            else
                set UnitIndexer___x[s]=true
                set UnitIndexer___b[s]=UnitIndexer___b[0]
                set UnitIndexer___b[0]=s
                call TimerStart(UnitIndexer___m, 0, false, function UnitIndexer___OnReincarnateStart)
            endif
            set UnitIndexer___o=d
        endif
        set u=null


























            return false
        endfunction
//Implemented from module UnitIndexer___UnitIndexerInit:
        function s__UnitIndexer_UnitIndexer___UnitIndexerInit___onInit takes nothing returns nothing
            local integer i=15
            local boolexpr bc=Condition(function s__UnitIndexer_onLeave)
            local boolexpr bc2=Condition(function s__UnitIndexer_onEnter)
            local group g=CreateGroup()
            local player l__UnitIndexer___p
            set s__UnitIndexer_INDEX=(s__Event_create()) // INLINED!!
            set s__UnitIndexer_DEINDEX=(s__Event_create()) // INLINED!!
            call TriggerRegisterEnterRegion(UnitIndexer___q, s__WorldBounds_worldRegion, bc2)
            loop
                set l__UnitIndexer___p=Player(i)
                call TriggerRegisterPlayerUnitEvent(UnitIndexer___l, l__UnitIndexer___p, EVENT_PLAYER_UNIT_ISSUED_ORDER, bc)
                call SetPlayerAbilityAvailable(l__UnitIndexer___p, ABILITIES_UNIT_INDEXER, false)
                call GroupEnumUnitsOfPlayer(g, l__UnitIndexer___p, bc2)
                exitwhen 0 == i
                set i=i - 1
            endloop
            call DestroyGroup(g)
            set bc=null
            set g=null
            set bc2=null
            set l__UnitIndexer___p=null
            call TimerStart(CreateTimer(), 0, false, function s__UnitIndexer___PreLoader_run)
        endfunction
//textmacro instance: UNIT_EVENT_MACRO_2()
//Implemented from module UnitIndexer___UnitEventInits:
        function s__UnitEvent_UnitIndexer___UnitEventInits___decayer takes nothing returns boolean
            set UnitIndexer___h=TimerGetElapsed(UnitIndexer___time) - .9375
            call DestroyTrigger(GetTriggeringTrigger())
            return false
        endfunction
        function s__UnitEvent_UnitIndexer___UnitEventInits___onInit takes nothing returns nothing
            local trigger t=CreateTrigger()
            local unit u
            set s__UnitEvent_REMOVE=(s__Event_create()) // INLINED!!
            set s__UnitEvent_DECAY=(s__Event_create()) // INLINED!!
            set s__UnitEvent_EXPLODE=(s__Event_create()) // INLINED!!
            set s__UnitEvent_RESURRECT=(s__Event_create()) // INLINED!!
            set s__UnitEvent_REINCARNATE=(s__Event_create()) // INLINED!!
            set s__UnitEvent_ANIMATE=(s__Event_create()) // INLINED!!
            set s__UnitEvent_START_REINCARNATE=(s__Event_create()) // INLINED!!
            call s__UnitIndexer__set_enabled(false)
            set u=CreateUnit(Player(14), UNITS_UNIT_EVENT, s__WorldBounds_maxX, s__WorldBounds_maxY, 0)
            call s__UnitIndexer__set_enabled(true)
            call KillUnit(u)
            call ShowUnit(u, false)
            call TriggerRegisterUnitEvent(t, u, EVENT_UNIT_ISSUED_ORDER)
            call TriggerAddCondition(t, Condition(function s__UnitEvent_UnitIndexer___UnitEventInits___decayer))
            call RegisterPlayerUnitEvent(EVENT_PLAYER_UNIT_DEATH , function UnitIndexer___OnDeath)
            call TimerStart(UnitIndexer___time, 1000000, false, null)
            set u=null
            set t=null
        endfunction
//end of: UNIT_EVENT_MACRO_2()
    function RegisterUnitIndexEvent takes boolexpr c,integer ev returns nothing
        call RegisterEvent(c , ev)
        if ( not UnitIndexer___a and ev == s__UnitIndexer_INDEX and 0 != UnitIndexer___n[0] ) then
            call s__UnitIndexer___PreLoader_evalb(c)
        endif
    endfunction
    function TriggerRegisterUnitIndexEvent takes trigger t,integer ev returns nothing
        call TriggerRegisterEvent(t , ev)
        if ( not UnitIndexer___a and ev == s__UnitIndexer_INDEX and 0 != UnitIndexer___n[0] ) then
            call s__UnitIndexer___PreLoader_eval(t)
        endif
    endfunction
    function GetUnitById takes integer W returns unit
        return UnitIndexer___e[W]
    endfunction
    function GetUnitId takes unit u returns integer
        return GetUnitUserData(u)
    endfunction
    function IsUnitIndexed takes unit u returns boolean
        return u == UnitIndexer___e[GetUnitUserData(u)]
    endfunction
    function IsUnitDeindexing takes unit u returns boolean
        return IsUnitIndexed(u) and 0 == GetUnitAbilityLevel(u, ABILITIES_UNIT_INDEXER)
    endfunction

//library UnitIndexer ends
//library BigInt:
    
    
        
        
        
        
        



        function s__BigInt_allocate takes nothing returns integer
            local integer this= s__BigInt_next[(0)]
            if ( 0 == this ) then
                set this=s__BigInt_count + 1
                set s__BigInt_count=this
            else
                set s__BigInt_next[(0)]=s__BigInt_next[this]
            endif
            







            
            set s__BigInt_digit[this]=0
            
            return this
        endfunction
        












        
















        
        function s__BigInt_ad takes integer this,integer n returns nothing
            set s__BigInt_next[n]=this
            set s__BigInt_prev[n]=s__BigInt_prev[this]
            set s__BigInt_next[s__BigInt_prev[this]]=n
            set s__BigInt_prev[this]=n
            set s__BigInt_size[this]=s__BigInt_size[this] + 1
        endfunction
        function s__BigInt_adp takes integer this,integer n returns nothing
            set s__BigInt_next[n]=s__BigInt_next[this]
            set s__BigInt_prev[n]=this
            set s__BigInt_prev[s__BigInt_next[this]]=n
            set s__BigInt_next[this]=n
            set s__BigInt_size[this]=s__BigInt_size[this] + 1
        endfunction
        function s__BigInt_deto takes integer this,integer tar returns nothing
            
            set s__BigInt_size[this]=s__BigInt_size[this] - 1
            set this=s__BigInt_prev[this]
            set s__BigInt_next[s__BigInt_prev[this]]=s__BigInt_next[this]
            set s__BigInt_prev[s__BigInt_next[this]]=s__BigInt_prev[this]
            
            if ( not s__BigInt_head[s__BigInt_prev[tar]] or 0 != s__BigInt_digit[this] ) then
                call s__BigInt_adp(tar,this)
            else



                    set s__BigInt_next[this]=s__BigInt_next[(0)]
                    set s__BigInt_next[(0)]=this

            endif
        endfunction
        function s__BigInt_popto takes integer this,integer tar returns nothing
            
            set s__BigInt_size[this]=s__BigInt_size[this] - 1
            set this=s__BigInt_next[this]
            set s__BigInt_next[s__BigInt_prev[this]]=s__BigInt_next[this]
            set s__BigInt_prev[s__BigInt_next[this]]=s__BigInt_prev[this]
            
            if ( not s__BigInt_head[s__BigInt_prev[tar]] or 0 != s__BigInt_digit[this] ) then
                call s__BigInt_ad(tar,this)
            else



                    set s__BigInt_next[this]=s__BigInt_next[(0)]
                    set s__BigInt_next[(0)]=this

            endif
        endfunction
        function s__BigInt_lt takes integer this,integer i returns boolean
            local boolean b= false
            
            if ( s__BigInt_size[this] == s__BigInt_size[i] ) then
                loop
                    set this=s__BigInt_prev[this]
                    set i=s__BigInt_prev[i]
                    exitwhen s__BigInt_head[this] or s__BigInt_digit[this] != s__BigInt_digit[i]
                endloop
                return s__BigInt_digit[this] < s__BigInt_digit[i]
            endif
            
            return s__BigInt_size[this] < s__BigInt_size[i]
        endfunction
        function s__BigInt_gt takes integer this,integer i returns boolean
            local boolean b= false
            
            if ( s__BigInt_size[this] == s__BigInt_size[i] ) then
                loop
                    set this=s__BigInt_prev[this]
                    set i=s__BigInt_prev[i]
                    exitwhen s__BigInt_head[this] or s__BigInt_digit[this] != s__BigInt_digit[i]
                endloop
                return s__BigInt_digit[this] > s__BigInt_digit[i]
            endif
            
            return s__BigInt_size[this] > s__BigInt_size[i]
        endfunction
        function s__BigInt_eq takes integer this,integer i returns boolean
            
            if ( 0 == i ) then
                loop
                    set this=s__BigInt_next[this]
                    exitwhen s__BigInt_head[this] or 0 != s__BigInt_digit[this]
                endloop
                return s__BigInt_head[this]
            endif
        
            
            if ( s__BigInt_size[this] == s__BigInt_size[i] ) then
                loop
                    set this=s__BigInt_next[this]
                    set i=s__BigInt_next[i]
                    exitwhen s__BigInt_head[this] or s__BigInt_digit[this] != s__BigInt_digit[i]
                endloop
                return s__BigInt_head[this]
            endif
            
            return false
        endfunction
        function s__BigInt_neq takes integer this,integer i returns boolean
            return not s__BigInt_eq(this,i)
        endfunction
        function s__BigInt_ltoe takes integer this,integer i returns boolean
            local boolean b= false
            
            if ( s__BigInt_size[this] == s__BigInt_size[i] ) then
                loop
                    set this=s__BigInt_prev[this]
                    set i=s__BigInt_prev[i]
                    exitwhen s__BigInt_head[this] or s__BigInt_digit[this] != s__BigInt_digit[i]
                endloop
                return s__BigInt_digit[this] <= s__BigInt_digit[i]
            endif
            
            return s__BigInt_size[this] < s__BigInt_size[i]
        endfunction
        function s__BigInt_gtoe takes integer this,integer i returns boolean
            local boolean b= false
            
            if ( s__BigInt_size[this] == s__BigInt_size[i] ) then
                loop
                    set this=s__BigInt_prev[this]
                    set i=s__BigInt_prev[i]
                    exitwhen s__BigInt_head[this] or s__BigInt_digit[this] != s__BigInt_digit[i]
                endloop
                return s__BigInt_digit[this] >= s__BigInt_digit[i]
            endif
            
            return s__BigInt_size[this] > s__BigInt_size[i]
        endfunction
        
        function s__BigInt_add takes integer this,integer i returns nothing
            local integer carry= 0
            local integer root= this
            local integer base
            
            
            if ( s__BigInt_packed[this] or 0 == s__BigInt_bm[this] ) then
                set base=s__BigInt_packedBase[(Base__s[(s__BigInt_bm[this])])] // INLINED!!
            else
                set base=(Base__s[(s__BigInt_bm[this])]) // INLINED!!
            endif
            
            loop
                exitwhen 0 == i
                set this=s__BigInt_next[this]
                if ( s__BigInt_head[this] ) then
                    set this=s__BigInt_allocate()
                    call s__BigInt_ad(root,this)
                endif
                set s__BigInt_digit[this]=s__BigInt_digit[this] + i - i / base * base + carry
                set i=i / base
                set carry=s__BigInt_digit[this] / base
                set s__BigInt_digit[this]=s__BigInt_digit[this] - s__BigInt_digit[this] / base * base
            endloop
            loop
                exitwhen 0 == carry
                set this=s__BigInt_next[this]
                if ( s__BigInt_head[this] ) then
                    set this=s__BigInt_allocate()
                    call s__BigInt_ad(root,this)
                endif
                set s__BigInt_digit[this]=s__BigInt_digit[this] + carry
                set carry=s__BigInt_digit[this] / base
                set s__BigInt_digit[this]=s__BigInt_digit[this] - s__BigInt_digit[this] / base * base
            endloop
        endfunction
        function s__BigInt_addBig takes integer this,integer i returns nothing
            local integer carry= 0
            local integer root= this
            local integer count= 0
            local integer base
            
            
            if ( s__BigInt_packed[this] or 0 == s__BigInt_bm[this] ) then
                set base=s__BigInt_packedBase[(Base__s[(s__BigInt_bm[this])])] // INLINED!!
            else
                set base=(Base__s[(s__BigInt_bm[this])]) // INLINED!!
            endif
            
            loop
                set i=s__BigInt_next[i]
                exitwhen s__BigInt_head[i]
                set this=s__BigInt_next[this]
                if ( s__BigInt_head[this] ) then
                    set this=s__BigInt_allocate()
                    call s__BigInt_ad(root,this)
                endif
                set s__BigInt_digit[this]=s__BigInt_digit[this] + s__BigInt_digit[i] + carry
                set carry=s__BigInt_digit[this] / base
                set s__BigInt_digit[this]=s__BigInt_digit[this] - s__BigInt_digit[this] / base * base
            endloop
            loop
                exitwhen 0 == carry
                set this=s__BigInt_next[this]
                if ( s__BigInt_head[this] ) then
                    set this=s__BigInt_allocate()
                    call s__BigInt_ad(root,this)
                endif
                set s__BigInt_digit[this]=s__BigInt_digit[this] + carry
                set carry=s__BigInt_digit[this] / base
                set s__BigInt_digit[this]=s__BigInt_digit[this] - s__BigInt_digit[this] / base * base
            endloop
        endfunction
        function s__BigInt_addString takes integer this,string s returns nothing
            local integer carry= 0
            local integer root= this
            local integer i= StringLength(s)
            local integer b= s__BigInt_bm[this]
            local integer base= (Base__s[(b)]) // INLINED!!
            
            
            loop
                exitwhen 0 == i
                set this=s__BigInt_next[this]
                if ( s__BigInt_head[this] ) then
                    set this=s__BigInt_allocate()
                    call s__BigInt_ad(root,this)
                endif
                set s__BigInt_digit[this]=s__BigInt_digit[this] + (LoadInteger(Table___ht, (Base__t[(b)]), (Char2Ascii((SubString(s, i - 1, i)))))) + carry // INLINED!!
                set carry=s__BigInt_digit[this] / base
                set s__BigInt_digit[this]=s__BigInt_digit[this] - s__BigInt_digit[this] / base * base
                set i=i - 1
            endloop
            
            loop
                exitwhen 0 == carry
                set this=s__BigInt_next[this]
                if ( s__BigInt_head[this] ) then
                    set this=s__BigInt_allocate()
                    call s__BigInt_ad(root,this)
                endif
                set s__BigInt_digit[this]=s__BigInt_digit[this] + carry
                set carry=s__BigInt_digit[this] / base
                set s__BigInt_digit[this]=s__BigInt_digit[this] - s__BigInt_digit[this] / base * base
            endloop
        endfunction
            
        function s__BigInt_create takes nothing returns integer
            local integer this= s__BigInt_allocate()
            
            set s__BigInt_size[this]=0
            set s__BigInt_next[this]=this
            set s__BigInt_prev[this]=this
            set s__BigInt_head[this]=true
            set s__BigInt_bm[this]=0
            
            set s__BigInt_packed[this]=false
            
            return this
        endfunction
        function s__BigInt_convertString takes string s,integer base returns integer
            local integer this= s__BigInt_allocate()
            
            
            set s__BigInt_size[this]=0
            set s__BigInt_next[this]=this
            set s__BigInt_prev[this]=this
            set s__BigInt_head[this]=true
            set s__BigInt_bm[this]=base
            set s__BigInt_packed[this]=false
            
            call s__BigInt_addString(this,s)
            
            return this
        endfunction
        function s__BigInt_clear takes integer this returns nothing
            if ( not s__BigInt_head[s__BigInt_next[this]] ) then



                    set s__BigInt_next[s__BigInt_prev[this]]=s__BigInt_next[(0)]
                    set s__BigInt_next[(0)]=s__BigInt_next[this]

                set s__BigInt_next[this]=this
                set s__BigInt_prev[this]=this
                set s__BigInt_size[this]=0
            endif
            set s__BigInt_digit[this]=0
        endfunction
        function s__BigInt_destroy takes integer this returns nothing
            



                set s__BigInt_next[s__BigInt_prev[this]]=s__BigInt_next[(0)]
                set s__BigInt_next[(0)]=this

            
            set s__BigInt_head[this]=false
            set s__BigInt_size[this]=0
        endfunction
        function s__BigInt_copy takes integer this returns integer
            local integer clone
            local integer n
            
            
            set clone=s__BigInt_allocate()
            set n=clone
            
            set s__BigInt_next[clone]=clone
            set s__BigInt_prev[clone]=clone
            set s__BigInt_head[clone]=true
            set s__BigInt_bm[clone]=s__BigInt_bm[this]
            set s__BigInt_packed[clone]=s__BigInt_packed[this]
            
            loop
                set this=s__BigInt_next[this]
                exitwhen s__BigInt_head[this]
                set n=s__BigInt_allocate()
                call s__BigInt_ad(clone,n)
                set s__BigInt_digit[n]=s__BigInt_digit[this]
            endloop
            return clone
        endfunction
        function s__BigInt_remake takes integer this returns integer
            local integer clone
            
            
            set clone=s__BigInt_allocate()
            set s__BigInt_head[clone]=true
            set s__BigInt_bm[clone]=s__BigInt_bm[this]
            set s__BigInt_size[clone]=s__BigInt_size[this]
            set s__BigInt_packed[clone]=s__BigInt_packed[this]
            if ( clone == this ) then
                call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, 10, "Allocation Error In Remake")
                set s__BigInt_size[this]=1 / 0
            endif
            set s__BigInt_size[this]=0
            if ( not s__BigInt_head[s__BigInt_next[this]] ) then
                set s__BigInt_next[clone]=s__BigInt_next[this]
                set s__BigInt_prev[clone]=s__BigInt_prev[this]
                set s__BigInt_prev[s__BigInt_next[clone]]=clone
                set s__BigInt_next[s__BigInt_prev[clone]]=clone
                set s__BigInt_next[this]=this
                set s__BigInt_prev[this]=this
            else
                set s__BigInt_next[clone]=clone
                set s__BigInt_prev[clone]=clone
            endif
            
            return clone
        endfunction
        function s__BigInt_enq takes integer this,integer i returns nothing
            local integer n
            set n=s__BigInt_allocate()
            call s__BigInt_ad(this,n)
            set s__BigInt_digit[n]=i
        endfunction
        function s__BigInt_push takes integer this,integer i returns nothing
            local integer n
            set n=s__BigInt_allocate()
            call s__BigInt_adp(this,n)
            set s__BigInt_digit[n]=i
        endfunction
        function s__BigInt_pop takes integer this returns nothing
            set s__BigInt_size[this]=s__BigInt_size[this] - 1
            set this=s__BigInt_next[this]
            set s__BigInt_next[s__BigInt_prev[this]]=s__BigInt_next[this]
            set s__BigInt_prev[s__BigInt_next[this]]=s__BigInt_prev[this]



                set s__BigInt_next[this]=s__BigInt_next[(0)]
                set s__BigInt_next[(0)]=this

        endfunction
        function s__BigInt_deq takes integer this returns nothing
            set s__BigInt_size[this]=s__BigInt_size[this] - 1
            set this=s__BigInt_prev[this]
            set s__BigInt_next[s__BigInt_prev[this]]=s__BigInt_next[this]
            set s__BigInt_prev[s__BigInt_next[this]]=s__BigInt_prev[this]



                set s__BigInt_next[this]=s__BigInt_next[(0)]
                set s__BigInt_next[(0)]=this

        endfunction
        function s__BigInt_toInt takes integer this returns integer
            local integer i= 0
            local integer base
            if ( s__BigInt_packed[this] or 0 == s__BigInt_bm[this] ) then
                set base=s__BigInt_packedBase[(Base__s[(s__BigInt_bm[this])])] // INLINED!!
            else
                set base=(Base__s[(s__BigInt_bm[this])]) // INLINED!!
            endif
            loop
                set this=s__BigInt_prev[this]
                exitwhen s__BigInt_head[this]
                set i=i * base + s__BigInt_digit[this]
            endloop
            return i
        endfunction
        function s__BigInt_toString takes integer this returns string
            local string s= ""
            local integer b= s__BigInt_bm[this]
            
            
            
            if ( s__BigInt_packed[this] or 0 == s__BigInt_bm[this] ) then
                if ( s__BigInt_head[s__BigInt_next[this]] ) then
                    return "0"
                endif
                loop
                    set this=s__BigInt_next[this]
                    exitwhen s__BigInt_head[this]
                    set s=I2S(s__BigInt_digit[this]) + ", " + s
                endloop
            else
                if ( s__BigInt_head[s__BigInt_next[this]] ) then
                    return (LoadStr(Table___ht, (((Base__t[(b)]))), (- (0)))) // INLINED!!
                endif
                loop
                    set this=s__BigInt_next[this]
                    exitwhen s__BigInt_head[this]
                    set s=(LoadStr(Table___ht, (((Base__t[(b)]))), (- (s__BigInt_digit[this])))) + s // INLINED!!
                endloop
            endif
            
            
            return s
        endfunction
        
        function s__BigInt_subtract takes integer this,integer i returns nothing
            local integer m
            local integer base
            local integer tn
            local integer tc
            local integer ro= this
            if ( s__BigInt_packed[this] or 0 == s__BigInt_bm[this] ) then
                set base=s__BigInt_packedBase[(Base__s[(s__BigInt_bm[this])])] // INLINED!!
            else
                set base=(Base__s[(s__BigInt_bm[this])]) // INLINED!!
            endif
            loop
                exitwhen 0 == i
                set this=s__BigInt_next[this]
                set m=i - i / base * base
                set i=i / base
                if ( s__BigInt_digit[this] < m ) then
                    set tc=this
                    set tn=s__BigInt_next[this]
                    loop
                        set s__BigInt_digit[tn]=s__BigInt_digit[tn] - 1
                        set s__BigInt_digit[tc]=s__BigInt_digit[tc] + base
                        exitwhen - 1 < s__BigInt_digit[tn]
                        set tc=s__BigInt_next[tc]
                        set tn=s__BigInt_next[tn]
                    endloop
                endif
                set s__BigInt_digit[this]=s__BigInt_digit[this] - m
            endloop
            
            set this=ro
            if ( 0 == s__BigInt_digit[s__BigInt_prev[this]] and not s__BigInt_head[s__BigInt_prev[this]] ) then
                loop
                    set this=s__BigInt_prev[this]
                    exitwhen 0 != s__BigInt_digit[this] or s__BigInt_head[this]
                    set s__BigInt_size[ro]=s__BigInt_size[ro] - 1
                endloop
            
                set this=s__BigInt_next[this]



                    set s__BigInt_next[s__BigInt_prev[ro]]=s__BigInt_next[(0)]
                    set s__BigInt_next[(0)]=this

                set s__BigInt_prev[ro]=s__BigInt_prev[this]
                set s__BigInt_next[s__BigInt_prev[this]]=ro
            endif
        endfunction
        function s__BigInt_subtractBig takes integer this,integer i returns nothing
            local integer base
            local integer root= this
            local integer tn
            local integer tc
            if ( s__BigInt_packed[this] or 0 == s__BigInt_bm[this] ) then
                set base=s__BigInt_packedBase[(Base__s[(s__BigInt_bm[this])])] // INLINED!!
            else
                set base=(Base__s[(s__BigInt_bm[this])]) // INLINED!!
            endif
            loop
                set this=s__BigInt_next[this]
                set i=s__BigInt_next[i]
                exitwhen s__BigInt_head[i]
                if ( s__BigInt_digit[this] < s__BigInt_digit[i] ) then
                    set tc=this
                    set tn=s__BigInt_next[this]
                    loop
                        set s__BigInt_digit[tn]=s__BigInt_digit[tn] - 1
                        set s__BigInt_digit[tc]=s__BigInt_digit[tc] + base
                        exitwhen - 1 < s__BigInt_digit[tn]
                        set tc=s__BigInt_next[tc]
                        set tn=s__BigInt_next[tn]
                    endloop
                endif
                set s__BigInt_digit[this]=s__BigInt_digit[this] - s__BigInt_digit[i]
            endloop
            
            set this=root
            if ( 0 == s__BigInt_digit[s__BigInt_prev[this]] and not s__BigInt_head[s__BigInt_prev[this]] ) then
                loop
                    set this=s__BigInt_prev[this]
                    exitwhen 0 != s__BigInt_digit[this] or s__BigInt_head[this]
                    set s__BigInt_size[root]=s__BigInt_size[root] - 1
                endloop
            
                set this=s__BigInt_next[this]



                    set s__BigInt_next[s__BigInt_prev[root]]=s__BigInt_next[(0)]
                    set s__BigInt_next[(0)]=this

                set s__BigInt_prev[root]=s__BigInt_prev[this]
                set s__BigInt_next[s__BigInt_prev[this]]=root
            endif
        endfunction
        
        function s__BigInt_multiply takes integer this,integer i returns nothing
            local integer carry= 0
            local integer root= this
            local integer m= 0
            local integer cur= this
            local integer i2
            local integer curi
            local integer base
            
            
            if ( 0 == i ) then
                call s__BigInt_clear(this)
                return
            elseif ( s__BigInt_head[s__BigInt_next[this]] ) then
                return
            endif
            
            if ( s__BigInt_packed[this] or 0 == s__BigInt_bm[this] ) then
                set base=s__BigInt_packedBase[(Base__s[(s__BigInt_bm[this])])] // INLINED!!
            else
                set base=(Base__s[(s__BigInt_bm[this])]) // INLINED!!
            endif
            
            set i2=s__BigInt_remake(this)
            
            loop
                exitwhen 0 == i
                set m=i - i / base * base
                set i=i / base
                loop
                    set this=s__BigInt_next[this]
                    set i2=s__BigInt_next[i2]
                    exitwhen s__BigInt_head[i2]
                    if ( s__BigInt_head[this] ) then
                        set this=s__BigInt_allocate()
                        call s__BigInt_ad(root,this)
                    endif
                    set s__BigInt_digit[this]=s__BigInt_digit[this] + s__BigInt_digit[i2] * m
                    set carry=s__BigInt_digit[this] / base
                    set s__BigInt_digit[this]=s__BigInt_digit[this] - s__BigInt_digit[this] / base * base
                    set curi=this
                    loop
                        exitwhen 0 == carry
                        set this=s__BigInt_next[this]
                        if ( s__BigInt_head[this] ) then
                            set this=s__BigInt_allocate()
                            call s__BigInt_ad(root,this)
                        endif
                        set s__BigInt_digit[this]=s__BigInt_digit[this] + carry
                        set carry=s__BigInt_digit[this] / base
                        set s__BigInt_digit[this]=s__BigInt_digit[this] - s__BigInt_digit[this] / base * base
                    endloop
                    set this=curi
                endloop
                set cur=s__BigInt_next[cur]
                set this=cur
            endloop
            
            call s__BigInt_destroy(i2)
        endfunction
        
        function s__BigInt_eMultiplyBig takes nothing returns boolean
            local integer this= s__BigInt_embt
            local integer i= s__BigInt_embm
            local integer carry= 0
            local integer root= s__BigInt_emto
            local integer m= 0
            local integer cur= s__BigInt_embc
            local integer i2= s__BigInt_embt2
            local integer curi
            local integer base= s__BigInt_embb
            local integer z= 2325
            
            loop
                if ( 0 == s__BigInt_embs ) then
                    set i=s__BigInt_next[i]
                    exitwhen s__BigInt_head[i]
                    set m=s__BigInt_digit[i]
                    set s__BigInt_embs=1
                endif
                
                if ( 0 == m ) then
                    call s__BigInt_push(root,0)
                else
                    loop
                        set this=s__BigInt_next[this]
                        set i2=s__BigInt_next[i2]
                        exitwhen s__BigInt_head[i2]
                        if ( s__BigInt_head[this] ) then
                            set this=s__BigInt_allocate()
                            call s__BigInt_ad(root,this)
                        endif
                        set curi=this
                        set s__BigInt_digit[this]=s__BigInt_digit[this] + s__BigInt_digit[i2] * m
                        set carry=s__BigInt_digit[this] / base
                        set s__BigInt_digit[this]=s__BigInt_digit[this] - s__BigInt_digit[this] / base * base
                        loop
                            exitwhen 0 == carry
                            set this=s__BigInt_next[this]
                            if ( s__BigInt_head[this] ) then
                                set this=s__BigInt_allocate()
                                call s__BigInt_ad(root,this)
                            endif
                            set s__BigInt_digit[this]=s__BigInt_digit[this] + carry
                            set carry=s__BigInt_digit[this] / base
                            set s__BigInt_digit[this]=s__BigInt_digit[this] - s__BigInt_digit[this] / base * base
                        endloop
                        set this=curi
                        set z=z - 1
                        if ( 0 == z ) then
                            set s__BigInt_embm=i
                            set s__BigInt_embt=this
                            set s__BigInt_embc=cur
                            set s__BigInt_embt2=i2
                            return false
                        endif
                    endloop
                endif
                set s__BigInt_embs=0
                
                set cur=s__BigInt_next[cur]
                set this=cur
            endloop
            
            return true
        endfunction
        function s__BigInt_multiplyBig takes integer this,integer i returns nothing
            
            if ( s__BigInt_head[s__BigInt_next[i]] ) then
                call s__BigInt_clear(this)
                return
            elseif ( s__BigInt_head[s__BigInt_next[this]] ) then
                return
            endif
            
            if ( s__BigInt_packed[this] or 0 == s__BigInt_bm[this] ) then
                set s__BigInt_embb=s__BigInt_packedBase[(Base__s[(s__BigInt_bm[this])])] // INLINED!!
            else
                set s__BigInt_embb=(Base__s[(s__BigInt_bm[this])]) // INLINED!!
            endif
            
            set s__BigInt_embc=this
            set s__BigInt_emto=this
            set s__BigInt_embt=this
            set s__BigInt_embm=i
            set i=s__BigInt_remake(this)
            set s__BigInt_embt2=i
            set s__BigInt_embs=0
            
            loop
                exitwhen TriggerEvaluate(s__BigInt_evalMultBig)
            endloop
            
            call s__BigInt_destroy(i)
        endfunction
        
        function s__BigInt_multFast takes integer this,integer base,integer orig,integer guess returns nothing
            local integer carry= 0
            local integer root= this
            local integer size= s__BigInt_size[orig]
            
            loop
                set orig=s__BigInt_next[orig]
                exitwhen s__BigInt_head[orig]
                set this=s__BigInt_next[this]
                set s__BigInt_digit[this]=s__BigInt_digit[orig] * guess + carry
                set carry=s__BigInt_digit[this] / base
                set s__BigInt_digit[this]=s__BigInt_digit[this] - s__BigInt_digit[this] / base * base
            endloop
            loop
                exitwhen 0 == carry
                set this=s__BigInt_next[this]
                if ( s__BigInt_head[this] ) then
                    set this=s__BigInt_allocate()
                    call s__BigInt_ad(root,this)
                endif
                set size=size + 1
                set s__BigInt_digit[this]=carry - carry / base * base
                set carry=carry / base
            endloop
            if ( s__BigInt_size[root] > size ) then
                set this=s__BigInt_next[this]
                set orig=s__BigInt_prev[root]
                
                //remove from list
                set s__BigInt_next[s__BigInt_prev[this]]=root
                set s__BigInt_prev[root]=s__BigInt_prev[this]
                



                    set s__BigInt_next[orig]=s__BigInt_next[(0)]
                    set s__BigInt_next[(0)]=this

            endif
            set s__BigInt_size[root]=size
        endfunction
        
        function s__BigInt_eDivideBig takes nothing returns boolean
            local integer guess1
            local integer guess2
            local integer this= s__BigInt_eDivBigT
            local integer remainder= s__BigInt_eDivBigR
            local integer divisor= s__BigInt_eDivBigD
            local integer numerator= s__BigInt_eDivBigN
            local integer base= s__BigInt_eDivBigB
            local integer toSubtract
            local integer rootThis= this
            local integer rootRemainder= remainder
            local integer rootDivisor= divisor
            local integer rootNumerator= numerator
            local integer rootToSubtract
            local integer tn
            local integer tc
            local integer toPush
            
            local integer guess
            
            local boolean isLessThan
            
            local integer largeRemainderCombined
            local integer largeDivisor= s__BigInt_digit[s__BigInt_prev[divisor]]
            local integer largeDivisor2= s__BigInt_digit[s__BigInt_prev[s__BigInt_prev[divisor]]]
            local integer largeDivisorCombined= largeDivisor * base + largeDivisor2
            
            
            
            loop
                if ( 0 == s__BigInt_size[this] ) then
                    set toPush=- s__BigInt_size[divisor]
                else
                    set toPush=- 1
                endif
                
                loop
                    exitwhen 0 == s__BigInt_size[numerator] or s__BigInt_gtoe(remainder,divisor)
                    call s__BigInt_deto(numerator,remainder)
                    set toPush=toPush + 1
                endloop
                



                
                set isLessThan=s__BigInt_lt(remainder,divisor)
                
                if ( isLessThan ) then
                    set toPush=toPush + 1
                endif
                
                if ( 0 < s__BigInt_size[this] and 0 < toPush ) then
                    loop
                        call s__BigInt_push(this,0)
                        set toPush=toPush - 1
                        exitwhen 0 == toPush
                    endloop
                endif
                
                exitwhen isLessThan
                
                set largeRemainderCombined=s__BigInt_digit[s__BigInt_prev[remainder]] * base + s__BigInt_digit[s__BigInt_prev[s__BigInt_prev[remainder]]]
                
                set guess=s__BigInt_digit[s__BigInt_prev[remainder]] / largeDivisor
                if ( 0 == guess and 1 < s__BigInt_size[remainder] ) then
                    set guess=largeRemainderCombined / largeDivisor
                elseif ( 1 < s__BigInt_size[divisor] and 1 < s__BigInt_size[remainder] ) then
                    set guess=largeRemainderCombined / largeDivisorCombined
                    if ( 0 == guess ) then
                        set guess=base - 1
                    endif
                endif
                






                
                set toSubtract=s__BigInt_copy(divisor)
                set rootToSubtract=toSubtract
                call s__BigInt_multFast(toSubtract,base , divisor , guess)
                



                
                set guess1=- 1
                set guess2=- 1
                loop
                    if ( s__BigInt_digit[s__BigInt_prev[toSubtract]] * base + s__BigInt_digit[s__BigInt_prev[s__BigInt_prev[toSubtract]]] > s__BigInt_digit[s__BigInt_prev[remainder]] * base + s__BigInt_digit[s__BigInt_prev[s__BigInt_prev[remainder]]] ) then
                        set guess1=guess - ( ( s__BigInt_digit[s__BigInt_prev[toSubtract]] * base + s__BigInt_digit[s__BigInt_prev[s__BigInt_prev[toSubtract]]] ) - ( s__BigInt_digit[s__BigInt_prev[remainder]] * base + s__BigInt_digit[s__BigInt_prev[s__BigInt_prev[remainder]]] ) ) / s__BigInt_digit[s__BigInt_prev[divisor]]
                        



                        if ( 0 < guess1 and base > guess1 and guess1 != guess ) then
                            call s__BigInt_multFast(toSubtract,base , divisor , guess1)
                            if ( guess1 + 5 > guess and guess1 - 5 < guess ) then
                                set guess=guess1
                                exitwhen true
                            endif
                            set guess=guess1
                            



                            
                            if ( s__BigInt_size[remainder] > s__BigInt_size[toSubtract] ) then
                                set guess2=guess + ( ( s__BigInt_digit[s__BigInt_prev[remainder]] * base + s__BigInt_digit[s__BigInt_prev[s__BigInt_prev[remainder]]] ) - ( s__BigInt_digit[s__BigInt_prev[toSubtract]] ) ) / s__BigInt_digit[s__BigInt_prev[divisor]]
                            else
                                if ( s__BigInt_digit[s__BigInt_prev[remainder]] > s__BigInt_digit[s__BigInt_prev[toSubtract]] ) then
                                    set guess2=guess + ( ( s__BigInt_digit[s__BigInt_prev[remainder]] * base + s__BigInt_digit[s__BigInt_prev[s__BigInt_prev[remainder]]] ) - ( s__BigInt_digit[s__BigInt_prev[toSubtract]] * base + s__BigInt_digit[s__BigInt_prev[s__BigInt_prev[toSubtract]]] ) ) / s__BigInt_digit[s__BigInt_prev[divisor]]
                                else
                                    set guess2=guess + ( s__BigInt_digit[s__BigInt_prev[s__BigInt_prev[remainder]]] - s__BigInt_digit[s__BigInt_prev[s__BigInt_prev[toSubtract]]] ) / s__BigInt_digit[s__BigInt_prev[divisor]] + ( s__BigInt_digit[s__BigInt_prev[s__BigInt_prev[divisor]]] + base / 2 ) / base
                                endif
                            endif
                            



                            
                            if ( base > guess2 and 0 < guess2 and guess1 != guess2 ) then
                                call s__BigInt_multFast(toSubtract,base , divisor , guess2)
                                if ( guess2 + 5 > guess and guess2 - 5 < guess ) then
                                    set guess=guess2
                                    exitwhen true
                                endif
                                set guess=guess2
                                



                            else
                                exitwhen true
                            endif
                        else
                            exitwhen true
                        endif
                    else
                        exitwhen true
                    endif
                endloop
                



                
                loop
                    //compare
                    if ( s__BigInt_size[remainder] == s__BigInt_size[toSubtract] ) then
                        loop
                            set toSubtract=s__BigInt_prev[toSubtract]
                            set remainder=s__BigInt_prev[remainder]
                            exitwhen s__BigInt_head[toSubtract] or s__BigInt_digit[remainder] != s__BigInt_digit[toSubtract]
                        endloop
                        exitwhen s__BigInt_digit[remainder] >= s__BigInt_digit[toSubtract]
                    else
                        exitwhen true
                    endif
                    
                    set toSubtract=rootToSubtract
                    set remainder=rootRemainder
                    
                    if ( 0 == guess - 1 ) then
                        set guess=base - 1
                        call s__BigInt_multFast(toSubtract,base , divisor , guess)
                        exitwhen true
                    else
                        
                        set guess=guess - 1
                        



                        
                        //subtract
                        loop
                            set toSubtract=s__BigInt_next[toSubtract]
                            set divisor=s__BigInt_next[divisor]
                            exitwhen s__BigInt_head[divisor]
                            if ( s__BigInt_digit[toSubtract] < s__BigInt_digit[divisor] ) then
                                set tc=toSubtract
                                set tn=s__BigInt_next[toSubtract]
                                loop
                                    set s__BigInt_digit[tn]=s__BigInt_digit[tn] - 1
                                    set s__BigInt_digit[tc]=s__BigInt_digit[tc] + base
                                    exitwhen - 1 < s__BigInt_digit[tn]
                                    set tc=s__BigInt_next[tc]
                                    set tn=s__BigInt_next[tn]
                                endloop
                            endif
                            set s__BigInt_digit[toSubtract]=s__BigInt_digit[toSubtract] - s__BigInt_digit[divisor]
                        endloop
                        
                        set divisor=rootDivisor
                        set toSubtract=rootToSubtract
                        
                        if ( 0 == s__BigInt_digit[s__BigInt_prev[toSubtract]] and 0 < s__BigInt_size[toSubtract] ) then
                            set tn=toSubtract
                            loop
                                set tn=s__BigInt_prev[tn]
                                exitwhen 0 != s__BigInt_digit[tn] or s__BigInt_head[tn]
                                set s__BigInt_size[toSubtract]=s__BigInt_size[toSubtract] - 1
                            endloop
                        
                            set tn=s__BigInt_next[tn]



                                set s__BigInt_next[s__BigInt_prev[toSubtract]]=s__BigInt_next[(0)]
                                set s__BigInt_next[(0)]=tn

                            set s__BigInt_prev[toSubtract]=s__BigInt_prev[tn]
                            set s__BigInt_next[s__BigInt_prev[tn]]=toSubtract
                        endif
                    endif
                endloop
                






                
                call s__BigInt_push(this,guess)
                



                
                set toSubtract=s__BigInt_next[rootToSubtract]
                set remainder=s__BigInt_next[rootRemainder]
                
                loop
                    if ( s__BigInt_digit[remainder] < s__BigInt_digit[toSubtract] ) then
                        set tc=remainder
                        set tn=s__BigInt_next[remainder]
                        loop
                            set s__BigInt_digit[tn]=s__BigInt_digit[tn] - 1
                            set s__BigInt_digit[tc]=s__BigInt_digit[tc] + base
                            exitwhen - 1 < s__BigInt_digit[tn]
                            set tc=s__BigInt_next[tc]
                            set tn=s__BigInt_next[tn]
                        endloop
                    endif
                    set s__BigInt_digit[remainder]=s__BigInt_digit[remainder] - s__BigInt_digit[toSubtract]
                    set toSubtract=s__BigInt_next[toSubtract]
                    set remainder=s__BigInt_next[remainder]
                    exitwhen s__BigInt_head[toSubtract]
                endloop
                
                set remainder=rootRemainder
                if ( 0 == s__BigInt_digit[s__BigInt_prev[remainder]] and 0 < s__BigInt_size[remainder] ) then
                    loop
                        set remainder=s__BigInt_prev[remainder]
                        exitwhen 0 != s__BigInt_digit[remainder] or s__BigInt_head[remainder]
                        set s__BigInt_size[rootRemainder]=s__BigInt_size[rootRemainder] - 1
                    endloop
                
                    set remainder=s__BigInt_next[remainder]



                        set s__BigInt_next[s__BigInt_prev[rootRemainder]]=s__BigInt_next[(0)]
                        set s__BigInt_next[(0)]=remainder

                    set s__BigInt_prev[rootRemainder]=s__BigInt_prev[remainder]
                    set s__BigInt_next[s__BigInt_prev[remainder]]=rootRemainder
                endif
                set remainder=rootRemainder
                
                call s__BigInt_destroy(toSubtract)
                



            endloop
            
            



            
            return true
        endfunction
        
        function s__BigInt_divideBig takes integer this,integer d returns integer
            local integer r
            local integer n
            
            local integer base
            
            
            set n=s__BigInt_remake(this)
            
            if ( s__BigInt_lt(n,d) ) then
                return n
            endif
            
            set r=s__BigInt_create()
            set s__BigInt_bm[r]=s__BigInt_bm[n]
            
            if ( s__BigInt_packed[this] or 0 == s__BigInt_bm[this] ) then
                set base=s__BigInt_packedBase[(Base__s[(s__BigInt_bm[this])])] // INLINED!!
            else
                set base=(Base__s[(s__BigInt_bm[this])]) // INLINED!!
            endif
            
            set s__BigInt_eDivBigN=n
            set s__BigInt_eDivBigT=this
            set s__BigInt_eDivBigR=r
            set s__BigInt_eDivBigD=d
            set s__BigInt_eDivBigB=base
            
            call TriggerEvaluate(s__BigInt_evalDivideBig)
            
            call s__BigInt_destroy(n)
            
            return r
        endfunction
        function s__BigInt_divide takes integer this,integer d returns integer
            local integer i
            local integer r
            
            
            set i=s__BigInt_create()
            set s__BigInt_bm[i]=s__BigInt_bm[this]
            call s__BigInt_add(i,d)
            set r=s__BigInt_divideBig(this,i)
            call s__BigInt_destroy(i)
            set d=s__BigInt_toInt(r)
            call s__BigInt_destroy(r)
            
            return d
        endfunction
        function s__BigInt__get_base takes integer this returns integer
            return s__BigInt_bm[this]
        endfunction
        
        function s__BigInt_pack takes integer this returns nothing
            local integer root= this
            local integer old
            local integer digit= 0
            local integer base= (Base__s[(s__BigInt_bm[this])]) // INLINED!!
            local integer packedBase= s__BigInt_packedBase[(Base__s[(s__BigInt_bm[this])])] // INLINED!!
            local integer packedPow= s__BigInt_packedPower[base]
            local integer extra= s__BigInt_size[this] - s__BigInt_size[this] / packedPow * packedPow
            local integer counter= packedPow
            
            if ( s__BigInt_packed[this] ) then
                return
            endif
            
            set s__BigInt_packed[this]=true
            
            if ( 0 == s__BigInt_bm[this] ) then
                return
            endif
            
            set old=s__BigInt_remake(this)
            
            if ( 0 != extra ) then
                loop
                    exitwhen 0 == extra
                    set extra=extra - 1
                    set old=s__BigInt_prev[old]
                    set digit=digit * base + s__BigInt_digit[old]
                endloop
                set this=s__BigInt_allocate()
                set s__BigInt_digit[this]=digit
                call s__BigInt_adp(root,this)
            endif
            
            set digit=0
            loop
                set old=s__BigInt_prev[old]
                exitwhen s__BigInt_head[old]
                set digit=digit * base + s__BigInt_digit[old]
                set counter=counter - 1
                if ( 0 == counter ) then
                    set counter=packedPow
                    set this=s__BigInt_allocate()
                    set s__BigInt_digit[this]=digit
                    call s__BigInt_adp(root,this)
                    set digit=0
                endif
            endloop
            
            call s__BigInt_destroy(old)
        endfunction
        
        function s__BigInt_unpack takes integer this returns nothing
            local integer root= this
            local integer old
            local integer oldRoot
            local integer digit= 0
            local integer base= (Base__s[(s__BigInt_bm[this])]) // INLINED!!
            local integer packedBase= s__BigInt_packedBase[(Base__s[(s__BigInt_bm[this])])] // INLINED!!
            local integer packedPow= s__BigInt_packedPower[base]
            local integer counter
            local integer lastDigit
            
            if ( not s__BigInt_packed[this] ) then
                return
            endif
            
            set s__BigInt_packed[this]=false
            
            if ( 0 == s__BigInt_bm[this] ) then
                return
            endif
            
            set old=s__BigInt_remake(this)
            set oldRoot=old
            
            set old=s__BigInt_prev[old]
            if ( s__BigInt_head[old] ) then
                call s__BigInt_destroy(old)
                return
            endif
            
            set lastDigit=s__BigInt_digit[old]
            call s__BigInt_deq(oldRoot)
            
            set old=oldRoot
            loop
                set old=s__BigInt_next[old]
                exitwhen s__BigInt_head[old]
                set digit=s__BigInt_digit[old]
                set counter=packedPow
                loop
                    set this=s__BigInt_allocate()
                    call s__BigInt_ad(root,this)
                    set s__BigInt_digit[this]=digit - digit / base * base
                    set counter=counter - 1
                    exitwhen 0 == counter
                    set digit=digit / base
                endloop
            endloop
            
            set digit=lastDigit
            loop
                set this=s__BigInt_allocate()
                call s__BigInt_ad(root,this)
                set s__BigInt_digit[this]=digit - digit / base * base
                set digit=digit / base
                exitwhen 0 == digit
            endloop
            
            call s__BigInt_destroy(old)
        endfunction
        
        //evalBase
        
        function s__BigInt_fastdiv takes integer this,integer base,integer divide,integer remainder returns integer
            loop
                set s__BigInt_digit[this]=remainder / divide
                set remainder=remainder - remainder / divide * divide
                
                loop
                    set this=s__BigInt_prev[this]
                    if ( s__BigInt_head[this] ) then
                        return remainder
                    endif
                    
                    set remainder=remainder * base + s__BigInt_digit[this]
                    exitwhen remainder >= divide
                    set s__BigInt_digit[this]=0
                endloop
            endloop
            
            return remainder
        endfunction
        function s__BigInt_ebase takes nothing returns boolean
            local integer from= s__BigInt_ebi
            local integer this= s__BigInt_ebt
            local integer fromBase= s__BigInt_ebs
            local integer toBase= s__BigInt_ebs2
            
            local integer node
            local integer remainder
            
            
            loop
                //allocate node
                set node=s__BigInt_allocate()
                
                //add node
                set s__BigInt_next[node]=this
                set s__BigInt_prev[node]=s__BigInt_prev[this]
                set s__BigInt_next[s__BigInt_prev[this]]=node
                set s__BigInt_prev[this]=node
                set s__BigInt_size[this]=s__BigInt_size[this] + 1
                
                set remainder=0
                loop
                    set remainder=remainder * fromBase + s__BigInt_digit[from]
                    exitwhen remainder >= toBase
                    set from=s__BigInt_prev[from]
                    exitwhen s__BigInt_head[from]
                endloop
                
                if ( s__BigInt_head[from] ) then
                    set s__BigInt_digit[node]=remainder
                else
                    set s__BigInt_digit[node]=s__BigInt_fastdiv(from,fromBase , toBase , remainder)
                endif
                
                exitwhen s__BigInt_head[from]
            endloop
            
            
            return false
        endfunction
        //evalBase
        
        function s__BigInt_setBase takes nothing returns boolean
            local integer this= s__BigInt_thisToConvert
            local integer base= s__BigInt_baseToSet
            local integer toConvert
            local integer oldBase
            local integer newBase
            local boolean wasPacked
            
            set wasPacked=s__BigInt_packed[this]
            
            if ( not wasPacked ) then
                call s__BigInt_pack(this)
            endif
            
            set oldBase=s__BigInt_packedBase[(Base__s[(s__BigInt_bm[this])])] // INLINED!!
            set newBase=s__BigInt_packedBase[(Base__s[(base)])] // INLINED!!
            
            if ( oldBase == newBase ) then
                set s__BigInt_bm[this]=base
                if ( not wasPacked ) then
                    call s__BigInt_unpack(this)
                    return false
                endif
            endif
            
            set toConvert=s__BigInt_remake(this)
            
            set s__BigInt_ebs=oldBase
            set s__BigInt_ebs2=newBase
            set s__BigInt_ebt=this
            set s__BigInt_ebi=s__BigInt_prev[toConvert]
            
            call TriggerEvaluate(s__BigInt_evalBase)
            
            call s__BigInt_destroy(toConvert)
            
            set s__BigInt_bm[this]=base
            
            if ( not wasPacked ) then
                call s__BigInt_unpack(this)
            endif
            
            return false
        endfunction
        
        function s__BigInt__set_base takes integer this,integer base returns nothing
            
            if ( (Base__s[(s__BigInt_bm[this])]) != (Base__s[(base)]) and 0 < s__BigInt_size[this] ) then // INLINED!!
                set s__BigInt_baseToSet=base
                set s__BigInt_thisToConvert=this
                call TriggerEvaluate(s__BigInt_evalSetBase)
            else
                set s__BigInt_bm[this]=base
            endif
        endfunction
        function s__BigInt_modBig takes integer this,integer i returns integer
            local integer h= s__BigInt_copy(this)
            local integer k= s__BigInt_divideBig(h,i)
            call s__BigInt_destroy(h)
            return k
        endfunction
        function s__BigInt_mod takes integer this,integer i returns integer
            local integer m
            local integer r
            if ( 1 == i ) then
                return 0
            endif
            set m=s__BigInt_create()
            set s__BigInt_bm[m]=s__BigInt_bm[this]
            call s__BigInt_add(m,i)
            set r=s__BigInt_modBig(this,m)
            set i=s__BigInt_toInt(r)
            call s__BigInt_destroy(m)
            call s__BigInt_destroy(r)
            return i
        endfunction
        
//Implemented from module BigInt__Init:
        function s__BigInt_BigInt__Init___onInit takes nothing returns nothing
            local integer base
        
            set s__BigInt_evalBase=CreateTrigger()
            call TriggerAddCondition(s__BigInt_evalBase, Condition(function s__BigInt_ebase))
            
            set s__BigInt_evalMultBig=CreateTrigger()
            call TriggerAddCondition(s__BigInt_evalMultBig, Condition(function s__BigInt_eMultiplyBig))
            
            set s__BigInt_evalDivideBig=CreateTrigger()
            call TriggerAddCondition(s__BigInt_evalDivideBig, Condition(function s__BigInt_eDivideBig))
            
            set s__BigInt_evalSetBase=CreateTrigger()
            call TriggerAddCondition(s__BigInt_evalSetBase, Condition(function s__BigInt_setBase))
            
            set s__BigInt_packedBase[0]=46340
            set s__BigInt_packedPower[0]=1
            set s__BigInt_packedBase[2]=32768
            set s__BigInt_packedPower[2]=15
            set s__BigInt_packedBase[3]=19683
            set s__BigInt_packedPower[3]=9
            set s__BigInt_packedBase[4]=16384
            set s__BigInt_packedPower[4]=8
            set s__BigInt_packedBase[5]=15625
            set s__BigInt_packedPower[5]=6
            set s__BigInt_packedBase[6]=7776
            set s__BigInt_packedPower[6]=5
            set s__BigInt_packedBase[7]=16807
            set s__BigInt_packedPower[7]=5
            set s__BigInt_packedBase[8]=32768
            set s__BigInt_packedPower[8]=5
            set s__BigInt_packedBase[9]=6561
            set s__BigInt_packedPower[9]=4
            set s__BigInt_packedBase[10]=10000
            set s__BigInt_packedPower[10]=4
            set s__BigInt_packedBase[11]=14641
            set s__BigInt_packedPower[11]=4
            set s__BigInt_packedBase[12]=20736
            set s__BigInt_packedPower[12]=4
            set s__BigInt_packedBase[13]=28561
            set s__BigInt_packedPower[13]=4
            set s__BigInt_packedBase[14]=38416
            set s__BigInt_packedPower[14]=4
            set s__BigInt_packedBase[15]=3375
            set s__BigInt_packedPower[15]=3
            set s__BigInt_packedBase[16]=4096
            set s__BigInt_packedPower[16]=3
            set s__BigInt_packedBase[17]=4913
            set s__BigInt_packedPower[17]=3
            set s__BigInt_packedBase[18]=5832
            set s__BigInt_packedPower[18]=3
            set s__BigInt_packedBase[19]=6859
            set s__BigInt_packedPower[19]=3
            set s__BigInt_packedBase[20]=8000
            set s__BigInt_packedPower[20]=3
            set s__BigInt_packedBase[21]=9261
            set s__BigInt_packedPower[21]=3
            set s__BigInt_packedBase[22]=10648
            set s__BigInt_packedPower[22]=3
            set s__BigInt_packedBase[23]=12167
            set s__BigInt_packedPower[23]=3
            set s__BigInt_packedBase[24]=13824
            set s__BigInt_packedPower[24]=3
            set s__BigInt_packedBase[25]=15625
            set s__BigInt_packedPower[25]=3
            set s__BigInt_packedBase[26]=17576
            set s__BigInt_packedPower[26]=3
            set s__BigInt_packedBase[27]=19683
            set s__BigInt_packedPower[27]=3
            set s__BigInt_packedBase[28]=21952
            set s__BigInt_packedPower[28]=3
            set s__BigInt_packedBase[29]=24389
            set s__BigInt_packedPower[29]=3
            set s__BigInt_packedBase[30]=27000
            set s__BigInt_packedPower[30]=3
            set s__BigInt_packedBase[31]=29791
            set s__BigInt_packedPower[31]=3
            set s__BigInt_packedBase[32]=32768
            set s__BigInt_packedPower[32]=3
            set s__BigInt_packedBase[33]=35937
            set s__BigInt_packedPower[33]=3
            set s__BigInt_packedBase[34]=39304
            set s__BigInt_packedPower[34]=3
            set s__BigInt_packedBase[35]=42875
            set s__BigInt_packedPower[35]=3
            
            set base=128
            loop
                exitwhen 35 == base
                set s__BigInt_packedBase[base]=base * base
                set s__BigInt_packedPower[base]=2
                set base=base - 1
            endloop
        endfunction

//library BigInt ends
//library Bonus:

//textmacro instance: BONUS_SCRIPT()
function s__Bonus___O_index takes nothing returns boolean
set Bonus___cb[(UnitIndexer___o)]=s__Table_create() // INLINED!!
return false
endfunction
function s__Bonus___O_deindex takes nothing returns boolean
call s__Table_destroy(Bonus___cb[(UnitIndexer___o)]) // INLINED!!
return false
endfunction
//Implemented from module Bonus___I:
function s__Bonus___O_Bonus___I___onInit takes nothing returns nothing

local unit u
call s__UnitIndexer__set_enabled(false)
set u=CreateUnit(Player(14), 'hpea', 0, 0, 0)
call UnitAddAbility(u, 'A!!!')
call UnitAddAbility(u, 'A!!"')
call UnitAddAbility(u, 'A!!#')
call UnitAddAbility(u, 'A!!$')
call UnitAddAbility(u, 'A!!%')
call UnitAddAbility(u, 'A!!&')
call UnitAddAbility(u, 'A!!(')
call UnitAddAbility(u, 'A!!)')
call UnitAddAbility(u, 'A!!*')
call UnitAddAbility(u, 'A!!+')
call UnitAddAbility(u, 'A!!-')
call UnitAddAbility(u, 'A!!.')
call UnitAddAbility(u, 'A!!:')
call UnitAddAbility(u, 'A!!;')
call UnitAddAbility(u, 'A!!<')
call UnitAddAbility(u, 'A!!=')
call UnitAddAbility(u, 'A!!>')
call UnitAddAbility(u, 'A!!?')
call UnitAddAbility(u, 'A!!@')
call UnitAddAbility(u, 'A!![')
call UnitAddAbility(u, 'A!!]')
call UnitAddAbility(u, 'A!!^')
call UnitAddAbility(u, 'A!!_')
call UnitAddAbility(u, 'A!!{')
call UnitAddAbility(u, 'A!!|')
call UnitAddAbility(u, 'A!!}')
call UnitAddAbility(u, 'A!!~')
call UnitAddAbility(u, 'A!"!')
call UnitAddAbility(u, 'A!""')
call UnitAddAbility(u, 'A!"#')
call UnitAddAbility(u, 'A!"$')
call UnitAddAbility(u, 'A!"%')
call UnitAddAbility(u, 'A!"&')
call UnitAddAbility(u, 'A!"(')
call UnitAddAbility(u, 'A!")')
call UnitAddAbility(u, 'A!"*')
call UnitAddAbility(u, 'A!"+')
call UnitAddAbility(u, 'A!"-')
call UnitAddAbility(u, 'A!".')
call UnitAddAbility(u, 'A!":')
call UnitAddAbility(u, 'A!";')
call UnitAddAbility(u, 'A!"<')
call UnitAddAbility(u, 'A!"=')
call UnitAddAbility(u, 'A!">')
call UnitAddAbility(u, 'A!"?')
call UnitAddAbility(u, 'A!"@')
call UnitAddAbility(u, 'A!"[')
call UnitAddAbility(u, 'A!"]')
call UnitAddAbility(u, 'A!"^')
call UnitAddAbility(u, 'A!"_')
call UnitAddAbility(u, 'A!"{')
call UnitAddAbility(u, 'A!"|')
call UnitAddAbility(u, 'A!"}')
call UnitAddAbility(u, 'A!"~')
call UnitAddAbility(u, 'A!#!')
call UnitAddAbility(u, 'A!#"')
call UnitAddAbility(u, 'A!##')
call UnitAddAbility(u, 'A!#$')
call UnitAddAbility(u, 'A!#%')
call UnitAddAbility(u, 'A!#&')
call UnitAddAbility(u, 'A!#(')
call UnitAddAbility(u, 'A!#)')
call UnitAddAbility(u, 'A!#*')
call UnitAddAbility(u, 'A!#+')
call UnitAddAbility(u, 'A!#-')
call UnitAddAbility(u, 'A!#.')
call UnitAddAbility(u, 'A!#:')
call UnitAddAbility(u, 'A!#;')
call UnitAddAbility(u, 'A!#<')
call UnitAddAbility(u, 'A!#=')
call UnitAddAbility(u, 'A!#>')
call UnitAddAbility(u, 'A!#?')
call UnitAddAbility(u, 'A!#@')
call UnitAddAbility(u, 'A!#[')
call UnitAddAbility(u, 'A!#]')
call UnitAddAbility(u, 'A!#^')
call UnitAddAbility(u, 'A!#_')
call UnitAddAbility(u, 'A!#{')
call UnitAddAbility(u, 'A!#|')
call UnitAddAbility(u, 'A!#}')
call UnitAddAbility(u, 'A!#~')
call UnitAddAbility(u, 'A!$!')
call UnitAddAbility(u, 'A!$"')
call UnitAddAbility(u, 'A!$#')
call UnitAddAbility(u, 'A!$$')
call UnitAddAbility(u, 'A!$%')
call UnitAddAbility(u, 'A!$&')
call UnitAddAbility(u, 'A!$(')
call UnitAddAbility(u, 'A!$)')
call UnitAddAbility(u, 'A!$*')
call UnitAddAbility(u, 'A!$+')
call UnitAddAbility(u, 'A!$-')
call UnitAddAbility(u, 'A!$.')
call UnitAddAbility(u, 'A!$:')
call UnitAddAbility(u, 'A!$;')
call UnitAddAbility(u, 'A!$<')
call UnitAddAbility(u, 'A!$=')
call UnitAddAbility(u, 'A!$>')
call UnitAddAbility(u, 'A!$?')
call UnitAddAbility(u, 'A!$@')
call UnitAddAbility(u, 'A!$[')
call UnitAddAbility(u, 'A!$]')
call UnitAddAbility(u, 'A!$^')
call UnitAddAbility(u, 'A!$_')
call UnitAddAbility(u, 'A!${')
call UnitAddAbility(u, 'A!$|')
call UnitAddAbility(u, 'A!$}')
call UnitAddAbility(u, 'A!$~')
call UnitAddAbility(u, 'A!%!')
call UnitAddAbility(u, 'A!%"')
call UnitAddAbility(u, 'A!%#')
call UnitAddAbility(u, 'A!%$')
call UnitAddAbility(u, 'A!%%')
call UnitAddAbility(u, 'A!%&')
call UnitAddAbility(u, 'A!%(')
call UnitAddAbility(u, 'A!%)')
call UnitAddAbility(u, 'A!%*')
call UnitAddAbility(u, 'A!%+')
call UnitAddAbility(u, 'A!%-')
call UnitAddAbility(u, 'A!%.')
call UnitAddAbility(u, 'A!%:')
call UnitAddAbility(u, 'A!%;')
call UnitAddAbility(u, 'A!%<')
call UnitAddAbility(u, 'A!%=')
call UnitAddAbility(u, 'A!%>')
call UnitAddAbility(u, 'A!%?')
call UnitAddAbility(u, 'A!%@')
call UnitAddAbility(u, 'A!%[')
call UnitAddAbility(u, 'A!%]')
call UnitAddAbility(u, 'A!%^')
call UnitAddAbility(u, 'A!%_')
call UnitAddAbility(u, 'A!%{')
call UnitAddAbility(u, 'A!%|')
call UnitAddAbility(u, 'A!%}')
call UnitAddAbility(u, 'A!%~')
call UnitAddAbility(u, 'A!&!')
call UnitAddAbility(u, 'A!&"')
call UnitAddAbility(u, 'A!&#')
call UnitAddAbility(u, 'A!&$')
call UnitAddAbility(u, 'A!&%')
call UnitAddAbility(u, 'A!&&')
call UnitAddAbility(u, 'A!&(')
call RemoveUnit(u)
set u=null
call s__UnitIndexer__set_enabled(true)

call RegisterUnitIndexEvent(Condition(function s__Bonus___O_index) , s__UnitIndexer_INDEX)
call RegisterUnitIndexEvent(Condition(function s__Bonus___O_deindex) , s__UnitIndexer_DEINDEX)
set Bonus___bo[0]='A!!!' //0
set Bonus___bo[1]='A!!"' //1
set Bonus___bo[2]='A!!#' //2
set Bonus___bo[3]='A!!$' //3
set Bonus___bo[4]='A!!%' //4
set Bonus___bo[5]='A!!&' //5
set Bonus___bo[6]='A!!(' //6
set Bonus___bo[7]='A!!)' //7
set Bonus___bo[8]='A!!*' //8
set Bonus___bo[9]='A!!+' //9
set Bonus___bo[10]='A!!-' //10
set Bonus___bo[11]='A!!.' //11
set Bonus___bo[12]='A!!:' //12
set Bonus___bo[13]='A!!;' //13
set Bonus___bo[14]='A!!<' //0
set Bonus___bo[15]='A!!=' //1
set Bonus___bo[16]='A!!>' //2
set Bonus___bo[17]='A!!?' //3
set Bonus___bo[18]='A!!@' //4
set Bonus___bo[19]='A!![' //5
set Bonus___bo[20]='A!!]' //6
set Bonus___bo[21]='A!!^' //7
set Bonus___bo[22]='A!!_' //8
set Bonus___bo[23]='A!!{' //9
set Bonus___bo[24]='A!!|' //10
set Bonus___bo[25]='A!!}' //11
set Bonus___bo[26]='A!!~' //12
set Bonus___bo[27]='A!"!' //13
set Bonus___bo[28]='A!""' //14
set Bonus___bo[29]='A!"#' //15
set Bonus___bo[30]='A!"$' //16
set Bonus___bo[31]='A!"%' //17
set Bonus___bo[32]='A!"&' //18
set Bonus___bo[33]='A!"(' //19
set Bonus___bo[34]='A!")' //20
set Bonus___bo[35]='A!"*' //21
set Bonus___bo[36]='A!"+' //22
set Bonus___bo[37]='A!"-' //23
set Bonus___bo[38]='A!".' //0
set Bonus___bo[39]='A!":' //1
set Bonus___bo[40]='A!";' //2
set Bonus___bo[41]='A!"<' //3
set Bonus___bo[42]='A!"=' //4
set Bonus___bo[43]='A!">' //5
set Bonus___bo[44]='A!"?' //6
set Bonus___bo[45]='A!"@' //7
set Bonus___bo[46]='A!"[' //8
set Bonus___bo[47]='A!"]' //9
set Bonus___bo[48]='A!"^' //10
set Bonus___bo[49]='A!"_' //11
set Bonus___bo[50]='A!"{' //12
set Bonus___bo[51]='A!"|' //13
set Bonus___bo[52]='A!"}' //14
set Bonus___bo[53]='A!"~' //15
set Bonus___bo[54]='A!#!' //16
set Bonus___bo[55]='A!#"' //17
set Bonus___bo[56]='A!##' //18
set Bonus___bo[57]='A!#$' //0
set Bonus___bo[58]='A!#%' //1
set Bonus___bo[59]='A!#&' //2
set Bonus___bo[60]='A!#(' //3
set Bonus___bo[61]='A!#)' //4
set Bonus___bo[62]='A!#*' //5
set Bonus___bo[63]='A!#+' //6
set Bonus___bo[64]='A!#-' //7
set Bonus___bo[65]='A!#.' //8
set Bonus___bo[66]='A!#:' //9
set Bonus___bo[67]='A!#;' //10
set Bonus___bo[68]='A!#<' //11
set Bonus___bo[69]='A!#=' //12
set Bonus___bo[70]='A!#>' //13
set Bonus___bo[71]='A!#?' //14
set Bonus___bo[72]='A!#@' //15
set Bonus___bo[73]='A!#[' //16
set Bonus___bo[74]='A!#]' //17
set Bonus___bo[75]='A!#^' //18
set Bonus___bo[76]='A!#_' //0
set Bonus___bo[77]='A!#{' //1
set Bonus___bo[78]='A!#|' //2
set Bonus___bo[79]='A!#}' //3
set Bonus___bo[80]='A!#~' //4
set Bonus___bo[81]='A!$!' //5
set Bonus___bo[82]='A!$"' //6
set Bonus___bo[83]='A!$#' //7
set Bonus___bo[84]='A!$$' //8
set Bonus___bo[85]='A!$%' //9
set Bonus___bo[86]='A!$&' //10
set Bonus___bo[87]='A!$(' //11
set Bonus___bo[88]='A!$)' //12
set Bonus___bo[89]='A!$*' //13
set Bonus___bo[90]='A!$+' //14
set Bonus___bo[91]='A!$-' //15
set Bonus___bo[92]='A!$.' //16
set Bonus___bo[93]='A!$:' //17
set Bonus___bo[94]='A!$;' //18
set Bonus___bo[95]='A!$<'
set Bonus___bo[122]='A!$=' //0
set Bonus___bo[123]='A!$>' //1
set Bonus___bo[124]='A!$?' //2
set Bonus___bo[125]='A!$@' //3
set Bonus___bo[126]='A!$[' //4
set Bonus___bo[127]='A!$]' //5
set Bonus___bo[128]='A!$^' //6
set Bonus___bo[129]='A!$_' //7
set Bonus___bo[130]='A!${' //8
set Bonus___bo[131]='A!$|' //9
set Bonus___bo[132]='A!$}' //10
set Bonus___bo[133]='A!$~' //11
set Bonus___bo[134]='A!%!' //12
set Bonus___bo[135]='A!%"' //13
set Bonus___bo[136]='A!%#' //14
set Bonus___bo[137]='A!%$' //15
set Bonus___bo[138]='A!%%'
set Bonus___bo[141]='A!%&' //0
set Bonus___bo[142]='A!%(' //1
set Bonus___bo[143]='A!%)' //2
set Bonus___bo[144]='A!%*' //3
set Bonus___bo[145]='A!%+' //4
set Bonus___bo[146]='A!%-' //5
set Bonus___bo[147]='A!%.' //6
set Bonus___bo[148]='A!%:' //7
set Bonus___bo[149]='A!%;' //8 
set Bonus___bo[150]='A!%<' //0
set Bonus___bo[151]='A!%=' //1
set Bonus___bo[152]='A!%>' //2
set Bonus___bo[153]='A!%?' //3
set Bonus___bo[154]='A!%@' //4
set Bonus___bo[155]='A!%[' //5
set Bonus___bo[156]='A!%]' //6
set Bonus___bo[157]='A!%^' //7
set Bonus___bo[158]='A!%_' //8
set Bonus___bo[159]='A!%{' //9
set Bonus___bo[160]='A!%|' //10
set Bonus___bo[161]='A!%}' //0
set Bonus___bo[162]='A!%~' //1
set Bonus___bo[163]='A!&!' //2
set Bonus___bo[164]='A!&"' //3
set Bonus___bo[165]='A!&#' //4
set Bonus___bo[166]='A!&$' //5
set Bonus___bo[167]='A!&%' //6
set Bonus___bo[168]='A!&&' //7
set Bonus___bo[169]='A!&(' //8
set Bonus___pm[0]=13
set Bonus___pm[14]=23
set Bonus___pm[38]=18
set Bonus___pm[57]=18
set Bonus___pm[76]=18
set Bonus___pm[95]=25
set Bonus___pm[122]=15
set Bonus___pm[138]=1
set Bonus___pm[141]=8
set Bonus___pm[150]=10
set Bonus___pm[161]=8
set Bonus___ps[0]=1
set Bonus___bp[0]=0
set Bonus___ps[1]=2
set Bonus___bp[1]=1
set Bonus___ps[2]=4
set Bonus___bp[2]=2
set Bonus___ps[3]=8
set Bonus___bp[3]=3
set Bonus___ps[4]=16
set Bonus___bp[4]=4
set Bonus___ps[5]=32
set Bonus___bp[5]=5
set Bonus___ps[6]=64
set Bonus___bp[6]=6
set Bonus___ps[7]=128
set Bonus___bp[7]=7
set Bonus___ps[8]=256
set Bonus___bp[8]=8
set Bonus___ps[9]=512
set Bonus___bp[9]=9
set Bonus___ps[10]=1024
set Bonus___bp[10]=10
set Bonus___ps[11]=2048
set Bonus___bp[11]=11
set Bonus___ps[12]=4096
set Bonus___bp[12]=12
set Bonus___ps[13]=- 8192
set Bonus___bp[13]=- 13
set Bonus___ps[14]=1
set Bonus___bp[14]=0
set Bonus___ps[15]=2
set Bonus___bp[15]=1
set Bonus___ps[16]=4
set Bonus___bp[16]=2
set Bonus___ps[17]=8
set Bonus___bp[17]=3
set Bonus___ps[18]=16
set Bonus___bp[18]=4
set Bonus___ps[19]=32
set Bonus___bp[19]=5
set Bonus___ps[20]=64
set Bonus___bp[20]=6
set Bonus___ps[21]=128
set Bonus___bp[21]=7
set Bonus___ps[22]=256
set Bonus___bp[22]=8
set Bonus___ps[23]=512
set Bonus___bp[23]=9
set Bonus___ps[24]=1024
set Bonus___bp[24]=10
set Bonus___ps[25]=2048
set Bonus___bp[25]=11
set Bonus___ps[26]=4096
set Bonus___bp[26]=12
set Bonus___ps[27]=8192
set Bonus___bp[27]=13
set Bonus___ps[28]=16384
set Bonus___bp[28]=14
set Bonus___ps[29]=32768
set Bonus___bp[29]=15
set Bonus___ps[30]=65536
set Bonus___bp[30]=16
set Bonus___ps[31]=131072
set Bonus___bp[31]=17
set Bonus___ps[32]=262144
set Bonus___bp[32]=18
set Bonus___ps[33]=524288
set Bonus___bp[33]=19
set Bonus___ps[34]=1048576
set Bonus___bp[34]=20
set Bonus___ps[35]=2097152
set Bonus___bp[35]=21
set Bonus___ps[36]=4194304
set Bonus___bp[36]=22
set Bonus___ps[37]=- 8388608
set Bonus___bp[37]=- 23
set Bonus___ps[38]=1
set Bonus___bp[38]=0
set Bonus___ps[39]=2
set Bonus___bp[39]=1
set Bonus___ps[40]=4
set Bonus___bp[40]=2
set Bonus___ps[41]=8
set Bonus___bp[41]=3
set Bonus___ps[42]=16
set Bonus___bp[42]=4
set Bonus___ps[43]=32
set Bonus___bp[43]=5
set Bonus___ps[44]=64
set Bonus___bp[44]=6
set Bonus___ps[45]=128
set Bonus___bp[45]=7
set Bonus___ps[46]=256
set Bonus___bp[46]=8
set Bonus___ps[47]=512
set Bonus___bp[47]=9
set Bonus___ps[48]=1024
set Bonus___bp[48]=10
set Bonus___ps[49]=2048
set Bonus___bp[49]=11
set Bonus___ps[50]=4096
set Bonus___bp[50]=12
set Bonus___ps[51]=8192
set Bonus___bp[51]=13
set Bonus___ps[52]=16384
set Bonus___bp[52]=14
set Bonus___ps[53]=32768
set Bonus___bp[53]=15
set Bonus___ps[54]=65536
set Bonus___bp[54]=16
set Bonus___ps[55]=131072
set Bonus___bp[55]=17
set Bonus___ps[56]=- 262144
set Bonus___bp[56]=- 18
set Bonus___ps[57]=1
set Bonus___bp[57]=0
set Bonus___ps[58]=2
set Bonus___bp[58]=1
set Bonus___ps[59]=4
set Bonus___bp[59]=2
set Bonus___ps[60]=8
set Bonus___bp[60]=3
set Bonus___ps[61]=16
set Bonus___bp[61]=4
set Bonus___ps[62]=32
set Bonus___bp[62]=5
set Bonus___ps[63]=64
set Bonus___bp[63]=6
set Bonus___ps[64]=128
set Bonus___bp[64]=7
set Bonus___ps[65]=256
set Bonus___bp[65]=8
set Bonus___ps[66]=512
set Bonus___bp[66]=9
set Bonus___ps[67]=1024
set Bonus___bp[67]=10
set Bonus___ps[68]=2048
set Bonus___bp[68]=11
set Bonus___ps[69]=4096
set Bonus___bp[69]=12
set Bonus___ps[70]=8192
set Bonus___bp[70]=13
set Bonus___ps[71]=16384
set Bonus___bp[71]=14
set Bonus___ps[72]=32768
set Bonus___bp[72]=15
set Bonus___ps[73]=65536
set Bonus___bp[73]=16
set Bonus___ps[74]=131072
set Bonus___bp[74]=17
set Bonus___ps[75]=- 262144
set Bonus___bp[75]=- 18
set Bonus___ps[76]=1
set Bonus___bp[76]=0
set Bonus___ps[77]=2
set Bonus___bp[77]=1
set Bonus___ps[78]=4
set Bonus___bp[78]=2
set Bonus___ps[79]=8
set Bonus___bp[79]=3
set Bonus___ps[80]=16
set Bonus___bp[80]=4
set Bonus___ps[81]=32
set Bonus___bp[81]=5
set Bonus___ps[82]=64
set Bonus___bp[82]=6
set Bonus___ps[83]=128
set Bonus___bp[83]=7
set Bonus___ps[84]=256
set Bonus___bp[84]=8
set Bonus___ps[85]=512
set Bonus___bp[85]=9
set Bonus___ps[86]=1024
set Bonus___bp[86]=10
set Bonus___ps[87]=2048
set Bonus___bp[87]=11
set Bonus___ps[88]=4096
set Bonus___bp[88]=12
set Bonus___ps[89]=8192
set Bonus___bp[89]=13
set Bonus___ps[90]=16384
set Bonus___bp[90]=14
set Bonus___ps[91]=32768
set Bonus___bp[91]=15
set Bonus___ps[92]=65536
set Bonus___bp[92]=16
set Bonus___ps[93]=131072
set Bonus___bp[93]=17
set Bonus___ps[94]=- 262144
set Bonus___bp[94]=- 18
set Bonus___ps[95]=0
set Bonus___ps[96]=1
set Bonus___bp[96]=0
set Bonus___ps[97]=2
set Bonus___bp[97]=1
set Bonus___ps[98]=4
set Bonus___bp[98]=2
set Bonus___ps[99]=8
set Bonus___bp[99]=3
set Bonus___ps[100]=16
set Bonus___bp[100]=4
set Bonus___ps[101]=32
set Bonus___bp[101]=5
set Bonus___ps[102]=64
set Bonus___bp[102]=6
set Bonus___ps[103]=128
set Bonus___bp[103]=7
set Bonus___ps[104]=256
set Bonus___bp[104]=8
set Bonus___ps[105]=512
set Bonus___bp[105]=9
set Bonus___ps[106]=1024
set Bonus___bp[106]=10
set Bonus___ps[107]=2048
set Bonus___bp[107]=11
set Bonus___ps[108]=4096
set Bonus___bp[108]=12
set Bonus___ps[109]=8192
set Bonus___bp[109]=13
set Bonus___ps[110]=16384
set Bonus___bp[110]=14
set Bonus___ps[111]=32768
set Bonus___bp[111]=15
set Bonus___ps[112]=65536
set Bonus___bp[112]=16
set Bonus___ps[113]=131072
set Bonus___bp[113]=17
set Bonus___ps[114]=262144
set Bonus___bp[114]=18
set Bonus___ps[115]=524288
set Bonus___bp[115]=19
set Bonus___ps[116]=1048576
set Bonus___bp[116]=20
set Bonus___ps[117]=2097152
set Bonus___bp[117]=21
set Bonus___ps[118]=4194304
set Bonus___bp[118]=22
set Bonus___ps[119]=8388608
set Bonus___bp[119]=23
set Bonus___ps[120]=16777216
set Bonus___bp[120]=24
set Bonus___ps[121]=- 33554432
set Bonus___bp[121]=- 25
set Bonus___ps[122]=1
set Bonus___bp[122]=0
set Bonus___ps[123]=2
set Bonus___bp[123]=1
set Bonus___ps[124]=4
set Bonus___bp[124]=2
set Bonus___ps[125]=8
set Bonus___bp[125]=3
set Bonus___ps[126]=16
set Bonus___bp[126]=4
set Bonus___ps[127]=32
set Bonus___bp[127]=5
set Bonus___ps[128]=64
set Bonus___bp[128]=6
set Bonus___ps[129]=128
set Bonus___bp[129]=7
set Bonus___ps[130]=256
set Bonus___bp[130]=8
set Bonus___ps[131]=512
set Bonus___bp[131]=9
set Bonus___ps[132]=1024
set Bonus___bp[132]=10
set Bonus___ps[133]=2048
set Bonus___bp[133]=11
set Bonus___ps[134]=4096
set Bonus___bp[134]=12
set Bonus___ps[135]=8192
set Bonus___bp[135]=13
set Bonus___ps[136]=16384
set Bonus___bp[136]=14
set Bonus___ps[137]=- 32768
set Bonus___bp[137]=- 15
set Bonus___ps[138]=0
set Bonus___ps[139]=1
set Bonus___bp[139]=0
set Bonus___ps[140]=- 2
set Bonus___bp[140]=- 1
set Bonus___ps[141]=1
set Bonus___bp[141]=0
set Bonus___ps[142]=2
set Bonus___bp[142]=1
set Bonus___ps[143]=4
set Bonus___bp[143]=2
set Bonus___ps[144]=8
set Bonus___bp[144]=3
set Bonus___ps[145]=16
set Bonus___bp[145]=4
set Bonus___ps[146]=32
set Bonus___bp[146]=5
set Bonus___ps[147]=64
set Bonus___bp[147]=6
set Bonus___ps[148]=128
set Bonus___bp[148]=7
set Bonus___ps[149]=- 256
set Bonus___bp[149]=- 8
set Bonus___ps[150]=1
set Bonus___bp[150]=0
set Bonus___ps[151]=2
set Bonus___bp[151]=1
set Bonus___ps[152]=4
set Bonus___bp[152]=2
set Bonus___ps[153]=8
set Bonus___bp[153]=3
set Bonus___ps[154]=16
set Bonus___bp[154]=4
set Bonus___ps[155]=32
set Bonus___bp[155]=5
set Bonus___ps[156]=64
set Bonus___bp[156]=6
set Bonus___ps[157]=128
set Bonus___bp[157]=7
set Bonus___ps[158]=256
set Bonus___bp[158]=8
set Bonus___ps[159]=512
set Bonus___bp[159]=9
set Bonus___ps[160]=- 1024
set Bonus___bp[160]=- 10
set Bonus___ps[161]=1
set Bonus___bp[161]=0
set Bonus___ps[162]=2
set Bonus___bp[162]=1
set Bonus___ps[163]=4
set Bonus___bp[163]=2
set Bonus___ps[164]=8
set Bonus___bp[164]=3
set Bonus___ps[165]=16
set Bonus___bp[165]=4
set Bonus___ps[166]=32
set Bonus___bp[166]=5
set Bonus___ps[167]=64
set Bonus___bp[167]=6
set Bonus___ps[168]=128
set Bonus___bp[168]=7
set Bonus___ps[169]=- 256
set Bonus___bp[169]=- 8
set Bonus___ir[0]=true
set Bonus___ir[14]=true
set Bonus___ir[38]=true
set Bonus___ir[57]=true
set Bonus___ir[76]=true
set Bonus___ir[95]=false
set Bonus___ir[122]=true
set Bonus___ir[138]=false
set Bonus___ir[141]=true
set Bonus___ir[150]=true
set Bonus___ir[161]=true
endfunction
//end of: BONUS_SCRIPT()
    function SetUnitBonus takes unit u,integer b,integer v returns nothing
        local boolean n
        local integer a
        local integer p
        local integer on
        local integer i
        local integer nch
        local integer nb
        set i=GetUnitUserData(u)
        if ( v != (LoadInteger(Table___ht, (Bonus___cb[i]), (b))) ) then // INLINED!!
            set nch=0
            if ( Bonus___ir[b] ) then
                set n=0 > v
                call SaveInteger(Table___ht, (Bonus___cb[i]), (b), ( v)) // INLINED!!
                set p=b + Bonus___pm[b] - 1
                set on=p + 1
                call UnitRemoveAbility(u, Bonus___bo[on])
                if ( n ) then
                    set v=v - Bonus___ps[on]
                endif
                loop
                    if ( 0 > v - Bonus___ps[p] ) then
                        call UnitRemoveAbility(u, Bonus___bo[p])
                    else
                        call UnitAddAbility(u, Bonus___bo[p])
                        call UnitMakeAbilityPermanent(u, true, Bonus___bo[p])
                        set v=v - Bonus___ps[p]
                    endif
                    exitwhen p == b
                    set p=p - 1
                endloop
                if ( n ) then
                    call UnitAddAbility(u, Bonus___bo[on])
                    call UnitMakeAbilityPermanent(u, true, Bonus___bo[on])
                endif
            else
                set nb=v
                set v=v - (LoadInteger(Table___ht, (Bonus___cb[i]), (b))) // INLINED!!
                call SaveInteger(Table___ht, (Bonus___cb[i]), (b), ( nb)) // INLINED!!
                set a=Bonus___bo[b]
                set on=b + Bonus___pm[b] + 1
                loop
                    loop
                        exitwhen 0 < v
                        set v=v - Bonus___ps[on]
                        set nch=nch + 1
                    endloop
                    set p=b + Bonus___pm[b]
                    loop
                        if ( 0 <= v - Bonus___ps[p] ) then
                            set v=v - Bonus___ps[p]
                            call UnitAddAbility(u, a)
                            call SetUnitAbilityLevel(u, a, Bonus___bp[p] + 2)
                            call UnitRemoveAbility(u, a)
                        else
                            set p=p - 1
                            exitwhen p == b
                        endif
                    endloop
                    exitwhen 0 == v
                endloop
                loop
                    exitwhen 0 == nch
                    set nch=nch - 1
                    call UnitAddAbility(u, a)
                    call SetUnitAbilityLevel(u, a, ( - Bonus___bp[on] ) + 2)
                    call UnitRemoveAbility(u, a)
                endloop
            endif
        endif
    endfunction
    function GetUnitBonus takes unit u,integer b returns integer
        return (LoadInteger(Table___ht, (Bonus___cb[GetUnitUserData(u)]), (b))) // INLINED!!
    endfunction
    function AddUnitBonus takes unit u,integer b,integer v returns nothing
        call SetUnitBonus(u , b , (LoadInteger(Table___ht, (Bonus___cb[GetUnitUserData((u ))]), (( b)))) + v) // INLINED!!
    endfunction
    function RemoveUnitBonus takes unit u,integer b,integer v returns nothing
        call SetUnitBonus(u , b , (LoadInteger(Table___ht, (Bonus___cb[GetUnitUserData((u ))]), (( b)))) - v) // INLINED!!
    endfunction

//library Bonus ends
//library GameStart:
    
    function IsGameStarted takes nothing returns boolean
        return GameStart__gameStarted
    endfunction
    function WaitForGameToStart takes nothing returns nothing
        loop
            exitwhen GameStart__gameStarted
            call TriggerSyncStart()
            call TriggerSyncReady()
        endloop
    endfunction
    
        function s__GameStart__Init_run takes nothing returns nothing
            local integer thread= s__Thread_create()
            call s__Thread_sync(thread)
            call s__Thread_wait(thread)
            call s__Thread_destroy(thread)
            set GameStart__gameStarted=true
        endfunction
        function s__GameStart__Init_init takes nothing returns nothing
            call TriggerExecute(st__GameStart__Init_run) // INLINED!!
        endfunction
//Implemented from module GameStart__InitMod:
        function s__GameStart__Init_GameStart__InitMod___onInit takes nothing returns nothing
            call TriggerExecute(st__GameStart__Init_run) // INLINED!!
        endfunction

//library GameStart ends
//library GetLearnedAbilities:
    function GetLearnedAbilities__Index takes nothing returns boolean
        call SaveInteger(Table___ht, (GetLearnedAbilities__abils), ((UnitIndexer___o)), ( s__Table_create())) // INLINED!!
        call SaveInteger(Table___ht, (GetLearnedAbilities__marked), ((UnitIndexer___o)), ( s__Table_create())) // INLINED!!
        return false
    endfunction
    function GetLearnedAbilities__Deindex takes nothing returns boolean
        call s__Table_destroy(((LoadInteger(Table___ht, (GetLearnedAbilities__abils), ((UnitIndexer___o)))))) // INLINED!!
        call s__Table_destroy(((LoadInteger(Table___ht, (GetLearnedAbilities__marked), ((UnitIndexer___o)))))) // INLINED!!
        set GetLearnedAbilities__c[(UnitIndexer___o)]=0 // INLINED!!
        return false
    endfunction
    function GetLearnedAbilities__Ability takes nothing returns boolean
        local integer i= GetUnitUserData(GetTriggerUnit())
        if ( 0 != i and not (HaveSavedBoolean(Table___ht, (((((LoadInteger(Table___ht, (GetLearnedAbilities__marked), (i))))))), (GetLearnedSkill()))) ) then // INLINED!!
            call SaveInteger(Table___ht, (((LoadInteger(Table___ht, (GetLearnedAbilities__abils), (i))))), (GetLearnedAbilities__c[i]), ( GetLearnedSkill())) // INLINED!!
            call SaveBoolean(Table___ht, (((((LoadInteger(Table___ht, (GetLearnedAbilities__marked), (i))))))), (GetLearnedSkill()), ( true)) // INLINED!!
            set GetLearnedAbilities__c[i]=GetLearnedAbilities__c[i] + 1
        endif
        return false
    endfunction
        function s__LearnedAbilities__staticgetindex takes unit u returns integer
            return GetUnitUserData(u)
        endfunction
function s__LearnedAbilities__getindex takes integer this,integer l__index returns integer
            return (LoadInteger(Table___ht, (((LoadInteger(Table___ht, (GetLearnedAbilities__abils), (this))))), (l__index))) // INLINED!!
        endfunction
        function s__LearnedAbilities__get_count takes integer this returns integer
            local integer i=GetLearnedAbilities__c[this]
            local integer m
            loop
                exitwhen 0 == i
                set i=i - 1
                set m=(LoadInteger(Table___ht, (((LoadInteger(Table___ht, (GetLearnedAbilities__abils), (this))))), (i))) // INLINED!!
                if ( 0 == GetUnitAbilityLevel((UnitIndexer___e[(this)]), m) ) then // INLINED!!
                    call RemoveSavedInteger(Table___ht, (((LoadInteger(Table___ht, (GetLearnedAbilities__marked), (this))))), (m)) // INLINED!!
                    set GetLearnedAbilities__c[this]=GetLearnedAbilities__c[this] - 1
                    call SaveInteger(Table___ht, (((LoadInteger(Table___ht, (GetLearnedAbilities__abils), (this))))), (i), ( (LoadInteger(Table___ht, (((LoadInteger(Table___ht, (GetLearnedAbilities__abils), (this))))), (GetLearnedAbilities__c[this]))))) // INLINED!!
                    call RemoveSavedInteger(Table___ht, (((LoadInteger(Table___ht, (GetLearnedAbilities__abils), (this))))), (GetLearnedAbilities__c[this])) // INLINED!!
                endif
            endloop
            return GetLearnedAbilities__c[this]
        endfunction
//Implemented from module GetLearnedAbilities__M:
        function s__LearnedAbilities_GetLearnedAbilities__M___onInit takes nothing returns nothing
            local integer i=15
            local trigger t=CreateTrigger()
            call TriggerAddCondition(t, Condition(function GetLearnedAbilities__Ability))
            set GetLearnedAbilities__abils=s__Table_create()
            set GetLearnedAbilities__marked=s__Table_create()
            call RegisterUnitIndexEvent(Condition(function GetLearnedAbilities__Index) , s__UnitIndexer_INDEX)
            call RegisterUnitIndexEvent(Condition(function GetLearnedAbilities__Deindex) , s__UnitIndexer_DEINDEX)
            loop
                call TriggerRegisterPlayerUnitEvent(t, Player(i), EVENT_PLAYER_HERO_SKILL, null)
                exitwhen 0 == i
                set i=i - 1
            endloop
        endfunction

//library GetLearnedAbilities ends
//library LevelTree:
        function s__LevelTree_lessThan takes integer this,integer val returns boolean
            return (this) < (val)
        endfunction
        function s__LevelTree_greaterThan takes integer this,integer val returns boolean
            return (this) > (val)
        endfunction
        
//Implemented from module AVL:
        function s__LevelTree__get_tree takes integer this returns integer
            return s__LevelTree_AVL___ro[this]
        endfunction
        function s__LevelTree__get_root takes integer this returns integer
            return s__LevelTree_AVL___p[this]
        endfunction
        function s__LevelTree__get_down takes integer this returns integer
            return s__LevelTree_AVL___b[this]
        endfunction
        function s__LevelTree__get_left takes integer this returns integer
            return s__LevelTree_AVL___l[this]
        endfunction
        function s__LevelTree__get_right takes integer this returns integer
            return s__LevelTree_AVL___r[this]
        endfunction
        function s__LevelTree__get_value takes integer this returns integer
            return s__LevelTree_AVL___v[this]
        endfunction
        function s__LevelTree__get_next takes integer this returns integer
            return s__LevelTree_AVL___nn[this]
        endfunction
        function s__LevelTree__get_prev takes integer this returns integer
            return s__LevelTree_AVL___pn[this]
        endfunction
        function s__LevelTree__get_head takes integer this returns boolean
            return 0 == s__LevelTree_AVL___p[this]
        endfunction
        function s__LevelTree_AVL___getHeight takes integer this returns integer
            //return the bigger leaf height
            if ( s__LevelTree_AVL___h[s__LevelTree_AVL___l[this]] > s__LevelTree_AVL___h[s__LevelTree_AVL___r[this]] ) then
                return s__LevelTree_AVL___h[s__LevelTree_AVL___l[this]] + 1
            endif
            return s__LevelTree_AVL___h[s__LevelTree_AVL___r[this]] + 1
        endfunction
        function s__LevelTree_AVL___updateParent takes integer this,integer n returns nothing
            //only update the parent of a target leaf if that leaf isn't the original leaf
            if ( n != this ) then
                //update the parent point to
                //first leaf
                if ( 0 == s__LevelTree_AVL___p[s__LevelTree_AVL___p[this]] ) then
                    set s__LevelTree_AVL___b[s__LevelTree_AVL___p[this]]=n
                //left
                elseif ( s__LevelTree_AVL___l[s__LevelTree_AVL___p[this]] == this ) then
                    set s__LevelTree_AVL___l[s__LevelTree_AVL___p[this]]=n
                //right
                else
                    set s__LevelTree_AVL___r[s__LevelTree_AVL___p[this]]=n
                endif
                
                //update the leaf point back
                //if the leaf isn't null, update the leaf's parent
                if ( 0 != n ) then
                    set s__LevelTree_AVL___p[n]=s__LevelTree_AVL___p[this]
                endif
            endif
        endfunction
        function s__LevelTree_AVL___finishRotate takes integer this,integer n returns nothing
            //this code is identical in rotateLeft and rotateRight, so it has
            //been abstracted to a method
            call s__LevelTree_AVL___updateParent(this,n)
            set s__LevelTree_AVL___p[this]=n
            set s__LevelTree_AVL___h[this]=s__LevelTree_AVL___getHeight(this)
            set s__LevelTree_AVL___h[n]=s__LevelTree_AVL___getHeight(n)
        endfunction
        function s__LevelTree_AVL___rotateLeft takes integer this returns integer
            local integer n=s__LevelTree_AVL___r[this]
            set s__LevelTree_AVL___r[this]=s__LevelTree_AVL___l[n]
            set s__LevelTree_AVL___p[s__LevelTree_AVL___l[n]]=this
            set s__LevelTree_AVL___l[n]=this
            call s__LevelTree_AVL___finishRotate(this,n)
            return n
        endfunction
        function s__LevelTree_AVL___rotateRight takes integer this returns integer
            local integer n=s__LevelTree_AVL___l[this]
            set s__LevelTree_AVL___l[this]=s__LevelTree_AVL___r[n]
            set s__LevelTree_AVL___p[s__LevelTree_AVL___r[n]]=this
            set s__LevelTree_AVL___r[n]=this
            call s__LevelTree_AVL___finishRotate(this,n)
            return n
        endfunction
        //return the difference between the left and right leaf heights
        function s__LevelTree_AVL___getBalanceFactor takes integer this returns integer
            return s__LevelTree_AVL___h[s__LevelTree_AVL___l[this]] - s__LevelTree_AVL___h[s__LevelTree_AVL___r[this]]
        endfunction
        function s__LevelTree_AVL___allocate takes nothing returns integer
            local integer n
            if ( 0 == s__LevelTree_AVL___nn[0] ) then
                set n=s__LevelTree_AVL___c + 1
                set s__LevelTree_AVL___c=n
            else
                set n=s__LevelTree_AVL___nn[0] //notice that the recycler uses the next pointer
                                //the reason it is used is for fast clear/destroy and to save
                                //a variable
                set s__LevelTree_AVL___nn[0]=s__LevelTree_AVL___nn[n]
            endif
            set s__LevelTree_AVL___l[n]=0 //left leaf
            set s__LevelTree_AVL___r[n]=0 //right leaf
            set s__LevelTree_AVL___b[n]=0 //down leaf (first node of tree)
            set s__LevelTree_AVL___h[n]=1 //height (a node will always have at least a height of 1 for itself)
            return n
        endfunction
        function s__LevelTree_create takes nothing returns integer
            local integer n=s__LevelTree_AVL___allocate()
            set s__LevelTree_AVL___p[n]=0 //the parent of the tree node is 0
            
            //initialize tree next and prev
            set s__LevelTree_AVL___nn[n]=n
            set s__LevelTree_AVL___pn[n]=n
            
            //tree value table for O(1) searches on specific values
            set s__LevelTree_AVL___table[n]=s__Table_create()
            
            //tree root is itself (allows one to pass any node from the tree into the methods)
            set s__LevelTree_AVL___ro[n]=n
            
            return n
        endfunction
        //balance from the current node up to the root O(log n)
        //balancing is rotations wherever rotations need to be done
        function s__LevelTree_AVL___balance takes integer this returns nothing
            local integer f
            loop
                exitwhen 0 == s__LevelTree_AVL___p[this]
                set s__LevelTree_AVL___h[this]=s__LevelTree_AVL___getHeight(this)
                set f=s__LevelTree_AVL___getBalanceFactor(this)
                if ( 2 == f ) then
                    if ( - 1 == s__LevelTree_AVL___getBalanceFactor(s__LevelTree_AVL___l[this]) ) then
                        call s__LevelTree_AVL___rotateLeft(s__LevelTree_AVL___l[this])
                    endif
                    set this=s__LevelTree_AVL___rotateRight(this)
                    return
                elseif ( - 2 == f ) then
                    if ( 1 == s__LevelTree_AVL___getBalanceFactor(s__LevelTree_AVL___r[this]) ) then
                        call s__LevelTree_AVL___rotateRight(s__LevelTree_AVL___r[this])
                    endif
                    set this=s__LevelTree_AVL___rotateLeft(this)
                    return
                endif
                set this=s__LevelTree_AVL___p[this]
            endloop
        endfunction
        //goes to the very bottom of a node (for deletion)
        function s__LevelTree_AVL___getBottom takes integer this returns integer
            if ( 0 != s__LevelTree_AVL___r[this] ) then
                if ( 0 != s__LevelTree_AVL___l[this] ) then
                    set this=s__LevelTree_AVL___r[this]
                    loop
                        exitwhen 0 == s__LevelTree_AVL___l[this]
                        set this=s__LevelTree_AVL___l[this]
                    endloop
                    return this
                else
                    return s__LevelTree_AVL___r[this]
                endif
            elseif ( 0 != s__LevelTree_AVL___l[this] ) then
                return s__LevelTree_AVL___l[this]
            endif
            return this
        endfunction
        function s__LevelTree_search takes integer this,integer val returns integer
            return (LoadInteger(Table___ht, (s__LevelTree_AVL___table[s__LevelTree_AVL___ro[this]]), (val))) // INLINED!!
        endfunction
        function s__LevelTree_has takes integer this,integer val returns boolean
            return (HaveSavedInteger(Table___ht, (s__LevelTree_AVL___table[s__LevelTree_AVL___ro[this]]), (val))) // INLINED!!
        endfunction
        function s__LevelTree_searchClose takes integer this,integer val,boolean low returns integer
            local integer n
            
            //retrieve tree
            set this=s__LevelTree_AVL___ro[this]
            
            //if tree is empty, return 0
            if ( 0 == s__LevelTree_AVL___b[this] ) then
                return 0
            endif
            
            //check to see if the node exists in the tree and return it if it does
            set n=(LoadInteger(Table___ht, (s__LevelTree_AVL___table[this]), (val))) // INLINED!!
            if ( 0 != n ) then
                return n
            endif
            
            //perform a standard tree search for the value to the bottom of the tree
            //will always be at most 1 off from the best match
            set this=s__LevelTree_AVL___b[this]
            loop
                if ( (((val)) < ((s__LevelTree_AVL___v[this]))) ) then // INLINED!!
                    exitwhen 0 == s__LevelTree_AVL___l[this]
                    set this=s__LevelTree_AVL___l[this]
                else
                    exitwhen 0 == s__LevelTree_AVL___r[this]
                    set this=s__LevelTree_AVL___r[this]
                endif
            endloop
            
            //look at the found value's neighbors on the linked list
            if ( low ) then
                //shift down if greater than
                if ( (((s__LevelTree_AVL___v[this])) > ((val))) ) then // INLINED!!
                    set this=(s__LevelTree_AVL___pn[(this)]) // INLINED!!
                endif
                //return 0 if node wasn't found
                if ( 0 == s__LevelTree_AVL___p[this] or (((s__LevelTree_AVL___v[this])) > ((val))) ) then // INLINED!!
                    return 0
                endif
            else
                //shift up if less than
                if ( (((s__LevelTree_AVL___v[this])) < ((val))) ) then // INLINED!!
                    set this=(s__LevelTree_AVL___nn[(this)]) // INLINED!!
                endif
                //return 0 if node wasn't found
                if ( 0 == s__LevelTree_AVL___p[this] or (((s__LevelTree_AVL___v[this])) < ((val))) ) then // INLINED!!
                    return 0
                endif
            endif
            
            return this
        endfunction
        function s__LevelTree_add takes integer this,integer val returns integer
            local integer n
            
            //check if the tree already has the value in it
            set this=s__LevelTree_AVL___ro[this]
            set n=(LoadInteger(Table___ht, (s__LevelTree_AVL___table[this]), (val))) // INLINED!!
            
            //if the tree doesn't have the value in it, add the value
            if ( 0 == n ) then
                set n=this
            
                set this=s__LevelTree_AVL___allocate()
                set s__LevelTree_AVL___ro[this]=n //store tree into leaf
                call SaveInteger(Table___ht, (s__LevelTree_AVL___table[n]), (val), ( this)) //store leaf into value table // INLINED!!
                set s__LevelTree_AVL___v[this]=val //store value into leaf
                
                //if the tree is empty
                if ( 0 == s__LevelTree_AVL___b[n] ) then
                    set s__LevelTree_AVL___b[n]=this //place as first node
                    set s__LevelTree_AVL___p[this]=n //parent of first node is tree
                    
                    //add to list
                    set s__LevelTree_AVL___nn[this]=n
                    set s__LevelTree_AVL___pn[this]=n
                    set s__LevelTree_AVL___nn[n]=this
                    set s__LevelTree_AVL___pn[n]=this
                else
                    //go to the first node in the tree
                    set n=s__LevelTree_AVL___b[n]
                    
                    //go to the bottom of the tree with search algorithm
                    loop
                        if ( (((val)) < ((s__LevelTree_AVL___v[n]))) ) then // INLINED!!
                            exitwhen 0 == s__LevelTree_AVL___l[n]
                            set n=s__LevelTree_AVL___l[n]
                        else
                            exitwhen 0 == s__LevelTree_AVL___r[n]
                            set n=s__LevelTree_AVL___r[n]
                        endif
                    endloop
                    
                    //add leaf to tree
                    set s__LevelTree_AVL___p[this]=n
                    if ( (((val)) < ((s__LevelTree_AVL___v[n]))) ) then // INLINED!!
                        set s__LevelTree_AVL___l[n]=this
                    else
                        set s__LevelTree_AVL___r[n]=this
                    endif
                    
                    //update the height of the parent
                    set s__LevelTree_AVL___h[n]=s__LevelTree_AVL___getHeight(n)
                    
                    //balance from the parent upwards
                    call s__LevelTree_AVL___balance(s__LevelTree_AVL___p[n])
                    
                    //add leaf to list
                    if ( (((s__LevelTree_AVL___v[n])) > ((s__LevelTree_AVL___v[this]))) ) then // INLINED!!
                        set n=s__LevelTree_AVL___pn[n]
                    endif
                    set s__LevelTree_AVL___nn[this]=s__LevelTree_AVL___nn[n]
                    set s__LevelTree_AVL___pn[this]=n
                    set s__LevelTree_AVL___pn[s__LevelTree_AVL___nn[n]]=this
                    set s__LevelTree_AVL___nn[n]=this
                endif
                return this
            endif
            return n
        endfunction
        function s__LevelTree_delete takes integer this returns nothing
            local integer n
            local integer y
            
            //if the leaf to be deleted isn't 0 and the leaf isn't the tree
            if ( 0 != this and 0 != s__LevelTree_AVL___p[this] ) then
                //remove the leaf from the value table
                call RemoveSavedInteger(Table___ht, (s__LevelTree_AVL___table[s__LevelTree_AVL___ro[this]]), (s__LevelTree_AVL___v[this])) // INLINED!!
                
                set n=s__LevelTree_AVL___getBottom(this) //retrieve the bottom leaf
                set y=s__LevelTree_AVL___p[n] //store the parent here for balancing later
                
                //move the found leaf into the deleted leaf's position
                call s__LevelTree_AVL___updateParent(n,0)
                call s__LevelTree_AVL___updateParent(this,n)
                if ( this != n ) then
                    set s__LevelTree_AVL___l[n]=s__LevelTree_AVL___l[this]
                    set s__LevelTree_AVL___p[s__LevelTree_AVL___l[n]]=n
                    set s__LevelTree_AVL___r[n]=s__LevelTree_AVL___r[this]
                    set s__LevelTree_AVL___p[s__LevelTree_AVL___r[n]]=n
                    set s__LevelTree_AVL___p[n]=s__LevelTree_AVL___p[this]
                    set s__LevelTree_AVL___h[n]=s__LevelTree_AVL___h[this]
                endif
                
                //balance from the found leaf's old parent upwards
                call s__LevelTree_AVL___balance(y)
                
                //remove deleted leaf from list
                set s__LevelTree_AVL___nn[s__LevelTree_AVL___pn[this]]=s__LevelTree_AVL___nn[this]
                set s__LevelTree_AVL___pn[s__LevelTree_AVL___nn[this]]=s__LevelTree_AVL___pn[this]
                set s__LevelTree_AVL___nn[this]=s__LevelTree_AVL___nn[0]
                set s__LevelTree_AVL___nn[0]=this
            endif
        endfunction
        function s__LevelTree_clear takes integer this returns integer
            //quick clear
            set this=s__LevelTree_AVL___ro[this]
            if ( s__LevelTree_AVL___nn[this] != this ) then
                set s__LevelTree_AVL___nn[s__LevelTree_AVL___pn[this]]=s__LevelTree_AVL___nn[0]
                set s__LevelTree_AVL___nn[0]=s__LevelTree_AVL___nn[this]
                set s__LevelTree_AVL___nn[this]=this
                set s__LevelTree_AVL___pn[this]=this
                set s__LevelTree_AVL___b[this]=0
                call FlushChildHashtable(Table___ht, (s__LevelTree_AVL___table[this])) // INLINED!!
            endif
            return this
        endfunction
        function s__LevelTree_destroy takes integer this returns nothing
            //quick destroy
            set this=s__LevelTree_AVL___ro[this]
            set s__LevelTree_AVL___nn[s__LevelTree_AVL___pn[this]]=s__LevelTree_AVL___nn[0]
            set s__LevelTree_AVL___nn[0]=this
            call s__Table_destroy(s__LevelTree_AVL___table[this])
        endfunction

//library LevelTree ends
//library LifeSaver:


    function ApplyMaxLife takes integer whichUnit returns nothing
        set LifeSaver___currentLife[whichUnit]=GetWidgetLife((UnitIndexer___e[(whichUnit)])) // INLINED!!
        
        set LifeSaver___scale=LifeSaver___currentLife[whichUnit] / GetUnitState((UnitIndexer___e[(whichUnit)]), UNIT_STATE_MAX_LIFE) // INLINED!!
        if ( LifeSaver___scale < .1 ) then
            set LifeSaver___scale=.1
        endif
    
        call UnitAddAbility((UnitIndexer___e[(whichUnit)]), LIFE_SAVER_ABILITY_ID) // INLINED!!
        call UnitMakeAbilityPermanent((UnitIndexer___e[(whichUnit)]), true, LIFE_SAVER_ABILITY_ID) // INLINED!!
        call SetWidgetLife((UnitIndexer___e[(whichUnit)]), GetUnitState((UnitIndexer___e[(whichUnit)]), UNIT_STATE_MAX_LIFE) * LifeSaver___scale) // INLINED!!
    endfunction
    function RemoveMaxLife takes integer whichUnit returns nothing
        call UnitRemoveAbility((UnitIndexer___e[(whichUnit)]), LIFE_SAVER_ABILITY_ID) // INLINED!!
        call SetWidgetLife((UnitIndexer___e[(whichUnit)]), LifeSaver___currentLife[whichUnit]) // INLINED!!
        set LifeSaver___currentLife[whichUnit]=- 1
    endfunction
    function GetUnitLife takes integer whichUnit returns real
        if ( LifeSaver___currentLife[whichUnit] == - 1 ) then
            return GetWidgetLife((UnitIndexer___e[(whichUnit)])) // INLINED!!
        endif
        return LifeSaver___currentLife[whichUnit]
    endfunction
    function AddUnitLife takes integer whichUnit,real r returns nothing
        call SetWidgetLife((UnitIndexer___e[(whichUnit)]), GetWidgetLife((UnitIndexer___e[(whichUnit)])) + r) // INLINED!!
    endfunction
    function AddUnitTargetLife takes integer whichUnit,real r returns nothing
        set LifeSaver___currentLife[whichUnit]=LifeSaver___currentLife[whichUnit] + r
    endfunction
    
    function LifeSaver___OnDeath takes nothing returns nothing
        call UnitRemoveAbility(GetTriggerUnit(), LIFE_SAVER_ABILITY_ID)
        set LifeSaver___currentLife[GetUnitUserData(GetTriggerUnit())]=- 1
    endfunction
    
    
        function s__LifeSaver___Index_init takes nothing returns nothing
            call RegisterPlayerUnitEvent(EVENT_PLAYER_UNIT_DEATH , function LifeSaver___OnDeath)
        endfunction
    
//Implemented from module LifeSaver___Init:
        function s__LifeSaver___Index_LifeSaver___Init___onInit takes nothing returns nothing
            call RegisterPlayerUnitEvent(EVENT_PLAYER_UNIT_DEATH , function LifeSaver___OnDeath) // INLINED!!
        endfunction
    
        function s__LifeSaver___Index_index takes integer this returns nothing
            set LifeSaver___currentLife[this]=- 1
        endfunction
        
//Implemented from module UnitIndexStruct:
        function s__LifeSaver___Index__staticgetindex takes unit u returns integer
            return GetUnitUserData(u)
        endfunction
        function s__LifeSaver___Index__get_unit takes integer this returns unit
            return UnitIndexer___e[this]
        endfunction
        


















                function s__LifeSaver___Index__get_allocated takes integer this returns boolean
                    return this == GetUnitUserData(UnitIndexer___e[this])
                endfunction







            function s__LifeSaver___Index_UnitIndexStruct___onIndexEvent takes nothing returns boolean











                    set LifeSaver___currentLife[((UnitIndexer___o))]=- 1 // INLINED!!

                return false
            endfunction






























                function s__LifeSaver___Index_UnitIndexStruct___onInit takes nothing returns nothing
                    call RegisterUnitIndexEvent(Condition(function s__LifeSaver___Index_UnitIndexStruct___onIndexEvent) , s__UnitIndexer_INDEX)
                endfunction







//library LifeSaver ends
//library MissileRecycler:
    //=======================================================================
    // Save the map, then delete the exclaimation mark in the following line.
    // Make sure that you don't have an object in your map with the rawcode
    // 'dumi' and also configure the model path (war3mapImported\dummy.mdl)
    // to the dummy.mdx model created by Vexorian.
    //Thanks to Vexorian that Optimizer 5.0 no longer kills natives











    //=======================================================================
    // Get a recycled dummy missile unit. If there are no recycled dummies
    // that are already facing the angle you need, it creates a new dummy for
    // you.
    //
    function GetRecycledMissile takes real x,real y,real z,real facing returns unit
        local integer i= ModuloInteger(R2I(facing), 360) / MissileRecycler___ANG_VAL
        local integer this= MissileRecycler___queueNext[i]
        local unit u
        if this != 0 and TimerGetElapsed(MissileRecycler___gameTime) >= MissileRecycler___timeStamp[this] then
            //Dequeue this
            set MissileRecycler___queueNext[i]=MissileRecycler___queueNext[this]
            if MissileRecycler___queueNext[i] == 0 then
                set MissileRecycler___queueLast[i]=i
            endif
            set MissileRecycler___stackN[i]=MissileRecycler___stackN[i] - 1
            //Recycle this index
            set MissileRecycler___queueLast[this]=MissileRecycler___recycle
            set MissileRecycler___recycle=this
            //Old unit will return as new
            set u=MissileRecycler___stack[this]
            call SetUnitFacing(u, facing)
            call GroupRemoveUnit(MissileRecycler___protect, u)
        else

                call s__UnitIndexer__set_enabled(false)

            set u=CreateUnit(MissileRecycler___OWNER, MissileRecycler___DUMMY_ID, x, y, facing)
            call SetUnitPathing(u, false)

                call s__UnitIndexer__set_enabled(true)

            call PauseUnit(u, true)
        endif
        call SetUnitX(u, x)
        call SetUnitY(u, y)
        call SetUnitFlyHeight(u, z, 0)
        set bj_lastCreatedUnit=u
        set u=null
        return bj_lastCreatedUnit
    endfunction

    //=======================================================================
    // You should recycle the dummy missile unit when its job is done.
    //
    function RecycleMissile takes unit u returns nothing
        local integer i
        local integer this= MissileRecycler___recycle
        if GetUnitTypeId(u) == MissileRecycler___DUMMY_ID and UnitAlive(u) and not IsUnitInGroup(u, MissileRecycler___protect) then
            if this == 0 then
                call RemoveUnit(u)
                return
            endif
            //Recycle this
            set MissileRecycler___recycle=MissileRecycler___queueLast[this]
            //Index the dummy unit to an available facing angle.
            set i=R2I(GetUnitFacing(u)) / MissileRecycler___ANG_VAL
            if MissileRecycler___stackN[i] < MissileRecycler___ANG_STORAGE_MAX then
                set i=MissileRecycler___ANG_N
                loop
                    set i=i - 1
                    exitwhen MissileRecycler___stackN[i] < MissileRecycler___ANG_STORAGE_MAX
                endloop
            endif
            //Enqueue this
            set MissileRecycler___queueNext[MissileRecycler___queueLast[i]]=this
            set MissileRecycler___queueLast[i]=this
            set MissileRecycler___queueNext[this]=0
            set MissileRecycler___stackN[i]=MissileRecycler___stackN[i] + 1
            //Allow a time barrier for the effect to destroy/turn to complete.
            set MissileRecycler___timeStamp[this]=TimerGetElapsed(MissileRecycler___gameTime) + MissileRecycler___DEATH_TIME
            set MissileRecycler___stack[this]=u
            //Prevent double-free of this unit.
            call GroupAddUnit(MissileRecycler___protect, u)
            //Reset the dummy's properties.
            call SetUnitFacing(u, i * MissileRecycler___ANG_VAL + MissileRecycler___ANG_MID)
            call SetUnitVertexColor(u, 255, 255, 255, 255)
            call SetUnitAnimationByIndex(u, 90)
            call SetUnitScale(u, 1, 0, 0)
            //call PauseUnit(u, false) -- you can disable "resets" that you don't need to worry about.
        endif
    endfunction

    //=======================================================================
    // Map the dummy units to their facing angles (map below is if ANG_N is
    // 4 and ANG_STORAGE_MAX is 3).
    //
    // angle[0] (0)   -  [4] [5] [6]
    // angle[1] (90)  -  [7] [8] [9]
    // angle[2] (180) - [10][11][12]
    // angle[3] (270) - [13][14][15]
    //
    function MissileRecycler___Init takes nothing returns nothing
        local integer end
        local integer i= MissileRecycler___ANG_N
        local integer n= i
        local integer angle
        local real x= GetRectMaxX(bj_mapInitialPlayableArea)
        local real y= GetRectMaxY(bj_mapInitialPlayableArea)

            call s__UnitIndexer__set_enabled(false)

        loop
            set i=i - 1
            set MissileRecycler___stackN[i]=MissileRecycler___ANG_STORAGE_MAX
            set MissileRecycler___queueNext[i]=n
            set angle=i * MissileRecycler___ANG_VAL + MissileRecycler___ANG_MID
            set end=n + MissileRecycler___ANG_STORAGE_MAX
            set MissileRecycler___queueLast[i]=end - 1
            loop
                set MissileRecycler___queueNext[n]=n + 1
                set MissileRecycler___stack[n]=CreateUnit(MissileRecycler___OWNER, MissileRecycler___DUMMY_ID, x, y, angle)
                call SetUnitPathing(MissileRecycler___stack[n], false)
                call PauseUnit(MissileRecycler___stack[n], true)
                set n=n + 1
                exitwhen n == end
            endloop
            set MissileRecycler___queueNext[n - 1]=0
            exitwhen i == 0
        endloop

            call s__UnitIndexer__set_enabled(true)

        call TimerStart(MissileRecycler___gameTime, 1000000., false, null)
    endfunction


//library MissileRecycler ends
//library PriorityEvent:
        function s__PriorityEvent___PriorityEventTree_lessThan takes integer this,integer value returns boolean
            return (this) < (value)
        endfunction
        
        function s__PriorityEvent___PriorityEventTree_greaterThan takes integer this,integer value returns boolean
            return (this) > (value)
        endfunction
        
//Implemented from module AVL:
        function s__PriorityEvent___PriorityEventTree__get_tree takes integer this returns integer
            return s__PriorityEvent___PriorityEventTree_AVL___ro[this]
        endfunction
        function s__PriorityEvent___PriorityEventTree__get_root takes integer this returns integer
            return s__PriorityEvent___PriorityEventTree_AVL___p[this]
        endfunction
        function s__PriorityEvent___PriorityEventTree__get_down takes integer this returns integer
            return s__PriorityEvent___PriorityEventTree_AVL___b[this]
        endfunction
        function s__PriorityEvent___PriorityEventTree__get_left takes integer this returns integer
            return s__PriorityEvent___PriorityEventTree_AVL___l[this]
        endfunction
        function s__PriorityEvent___PriorityEventTree__get_right takes integer this returns integer
            return s__PriorityEvent___PriorityEventTree_AVL___r[this]
        endfunction
        function s__PriorityEvent___PriorityEventTree__get_value takes integer this returns integer
            return s__PriorityEvent___PriorityEventTree_AVL___v[this]
        endfunction
        function s__PriorityEvent___PriorityEventTree__get_next takes integer this returns integer
            return s__PriorityEvent___PriorityEventTree_AVL___nn[this]
        endfunction
        function s__PriorityEvent___PriorityEventTree__get_prev takes integer this returns integer
            return s__PriorityEvent___PriorityEventTree_AVL___pn[this]
        endfunction
        function s__PriorityEvent___PriorityEventTree__get_head takes integer this returns boolean
            return 0 == s__PriorityEvent___PriorityEventTree_AVL___p[this]
        endfunction
        function s__PriorityEvent___PriorityEventTree_AVL___getHeight takes integer this returns integer
            //return the bigger leaf height
            if ( s__PriorityEvent___PriorityEventTree_AVL___h[s__PriorityEvent___PriorityEventTree_AVL___l[this]] > s__PriorityEvent___PriorityEventTree_AVL___h[s__PriorityEvent___PriorityEventTree_AVL___r[this]] ) then
                return s__PriorityEvent___PriorityEventTree_AVL___h[s__PriorityEvent___PriorityEventTree_AVL___l[this]] + 1
            endif
            return s__PriorityEvent___PriorityEventTree_AVL___h[s__PriorityEvent___PriorityEventTree_AVL___r[this]] + 1
        endfunction
        function s__PriorityEvent___PriorityEventTree_AVL___updateParent takes integer this,integer n returns nothing
            //only update the parent of a target leaf if that leaf isn't the original leaf
            if ( n != this ) then
                //update the parent point to
                //first leaf
                if ( 0 == s__PriorityEvent___PriorityEventTree_AVL___p[s__PriorityEvent___PriorityEventTree_AVL___p[this]] ) then
                    set s__PriorityEvent___PriorityEventTree_AVL___b[s__PriorityEvent___PriorityEventTree_AVL___p[this]]=n
                //left
                elseif ( s__PriorityEvent___PriorityEventTree_AVL___l[s__PriorityEvent___PriorityEventTree_AVL___p[this]] == this ) then
                    set s__PriorityEvent___PriorityEventTree_AVL___l[s__PriorityEvent___PriorityEventTree_AVL___p[this]]=n
                //right
                else
                    set s__PriorityEvent___PriorityEventTree_AVL___r[s__PriorityEvent___PriorityEventTree_AVL___p[this]]=n
                endif
                
                //update the leaf point back
                //if the leaf isn't null, update the leaf's parent
                if ( 0 != n ) then
                    set s__PriorityEvent___PriorityEventTree_AVL___p[n]=s__PriorityEvent___PriorityEventTree_AVL___p[this]
                endif
            endif
        endfunction
        function s__PriorityEvent___PriorityEventTree_AVL___finishRotate takes integer this,integer n returns nothing
            //this code is identical in rotateLeft and rotateRight, so it has
            //been abstracted to a method
            call s__PriorityEvent___PriorityEventTree_AVL___updateParent(this,n)
            set s__PriorityEvent___PriorityEventTree_AVL___p[this]=n
            set s__PriorityEvent___PriorityEventTree_AVL___h[this]=s__PriorityEvent___PriorityEventTree_AVL___getHeight(this)
            set s__PriorityEvent___PriorityEventTree_AVL___h[n]=s__PriorityEvent___PriorityEventTree_AVL___getHeight(n)
        endfunction
        function s__PriorityEvent___PriorityEventTree_AVL___rotateLeft takes integer this returns integer
            local integer n=s__PriorityEvent___PriorityEventTree_AVL___r[this]
            set s__PriorityEvent___PriorityEventTree_AVL___r[this]=s__PriorityEvent___PriorityEventTree_AVL___l[n]
            set s__PriorityEvent___PriorityEventTree_AVL___p[s__PriorityEvent___PriorityEventTree_AVL___l[n]]=this
            set s__PriorityEvent___PriorityEventTree_AVL___l[n]=this
            call s__PriorityEvent___PriorityEventTree_AVL___finishRotate(this,n)
            return n
        endfunction
        function s__PriorityEvent___PriorityEventTree_AVL___rotateRight takes integer this returns integer
            local integer n=s__PriorityEvent___PriorityEventTree_AVL___l[this]
            set s__PriorityEvent___PriorityEventTree_AVL___l[this]=s__PriorityEvent___PriorityEventTree_AVL___r[n]
            set s__PriorityEvent___PriorityEventTree_AVL___p[s__PriorityEvent___PriorityEventTree_AVL___r[n]]=this
            set s__PriorityEvent___PriorityEventTree_AVL___r[n]=this
            call s__PriorityEvent___PriorityEventTree_AVL___finishRotate(this,n)
            return n
        endfunction
        //return the difference between the left and right leaf heights
        function s__PriorityEvent___PriorityEventTree_AVL___getBalanceFactor takes integer this returns integer
            return s__PriorityEvent___PriorityEventTree_AVL___h[s__PriorityEvent___PriorityEventTree_AVL___l[this]] - s__PriorityEvent___PriorityEventTree_AVL___h[s__PriorityEvent___PriorityEventTree_AVL___r[this]]
        endfunction
        function s__PriorityEvent___PriorityEventTree_AVL___allocate takes nothing returns integer
            local integer n
            if ( 0 == s__PriorityEvent___PriorityEventTree_AVL___nn[0] ) then
                set n=s__PriorityEvent___PriorityEventTree_AVL___c + 1
                set s__PriorityEvent___PriorityEventTree_AVL___c=n
            else
                set n=s__PriorityEvent___PriorityEventTree_AVL___nn[0] //notice that the recycler uses the next pointer
                                //the reason it is used is for fast clear/destroy and to save
                                //a variable
                set s__PriorityEvent___PriorityEventTree_AVL___nn[0]=s__PriorityEvent___PriorityEventTree_AVL___nn[n]
            endif
            set s__PriorityEvent___PriorityEventTree_AVL___l[n]=0 //left leaf
            set s__PriorityEvent___PriorityEventTree_AVL___r[n]=0 //right leaf
            set s__PriorityEvent___PriorityEventTree_AVL___b[n]=0 //down leaf (first node of tree)
            set s__PriorityEvent___PriorityEventTree_AVL___h[n]=1 //height (a node will always have at least a height of 1 for itself)
            return n
        endfunction
        function s__PriorityEvent___PriorityEventTree_create takes nothing returns integer
            local integer n=s__PriorityEvent___PriorityEventTree_AVL___allocate()
            set s__PriorityEvent___PriorityEventTree_AVL___p[n]=0 //the parent of the tree node is 0
            
            //initialize tree next and prev
            set s__PriorityEvent___PriorityEventTree_AVL___nn[n]=n
            set s__PriorityEvent___PriorityEventTree_AVL___pn[n]=n
            
            //tree value table for O(1) searches on specific values
            set s__PriorityEvent___PriorityEventTree_AVL___table[n]=s__Table_create()
            
            //tree root is itself (allows one to pass any node from the tree into the methods)
            set s__PriorityEvent___PriorityEventTree_AVL___ro[n]=n
            
            return n
        endfunction
        //balance from the current node up to the root O(log n)
        //balancing is rotations wherever rotations need to be done
        function s__PriorityEvent___PriorityEventTree_AVL___balance takes integer this returns nothing
            local integer f
            loop
                exitwhen 0 == s__PriorityEvent___PriorityEventTree_AVL___p[this]
                set s__PriorityEvent___PriorityEventTree_AVL___h[this]=s__PriorityEvent___PriorityEventTree_AVL___getHeight(this)
                set f=s__PriorityEvent___PriorityEventTree_AVL___getBalanceFactor(this)
                if ( 2 == f ) then
                    if ( - 1 == s__PriorityEvent___PriorityEventTree_AVL___getBalanceFactor(s__PriorityEvent___PriorityEventTree_AVL___l[this]) ) then
                        call s__PriorityEvent___PriorityEventTree_AVL___rotateLeft(s__PriorityEvent___PriorityEventTree_AVL___l[this])
                    endif
                    set this=s__PriorityEvent___PriorityEventTree_AVL___rotateRight(this)
                    return
                elseif ( - 2 == f ) then
                    if ( 1 == s__PriorityEvent___PriorityEventTree_AVL___getBalanceFactor(s__PriorityEvent___PriorityEventTree_AVL___r[this]) ) then
                        call s__PriorityEvent___PriorityEventTree_AVL___rotateRight(s__PriorityEvent___PriorityEventTree_AVL___r[this])
                    endif
                    set this=s__PriorityEvent___PriorityEventTree_AVL___rotateLeft(this)
                    return
                endif
                set this=s__PriorityEvent___PriorityEventTree_AVL___p[this]
            endloop
        endfunction
        //goes to the very bottom of a node (for deletion)
        function s__PriorityEvent___PriorityEventTree_AVL___getBottom takes integer this returns integer
            if ( 0 != s__PriorityEvent___PriorityEventTree_AVL___r[this] ) then
                if ( 0 != s__PriorityEvent___PriorityEventTree_AVL___l[this] ) then
                    set this=s__PriorityEvent___PriorityEventTree_AVL___r[this]
                    loop
                        exitwhen 0 == s__PriorityEvent___PriorityEventTree_AVL___l[this]
                        set this=s__PriorityEvent___PriorityEventTree_AVL___l[this]
                    endloop
                    return this
                else
                    return s__PriorityEvent___PriorityEventTree_AVL___r[this]
                endif
            elseif ( 0 != s__PriorityEvent___PriorityEventTree_AVL___l[this] ) then
                return s__PriorityEvent___PriorityEventTree_AVL___l[this]
            endif
            return this
        endfunction
        function s__PriorityEvent___PriorityEventTree_search takes integer this,integer val returns integer
            return (LoadInteger(Table___ht, (s__PriorityEvent___PriorityEventTree_AVL___table[s__PriorityEvent___PriorityEventTree_AVL___ro[this]]), (val))) // INLINED!!
        endfunction
        function s__PriorityEvent___PriorityEventTree_has takes integer this,integer val returns boolean
            return (HaveSavedInteger(Table___ht, (s__PriorityEvent___PriorityEventTree_AVL___table[s__PriorityEvent___PriorityEventTree_AVL___ro[this]]), (val))) // INLINED!!
        endfunction
        function s__PriorityEvent___PriorityEventTree_searchClose takes integer this,integer val,boolean low returns integer
            local integer n
            
            //retrieve tree
            set this=s__PriorityEvent___PriorityEventTree_AVL___ro[this]
            
            //if tree is empty, return 0
            if ( 0 == s__PriorityEvent___PriorityEventTree_AVL___b[this] ) then
                return 0
            endif
            
            //check to see if the node exists in the tree and return it if it does
            set n=(LoadInteger(Table___ht, (s__PriorityEvent___PriorityEventTree_AVL___table[this]), (val))) // INLINED!!
            if ( 0 != n ) then
                return n
            endif
            
            //perform a standard tree search for the value to the bottom of the tree
            //will always be at most 1 off from the best match
            set this=s__PriorityEvent___PriorityEventTree_AVL___b[this]
            loop
                if ( (((val)) < ((s__PriorityEvent___PriorityEventTree_AVL___v[this]))) ) then // INLINED!!
                    exitwhen 0 == s__PriorityEvent___PriorityEventTree_AVL___l[this]
                    set this=s__PriorityEvent___PriorityEventTree_AVL___l[this]
                else
                    exitwhen 0 == s__PriorityEvent___PriorityEventTree_AVL___r[this]
                    set this=s__PriorityEvent___PriorityEventTree_AVL___r[this]
                endif
            endloop
            
            //look at the found value's neighbors on the linked list
            if ( low ) then
                //shift down if greater than
                if ( (((s__PriorityEvent___PriorityEventTree_AVL___v[this])) > ((val))) ) then // INLINED!!
                    set this=(s__PriorityEvent___PriorityEventTree_AVL___pn[(this)]) // INLINED!!
                endif
                //return 0 if node wasn't found
                if ( 0 == s__PriorityEvent___PriorityEventTree_AVL___p[this] or (((s__PriorityEvent___PriorityEventTree_AVL___v[this])) > ((val))) ) then // INLINED!!
                    return 0
                endif
            else
                //shift up if less than
                if ( (((s__PriorityEvent___PriorityEventTree_AVL___v[this])) < ((val))) ) then // INLINED!!
                    set this=(s__PriorityEvent___PriorityEventTree_AVL___nn[(this)]) // INLINED!!
                endif
                //return 0 if node wasn't found
                if ( 0 == s__PriorityEvent___PriorityEventTree_AVL___p[this] or (((s__PriorityEvent___PriorityEventTree_AVL___v[this])) < ((val))) ) then // INLINED!!
                    return 0
                endif
            endif
            
            return this
        endfunction
        function s__PriorityEvent___PriorityEventTree_add takes integer this,integer val returns integer
            local integer n
            
            //check if the tree already has the value in it
            set this=s__PriorityEvent___PriorityEventTree_AVL___ro[this]
            set n=(LoadInteger(Table___ht, (s__PriorityEvent___PriorityEventTree_AVL___table[this]), (val))) // INLINED!!
            
            //if the tree doesn't have the value in it, add the value
            if ( 0 == n ) then
                set n=this
            
                set this=s__PriorityEvent___PriorityEventTree_AVL___allocate()
                set s__PriorityEvent___PriorityEventTree_AVL___ro[this]=n //store tree into leaf
                call SaveInteger(Table___ht, (s__PriorityEvent___PriorityEventTree_AVL___table[n]), (val), ( this)) //store leaf into value table // INLINED!!
                set s__PriorityEvent___PriorityEventTree_AVL___v[this]=val //store value into leaf
                
                //if the tree is empty
                if ( 0 == s__PriorityEvent___PriorityEventTree_AVL___b[n] ) then
                    set s__PriorityEvent___PriorityEventTree_AVL___b[n]=this //place as first node
                    set s__PriorityEvent___PriorityEventTree_AVL___p[this]=n //parent of first node is tree
                    
                    //add to list
                    set s__PriorityEvent___PriorityEventTree_AVL___nn[this]=n
                    set s__PriorityEvent___PriorityEventTree_AVL___pn[this]=n
                    set s__PriorityEvent___PriorityEventTree_AVL___nn[n]=this
                    set s__PriorityEvent___PriorityEventTree_AVL___pn[n]=this
                else
                    //go to the first node in the tree
                    set n=s__PriorityEvent___PriorityEventTree_AVL___b[n]
                    
                    //go to the bottom of the tree with search algorithm
                    loop
                        if ( (((val)) < ((s__PriorityEvent___PriorityEventTree_AVL___v[n]))) ) then // INLINED!!
                            exitwhen 0 == s__PriorityEvent___PriorityEventTree_AVL___l[n]
                            set n=s__PriorityEvent___PriorityEventTree_AVL___l[n]
                        else
                            exitwhen 0 == s__PriorityEvent___PriorityEventTree_AVL___r[n]
                            set n=s__PriorityEvent___PriorityEventTree_AVL___r[n]
                        endif
                    endloop
                    
                    //add leaf to tree
                    set s__PriorityEvent___PriorityEventTree_AVL___p[this]=n
                    if ( (((val)) < ((s__PriorityEvent___PriorityEventTree_AVL___v[n]))) ) then // INLINED!!
                        set s__PriorityEvent___PriorityEventTree_AVL___l[n]=this
                    else
                        set s__PriorityEvent___PriorityEventTree_AVL___r[n]=this
                    endif
                    
                    //update the height of the parent
                    set s__PriorityEvent___PriorityEventTree_AVL___h[n]=s__PriorityEvent___PriorityEventTree_AVL___getHeight(n)
                    
                    //balance from the parent upwards
                    call s__PriorityEvent___PriorityEventTree_AVL___balance(s__PriorityEvent___PriorityEventTree_AVL___p[n])
                    
                    //add leaf to list
                    if ( (((s__PriorityEvent___PriorityEventTree_AVL___v[n])) > ((s__PriorityEvent___PriorityEventTree_AVL___v[this]))) ) then // INLINED!!
                        set n=s__PriorityEvent___PriorityEventTree_AVL___pn[n]
                    endif
                    set s__PriorityEvent___PriorityEventTree_AVL___nn[this]=s__PriorityEvent___PriorityEventTree_AVL___nn[n]
                    set s__PriorityEvent___PriorityEventTree_AVL___pn[this]=n
                    set s__PriorityEvent___PriorityEventTree_AVL___pn[s__PriorityEvent___PriorityEventTree_AVL___nn[n]]=this
                    set s__PriorityEvent___PriorityEventTree_AVL___nn[n]=this
                endif
                return this
            endif
            return n
        endfunction
        function s__PriorityEvent___PriorityEventTree_delete takes integer this returns nothing
            local integer n
            local integer y
            
            //if the leaf to be deleted isn't 0 and the leaf isn't the tree
            if ( 0 != this and 0 != s__PriorityEvent___PriorityEventTree_AVL___p[this] ) then
                //remove the leaf from the value table
                call RemoveSavedInteger(Table___ht, (s__PriorityEvent___PriorityEventTree_AVL___table[s__PriorityEvent___PriorityEventTree_AVL___ro[this]]), (s__PriorityEvent___PriorityEventTree_AVL___v[this])) // INLINED!!
                
                set n=s__PriorityEvent___PriorityEventTree_AVL___getBottom(this) //retrieve the bottom leaf
                set y=s__PriorityEvent___PriorityEventTree_AVL___p[n] //store the parent here for balancing later
                
                //move the found leaf into the deleted leaf's position
                call s__PriorityEvent___PriorityEventTree_AVL___updateParent(n,0)
                call s__PriorityEvent___PriorityEventTree_AVL___updateParent(this,n)
                if ( this != n ) then
                    set s__PriorityEvent___PriorityEventTree_AVL___l[n]=s__PriorityEvent___PriorityEventTree_AVL___l[this]
                    set s__PriorityEvent___PriorityEventTree_AVL___p[s__PriorityEvent___PriorityEventTree_AVL___l[n]]=n
                    set s__PriorityEvent___PriorityEventTree_AVL___r[n]=s__PriorityEvent___PriorityEventTree_AVL___r[this]
                    set s__PriorityEvent___PriorityEventTree_AVL___p[s__PriorityEvent___PriorityEventTree_AVL___r[n]]=n
                    set s__PriorityEvent___PriorityEventTree_AVL___p[n]=s__PriorityEvent___PriorityEventTree_AVL___p[this]
                    set s__PriorityEvent___PriorityEventTree_AVL___h[n]=s__PriorityEvent___PriorityEventTree_AVL___h[this]
                endif
                
                //balance from the found leaf's old parent upwards
                call s__PriorityEvent___PriorityEventTree_AVL___balance(y)
                
                //remove deleted leaf from list
                set s__PriorityEvent___PriorityEventTree_AVL___nn[s__PriorityEvent___PriorityEventTree_AVL___pn[this]]=s__PriorityEvent___PriorityEventTree_AVL___nn[this]
                set s__PriorityEvent___PriorityEventTree_AVL___pn[s__PriorityEvent___PriorityEventTree_AVL___nn[this]]=s__PriorityEvent___PriorityEventTree_AVL___pn[this]
                set s__PriorityEvent___PriorityEventTree_AVL___nn[this]=s__PriorityEvent___PriorityEventTree_AVL___nn[0]
                set s__PriorityEvent___PriorityEventTree_AVL___nn[0]=this
            endif
        endfunction
        function s__PriorityEvent___PriorityEventTree_clear takes integer this returns integer
            //quick clear
            set this=s__PriorityEvent___PriorityEventTree_AVL___ro[this]
            if ( s__PriorityEvent___PriorityEventTree_AVL___nn[this] != this ) then
                set s__PriorityEvent___PriorityEventTree_AVL___nn[s__PriorityEvent___PriorityEventTree_AVL___pn[this]]=s__PriorityEvent___PriorityEventTree_AVL___nn[0]
                set s__PriorityEvent___PriorityEventTree_AVL___nn[0]=s__PriorityEvent___PriorityEventTree_AVL___nn[this]
                set s__PriorityEvent___PriorityEventTree_AVL___nn[this]=this
                set s__PriorityEvent___PriorityEventTree_AVL___pn[this]=this
                set s__PriorityEvent___PriorityEventTree_AVL___b[this]=0
                call FlushChildHashtable(Table___ht, (s__PriorityEvent___PriorityEventTree_AVL___table[this])) // INLINED!!
            endif
            return this
        endfunction
        function s__PriorityEvent___PriorityEventTree_destroy takes integer this returns nothing
            //quick destroy
            set this=s__PriorityEvent___PriorityEventTree_AVL___ro[this]
            set s__PriorityEvent___PriorityEventTree_AVL___nn[s__PriorityEvent___PriorityEventTree_AVL___pn[this]]=s__PriorityEvent___PriorityEventTree_AVL___nn[0]
            set s__PriorityEvent___PriorityEventTree_AVL___nn[0]=this
            call s__Table_destroy(s__PriorityEvent___PriorityEventTree_AVL___table[this])
        endfunction

//Implemented from module PriorityEvent___PriorityEventMod:
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        function s__PriorityEvent_create takes nothing returns integer
            local integer this
            
            
            
            set this=s__PriorityEvent___PriorityEventTree_create()
            
            
            set s__PriorityEvent_PriorityEvent___PriorityEventMod___tree[s__PriorityEvent_PriorityEvent___PriorityEventMod___count]=this
            set s__PriorityEvent_PriorityEvent___PriorityEventMod___count=s__PriorityEvent_PriorityEvent___PriorityEventMod___count + 1
            
            
            set s__PriorityEvent_PriorityEvent___PriorityEventMod___allEvent[(s__PriorityEvent_PriorityEvent___PriorityEventMod___count)]=CreateTrigger()
            
            return s__PriorityEvent_PriorityEvent___PriorityEventMod___count
        endfunction
    
        function s__PriorityEvent_register takes integer this,boolexpr func,integer priority returns nothing
            local integer node
            
            
            
            set node=s__PriorityEvent_PriorityEvent___PriorityEventMod___instanceCount + 1
            set s__PriorityEvent_PriorityEvent___PriorityEventMod___instanceCount=node
            
            set s__PriorityEvent_PriorityEvent___PriorityEventMod___code[node]=func
            
            
            set this=s__PriorityEvent___PriorityEventTree_add((this),priority)
            
            if ( null == s__PriorityEvent_PriorityEvent___PriorityEventMod___event[this] ) then
                
                set s__PriorityEvent_PriorityEvent___PriorityEventMod___event[this]=CreateTrigger()
                
                set s__PriorityEvent_PriorityEvent___PriorityEventMod___first_p[this]=node
                set s__PriorityEvent_PriorityEvent___PriorityEventMod___last_p[this]=node
            else
                
                set s__PriorityEvent_PriorityEvent___PriorityEventMod___next_p[s__PriorityEvent_PriorityEvent___PriorityEventMod___last_p[this]]=node
                set s__PriorityEvent_PriorityEvent___PriorityEventMod___last_p[this]=node
            endif
            
            call TriggerAddCondition(s__PriorityEvent_PriorityEvent___PriorityEventMod___event[this], func)
        endfunction
        
        function s__PriorityEvent_fire takes integer this returns nothing
            if ( s__PriorityEvent_PriorityEvent___PriorityEventMod___merged ) then
                
                call TriggerEvaluate(s__PriorityEvent_PriorityEvent___PriorityEventMod___allEvent[this])
            else
                
                loop
                    set this=(s__PriorityEvent___PriorityEventTree_AVL___pn[((this))]) // INLINED!!
                    exitwhen (0 == s__PriorityEvent___PriorityEventTree_AVL___p[((this))]) // INLINED!!
                    call TriggerEvaluate(s__PriorityEvent_PriorityEvent___PriorityEventMod___event[this])
                endloop
            endif
        endfunction
        
        
        function s__PriorityEvent_PriorityEvent___PriorityEventMod___merge takes nothing returns nothing
            local integer this
            local integer current= s__PriorityEvent_PriorityEvent___PriorityEventMod___count
            local integer priority
            local integer node
            
            set s__PriorityEvent_PriorityEvent___PriorityEventMod___merged=true
            
            
            loop
                exitwhen 0 == current
                set current=current - 1
                set this=s__PriorityEvent_PriorityEvent___PriorityEventMod___tree[current]
                
                
                set priority=this
                loop
                    set priority=(s__PriorityEvent___PriorityEventTree_AVL___pn[(priority)]) // INLINED!!
                    exitwhen (0 == s__PriorityEvent___PriorityEventTree_AVL___p[(priority)]) // INLINED!!
                    
                    
                    call TriggerClearConditions(s__PriorityEvent_PriorityEvent___PriorityEventMod___event[(priority)])
                    call DestroyTrigger(s__PriorityEvent_PriorityEvent___PriorityEventMod___event[(priority)])
                    set s__PriorityEvent_PriorityEvent___PriorityEventMod___event[(priority)]=null
                    
                    
                    set node=s__PriorityEvent_PriorityEvent___PriorityEventMod___first_p[(priority)]
                    loop
                        exitwhen 0 == node
                        
                        
                        call TriggerAddCondition(s__PriorityEvent_PriorityEvent___PriorityEventMod___allEvent[this], s__PriorityEvent_PriorityEvent___PriorityEventMod___code[node])
                        
                        set node=s__PriorityEvent_PriorityEvent___PriorityEventMod___next_p[node]
                    endloop
                endloop
            endloop
        
            call DestroyTimer(GetExpiredTimer())
        endfunction
        
        function s__PriorityEvent_PriorityEvent___PriorityEventMod___onInit takes nothing returns nothing
            call TimerStart(CreateTimer(), 0, false, function s__PriorityEvent_PriorityEvent___PriorityEventMod___merge)
        endfunction

//library PriorityEvent ends
//library Quest:
//Implemented from module Alloc:
    
    function s__QuestAPI_allocate takes nothing returns integer
        local integer this= s__QuestAPI_Alloc___recycler[0]
        
        
        if ( this == 0 ) then
        
            set this=s__QuestAPI_Alloc___instanceCount + 1
            set s__QuestAPI_Alloc___instanceCount=this
        else
            set s__QuestAPI_Alloc___recycler[0]=s__QuestAPI_Alloc___recycler[this]
        endif
        
        
        return this
    endfunction
    
    function s__QuestAPI_deallocate takes integer this returns nothing
        
        
        set s__QuestAPI_Alloc___recycler[this]=s__QuestAPI_Alloc___recycler[0]
        set s__QuestAPI_Alloc___recycler[0]=this
    endfunction
        
        
        
            
        function s__QuestAPI_create takes string name returns integer
            local integer this= s__QuestAPI_allocate()
            set s__QuestAPI_indice[this]=0
            set s__QuestAPI_rewardIndice[this]=0
            set s__QuestAPI_stageIndice[this]=- 1
            set s__QuestAPI_instances[this]=s__Table_create()
            set s__QuestAPI_instancesCount[this]=0
            //call questArray[this].flush()
            set Quest__questArray[this]=this
            set s__QuestAPI_interactIndice[this]=0
            set s__QuestAPI_interactPosition[this]=0
            set s__QuestAPI_isInInteractTable[this]=false
            set s__QuestAPI_active[this]=false
            set s__QuestAPI_hasFinished[this]=CreateForce()
            set s__QuestAPI_starter[this]=0
            set s__QuestAPI_questName[this]=name
            return this
        endfunction
        function s__QuestAPI_startNextStage takes integer this,string notification returns integer
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (( s__QuestAPI_stageIndice[this] + 1 ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( Quest__STAGE_FINISH)) // INLINED!!
            call SaveStr(Table___ht, (((((Quest__questTable) + (this))))), (( Quest__STAGE_INDICE_INDENT - 2 ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( notification)) // INLINED!!
            set s__QuestAPI_indice[this]=s__QuestAPI_indice[this] + 1
            set s__QuestAPI_stageIndice[this]=- 1
            return this
        endfunction
        function s__QuestAPI_addInteractQuestStarter takes integer this,widget interactee,boolean enabled,string onInteract,string onQuestAccept returns integer
            set s__QuestAPI_starter[this]=sc__QuestInteractListener_create(this , interactee , s__QuestAPI_questName[this] , onInteract , onQuestAccept , enabled)
            return this
        endfunction
        function s__QuestAPI_addStarterWithLvl takes integer this,integer lvl,widget interactee,string onInteract,string onQuestAccept returns integer
            set s__QuestAPI_starter[this]=sc__QuestInteractListener_create(this , interactee , s__QuestAPI_questName[this] , onInteract , onQuestAccept , false)
            call sc__QuestInteractListener_setLevel(s__QuestAPI_starter[this],lvl , true)
            return this
        endfunction
        function s__QuestAPI_getStarter takes integer this returns integer
            return s__QuestAPI_starter[this]
        endfunction
        function s__QuestAPI_addInteract takes integer this,widget interactee,string onInteract,real hoverHeight returns integer
            set s__QuestAPI_stageIndice[this]=s__QuestAPI_stageIndice[this] + 7
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (( s__QuestAPI_stageIndice[this] - 6 ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( - 1)) // INLINED!!
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (( s__QuestAPI_stageIndice[this] - 5 ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( GetHandleId(interactee))) // INLINED!!
            call SaveStr(Table___ht, (((((Quest__questTable) + (this))))), (s__QuestAPI_stageIndice[this] - 4 + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( onInteract)) // INLINED!!
            call SaveBoolean(Table___ht, (((((Quest__questTable) + (this))))), (s__QuestAPI_stageIndice[this] - 3 + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( false)) // INLINED!!
            call SaveReal(Table___ht, (((((Quest__questTable) + (this))))), (s__QuestAPI_stageIndice[this] - 2 + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), (( hoverHeight)*1.0)) // INLINED!!
            call SaveReal(Table___ht, (((((Quest__questTable) + (this))))), (s__QuestAPI_stageIndice[this] - 1 + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), (( GetWidgetX(interactee))*1.0)) // INLINED!!
            call SaveReal(Table___ht, (((((Quest__questTable) + (this))))), (s__QuestAPI_stageIndice[this] + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), (( GetWidgetY(interactee))*1.0)) // INLINED!!
            return this
        endfunction
        function s__QuestAPI_addKillType takes integer this,integer unitType,integer amount,string onKill,string onWhole,real x,real y returns integer
            set s__QuestAPI_stageIndice[this]=s__QuestAPI_stageIndice[this] + 7
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (( s__QuestAPI_stageIndice[this] - 6 ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( - 2)) // INLINED!!
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (( s__QuestAPI_stageIndice[this] - 5 ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( unitType)) // INLINED!!
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (s__QuestAPI_stageIndice[this] - 4 + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( amount)) // INLINED!!
            call SaveStr(Table___ht, (((((Quest__questTable) + (this))))), (s__QuestAPI_stageIndice[this] - 3 + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( onKill)) // INLINED!!
            call SaveStr(Table___ht, (((((Quest__questTable) + (this))))), (s__QuestAPI_stageIndice[this] - 2 + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( onWhole)) // INLINED!!
            call SaveReal(Table___ht, (((((Quest__questTable) + (this))))), (( s__QuestAPI_stageIndice[this] - 1 ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), (( x)*1.0)) // INLINED!!
            call SaveReal(Table___ht, (((((Quest__questTable) + (this))))), (( s__QuestAPI_stageIndice[this] ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), (( y)*1.0)) // INLINED!!
            return this
        endfunction
        function s__QuestAPI_addItemType takes integer this,integer itemType,integer charges,string onSingle,string onWhole,real x,real y returns integer
            set s__QuestAPI_stageIndice[this]=s__QuestAPI_stageIndice[this] + 7
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (( s__QuestAPI_stageIndice[this] - 6 ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( - 3)) // INLINED!!
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (( s__QuestAPI_stageIndice[this] - 5 ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( itemType)) // INLINED!!
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (s__QuestAPI_stageIndice[this] - 4 + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( charges)) // INLINED!!
            call SaveStr(Table___ht, (((((Quest__questTable) + (this))))), (s__QuestAPI_stageIndice[this] - 3 + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( onSingle)) // INLINED!!
            call SaveStr(Table___ht, (((((Quest__questTable) + (this))))), (s__QuestAPI_stageIndice[this] - 2 + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( onWhole)) // INLINED!!
            call SaveReal(Table___ht, (((((Quest__questTable) + (this))))), (s__QuestAPI_stageIndice[this] - 1 + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), (( x)*1.0)) // INLINED!!
            call SaveReal(Table___ht, (((((Quest__questTable) + (this))))), (s__QuestAPI_stageIndice[this] + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), (( y)*1.0)) // INLINED!!
            return this
        endfunction
        function s__QuestAPI_addTriggerRun takes integer this,trigger t returns integer
            set s__QuestAPI_stageIndice[this]=s__QuestAPI_stageIndice[this] + 2
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (( s__QuestAPI_stageIndice[this] - 1 ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( - 121)) // INLINED!!
            call SaveTriggerHandle(Table___ht, (((((Quest__questTable) + (this))))), (( s__QuestAPI_stageIndice[this] ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( t)) // INLINED!!
            return this
        endfunction
        function s__QuestAPI_addTriggerRunIfDestroyed takes integer this,trigger t returns integer
            set s__QuestAPI_stageIndice[this]=s__QuestAPI_stageIndice[this] + 2
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (( s__QuestAPI_stageIndice[this] - 1 ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( - 122)) // INLINED!!
            call SaveTriggerHandle(Table___ht, (((((Quest__questTable) + (this))))), (( s__QuestAPI_stageIndice[this] ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( t)) // INLINED!!
            return this
        endfunction
            
        function s__QuestAPI_hasPlayerCompleted takes integer this,player p returns boolean
            return IsPlayerInForce(p, s__QuestAPI_hasFinished[this])
        endfunction
        
        function s__QuestAPI_triggerAdd takes nothing returns boolean
            local integer this= (LoadInteger(Table___ht, (Quest__triggerAttachedData), (GetHandleId(GetTriggeringTrigger())))) // INLINED!!
            if this == 0 then
                return false
            endif
            call sc__QuestAPI_triggerRun(this,GetTriggeringTrigger())
            return false
        endfunction
        function s__QuestAPI_addTrigger takes integer this,real x,real y returns trigger
            local trigger t= CreateTrigger()
            set Quest__last=t
            call TriggerAddCondition(t, Condition(function s__QuestAPI_triggerAdd))
            call SaveInteger(Table___ht, (Quest__triggerAttachedData), (GetHandleId(t)), ( this)) // INLINED!!
            set s__QuestAPI_stageIndice[this]=s__QuestAPI_stageIndice[this] + 5
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (( s__QuestAPI_stageIndice[this] - 4 ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( - 4)) // INLINED!!
            call SaveTriggerHandle(Table___ht, (((((Quest__questTable) + (this))))), (s__QuestAPI_stageIndice[this] - 3 + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( t)) // INLINED!!
            call SaveBoolean(Table___ht, (((((Quest__questTable) + (this))))), (s__QuestAPI_stageIndice[this] - 2 + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( false)) // INLINED!!
            call SaveReal(Table___ht, (((((Quest__questTable) + (this))))), (s__QuestAPI_stageIndice[this] - 1 + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), (( x)*1.0)) // INLINED!!
            call SaveReal(Table___ht, (((((Quest__questTable) + (this))))), (s__QuestAPI_stageIndice[this] + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), (( y)*1.0)) // INLINED!!
            return Quest__last
        endfunction
        function s__QuestAPI_addFinish takes integer this returns integer
            call s__QuestAPI_startNextStage(this,null)
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (Quest__STAGE_INDICE_INDENT * ( s__QuestAPI_indice[this] )), ( Quest__GLOBAL_FINISH)) // INLINED!!
            call SaveStr(Table___ht, (((((Quest__questTable) + (this))))), (1 + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( Quest__beforeQuestName + s__QuestAPI_questName[this] + Quest__afterQuestName)) // INLINED!!
            set s__QuestAPI_indice[this]=s__QuestAPI_indice[this] + 1
            set s__QuestAPI_stageIndice[this]=- 1
            return this
        endfunction
        function s__QuestAPI_addUnitReward takes integer this,integer unitId,integer amount returns integer
            set s__QuestAPI_stageIndice[this]=s__QuestAPI_stageIndice[this] + 3
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (( s__QuestAPI_stageIndice[this] - 2 ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( - 1)) // INLINED!!
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (( s__QuestAPI_stageIndice[this] - 1 ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( unitId)) // INLINED!!
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (s__QuestAPI_stageIndice[this] - 0 + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( amount)) // INLINED!!
            return this
        endfunction
        function s__QuestAPI_addItemReward takes integer this,integer itemId,integer amount returns integer
            set s__QuestAPI_stageIndice[this]=s__QuestAPI_stageIndice[this] + 3
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (( s__QuestAPI_stageIndice[this] - 2 ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( - 2)) // INLINED!!
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (( s__QuestAPI_stageIndice[this] - 1 ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( itemId)) // INLINED!!
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (s__QuestAPI_stageIndice[this] + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( amount)) // INLINED!!
            return this
        endfunction
        function s__QuestAPI_addGoldReward takes integer this,integer amount returns integer
            set s__QuestAPI_stageIndice[this]=s__QuestAPI_stageIndice[this] + 2
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (( s__QuestAPI_stageIndice[this] - 1 ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( - 3)) // INLINED!!
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (s__QuestAPI_stageIndice[this] + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( amount)) // INLINED!!
            return this
        endfunction
        function s__QuestAPI_addWoodReward takes integer this,integer amount returns integer
            set s__QuestAPI_stageIndice[this]=s__QuestAPI_stageIndice[this] + 2
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (( s__QuestAPI_stageIndice[this] - 1 ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( - 4)) // INLINED!!
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (s__QuestAPI_stageIndice[this] + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( amount)) // INLINED!!
            return this
        endfunction
        function s__QuestAPI_addExpReward takes integer this,integer amount returns integer
            set s__QuestAPI_stageIndice[this]=s__QuestAPI_stageIndice[this] + 2
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (( s__QuestAPI_stageIndice[this] - 1 ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( - 5)) // INLINED!!
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (( s__QuestAPI_stageIndice[this] ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( amount)) // INLINED!!
            return this
        endfunction
        function s__QuestAPI_addQuestStartReward takes integer this,integer s returns integer
            set s__QuestAPI_stageIndice[this]=s__QuestAPI_stageIndice[this] + 2
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (( s__QuestAPI_stageIndice[this] - 1 ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( - 6)) // INLINED!!
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (( s__QuestAPI_stageIndice[this] ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( s)) // INLINED!!
            return this
        endfunction
        function s__QuestAPI_addQuestEnableReward takes integer this,integer s returns integer
            set s__QuestAPI_stageIndice[this]=s__QuestAPI_stageIndice[this] + 2
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (( s__QuestAPI_stageIndice[this] - 1 ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( - 7)) // INLINED!!
            call SaveInteger(Table___ht, (((Quest__questTable) + (this))), (( s__QuestAPI_stageIndice[this] ) + ( Quest__STAGE_INDICE_INDENT * s__QuestAPI_indice[this] )), ( s)) // INLINED!!
            return this
        endfunction
        function s__QuestAPI_isFinished takes integer this,player p returns boolean
            return IsPlayerInForce(p, s__QuestAPI_hasFinished[this])
        endfunction
        function s__QuestAPI_isInStage takes integer this,player p,integer stage returns boolean
            local integer i= 0
            if s__QuestAPI_isFinished(this,p) then
                return true
            endif
            loop
                exitwhen i >= s__QuestAPI_instancesCount[this]
                if sc__QuestInstance_containsPlayer(((LoadInteger(Table___ht, (s__QuestAPI_instances[this]), (i)))),p) then // INLINED!!
                    return (s__QuestInstance_stage[(((LoadInteger(Table___ht, (s__QuestAPI_instances[this]), (i)))))]) >= stage // INLINED!!
                endif
                set i=i + 1
            endloop
            return false
            
        endfunction
        
        function s__QuestAPI_triggerRun takes integer this,trigger t returns nothing
            local integer i= 0
            if not s__QuestAPI_active[this] then
                return
            endif
            loop
                exitwhen i == s__QuestAPI_instancesCount[this]
                if sc__QuestInstance_triggerFulfill(((LoadInteger(Table___ht, (s__QuestAPI_instances[this]), (i)))),t) then // INLINED!!
                    return
                endif
                
                set i=i + 1
            endloop
        endfunction
        //method addInteractStarter takes widget u returns nothing
        //endmethod
        function s__QuestAPI_start takes integer this,integer p returns integer
            local integer f= sc__QuestInstance_start(sc__QuestInstance_create(this),p)
            set s__QuestAPI_active[this]=true
            call SaveInteger(Table___ht, (s__QuestAPI_instances[this]), (s__QuestAPI_instancesCount[this]), ( f)) // INLINED!!
            set s__QuestAPI_instancesCount[this]=s__QuestAPI_instancesCount[this] + 1
            return f
        endfunction
        function s__QuestAPI_finish takes integer this,integer inst,boolean good,integer p returns nothing
            local integer i= 0
            if good then
                call s__Party_populateForce(p,s__QuestAPI_hasFinished[this])
            endif
            
            loop
                exitwhen i == s__QuestAPI_instancesCount[this]
                if inst == (LoadInteger(Table___ht, (s__QuestAPI_instances[this]), (i))) then // INLINED!!
                    call SaveInteger(Table___ht, (s__QuestAPI_instances[this]), (i), ( (LoadInteger(Table___ht, (s__QuestAPI_instances[this]), (s__QuestAPI_instancesCount[this] - 1))))) // INLINED!!
                    set s__QuestAPI_instancesCount[this]=s__QuestAPI_instancesCount[this] - 1
                    if s__QuestAPI_instancesCount[this] == 0 then
                        set s__QuestAPI_active[this]=false
                    endif
                    return
                endif
                set i=i + 1
            endloop
        endfunction
        
        
        
        function s__QuestAPI_onRepick takes player p returns nothing
            local integer i= 0
            loop
                exitwhen i == Quest__listeningQuestsIndex
                call sc__QuestInteractListener_reset(Quest__interactTable[i],p)
                set i=i + 1
            endloop
        endfunction
        
        function s__QuestAPI_onInit takes nothing returns nothing
//textmacro instance: Init()
            set Quest__questTable=s__TableArray__staticgetindex(29)
            set Quest__unitTable=s__TableArray__staticgetindex(Quest__MAX_NUM_QUESTS)
        //    set playerProgressTable = TableArray[NUM_PLAYERS]
            set Quest__sequenceTable=s__TableArray__staticgetindex(Quest__MAX_NUM_QUESTS)
            set Quest__triggerAttachedData=s__Table_create()
            
//end of: Init()
        endfunction
//Implemented from module Alloc:
    
    function s__QuestInteractListener_allocate takes nothing returns integer
        local integer this= s__QuestInteractListener_Alloc___recycler[0]
        
        
        if ( this == 0 ) then
        
            set this=s__QuestInteractListener_Alloc___instanceCount + 1
            set s__QuestInteractListener_Alloc___instanceCount=this
        else
            set s__QuestInteractListener_Alloc___recycler[0]=s__QuestInteractListener_Alloc___recycler[this]
        endif
        
        
        return this
    endfunction
    
    function s__QuestInteractListener_deallocate takes integer this returns nothing
        
        
        set s__QuestInteractListener_Alloc___recycler[this]=s__QuestInteractListener_Alloc___recycler[0]
        set s__QuestInteractListener_Alloc___recycler[0]=this
    endfunction
        
        
        function s__QuestInteractListener_create takes integer roott,widget interacter,string name,string onInteract,string onAccept,boolean enable returns integer
            local integer this= s__QuestInteractListener_allocate()
            local integer i= 0
            local integer l
            if enable then
                set l=1
            else
                set l=0
            endif
            if roott == 0 then
               return 0
            endif
            
            set s__QuestInteractListener_root[this]=roott
            set s__QuestInteractListener_b[this]=s__Table_create()
            loop
                exitwhen i == 10
                call SaveInteger(Table___ht, (s__QuestInteractListener_b[this]), (i), ( l)) // INLINED!!
                set i=i + 1
            endloop
            set s__QuestInteractListener_onInt[this]=onInteract
            set s__QuestInteractListener_level[this]=0
            set s__QuestInteractListener_questName[this]=name
            set s__QuestInteractListener_onAcc[this]=onAccept
            set s__QuestInteractListener_interact[this]=interacter
            set s__QuestInteractListener_interactPosition[this]=Quest__listeningQuestsIndex
            set Quest__listeningQuestsIndex=Quest__listeningQuestsIndex + 1
            set Quest__interactTable[s__QuestInteractListener_interactPosition[this]]=this
            set s__QuestInteractListener_defaultEnabled[this]=enable
            set s__QuestInteractListener_exc[this]=CreateUnit(Player(15), Quest__EXCLAMATION_POINT_ID, GetWidgetX(s__QuestInteractListener_interact[this]), GetWidgetY(s__QuestInteractListener_interact[this]), 0)
            call ShowUnit(s__QuestInteractListener_exc[this], enable)
            return this
        endfunction
        
        function s__QuestInteractListener_setLevel takes integer this,integer reqLevel,boolean enableWhenReady returns nothing
            local integer i= 0
            set s__QuestInteractListener_levelPinged[this]=s__Table_create()
            set s__QuestInteractListener_usesLevel[this]=true
            set s__QuestInteractListener_level[this]=reqLevel
            set s__QuestInteractListener_levelPosition[this]=Quest__interactLevelTablePos
            set Quest__interactLevelTablePos=Quest__interactLevelTablePos + 1
            set Quest__interactLevelTable[s__QuestInteractListener_levelPosition[this]]=this
            if enableWhenReady then
                set s__QuestInteractListener_defaultEnabled[this]=true
                loop
                    exitwhen i == 10
                    call SaveInteger(Table___ht, (s__QuestInteractListener_b[this]), (i), ( 1)) // INLINED!!
                    set i=i + 1
                endloop
            endif
        endfunction
        
        function s__QuestInteractListener_lvlCheck takes integer this,integer newLevel,player p returns nothing
            if (LoadBoolean(Table___ht, (((s__QuestInteractListener_levelPinged[this]))), (GetPlayerId(p)))) then // INLINED!!
                return
            endif
            if newLevel >= s__QuestInteractListener_level[this] then
                call SaveBoolean(Table___ht, (((s__QuestInteractListener_levelPinged[this]))), (GetPlayerId(p)), ( true)) // INLINED!!
                if (LoadInteger(Table___ht, (s__QuestInteractListener_b[this]), (GetPlayerId(p)))) == 1 then // INLINED!!
                    call sc__QuestInteractListener_enable(this,p)
                endif
            endif
        endfunction
        
        function s__QuestInteractListener_isEnabled takes integer this,player p returns boolean
            return (LoadInteger(Table___ht, (s__QuestInteractListener_b[this]), (GetPlayerId(p)))) != 0 // INLINED!!
        endfunction
        
        function s__QuestInteractListener_enable takes integer this,player p returns integer
            call SaveInteger(Table___ht, (s__QuestInteractListener_b[this]), (GetPlayerId(p)), ( 1)) // INLINED!!
            call PingMinimap(GetWidgetX(s__QuestInteractListener_interact[this]), GetWidgetY(s__QuestInteractListener_interact[this]), 5)
            call ShowUnit(s__QuestInteractListener_exc[this], (LoadInteger(Table___ht, (s__QuestInteractListener_b[this]), (GetPlayerId(GetLocalPlayer())))) != 99) // INLINED!!
            call TimedTextBoolean(15 , (LoadInteger(Table___ht, (s__QuestInteractListener_b[this]), (GetPlayerId(GetLocalPlayer())))) != 99 , Quest__beforeQuestNameAccepted + s__QuestInteractListener_questName[this] + Quest__afterQuestNameAccepted) // INLINED!!
            return this
        endfunction
        
        function s__QuestInteractListener_enableParty takes integer this,integer p returns integer
            local integer i=0
            local real dur
            loop
                exitwhen i == 10
                if s__Party_doesContainPlayer(p,Player(i)) then
                    call SaveInteger(Table___ht, (s__QuestInteractListener_b[this]), (i), ( 1)) // INLINED!!
                endif
                set i=i + 1
            endloop
            if s__Party_doesContainPlayer(p,GetLocalPlayer()) then
                set dur=5
            else
                set dur=0
            endif
            call PingMinimap(GetWidgetX(s__QuestInteractListener_interact[this]), GetWidgetY(s__QuestInteractListener_interact[this]), dur)
            call ShowUnit(s__QuestInteractListener_exc[this], (LoadInteger(Table___ht, (s__QuestInteractListener_b[this]), (GetPlayerId(GetLocalPlayer())))) != 99) // INLINED!!
            call TimedTextBoolean(15 , dur == 5 , Quest__beforeQuestNameAccepted + s__QuestInteractListener_questName[this] + Quest__afterQuestNameAccepted)
            
            return this
        endfunction
        
        function s__QuestInteractListener_disable takes integer this,player p returns integer
            call SaveInteger(Table___ht, (s__QuestInteractListener_b[this]), (GetPlayerId(p)), ( 0)) // INLINED!!
            call ShowUnit(s__QuestInteractListener_exc[this], (LoadInteger(Table___ht, (s__QuestInteractListener_b[this]), (GetPlayerId(GetLocalPlayer())))) != 99) // INLINED!!
            return this
        endfunction
        
        function s__QuestInteractListener_destroy takes integer this returns nothing
            set Quest__interactTable[s__QuestInteractListener_interactPosition[this]]=Quest__interactTable[Quest__listeningQuestsIndex - 1]
            set Quest__listeningQuestsIndex=Quest__listeningQuestsIndex - 1
            set s__QuestInteractListener_interact[this]=null
            call FlushChildHashtable(Table___ht, (s__QuestInteractListener_b[this])) // INLINED!!
            call s__QuestInteractListener_deallocate(this)
        endfunction
        
        function s__QuestInteractListener_reset takes integer this,player p returns nothing
            if s__QuestInteractListener_defaultEnabled[this] then
                call print("defeaultEnabled")
                call SaveInteger(Table___ht, (s__QuestInteractListener_b[this]), (GetPlayerId(p)), ( 1)) // INLINED!!
            else
                call print("nonenabled")
                call SaveInteger(Table___ht, (s__QuestInteractListener_b[this]), (GetPlayerId(p)), ( 0)) // INLINED!!
            endif
            call SaveBoolean(Table___ht, (((s__QuestInteractListener_levelPinged[this]))), (GetPlayerId(p)), ( false)) // INLINED!!
            call ShowUnit(s__QuestInteractListener_exc[this], not s__QuestInteractListener_usesLevel[this] and (LoadInteger(Table___ht, (s__QuestInteractListener_b[this]), (GetPlayerId(GetLocalPlayer())))) != 99 and (LoadInteger(Table___ht, (s__QuestInteractListener_b[this]), (GetPlayerId(GetLocalPlayer())))) != 0) // INLINED!!
        endfunction
        
        function s__QuestInteractListener_onInteract takes integer this,widget u,player target returns boolean
            local integer i= GetPlayerId(target)
            local integer i2= 0
            local integer a= 0
            local integer p
            if u != s__QuestInteractListener_interact[this] or (LoadInteger(Table___ht, (s__QuestInteractListener_b[this]), (i))) == 99 or ((s__Party_p_perPlayer[GetPlayerId((target))])) < 7 then // INLINED!!
                return false
            endif
            if s__QuestInteractListener_usesLevel[this] and s__QuestInteractListener_level[this] > s__Party_getLevelReq((s__Party_p_perPlayer[GetPlayerId((target))])) then // INLINED!!
       //         call TimedText(target,MESSAGE_DURATION,"|cff"+questColor+"Notice:|r Your party is too low level to accept this quest")
                return false
            endif
            loop
                exitwhen i2 == 10
                if s__Party_doesContainPlayer((s__Party_p_perPlayer[GetPlayerId((target))]),Player(i2)) and (LoadInteger(Table___ht, (s__QuestInteractListener_b[this]), (i2))) == 0 then // INLINED!!
       //             call TimedText(target,MESSAGE_DURATION,"|cff"+questColor+"Notice:|r Player "+I2S(i)+" does not have this quest unlocked")
                    return false
                endif
                set i2=i2 + 1
            endloop
            if (LoadInteger(Table___ht, (s__QuestInteractListener_b[this]), (i))) == 5 then // INLINED!!
                set p=(s__Party_p_perPlayer[GetPlayerId((target))]) // INLINED!!
                call s__QuestAPI_start(s__QuestInteractListener_root[this],p)
                call TimedTextBoolean(15 , s__Party_doesContainPlayer((s__Party_p_perPlayer[GetPlayerId((target))]),GetLocalPlayer()) , s__QuestInteractListener_onAcc[this]) // INLINED!!
                loop
                    if IsPlayerInForce(Player(a), (s__Party_playerPool[(p)])) then // INLINED!!
                        call SaveInteger(Table___ht, (s__QuestInteractListener_b[this]), (a), ( 99)) // INLINED!!
                    endif
                    set a=a + 1
                    exitwhen a == 11
                endloop
            elseif (LoadInteger(Table___ht, (s__QuestInteractListener_b[this]), (i))) == 1 then // INLINED!!
                call SaveInteger(Table___ht, (s__QuestInteractListener_b[this]), (i), ( 5)) // INLINED!!
                call TimedTextBoolean(15 , s__Party_doesContainPlayer((s__Party_p_perPlayer[GetPlayerId((target))]),GetLocalPlayer()) , s__QuestInteractListener_onInt[this]) // INLINED!!
            endif
            call ShowUnit(s__QuestInteractListener_exc[this], (LoadInteger(Table___ht, (s__QuestInteractListener_b[this]), (GetPlayerId(GetLocalPlayer())))) != 99) // INLINED!!
            return true
        endfunction
            
        function s__QuestInstance_create takes integer root returns integer
            local integer this= s__QuestInstance__allocate()
            set s__QuestInstance_root[this]=root
            set s__QuestInstance_stage[this]=- 1
            set s__QuestInstance_onDestIndex[this]=0
            set s__QuestInstance_onDestroy[this]=s__Table_create()
            set s__QuestInstance_progress[this]=s__Table_create()
            set Quest__listOfQuestsIndex=Quest__listOfQuestsIndex + 1
            set Quest__listOfQuests[Quest__listOfQuestsIndex]=this
            set s__QuestInstance_thisIndex[this]=Quest__listOfQuestsIndex
            set s__QuestInstance_currentProgress[this]=s__Table_create()
            return this
        endfunction
        function s__QuestInstance_destroy takes integer this returns nothing
            local integer i= 0
            local integer i2= 0
            call s__QuestInteractListener_enableParty((s__QuestAPI_starter[(s__QuestInstance_root[this])]),s__QuestInstance_party[this]) // INLINED!!
            set s__QuestInstance_thisIndex[Quest__listOfQuests[Quest__listOfQuestsIndex]]=s__QuestInstance_thisIndex[this]
            set Quest__listOfQuests[s__QuestInstance_thisIndex[this]]=Quest__listOfQuests[Quest__listOfQuestsIndex]
            set Quest__listOfQuests[Quest__listOfQuestsIndex]=0
            set Quest__listOfQuestsIndex=Quest__listOfQuestsIndex - 1
            set s__QuestInstance_lastTrigger[this]=null
            set i=0
            loop
                exitwhen i == s__QuestInstance_onDestIndex[this]
                call runTriggerForForce((s__Party_playerPool[(s__QuestInstance_party[this])]) , (LoadTriggerHandle(Table___ht, (((s__QuestInstance_onDestroy[this]))), (i)))) // INLINED!!
                set i=i + 1
            endloop
            call s__Table_destroy(s__QuestInstance_onDestroy[this])
            set i=0
            loop
                set i2=- (LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (i))) // INLINED!!
                exitwhen i2 == - Quest__STAGE_FINISH
                if i2 == 1 then
                    call SetWidgetLife((LoadWidgetHandle(Table___ht, (((s__QuestInstance_progress[this]))), (i + 4))), 0) // INLINED!!
                    set i=i + 6
                elseif i2 == 2 or i2 == 3 then
                    set i=i + 7
                elseif i2 == 4 then
                    set i=i + 5
                endif
                set i=i + 1
            endloop
            call s__Table_destroy(s__QuestInstance_progress[this])
            call s__Table_destroy(s__QuestInstance_currentProgress[this])
            call s__QuestAPI_finish(s__QuestInstance_root[this],this , false , 0)
            call s__QuestInstance_deallocate(this)
        endfunction
        function s__QuestInstance_endQuest takes integer this returns nothing
            set s__QuestInstance_thisIndex[Quest__listOfQuests[Quest__listOfQuestsIndex]]=s__QuestInstance_thisIndex[this]
            set Quest__listOfQuests[s__QuestInstance_thisIndex[this]]=Quest__listOfQuests[Quest__listOfQuestsIndex]
            set Quest__listOfQuests[Quest__listOfQuestsIndex]=0
            set Quest__listOfQuestsIndex=Quest__listOfQuestsIndex - 1
            set s__QuestInstance_lastTrigger[this]=null
            call s__Table_destroy(s__QuestInstance_progress[this])
            call s__Table_destroy(s__QuestInstance_currentProgress[this])
            call s__Table_destroy(s__QuestInstance_onDestroy[this])
            call s__QuestAPI_finish(s__QuestInstance_root[this],this , true , s__QuestInstance_party[this])
            call s__QuestInstance_deallocate(this)
        endfunction
        function s__QuestInstance_containsPlayer takes integer this,player p returns boolean
            return s__Party_doesContainPlayer(s__QuestInstance_party[this],p)
        endfunction
        function s__QuestInstance_getStage takes integer this returns integer
            return s__QuestInstance_stage[this]
        endfunction
        function s__QuestInstance_start takes integer this,integer p returns integer
            if s__QuestInstance_stage[this] != - 1 then
                call TimedTextAll(Quest__MESSAGE_DURATION , "FAIL")
            endif
            set s__QuestInstance_party[this]=p
            call s__Party_startQuest(s__QuestInstance_party[this],this)
            call sc__QuestInstance_nextStage(this)
            return this
        endfunction
        function s__QuestInstance_nextStage takes integer this returns nothing
            local integer forLoop= 0
            local integer i= 0
            local integer numIteration= - 1
            local widget w
            local integer t= ((Quest__questTable) + (s__QuestInstance_root[this])) // INLINED!!
            call FlushChildHashtable(Table___ht, (s__QuestInstance_progress[this])) // INLINED!!
            call FlushChildHashtable(Table___ht, (s__QuestInstance_currentProgress[this])) // INLINED!!
            set s__QuestInstance_onDestIndex[this]=0
            call FlushChildHashtable(Table___ht, (s__QuestInstance_onDestroy[this])) // INLINED!!
            set s__QuestInstance_stage[this]=s__QuestInstance_stage[this] + 1
            if (LoadInteger(Table___ht, (t), (s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT))) == Quest__GLOBAL_FINISH then // INLINED!!
                call TimedTextBoolean(Quest__MESSAGE_DURATION , s__Party_doesContainPlayer(s__QuestInstance_party[this],GetLocalPlayer()) , (LoadStr(Table___ht, (((t))), (1 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT ))))) // INLINED!!
                call sc__QuestInstance_finish(this)
                return
            elseif (LoadStr(Table___ht, (((t))), (( Quest__STAGE_INDICE_INDENT - 2 ) + ( Quest__STAGE_INDICE_INDENT * ( s__QuestInstance_stage[this] - 1 ) )))) != null then // INLINED!!
                call TimedTextBoolean(Quest__MESSAGE_DURATION , s__Party_doesContainPlayer(s__QuestInstance_party[this],GetLocalPlayer()) , (LoadStr(Table___ht, (((t))), (( Quest__STAGE_INDICE_INDENT - 2 ) + ( ( s__QuestInstance_stage[this] - 1 ) * Quest__STAGE_INDICE_INDENT ))))) // INLINED!!
            endif
            loop
                set i=(LoadInteger(Table___ht, (t), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) // INLINED!!
                if i < 0 then
                    set i=- i
                    if i == - Quest__STAGE_FINISH then
                        call SaveInteger(Table___ht, (s__QuestInstance_progress[this]), (numIteration), ( Quest__STAGE_FINISH)) // INLINED!!
                        return
                    elseif i == 1 then
                        set numIteration=numIteration + 7
                        set forLoop=forLoop + 6
                        set w=I2W((LoadInteger(Table___ht, (t), (forLoop - 5 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT ))))) // INLINED!!
                        call SaveInteger(Table___ht, (s__QuestInstance_progress[this]), (numIteration - 6), ( - 1)) // INLINED!!
                        call SaveInteger(Table___ht, (s__QuestInstance_progress[this]), (numIteration - 5), ( (LoadInteger(Table___ht, (t), (forLoop - 5 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))))) // INLINED!!
                        call SaveStr(Table___ht, (((s__QuestInstance_progress[this]))), (numIteration - 4), ( (LoadStr(Table___ht, (((t))), (forLoop - 4 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))))) // INLINED!!
                        call SaveBoolean(Table___ht, (((s__QuestInstance_progress[this]))), (numIteration - 3), ( false)) // INLINED!!
                        call SaveUnitHandle(Table___ht, (((s__QuestInstance_progress[this]))), (numIteration - 2), ( CreateUnit(Player(10), Quest__EXCLAMATION_POINT_ID, GetWidgetX(w), GetWidgetY(w), 0))) // INLINED!!
                        call ShowUnit((LoadUnitHandle(Table___ht, (((s__QuestInstance_progress[this]))), (numIteration - 2))), s__Party_doesContainPlayer(s__QuestInstance_party[this],GetLocalPlayer())) // INLINED!!
                        call UnitAddAbility((LoadUnitHandle(Table___ht, (((s__QuestInstance_progress[this]))), (numIteration - 2))), 'Amrf') // INLINED!!
                        call SetUnitFlyHeight((LoadUnitHandle(Table___ht, (((s__QuestInstance_progress[this]))), (numIteration - 2))), (LoadReal(Table___ht, (((t))), (forLoop - 2 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))), 100000) // INLINED!!
                        call UnitRemoveAbility((LoadUnitHandle(Table___ht, (((s__QuestInstance_progress[this]))), (numIteration - 2))), 'Amrf') // INLINED!!
                        call s__Party_addPing(s__QuestInstance_party[this],(LoadReal(Table___ht, (((t))), (forLoop - 1 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) , (LoadReal(Table___ht, (((t))), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT ))))) // INLINED!!
                        set w=null
                    elseif i == 2 or i == 3 then
                        set numIteration=numIteration + 7
                        set forLoop=forLoop + 6
                        if i == 2 then
                            call SaveInteger(Table___ht, (s__QuestInstance_progress[this]), (numIteration - 6), ( - 2)) // INLINED!!
                        else
                            call SaveInteger(Table___ht, (s__QuestInstance_progress[this]), (numIteration - 6), ( - 3)) // INLINED!!
                        endif
                        call SaveInteger(Table___ht, (s__QuestInstance_progress[this]), (numIteration - 5), ( (LoadInteger(Table___ht, (t), (forLoop - 5 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))))) // INLINED!!
                        call SaveInteger(Table___ht, (s__QuestInstance_progress[this]), (numIteration - 4), ( (LoadInteger(Table___ht, (t), (forLoop - 4 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))))) // INLINED!!
                        call SaveStr(Table___ht, (((s__QuestInstance_progress[this]))), (numIteration - 3), ( (LoadStr(Table___ht, (((t))), (forLoop - 3 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))))) // INLINED!!
                        call SaveStr(Table___ht, (((s__QuestInstance_progress[this]))), (numIteration - 2), ( (LoadStr(Table___ht, (((t))), (forLoop - 2 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))))) // INLINED!!
                    elseif i == 4 then
                        set numIteration=numIteration + 5
                        set forLoop=forLoop + 4
                        call SaveInteger(Table___ht, (s__QuestInstance_progress[this]), (numIteration - 4), ( - 4)) // INLINED!!
                        call SaveTriggerHandle(Table___ht, (((s__QuestInstance_progress[this]))), (numIteration - 3), ( (LoadTriggerHandle(Table___ht, (((t))), (forLoop - 3 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))))) // INLINED!!
                        call SaveBoolean(Table___ht, (((s__QuestInstance_progress[this]))), (numIteration - 2), ( false)) // INLINED!!
                    elseif i == 121 then
                        set forLoop=forLoop + 1
                        call runTriggerForForce((s__Party_playerPool[(s__QuestInstance_party[this])]) , (LoadTriggerHandle(Table___ht, (((t))), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT ))))) // INLINED!!
                    elseif i == 122 then
                        call print("On Destroy")
                        set forLoop=forLoop + 1
                        call SaveTriggerHandle(Table___ht, (((s__QuestInstance_onDestroy[this]))), (s__QuestInstance_onDestIndex[this]), ( (LoadTriggerHandle(Table___ht, (((t))), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))))) // INLINED!!
                        set s__QuestInstance_onDestIndex[this]=s__QuestInstance_onDestIndex[this] + 1
                    endif
                endif
                set forLoop=forLoop + 1
                exitwhen (LoadInteger(Table___ht, (t), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) == 0 // INLINED!!
            endloop
            call SaveInteger(Table___ht, (s__QuestInstance_progress[this]), (numIteration + 1), ( Quest__STAGE_FINISH)) // INLINED!!
        endfunction
        
        function s__QuestInstance_notifyClosure takes integer this returns nothing
            call s__QuestInstance_destroy(this)
        endfunction
        
        function s__QuestInstance_finish takes integer this returns nothing
            local integer forLoop= 0
            local integer i= 0
            local player playerNoob
            local integer t= ((Quest__questTable) + (s__QuestInstance_root[this])) // INLINED!!
            set s__QuestInstance_stage[this]=s__QuestInstance_stage[this] + 1
            loop
                if (LoadInteger(Table___ht, (t), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) == - 1 then // INLINED!!
                    loop
                        set playerNoob=Player(i)
                        set i=i + 1
                        exitwhen i > 11
                    endloop
                    set forLoop=forLoop + 2
                elseif (LoadInteger(Table___ht, (t), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) == - 2 then // INLINED!!
                    set i=0
                    loop
                        set playerNoob=Player(i)
                        if s__Party_doesContainPlayer(s__QuestInstance_party[this],playerNoob) then
                            set Quest_QUESTSYSTEM_ITEMTYPE=(LoadInteger(Table___ht, (t), (forLoop + 1 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) // INLINED!!
                            set Quest_QUESTSYSTEM_ITEMAMOUNT=(LoadInteger(Table___ht, (t), (forLoop + 2 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) // INLINED!!
                            set Quest_QUESTSYSTEM_TRIGGERUNIT=udg_PlayerUnit[i + 1]
                            set Quest_QUESTSYSTEM_TRIGGERPLAYERUNIT=udg_PlayerUnit[i + 1]
                            //set QUESTSYSTEM_TRIGGERUNIT = lastTrigger
                            //set QUESTSYSTEM_TRIGGERPLAYERUNIT = lastTriggerUnit[GetPlayerId(playerNoob)]
                            set Quest_QUESTSYSTEM_RESPONSETYPE=4
                            call TriggerEvaluate(Quest_QUESTSYSTEM_MAINTRIGGER)
                        endif
                        set i=i + 1
                        exitwhen i > 11
                    endloop
                    set forLoop=forLoop + 2
                elseif (LoadInteger(Table___ht, (t), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) == - 3 then // INLINED!!
                    set i=0
                    loop
                        set playerNoob=Player(i)
                        if s__Party_doesContainPlayer(s__QuestInstance_party[this],playerNoob) then
                            set Quest_QUESTSYSTEM_GOLDTOADD=(LoadInteger(Table___ht, (t), (forLoop + 1 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) // INLINED!!
                            set Quest_QUESTSYSTEM_TRIGGERUNIT=s__QuestInstance_lastTrigger[this]
                            set Quest_QUESTSYSTEM_PLAYER=playerNoob
                            set Quest_QUESTSYSTEM_TRIGGERPLAYERUNIT=s___QuestInstance_lastTriggerUnit[s__QuestInstance_lastTriggerUnit[this]+GetPlayerId(playerNoob)]
                            set Quest_QUESTSYSTEM_RESPONSETYPE=1
                            call TriggerEvaluate(Quest_QUESTSYSTEM_MAINTRIGGER)
                            //call SetPlayerState(playerNoob, PLAYER_STATE_RESOURCE_GOLD, t[forLoop+1 + (stage * STAGE_INDICE_INDENT)])
                        endif
                        set i=i + 1
                        exitwhen i > 11
                    endloop
                    set forLoop=forLoop + 1
                elseif (LoadInteger(Table___ht, (t), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) == - 4 then // INLINED!!
                    set i=0
                    loop
                        set playerNoob=Player(i)
                        if s__Party_doesContainPlayer(s__QuestInstance_party[this],playerNoob) then
                            set Quest_QUESTSYSTEM_LUMBTOADD=(LoadInteger(Table___ht, (t), (forLoop + 1 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) // INLINED!!
                            set Quest_QUESTSYSTEM_TRIGGERUNIT=s__QuestInstance_lastTrigger[this]
                            set Quest_QUESTSYSTEM_TRIGGERPLAYERUNIT=s___QuestInstance_lastTriggerUnit[s__QuestInstance_lastTriggerUnit[this]+GetPlayerId(playerNoob)]
                            set Quest_QUESTSYSTEM_PLAYER=playerNoob
                            set Quest_QUESTSYSTEM_RESPONSETYPE=2
                            call TriggerEvaluate(Quest_QUESTSYSTEM_MAINTRIGGER)
                        endif
                        set i=i + 1
                        exitwhen i > 11
                    endloop
                    set forLoop=forLoop + 1
                elseif (LoadInteger(Table___ht, (t), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) == - 5 then // INLINED!!
                    set i=0
                    loop
                        set playerNoob=Player(i)
                        if s__Party_doesContainPlayer(s__QuestInstance_party[this],playerNoob) then
                            set Quest_QUESTSYSTEM_EXPTOADD=(LoadInteger(Table___ht, (t), (forLoop + 1 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) // INLINED!!
                            set Quest_QUESTSYSTEM_TRIGGERUNIT=udg_PlayerUnit[i + 1]
                            set Quest_QUESTSYSTEM_TRIGGERPLAYERUNIT=udg_PlayerUnit[i + 1]
                            set Quest_QUESTSYSTEM_PLAYER=playerNoob
                            set Quest_QUESTSYSTEM_RESPONSETYPE=6
                            call TriggerEvaluate(Quest_QUESTSYSTEM_MAINTRIGGER)
                        endif
                        set i=i + 1
                        exitwhen i > 11
                    endloop
                    set forLoop=forLoop + 1
                elseif (LoadInteger(Table___ht, (t), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) == - 6 then // INLINED!!
                    call s__QuestAPI_start(((LoadInteger(Table___ht, (t), (forLoop + 1 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT ))))),s__QuestInstance_party[this]) // INLINED!!
                    set forLoop=forLoop + 1
                elseif (LoadInteger(Table___ht, (t), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) == - 7 then // INLINED!!
                    call s__QuestInteractListener_enableParty((s__QuestAPI_starter[(((LoadInteger(Table___ht, (t), (forLoop + 1 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT ))))))]),s__QuestInstance_party[this]) // INLINED!!
                    set forLoop=forLoop + 1
                elseif (LoadInteger(Table___ht, (t), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) == - 121 then // INLINED!!
                    call print("Trigger Run")
                    call runTriggerForForce((s__Party_playerPool[(s__QuestInstance_party[this])]) , (LoadTriggerHandle(Table___ht, (((t))), (forLoop + 1 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT ))))) // INLINED!!
                    set forLoop=forLoop + 1
                else
                    call print("Error?")
                endif
                set forLoop=forLoop + 1
                exitwhen (LoadInteger(Table___ht, (t), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) == 0 // INLINED!!
            endloop
            //set p = null
            //set listOfQuests[listOfQuestsIndex].thisIndex = thisIndex
           // set listOfQuests[thisIndex] = listOfQuests[listOfQuestsIndex] 
            //set listOfQuests[listOfQuestsIndex] = 0
           // set listOfQuestsIndex = listOfQuestsIndex - 1
           // call progress.flush()
           // set playerNoob = null
            call s__QuestInstance_endQuest(this)
     //      call nextStage()
        endfunction
        
        function s__QuestInstance_checkFinish takes integer this returns nothing
            local integer forLoop= 0
            local integer f
            local integer t= ((Quest__questTable) + (s__QuestInstance_root[this])) // INLINED!!
            loop
                set f=(LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop))) // INLINED!!
                if f == - 2 or f == - 3 then
                    if (LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop + 2))) != Quest__KILL_FINISH then // INLINED!!
                        return
                    else
                        set forLoop=forLoop + 6
                    endif
                elseif f == - 1 then
                    if (LoadBoolean(Table___ht, (((s__QuestInstance_progress[this]))), (forLoop + 3))) == false then // INLINED!!
                        return
                    else
                        set forLoop=forLoop + 6
                    endif
                elseif f == - 4 then
                    if (LoadBoolean(Table___ht, (((s__QuestInstance_progress[this]))), (forLoop + 2))) == false then // INLINED!!
                        return
                    else
                        set forLoop=forLoop + 4
                    endif
                endif
                set forLoop=forLoop + 1
                if (LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop))) == Quest__STAGE_FINISH or (LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop))) == 0 then // INLINED!!
                    call s__QuestInstance_nextStage(this)
                    return
                endif
            endloop
        endfunction

        function s__QuestInstance_unitFulfill takes integer this,unit u,unit killer returns boolean
            local integer forLoop= 0
            local integer unitId
            if not s__Party_doesContainPlayer(s__QuestInstance_party[this],GetOwningPlayer(killer)) then
                return false
            endif
            set unitId=GetUnitTypeId(u)
            loop
                if (LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop))) == - 2 then // INLINED!!
                    if unitId == (LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop + 1))) and (LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop + 2))) != Quest__GLOBAL_FINISH then // INLINED!!
                        set s__QuestInstance_lastTrigger[this]=killer
                        set s___QuestInstance_lastTriggerUnit[s__QuestInstance_lastTriggerUnit[this]+GetPlayerId(GetOwningPlayer(killer))]=killer
                        call SaveInteger(Table___ht, (s__QuestInstance_currentProgress[this]), (forLoop), ( (LoadInteger(Table___ht, (s__QuestInstance_currentProgress[this]), (forLoop))) + 1)) // INLINED!!
                        if (LoadInteger(Table___ht, (s__QuestInstance_currentProgress[this]), (forLoop))) == (LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop + 2))) then // INLINED!!
                            call SaveInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop + 2), ( Quest__KILL_FINISH)) // INLINED!!
                            call TimedTextBoolean(Quest__MESSAGE_DURATION , s__Party_doesContainPlayer(s__QuestInstance_party[this],GetLocalPlayer()) , (LoadStr(Table___ht, (((s__QuestInstance_progress[this]))), (forLoop + 4)))) // INLINED!!
                            call s__QuestInstance_checkFinish(this)
                            return true
                        else
                            call TimedTextBoolean(Quest__MESSAGE_DURATION , s__Party_doesContainPlayer(s__QuestInstance_party[this],GetLocalPlayer()) , ReplaceString((LoadStr(Table___ht, (((s__QuestInstance_progress[this]))), (forLoop + 3))) , "$NUMB$" , 0 , I2S((LoadInteger(Table___ht, (s__QuestInstance_currentProgress[this]), (forLoop)))) + "/" + I2S((LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop + 2)))))) // INLINED!!
                            return true
                        endif
                    endif
                endif
                set forLoop=forLoop + 1
                exitwhen (LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop))) == Quest__STAGE_FINISH or (LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop))) == 0 // INLINED!!
            endloop
            return false
        endfunction
        function s__QuestInstance_itemFulfill takes integer this,item u,unit killer returns boolean
            local integer forLoop= 0
            local integer itemId= GetItemTypeId(u)
            if not s__Party_doesContainPlayer(s__QuestInstance_party[this],GetOwningPlayer(killer)) then
                return false
            endif
            loop
                if (LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop))) == - 3 then // INLINED!!
                    if itemId == (LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop + 1))) and (LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop + 2))) != Quest__KILL_FINISH then // INLINED!!
                        set s__QuestInstance_lastTrigger[this]=killer
                        set s___QuestInstance_lastTriggerUnit[s__QuestInstance_lastTriggerUnit[this]+GetPlayerId(GetOwningPlayer(killer))]=killer
                        if GetTotalItemCharges(killer , itemId) >= (LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop + 2))) then // INLINED!!
                            call ReduceItemCharges(killer , itemId , (LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop + 2)))) // INLINED!!
                            call SaveInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop + 2), ( Quest__KILL_FINISH)) // INLINED!!
                            call TimedTextBoolean(Quest__MESSAGE_DURATION , s__Party_doesContainPlayer(s__QuestInstance_party[this],GetLocalPlayer()) , (LoadStr(Table___ht, (((s__QuestInstance_progress[this]))), (forLoop + 4)))) // INLINED!!
                            call s__QuestInstance_checkFinish(this)
                        else
                            call TimedTextBoolean(Quest__MESSAGE_DURATION , s__Party_doesContainPlayer(s__QuestInstance_party[this],GetLocalPlayer()) , ReplaceString((LoadStr(Table___ht, (((s__QuestInstance_progress[this]))), (forLoop + 3))) , "$NUMB$" , 0 , I2S(GetTotalItemCharges(killer , itemId)) + "/" + I2S((LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop + 2)))))) // INLINED!!
                        endif
                        return true
                    endif
                endif
                set forLoop=forLoop + 1
                exitwhen (LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop))) == Quest__STAGE_FINISH // INLINED!!
            endloop
            return false
        endfunction        
        function s__QuestInstance_interactFulfill takes integer this,unit triggerUnit,widget victimUnit returns boolean
            local integer forLoop= 0
            if not s__Party_doesContainPlayer(s__QuestInstance_party[this],GetOwningPlayer(triggerUnit)) then
                return false
            endif
            loop
                if (LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop))) == - 1 then // INLINED!!
                    if GetHandleId(victimUnit) == (LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop + 1))) and (LoadBoolean(Table___ht, (((s__QuestInstance_progress[this]))), (forLoop + 3))) == false then // INLINED!!
                        set s__QuestInstance_lastTrigger[this]=triggerUnit
                        set s___QuestInstance_lastTriggerUnit[s__QuestInstance_lastTriggerUnit[this]+GetPlayerId(GetOwningPlayer(triggerUnit))]=triggerUnit
                        if (LoadStr(Table___ht, (((s__QuestInstance_progress[this]))), (forLoop + 2))) != null then // INLINED!!
                            call TimedTextBoolean(Quest__MESSAGE_DURATION , s__Party_doesContainPlayer(s__QuestInstance_party[this],GetLocalPlayer()) , (LoadStr(Table___ht, (((s__QuestInstance_progress[this]))), (forLoop + 2)))) // INLINED!!
                        endif
                        call SaveBoolean(Table___ht, (((s__QuestInstance_progress[this]))), (forLoop + 3), ( true)) // INLINED!!
                        call SetWidgetLife((LoadWidgetHandle(Table___ht, (((s__QuestInstance_progress[this]))), (forLoop + 4))), 0) // INLINED!!
                        call s__QuestInstance_checkFinish(this)
                        return true
                    else
                        set forLoop=forLoop + 6
                    endif
                endif
                set forLoop=forLoop + 1
                exitwhen (LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop))) == Quest__STAGE_FINISH or (LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop))) == 0 // INLINED!!
            endloop
            return false
        endfunction
        function s__QuestInstance_triggerFulfill takes integer this,trigger t returns boolean
            local integer forLoop= 0
            if not s__Party_doesContainPlayer(s__QuestInstance_party[this],applicablePlayer) then
                return false
            endif
            loop
                if (LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop))) == - 4 then // INLINED!!
                    if (LoadTriggerHandle(Table___ht, (((s__QuestInstance_progress[this]))), (forLoop + 1))) == t and (LoadBoolean(Table___ht, (((s__QuestInstance_progress[this]))), (forLoop + 2))) == false then // INLINED!!
                        call SaveBoolean(Table___ht, (((s__QuestInstance_progress[this]))), (forLoop + 2), ( true)) // INLINED!!
                        call s__QuestInstance_checkFinish(this)
                        return true
                    else
                        set forLoop=forLoop + 2
                    endif
                endif
                set forLoop=forLoop + 1
                exitwhen (LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop))) == Quest__STAGE_FINISH or (LoadInteger(Table___ht, (s__QuestInstance_progress[this]), (forLoop))) == 0 // INLINED!!
            endloop
            return false
        endfunction
            
        function s__QuestMain_onInteract takes nothing returns nothing
            local integer i= 0
            local unit t
            local widget k
            local boolean aCQ= false
            local boolean bCQ= false
            local player p
            set Quest_QUESTSYSTEM_RESPONSETYPE=8
            call TriggerEvaluate(Quest_QUESTSYSTEM_MAINTRIGGER)
            set k=Quest_QUESTSYSTEM_TEMPWIDGET
            if k == null then
                return
            endif
            set Quest_QUESTSYSTEM_RESPONSETYPE=7
            call TriggerEvaluate(Quest_QUESTSYSTEM_MAINTRIGGER)
            set t=Quest_QUESTSYSTEM_TEMPUNIT
            set p=GetOwningPlayer(t)
            loop
                if not aCQ then
                    if Quest__listOfQuests[i] != 0 then
                        if s__QuestInstance_interactFulfill(Quest__listOfQuests[i],t , k) then
                            exitwhen true
                        endif
                    else
                        set aCQ=true
                    endif
                endif
                if not bCQ then
                    if Quest__interactTable[i] != 0 then
                        if s__QuestInteractListener_onInteract(Quest__interactTable[i],k , p) then
                            exitwhen true
                        endif
                    else
                        set bCQ=true
                    endif
                endif
                exitwhen aCQ and bCQ
                set i=i + 1
            endloop
            set t=null
            set k=null
        endfunction
        function s__QuestMain_onUnitDeath takes nothing returns boolean
            local integer i= 0
            local unit u= GetTriggerUnit()
            local unit u2= GetKillingUnit()
            loop
                if Quest__listOfQuests[i] != null then
                    if s__QuestInstance_unitFulfill(Quest__listOfQuests[i],u , u2) then
                        set u=null
                        set u2=null
                        return false
                    endif
                else
                    exitwhen true
                endif
                set i=i + 1
            endloop
            set u=null
            set u2=null
            return false
        endfunction
        function s__QuestMain_onItemPickup takes nothing returns boolean
            local integer i= 0
            local item it= GetManipulatedItem()
            local unit u= GetTriggerUnit()
            if GetItemTypeId(it) == GetItemUserData(it) or GetItemTypeId(it) == 'I01Q' then
                set it=null
                set u=null
                return false
            endif
            loop
                if Quest__listOfQuests[i] != null then
                    if s__QuestInstance_itemFulfill(Quest__listOfQuests[i],it , u) then
                        exitwhen true
                    endif
                else
                    exitwhen true
                endif
                set i=i + 1
            endloop
            set it=null
            set u=null
            return false
        endfunction
        function s__QuestMain_onLevelUp takes nothing returns boolean
            local integer i= 0
            local player p= GetOwningPlayer(GetTriggerUnit())
            local integer lvl= GetHeroLevel(udg_PlayerUnit[GetPlayerId(p) + 1])
            loop
                exitwhen i == Quest__interactLevelTablePos
                call s__QuestInteractListener_lvlCheck((Quest__interactLevelTable[i]),lvl , p)
                set i=i + 1
            endloop
            return false
        endfunction
        function s__QuestMain_onInit takes nothing returns nothing
            local trigger t
            local integer fly_low= 50
            local integer fly_mid= 100
            local integer fly_high= 125
//textmacro instance: GotumLocals()
    local integer q1
    local integer q2
//end of: GotumLocals()
            local integer starterQuest
            local integer recipes
            local integer recipes2
            local integer temp
            local integer q
            
            set t=CreateTrigger()
            set Quest_QUESTSYSTEM_TEMPTRIGGER=t
            set Quest_QUESTSYSTEM_RESPONSETYPE=5
            if Quest_QUESTSYSTEM_MAINTRIGGER != null then
                call TriggerEvaluate(Quest_QUESTSYSTEM_MAINTRIGGER)
            endif
            call TriggerAddAction(t, function s__QuestMain_onInteract)
            set t=null
            set t=CreateTrigger()
            call TriggerRegisterAnyUnitEventBJ(t, EVENT_PLAYER_UNIT_DEATH)
            call TriggerAddCondition(t, Filter(function s__QuestMain_onUnitDeath))
            set t=null
            set t=CreateTrigger()
            call TriggerRegisterAnyUnitEventBJ(t, EVENT_PLAYER_UNIT_PICKUP_ITEM)
            call TriggerAddCondition(t, Filter(function s__QuestMain_onItemPickup))
            set t=null
            set t=CreateTrigger()
            call TriggerRegisterAnyUnitEventBJ(t, EVENT_PLAYER_HERO_LEVEL)
            call TriggerAddCondition(t, Filter(function s__QuestMain_onLevelUp))
            set t=null
//textmacro instance: GotumStarterQuests()

    set q1=s__QuestAPI_addItemType(s__QuestAPI_addStarterWithLvl(s__QuestAPI_create("Gotum: Lesser Potions of Healing"),3 , gg_unit_h00H_0310 , "|cff" + Quest__questColor + "Alchemist|r: Well hello again. Now that you are hooked on my potions, I am going to need some assistance. Can you collect some spider venom for me? I need some to make my potions." , "|cff" + Quest__questColor + "Alchemist|r: These are the same spiders that you killed for your bounty. Collect 10 vials of spider venom and bring them back to me"),'I02G' , 10 , "|cff" + Quest__questColor + "Spider Venom|r: $NUMB$" , "|cff" + Quest__questColor + "All Spider Venom collected|r" , 0 , 0)
    set t=CreateTrigger()
    call TriggerAddCondition(t, Filter(function s__CDS_StartSpiderVenom))
    call s__QuestAPI_addTriggerRun(q1,t)
    set t=CreateTrigger()
    call TriggerAddCondition(t, Filter(function s__CDS_EndSpiderVenom))
    call s__QuestAPI_addInteract(s__QuestAPI_startNextStage(s__QuestAPI_addTriggerRunIfDestroyed(q1,t),"|cff" + Quest__questColor + "Notice|r: Return to the Alchemist to claim your reward."),gg_unit_h00H_0310 , "|cff" + Quest__questColor + "Alchemist|r: Great! This will do nicely. You get the first batch!" , fly_high)
    call s__QuestAPI_addItemReward(s__QuestAPI_addExpReward(s__QuestAPI_addFinish(s__QuestAPI_addTriggerRun(q1,t)),300),'I02H' , 20)
    set t=null
    

//end of: GotumStarterQuests()
            set bountyQuest=s__QuestAPI_startNextStage(s__QuestAPI_addItemType(s__QuestAPI_addInteractQuestStarter(s__QuestAPI_create("Intro : Bounties"),gg_unit_h00B_0223 , false , "|cff" + Quest__questColor + "Bounty Agent:|r Hello! Looking to go out to kill some enemies? Doing a quest? Snag some bounties for whatever you're hunting for and you'll be leveling faster than ever" , "|cff" + Quest__questColor + "Bounty Agent:|r Okay, purchase a spider bounty from me and you can embark on your first adventure"),'I005' , 1 , "" , " " , 0 , 0),"|cff" + Quest__questColor + "Bounty Agent:|r To start the bounty, click on it. To turn it in, click on it again. Come to me when you have completed the bounty. Good luck on your first adventure!")
            
            
            set BountySystem___onComp=(s__QuestAPI_addTrigger(bountyQuest,0 , 0)) // INLINED!!
            
            call s__QuestAPI_addExpReward(s__QuestAPI_addFinish(bountyQuest),60)
            
            
            
            
            set recipes2=s__QuestAPI_addQuestEnableReward(s__QuestAPI_addExpReward(s__QuestAPI_addFinish(s__QuestAPI_addInteract(s__QuestAPI_startNextStage(s__QuestAPI_addItemType(s__QuestAPI_addItemType(s__QuestAPI_addInteractQuestStarter(s__QuestAPI_create("Intro : Alchemist"),gg_unit_h00H_0310 , false , "|cff" + Quest__questColor + "Alchemist|r : Hello. I sell potions. Would you like to buy one?" , "|cff" + Quest__questColor + "Alchemist|r : Excellent! Purchase 10 inferior health and mana potions"),'I01P' , 10 , "|cff" + Quest__questColor + "Progress:|r $NUMB$ Inferior Health Potions purchased" , "|cff" + Quest__questColor + "Progress|r : All inferior health potions purchased!" , 0 , 0),'I01T' , 10 , "|cff" + Quest__questColor + "Progress|r: $NUMB$ Inferior Mana Potions purchased" , "|cff" + Quest__questColor + "Progress:|r All inferior mana potions purchased" , 0 , 0),"|cff" + Quest__questColor + "Progress:|r Return to the Alchemist for your reward"),gg_unit_h00H_0310 , "|cff" + Quest__questColor + "Alchemist|r : Excellent! Talk to the bounty agent for your first adventure" , 0)),60),bountyQuest)
            
            
            set recipes=s__QuestAPI_addInteractQuestStarter(s__QuestAPI_startNextStage(s__QuestAPI_addItemType(s__QuestAPI_create("Intro : Blacksmith"),'I006' , 0 , "ERROR" , " " , 0 , 0),"|cff" + Quest__questColor + "Blacksmith |r: Great! Now. Go into your inventory and take off a piece of starting gear along with your recipe and the scrap I gave you and put them in the recipe area and double click the recipe"),gg_unit_h00C_0139 , false , "|cff" + Quest__questColor + "Quest Description|r : Hello, In this village I am the master of crafting. I can tell you everything you need to know about upgrading your basic gear.\n\n|cff" + Quest__questColor + "Goal|r : Combine your weak iron scraps with my Gotum Gear + recipe and one of your pieces of gear to form an upgraded piece of gear.\n\n|cff" + Quest__questColor + "Information|r : To combine items, open your inventory and put all three items in the area to the right of your equipment and double click the recipe. The new item will be sent to your inventory\n\n|cff" + Quest__questColor + "Talk to me again to accept this quest" , "|cff" + Quest__questColor + "Blacksmith|r : Buy a Gotum + recipe from me to combine your recipe and move to the next stage")
            
            set s__CustomInventory_onRecipe=(s__QuestAPI_addTrigger(recipes,0 , 0)) // INLINED!!
            call s__QuestAPI_addQuestEnableReward(s__QuestAPI_addGoldReward(s__QuestAPI_addExpReward(s__QuestAPI_addFinish(recipes),100),200),recipes2)
            
           // set RECIPES_trigger = 
            
            set starterQuest=s__QuestAPI_addInteractQuestStarter(s__QuestAPI_addQuestEnableReward(s__QuestAPI_addExpReward(s__QuestAPI_addItemReward(s__QuestAPI_addFinish(s__QuestAPI_addInteract(s__QuestAPI_startNextStage(s__QuestAPI_addInteract(s__QuestAPI_addInteract(s__QuestAPI_addInteract(s__QuestAPI_addInteract(s__QuestAPI_create("Intro : Introductions"),gg_unit_h00D_0307 , "|cff" + Quest__questColor + "Ship Captain|r : Good day. When you are ready to leave Elohim, I am the person you will talk to." , fly_low),gg_unit_h00C_0139 , "|cff" + Quest__questColor + "Blacksmith|r : Hello. My job in this town is to sell building manuscripts and recipes." , fly_low),gg_unit_h00B_0223 , "|cff" + Quest__questColor + "Bounty Agent|r Hello. My job is to sell bounties to adventurers. If you are going on a quest you should grab bounties to maximize your time." , fly_high),gg_unit_h00H_0310 , "|cff" + Quest__questColor + "Alchemist|r : Hello, I am the Alchemist. My job in town is to sell potions and other chemical creation formulas." , fly_mid),"|cff" + Quest__questColor + "Information|r : Talk to the woman to complete your quest"),gg_unit_h00L_0367 , "|cff" + Quest__questColor + "Woman|r : Have you acquainted yourself with the membersof the town? Good. Here are some iron scraps, talk to the Blacksmith about using and upgrading gear" , fly_low)),'I00U' , 0),60),recipes),gg_unit_h00L_0367 , true , "|cff" + Quest__questColor + "Quest Description|r : I would like you walk around town and talk to the villagers\n\n|cff" + Quest__questColor + "Goal|r \n     - Talk to the Ship Captain\n     - Talk to the Blacksmith \n     - Talk to the Bounty Agent\n     - Talk to the Alchemist\n\n|cff" + Quest__questColor + "Reward|r : 150 Gold, 500 EXP, Quest 'Alchemy'\n\n|cff" + Quest__questColor + "Hint|r : The Ship Captain is located in the topleft of the village, the Blacksmith is located in the mid-top of the village, the Bounty Agent islocated at the entrance of the forest, and the Alchemist is located in the bottomright of the village.\n\n|cff" + Quest__questColor + "Talk to me again to accept this quest|r" , "Quest |cff" + Quest__questColor + "Introductions|r accepted|r")
            
            
            //call starterQuest.start(Player(0))
        endfunction
    function Quest__init takes nothing returns nothing
        call s__QuestAPI_create(" ")
        call s__QuestInteractListener_create(0 , null , "" , "" , "" , false)
    endfunction

//library Quest ends
//library TempCatalog:
        
        function s__TempCatalog_destroyer takes nothing returns nothing
            loop
                set s__TempCatalog_recc=s__TempCatalog_recc - 1
                call CatalogDestroy(s__TempCatalog_rec[s__TempCatalog_recc])
                exitwhen 0 == s__TempCatalog_recc
            endloop
        endfunction
        
        function s__TempCatalog_create takes nothing returns integer
            local integer catalog= (CatalogCreate()) // INLINED!!
        
            set s__TempCatalog_rec[s__TempCatalog_recc]=catalog
            set s__TempCatalog_recc=s__TempCatalog_recc + 1
            call TimerStart(s__TempCatalog_dest, 0, false, function s__TempCatalog_destroyer)
            
            return catalog
        endfunction

//library TempCatalog ends
//library TriggerRefresh:

//library TriggerRefresh ends
//library UnitEvent:


//library UnitEvent ends
//library WordWrap:
 
 
function s__WordWrap_getLine takes integer l__index returns string
            return s__WordWrap_line[l__index]
        endfunction
        
        function s__WordWrap_getCount takes nothing returns integer
            return s__WordWrap_count
        endfunction
        
        function s__WordWrap_preserveColor takes nothing returns nothing
            local integer i= 0
            local integer k= 0
            local integer l= 0
            local string temp= ""
            local string hex= ""
            local boolean carryOn= false
            loop
                exitwhen i == s__WordWrap_count
                set carryOn=false
                set hex=""
                set k=0
                set l=StringLength(s__WordWrap_line[i])
                loop
                    exitwhen k == l
                    set temp=SubString(s__WordWrap_line[i], k, k + 1)
                    if temp == "|" then
                        set temp=SubString(s__WordWrap_line[i], k + 1, k + 2)
                        if temp == "c" then
                            set hex=SubString(s__WordWrap_line[i], k, k + 10)
                            set carryOn=true
                        elseif temp == "r" then
                            set carryOn=false
                        endif
                    endif
                    set k=k + 1
                endloop
                set i=i + 1
                if carryOn then
                    set s__WordWrap_line[i]=hex + s__WordWrap_line[i]
                endif
            endloop
        endfunction
        
        function s__WordWrap_create takes string source,real size,boolean preserveColors returns integer
            local integer l= StringLength(source)
            local integer i= 0
            local integer k= 0
            local string s
            
            local string word
            local real result= 0
            local real ssize= 0
            
            loop
                exitwhen s__WordWrap_count == 0
                set s__WordWrap_count=s__WordWrap_count - 1
                set s__WordWrap_line[s__WordWrap_count]=""
            endloop
            loop
                exitwhen i == l
                set s=SubString(source, i, i + 1)
                if s == " " or i == ( l - 1 ) then
                    set word=SubString(source, k, i) + s
                    set ssize=(s__StringSize_measure((word))) // INLINED!!
                    set result=result + ssize
                    if result <= size then
                        set s__WordWrap_line[s__WordWrap_count]=s__WordWrap_line[s__WordWrap_count] + word
                    else
                        set s__WordWrap_count=s__WordWrap_count + 1
                        set s__WordWrap_line[s__WordWrap_count]=word
                        set result=ssize
                    endif
                    set k=i + 1
                endif
                set i=i + 1
            endloop
            set s__WordWrap_count=s__WordWrap_count + 1
            if preserveColors then
                call ForForce(bj_FORCE_PLAYER[0], function s__WordWrap_preserveColor)
            endif
            return 0
        endfunction
 
    function WordWrapString takes string source,real sizeMargin,boolean preserveColors returns nothing
        call s__WordWrap_create(source , sizeMargin , preserveColors)
    endfunction
 
    function GetWrappedStringFragment takes integer i returns string
        return (s__WordWrap_line[(i)]) // INLINED!!
    endfunction
 
    function GetWrappedStringCount takes nothing returns integer
        return (s__WordWrap_count) // INLINED!!
    endfunction
 

//library WordWrap ends
//library DDS:

    

//textmacro instance: DAMAGE_EVENT_CODE()
// scope DDS_DamageEvent begins
        
        

        



        
// scope DDS_DamageEvent ends
//end of: DAMAGE_EVENT_CODE()
//textmacro instance: DAMAGE_EVENT_MODIFICATION_CODE()
// scope DDS_DamageEventModification begins
        
        function DDS_DamageEventModification___OnAfterDamage takes nothing returns nothing
            local integer i= DDS_DamageEventModification___stackCount
            local integer u
            
            loop
                set i=i - 1
                
                set u=DDS_DamageEventModification___id[i]
                
                call RemoveMaxLife(u)
                set DDS___saved[u]=false
                
                exitwhen 0 == i
            endloop
            
            set DDS_DamageEventModification___stackCount=0
        endfunction
        
        function DDS_DamageEventModification___AddAfterDamage takes integer whichUnit returns nothing
            if ( not DDS___saved[whichUnit] ) then
                set DDS___saved[whichUnit]=true
                
                set DDS_DamageEventModification___id[DDS_DamageEventModification___stackCount]=whichUnit
                set DDS_DamageEventModification___index[whichUnit]=DDS_DamageEventModification___stackCount
                set DDS_DamageEventModification___stackCount=DDS_DamageEventModification___stackCount + 1
                
                call TimerStart(DDS_DamageEventModification___afterDamageTimer, 0, false, function DDS_DamageEventModification___OnAfterDamage)
                
                call ApplyMaxLife(whichUnit)
            endif
        endfunction
        
        function DDS_DamageEventModification___RemoveAfterDamage takes integer whichUnit returns nothing
            if ( DDS___saved[whichUnit] ) then
                set DDS___saved[whichUnit]=false
                
                call RemoveMaxLife(whichUnit)
                
                set DDS_DamageEventModification___stackCount=DDS_DamageEventModification___stackCount - 1
                set DDS_DamageEventModification___id[DDS_DamageEventModification___index[whichUnit]]=DDS_DamageEventModification___id[DDS_DamageEventModification___stackCount]
                set DDS_DamageEventModification___index[DDS_DamageEventModification___id[DDS_DamageEventModification___stackCount]]=DDS_DamageEventModification___index[whichUnit]
                
                if ( DDS_DamageEventModification___stackCount == 0 ) then
                    call PauseTimer(DDS_DamageEventModification___afterDamageTimer)
                endif
            endif
        endfunction
    
        

        

        
        
            function s__DDS_DamageEventModification___OnDeath_onDeath takes nothing returns nothing
                call DDS_DamageEventModification___RemoveAfterDamage(GetUnitUserData(GetTriggerUnit()))
            endfunction
        
            function s__DDS_DamageEventModification___OnDeath_init takes nothing returns nothing
                call RegisterPlayerUnitEvent(EVENT_PLAYER_UNIT_DEATH , function s__DDS_DamageEventModification___OnDeath_onDeath)
            endfunction
            
//Implemented from module DDS_DamageEventModification___Init:
            function s__DDS_DamageEventModification___OnDeath_DDS_DamageEventModification___Init___onInit takes nothing returns nothing
                call RegisterPlayerUnitEvent(EVENT_PLAYER_UNIT_DEATH , function s__DDS_DamageEventModification___OnDeath_onDeath) // INLINED!!
            endfunction
            function s__DDS_DamageEventModification___Deindex_deindex takes integer this returns nothing
                call DDS_DamageEventModification___RemoveAfterDamage(this)
            endfunction
        
//Implemented from module UnitIndexStruct:
        function s__DDS_DamageEventModification___Deindex__staticgetindex takes unit u returns integer
            return GetUnitUserData(u)
        endfunction
        function s__DDS_DamageEventModification___Deindex__get_unit takes integer this returns unit
            return UnitIndexer___e[this]
        endfunction
        























            function s__DDS_DamageEventModification___Deindex__get_allocated takes integer this returns boolean
                return this == GetUnitUserData(UnitIndexer___e[this])
            endfunction




















            function s__DDS_DamageEventModification___Deindex_UnitIndexStruct___onDeindexEvent takes nothing returns boolean















                    call DDS_DamageEventModification___RemoveAfterDamage(((UnitIndexer___o))) // INLINED!!

                return false
            endfunction













            function s__DDS_DamageEventModification___Deindex_UnitIndexStruct___onInit takes nothing returns nothing
                call RegisterUnitIndexEvent(Condition(function s__DDS_DamageEventModification___Deindex_UnitIndexStruct___onDeindexEvent) , s__UnitIndexer_DEINDEX)
            endfunction

// scope DDS_DamageEventModification ends
//end of: DAMAGE_EVENT_MODIFICATION_CODE()
//textmacro instance: DAMAGE_EVENT_ARCHETYPE_CODE()
    
// scope DDS_Archetype begins
            
            
    
        

        

        
// scope DDS_Archetype ends
//end of: DAMAGE_EVENT_ARCHETYPE_CODE()
//ignored textmacro command: DAMAGE_EVENT_UNIT_MODIFICATION_CODE()
    
        function s__DDS__get_enabled takes integer this returns boolean
            return IsTriggerEnabled(s__DDS___Trigger_trigger[s__DDS___Trigger_parent[(this)]])
        endfunction









//Implemented from module DAMAGE_EVENT_ENABLE:
                function s__DDS__set_enabled takes integer this,boolean b returns nothing
                    if ( b ) then
                        call EnableTrigger(s__DDS___Trigger_trigger[s__DDS___Trigger_parent[(this)]])
                        call UnitAddAbility((UnitIndexer___e[((this))]), DAMAGE_EVENT_ARCHETYPE_PLUGIN_ABILITY) // INLINED!!
                        call UnitMakeAbilityPermanent((UnitIndexer___e[((this))]), true, DAMAGE_EVENT_ARCHETYPE_PLUGIN_ABILITY) // INLINED!!
                    else
                        call DisableTrigger(s__DDS___Trigger_trigger[s__DDS___Trigger_parent[(this)]])
                        call UnitRemoveAbility((UnitIndexer___e[((this))]), DAMAGE_EVENT_ARCHETYPE_PLUGIN_ABILITY) // INLINED!!
                    endif
                endfunction

    
//Implemented from module DDS___DAMAGE_EVENT_API:




            
            
            function s__DDS__get_targetId takes nothing returns integer
                return s__DDS_DDS___targetId_p
            endfunction
            function s__DDS__get_target takes nothing returns unit
                return (UnitIndexer___e[((s__DDS_DDS___targetId_p))]) // INLINED!!
            endfunction
            
            function s__DDS__get_sourceId takes nothing returns integer
                return s__DDS_DDS___sourceId_p
            endfunction
            function s__DDS__get_source takes nothing returns unit
                return (UnitIndexer___e[((s__DDS_DDS___sourceId_p))]) // INLINED!!
            endfunction
            
            function s__DDS__get_damage takes nothing returns real
                return s__DDS_DDS___damage_p
            endfunction
            
            function s__DDS__get_sourcePlayer takes nothing returns player
                return s__DDS_DDS___sourcePlayer_p
            endfunction
            
            function s__DDS_DDS_DamageEvent___damageEventInit takes nothing returns nothing

                    set s__DDS_ANY=s__PriorityEvent_create()



            endfunction
//Implemented from module DDS___DAMAGE_EVENT_MODIFICATION_API:
            
            function s__DDS__set_damage takes real newDamage returns nothing
                set s__DDS_DDS___damage_p=newDamage
            endfunction
            function s__DDS__get_damageModifiedAmount takes nothing returns real
                return s__DDS_DDS___damage_p - s__DDS_damageOriginal
            endfunction
            function s__DDS__get_life takes nothing returns real
                return GetUnitLife(s__DDS_DDS___targetId_p)
            endfunction
//Implemented from module DDS___DAMAGE_EVENT_ARCHETYPE_API:
                
                function s__DDS__set_damageCode takes integer u returns nothing
                    set s__DDS_DDS_Archetype___damageCode_p=u
                endfunction
                function s__DDS__get_damageCode takes nothing returns integer
                    return s__DDS_DDS_Archetype___damageCode_p
                endfunction
                
                function s__DDS__get_archetype takes nothing returns integer
                    return s__DDS_DDS_Archetype___archetype_p
                endfunction
                
                function s__DDS_DDS___DAMAGE_EVENT_ARCHETYPE_API___onIndex takes nothing returns boolean
                    call UnitAddAbility((UnitIndexer___e[UnitIndexer___o]), DAMAGE_EVENT_ARCHETYPE_PLUGIN_ABILITY) // INLINED!!
                    call UnitMakeAbilityPermanent((UnitIndexer___e[UnitIndexer___o]), true, DAMAGE_EVENT_ARCHETYPE_PLUGIN_ABILITY) // INLINED!!
                    
                    return false
                endfunction
                
                function s__DDS_DDS_Archetype___damageEventArchetypeInit takes nothing returns nothing
                    local integer playerId
            
                    set playerId=15
                    loop
                        call SetPlayerAbilityAvailable(Player(playerId), DAMAGE_EVENT_ARCHETYPE_PLUGIN_ABILITY, false)
                        
                        exitwhen 0 == playerId
                        set playerId=playerId - 1
                    endloop
                
                    call RegisterUnitIndexEvent(Condition(function s__DDS_DDS___DAMAGE_EVENT_ARCHETYPE_API___onIndex) , s__UnitIndexer_INDEX)
                endfunction
    
        function s__DDS_DDS___DDS_onDamage takes nothing returns nothing
//Implemented from module DDS___DAMAGE_EVENT_RESPONSE_LOCALS:
                local integer prevTarget= s__DDS_DDS___targetId_p
                local integer prevSource= s__DDS_DDS___sourceId_p
                
                local real prevDamage= s__DDS_DDS___damage_p
//Implemented from module DDS___DAMAGE_EVENT_MODIFICATION_RESPONSE_LOCALS:
                local real actualDamage
                local real prevDamageOriginal= s__DDS_damageOriginal
                local real life
                local unit u
//Implemented from module DDS___DAMAGE_EVENT_ARCHETYPE_RESPONSE_LOCALS:
                local integer prevArchetype= s__DDS_DDS_Archetype___archetype_p
            
//Implemented from module DDS___DAMAGE_EVENT_RESPONSE_BEFORE:
                set s__DDS_DDS___targetId_p=GetUnitUserData(GetTriggerUnit())
                set s__DDS_DDS___sourceId_p=GetUnitUserData(GetEventDamageSource())
                set s__DDS_DDS___damage_p=GetEventDamage()
                set s__DDS_DDS___sourcePlayer_p=GetOwningPlayer((UnitIndexer___e[(s__DDS_DDS___sourceId_p)])) // INLINED!!
//Implemented from module DDS___DAMAGE_EVENT_MODIFICATION_RESPONSE_BEFORE:
                set actualDamage=s__DDS_DDS___damage_p
                set s__DDS_damageOriginal=actualDamage //original damage as seen by user
                set u=(UnitIndexer___e[(s__DDS_DDS___targetId_p)]) // INLINED!!
//Implemented from module DDS___DAMAGE_EVENT_ARCHETYPE_RESPONSE_BEFORE:
                if DAMAGE_EVENT_REQUEST_TYPE == 7 then
                    return
                elseif DAMAGE_EVENT_REQUEST_TYPE == 4 then
                    set s__DDS_DDS_Archetype___archetype_p=s__DDS_Archetype___DamageEventArchtype_HEAL
                elseif ( s__DDS_DDS___damage_p < 0 ) or DAMAGE_EVENT_REQUEST_TYPE == s__DDS_Archetype___DamageEventArchtype_SPELL then
                    set s__DDS_DDS_Archetype___archetype_p=s__DDS_Archetype___DamageEventArchtype_SPELL
                    if DAMAGE_EVENT_REQUEST_TYPE != s__DDS_Archetype___DamageEventArchtype_SPELL then
                        
                        call DisableTrigger(s__DDS___Trigger_trigger[s__DDS___Trigger_parent[(s__DDS_DDS___targetId_p)]])
                        
                            set life=GetWidgetLife(u)
                            set DDS___scale=GetUnitState(u, UNIT_STATE_MAX_LIFE)
                            call SetWidgetLife(u, DDS___scale)
                            call UnitDamageTarget(u, u, - DDS___scale / 2, false, false, null, DAMAGE_TYPE_UNIVERSAL, null)
                            set DDS___scale=2 * ( DDS___scale - GetWidgetLife(u) ) / DDS___scale
                            if ( DDS___scale > 1 ) then
                                set s__DDS_damageOriginal=- s__DDS_damageOriginal * DDS___scale
                            else
                                set s__DDS_damageOriginal=- s__DDS_damageOriginal
                            endif
                            call SetWidgetLife(u, life)
                        
                        call EnableTrigger(s__DDS___Trigger_trigger[s__DDS___Trigger_parent[(s__DDS_DDS___targetId_p)]])
                        
                        set s__DDS_DDS___damage_p=s__DDS_damageOriginal
                    endif
                elseif ( s__DDS_DDS_Archetype___damageCode_p != 0 ) or DAMAGE_EVENT_REQUEST_TYPE == s__DDS_Archetype___DamageEventArchtype_CODE then
                    set s__DDS_DDS_Archetype___archetype_p=s__DDS_Archetype___DamageEventArchtype_CODE
                    set s__DDS_DDS_Archetype___damageCode_p=0
                elseif DAMAGE_EVENT_REQUEST_TYPE == 3 then
                    set s__DDS_DDS_Archetype___archetype_p=s__DDS_Archetype___DamageEventArchtype_DOT
                elseif DAMAGE_EVENT_REQUEST_TYPE == 6 then
                    set s__DDS_DDS_Archetype___archetype_p=s__DDS_Archetype___DamageEventArchtype_AGGRO
                else
                    set s__DDS_DDS_Archetype___archetype_p=s__DDS_Archetype___DamageEventArchtype_PHYSICAL
                endif
                    set DAMAGE_EVENT_REQUEST_TYPE=- 1
            
//Implemented from module DDS___DAMAGE_EVENT_RESPONSE:
                call s__PriorityEvent_fire(s__DDS_ANY)
//Implemented from module DDS___DAMAGE_EVENT_MODIFICATION_RESPONSE:
                
//Implemented from module DDS___DAMAGE_EVENT_ARCHETYPE_RESPONSE:
                
            
//Implemented from module DDS___DAMAGE_EVENT_RESPONSE_AFTER:
                
//Implemented from module DDS___DAMAGE_EVENT_MODIFICATION_RESPONSE_AFTER:
                set life=GetUnitLife(s__DDS_DDS___targetId_p)
                
                if ( life - s__DDS_DDS___damage_p < .4051 ) then
                    call DDS_DamageEventModification___RemoveAfterDamage(s__DDS_DDS___targetId_p)
                    
                    if ( actualDamage < 0 ) then
                        call s__DDS__set_enabled((s__DDS_DDS___targetId_p),false)
                        
                        call SetUnitX(DDS_DamageEventModification___killUnit, GetUnitX(u))
                        call SetUnitY(DDS_DamageEventModification___killUnit, GetUnitY(u))
                        call SetUnitOwner(DDS_DamageEventModification___killUnit, s__DDS_DDS___sourcePlayer_p, false)
                        
                        call SetWidgetLife(u, s__DDS_damageOriginal)
                        call UnitDamageTarget(DDS_DamageEventModification___killUnit, u, s__DDS_damageOriginal * 100, true, false, null, DAMAGE_TYPE_UNIVERSAL, null)
                        call SetWidgetLife(u, s__DDS_damageOriginal)
                        call UnitDamageTarget(DDS_DamageEventModification___killUnit, u, s__DDS_damageOriginal * 100, true, false, null, DAMAGE_TYPE_NORMAL, null)
                        
                        call s__DDS__set_enabled((s__DDS_DDS___targetId_p),true)
                    else
                        call SetWidgetLife(u, actualDamage)
                    endif
                elseif ( DDS___saved[s__DDS_DDS___targetId_p] ) then
                    call AddUnitTargetLife(s__DDS_DDS___targetId_p , - s__DDS_DDS___damage_p)
                    
                    if ( actualDamage > 0 ) then
                        call SetWidgetLife(u, GetWidgetLife(u) + actualDamage)
                    endif
                elseif ( actualDamage < 0 ) then
                    if ( life + actualDamage - s__DDS_DDS___damage_p < .406 ) then
                        call DDS_DamageEventModification___AddAfterDamage(s__DDS_DDS___targetId_p)
                        call AddUnitTargetLife(s__DDS_DDS___targetId_p , - s__DDS_DDS___damage_p)
                    else
                        call SetWidgetLife(u, life + actualDamage - s__DDS_DDS___damage_p)
                    endif
                else
                    if ( life + actualDamage - s__DDS_DDS___damage_p > GetUnitState(u, UNIT_STATE_MAX_LIFE) ) then
                        call DDS_DamageEventModification___AddAfterDamage(s__DDS_DDS___targetId_p)
                        call AddUnitTargetLife(s__DDS_DDS___targetId_p , - s__DDS_DDS___damage_p)
                        call SetWidgetLife(u, GetWidgetLife(u) + actualDamage)
                    else
                        call SetWidgetLife(u, life + actualDamage - s__DDS_DDS___damage_p)
                    endif
                endif
//Implemented from module DDS___DAMAGE_EVENT_ARCHETYPE_RESPONSE_AFTER:
                
            
//Implemented from module DDS___DAMAGE_EVENT_RESPONSE_CLEANUP:
                set s__DDS_DDS___targetId_p=prevTarget
                set s__DDS_DDS___sourceId_p=prevSource
                set s__DDS_DDS___damage_p=prevDamage
                set s__DDS_DDS___sourcePlayer_p=GetOwningPlayer((UnitIndexer___e[(s__DDS_DDS___sourceId_p)])) // INLINED!!
//Implemented from module DDS___DAMAGE_EVENT_MODIFICATION_RESPONSE_CLEANUP:
                set s__DDS_damageOriginal=prevDamageOriginal
                set u=null
//Implemented from module DDS___DAMAGE_EVENT_ARCHETYPE_RESPONSE_CLEANUP:
                set s__DDS_DDS_Archetype___archetype_p=prevArchetype
        endfunction
    

//textmacro instance: TRIGGER_REFRESH("TRIGGER_SIZE", "EVENT_UNIT_DAMAGED", "function DDS.DDS_onDamage")
// scope DDS_TriggerRefresh begins
        
        
            
            
            
            function s__DDS___Trigger_registerUnit takes integer this,integer whichUnit returns boolean
                if ( s__DDS___Trigger_activeUnits[this] < DDS___TRIGGER_SIZE ) then
                    call TriggerRegisterUnitEvent(s__DDS___Trigger_trigger[this], (UnitIndexer___e[(whichUnit)]), EVENT_UNIT_DAMAGED) // INLINED!!
                    set s__DDS___Trigger_activeUnits[this]=s__DDS___Trigger_activeUnits[this] + 1
                    
                    return true
                endif
                
                return false
            endfunction
            function s__DDS___Trigger_unregisterUnit takes integer this returns nothing
                set s__DDS___Trigger_inactiveUnits[this]=s__DDS___Trigger_inactiveUnits[this] + 1
                set s__DDS___Trigger_activeUnits[this]=s__DDS___Trigger_activeUnits[this] - 1
            endfunction
            
            function s__DDS___Trigger_createTrigger takes integer this returns nothing
                set s__DDS___Trigger_trigger[this]=CreateTrigger()
                call TriggerAddCondition(s__DDS___Trigger_trigger[this], DDS_TriggerRefresh___condition)
            endfunction
            function s__DDS___Trigger_remakeTrigger takes integer this returns nothing
                call DestroyTrigger(s__DDS___Trigger_trigger[this])
                call s__DDS___Trigger_createTrigger(this)
            endfunction
            function s__DDS___Trigger_rebuildTrigger takes integer this returns nothing
                local integer current= s__DDS___Trigger_first[this]
                
                call s__DDS___Trigger_remakeTrigger(this)
                
                
                set s__DDS___Trigger_next[s__DDS___Trigger_prev[current]]=0
                loop
                    exitwhen 0 == current
                    call TriggerRegisterUnitEvent(s__DDS___Trigger_trigger[this], (UnitIndexer___e[(current)]), EVENT_UNIT_DAMAGED) // INLINED!!
                    set current=s__DDS___Trigger_next[current]
                endloop
                set s__DDS___Trigger_next[s__DDS___Trigger_prev[s__DDS___Trigger_first[this]]]=current
            endfunction
            
            function s__DDS___Trigger_remake takes integer this returns nothing
                if ( s__DDS___Trigger_inactiveUnits[this] == DDS___TRIGGER_SIZE ) then
                    set s__DDS___Trigger_inactiveUnits[this]=0
                    call s__DDS___Trigger_rebuildTrigger(this)
                endif
            endfunction
            
            function s__DDS___Trigger_addToList takes integer this,integer whichUnit returns nothing
                set s__DDS___Trigger_parent[whichUnit]=this
            
                if ( 0 == s__DDS___Trigger_first[this] ) then
                    set s__DDS___Trigger_first[this]=whichUnit
                    set s__DDS___Trigger_next[whichUnit]=whichUnit
                    set s__DDS___Trigger_prev[whichUnit]=whichUnit
                else
                    set this=s__DDS___Trigger_first[this]
                    
                    set s__DDS___Trigger_prev[whichUnit]=s__DDS___Trigger_prev[this]
                    set s__DDS___Trigger_next[whichUnit]=this
                    set s__DDS___Trigger_next[s__DDS___Trigger_prev[this]]=whichUnit
                    set s__DDS___Trigger_prev[this]=whichUnit
                endif
            endfunction
            function s__DDS___Trigger_add takes integer this,integer whichUnit returns boolean
                if ( 0 == this ) then
                    return false
                endif
            
                if ( s__DDS___Trigger_registerUnit(this,whichUnit) ) then
                    call s__DDS___Trigger_addToList(this,whichUnit)
                    
                    return true
                endif
                
                return false
            endfunction
            
            function s__DDS___Trigger_removeFromList takes integer this,integer whichUnit returns nothing
                set s__DDS___Trigger_parent[whichUnit]=0
            
                set s__DDS___Trigger_next[s__DDS___Trigger_prev[whichUnit]]=s__DDS___Trigger_next[whichUnit]
                set s__DDS___Trigger_prev[s__DDS___Trigger_next[whichUnit]]=s__DDS___Trigger_prev[whichUnit]
                
                if ( s__DDS___Trigger_first[this] == whichUnit ) then
                    set s__DDS___Trigger_first[this]=s__DDS___Trigger_next[whichUnit]
                    if ( s__DDS___Trigger_first[this] == whichUnit ) then
                        set s__DDS___Trigger_first[this]=0
                    endif
                endif
            endfunction
            function s__DDS___Trigger_remove takes integer whichUnit returns nothing
                local integer this= s__DDS___Trigger_parent[whichUnit]
            
                call s__DDS___Trigger_removeFromList(this,whichUnit)
                call s__DDS___Trigger_unregisterUnit(this)
                call s__DDS___Trigger_remake(this)
            endfunction
            
            function s__DDS___Trigger_allocate takes nothing returns integer
                set s__DDS___Trigger_instanceCount=s__DDS___Trigger_instanceCount + 1
                return s__DDS___Trigger_instanceCount
            endfunction
            function s__DDS___Trigger_create takes nothing returns integer
                local integer this= s__DDS___Trigger_allocate()
                
                call s__DDS___Trigger_createTrigger(this)
                
                return this
            endfunction
        
            
            function s__DDS_TriggerRefresh___TriggerHeapInner_bubbleUp takes integer this returns nothing
                local integer activeUnits= s__DDS___Trigger_activeUnits[(this)]
                local integer heapPosition= s__DDS_TriggerRefresh___TriggerHeapInner_heap[this]
                
                local integer parent
                
                
                loop
                    set parent=heapPosition / 2
                    
                    if ( (parent) != 0 and activeUnits < s__DDS___Trigger_activeUnits[(s__DDS_TriggerRefresh___TriggerHeapInner_node[parent])] ) then
                        set s__DDS_TriggerRefresh___TriggerHeapInner_node[heapPosition]=s__DDS_TriggerRefresh___TriggerHeapInner_node[parent]
                        set s__DDS_TriggerRefresh___TriggerHeapInner_heap[s__DDS_TriggerRefresh___TriggerHeapInner_node[heapPosition]]=heapPosition
                    else
                        exitwhen true
                    endif
                    
                    set heapPosition=parent
                endloop
                
                
                set s__DDS_TriggerRefresh___TriggerHeapInner_node[heapPosition]=this
                set s__DDS_TriggerRefresh___TriggerHeapInner_heap[this]=heapPosition
            endfunction
            function s__DDS_TriggerRefresh___TriggerHeapInner_bubbleDown takes integer this returns nothing
                local integer activeUnits= s__DDS___Trigger_activeUnits[(this)]
                local integer heapPosition= s__DDS_TriggerRefresh___TriggerHeapInner_heap[this]
                
                local integer left
                local integer right
                
                
                loop
                    set left=heapPosition * 2
                    set right=left + 1
                    
                    if ( s__DDS___Trigger_activeUnits[(s__DDS_TriggerRefresh___TriggerHeapInner_node[left])] < activeUnits and s__DDS___Trigger_activeUnits[(s__DDS_TriggerRefresh___TriggerHeapInner_node[left])] < s__DDS___Trigger_activeUnits[(s__DDS_TriggerRefresh___TriggerHeapInner_node[right])] ) then
                        
                        set s__DDS_TriggerRefresh___TriggerHeapInner_node[heapPosition]=s__DDS_TriggerRefresh___TriggerHeapInner_node[left]
                        set s__DDS_TriggerRefresh___TriggerHeapInner_heap[s__DDS_TriggerRefresh___TriggerHeapInner_node[heapPosition]]=heapPosition
                        set heapPosition=left
                    elseif ( s__DDS___Trigger_activeUnits[(s__DDS_TriggerRefresh___TriggerHeapInner_node[right])] < activeUnits ) then
                        
                        set s__DDS_TriggerRefresh___TriggerHeapInner_node[heapPosition]=s__DDS_TriggerRefresh___TriggerHeapInner_node[right]
                        set s__DDS_TriggerRefresh___TriggerHeapInner_heap[s__DDS_TriggerRefresh___TriggerHeapInner_node[heapPosition]]=heapPosition
                        set heapPosition=right
                    else
                        exitwhen true
                    endif
                endloop
                
                
                set s__DDS_TriggerRefresh___TriggerHeapInner_node[heapPosition]=this
                set s__DDS_TriggerRefresh___TriggerHeapInner_heap[this]=heapPosition
            endfunction
            
            function s__DDS_TriggerRefresh___TriggerHeapInner_insert takes integer this returns nothing
                
                set s__DDS_TriggerRefresh___TriggerHeapInner_size=s__DDS_TriggerRefresh___TriggerHeapInner_size + 1
                
                
                set s__DDS_TriggerRefresh___TriggerHeapInner_node[(s__DDS_TriggerRefresh___TriggerHeapInner_size)]=this
                set s__DDS_TriggerRefresh___TriggerHeapInner_heap[this]=s__DDS_TriggerRefresh___TriggerHeapInner_size
                
                
                call s__DDS_TriggerRefresh___TriggerHeapInner_bubbleUp(this)
            endfunction
        
            function s__DDS_TriggerRefresh___TriggerHeap_add takes integer whichUnit returns nothing
                local integer trig= s__DDS_TriggerRefresh___TriggerHeapInner_node[(1)]
                
                if ( not s__DDS___Trigger_add(trig,whichUnit) ) then
                    set trig=s__DDS___Trigger_create()
                    call s__DDS___Trigger_add(trig,whichUnit)
                    call s__DDS_TriggerRefresh___TriggerHeapInner_insert(trig)
                else
                    call s__DDS_TriggerRefresh___TriggerHeapInner_bubbleDown((trig))
                endif
            endfunction
            function s__DDS_TriggerRefresh___TriggerHeap_remove takes integer whichUnit returns nothing
                local integer trig= s__DDS___Trigger_parent[(whichUnit)]
                call s__DDS___Trigger_remove(whichUnit)
                call s__DDS_TriggerRefresh___TriggerHeapInner_bubbleUp((trig))
            endfunction
        
        
            function s__DDS_TriggerRefresh___TriggerRefreshInit_onIndex takes nothing returns boolean
                call s__DDS_TriggerRefresh___TriggerHeap_add((UnitIndexer___o)) // INLINED!!
                
                return false
            endfunction
            
            function s__DDS_TriggerRefresh___TriggerRefreshInit_onDeindex takes nothing returns boolean
                call s__DDS_TriggerRefresh___TriggerHeap_remove((UnitIndexer___o)) // INLINED!!
            
                return false
            endfunction
        
            function s__DDS_TriggerRefresh___TriggerRefreshInit_init takes code c returns nothing
                set DDS_TriggerRefresh___condition=Condition(c)
                
                call RegisterUnitIndexEvent(Condition(function s__DDS_TriggerRefresh___TriggerRefreshInit_onIndex) , s__UnitIndexer_INDEX)
                call RegisterUnitIndexEvent(Condition(function s__DDS_TriggerRefresh___TriggerRefreshInit_onDeindex) , s__UnitIndexer_DEINDEX)
            endfunction
            
//Implemented from module DDS_TriggerRefresh___TriggerRefreshInitModule:
            function s__DDS_TriggerRefresh___TriggerRefreshInit_DDS_TriggerRefresh___TriggerRefreshInitModule___onInit takes nothing returns nothing
                call s__DDS_TriggerRefresh___TriggerRefreshInit_init(function s__DDS_DDS___DDS_onDamage)
            endfunction
// scope DDS_TriggerRefresh ends
//end of: TRIGGER_REFRESH("TRIGGER_SIZE", "EVENT_UNIT_DAMAGED", "function DDS.DDS_onDamage")
    
//Implemented from module DDS___DDS_Init_Module:
        function s__DDS___DDS_Init_DDS___DDS_Init_Module___onInit takes nothing returns nothing
            set s__DDS_ANY=s__PriorityEvent_create() // INLINED!!
            call s__UnitIndexer__set_enabled(false)
            set DDS_DamageEventModification___killUnit=CreateUnit(Player(15), 'hfoo', s__WorldBounds_maxX - 128, s__WorldBounds_maxY - 128, 0)
            call s__UnitIndexer__set_enabled(true)
            
            call UnitAddAbility(DDS_DamageEventModification___killUnit, 'Aloc')
            call UnitAddAbility(DDS_DamageEventModification___killUnit, 'Avul')
            call ShowUnit(DDS_DamageEventModification___killUnit, false)
            call PauseUnit(DDS_DamageEventModification___killUnit, true)
                call s__DDS_DDS_Archetype___damageEventArchetypeInit()
        endfunction

//library DDS ends
//library GroupVersionCatalog:
    
        
        function s__GroupVersionCatalog__GroupFilter_getGroupFilter takes integer this,integer groupId returns integer
            local integer groupFilter= (LoadInteger(Table___ht, (s__GroupVersionCatalog__GroupFilter_groupFilterTable[this]), (groupId))) // INLINED!!
            
            if ( 0 == groupFilter ) then
                set groupFilter=(CatalogCreate()) // INLINED!!
                call SaveInteger(Table___ht, (s__GroupVersionCatalog__GroupFilter_groupCatalog), (groupFilter), ( (CatalogCreate()))) // INLINED!!
                
                call CatalogAdd(((groupFilter)) , (groupFilter)) // INLINED!!
                call SaveInteger(Table___ht, (s__GroupVersionCatalog__GroupFilter_groupFilterTable[this]), (groupId), ( groupFilter)) // INLINED!!
                
                call SaveInteger(Table___ht, (s__GroupVersionCatalog__GroupFilter_groupIdTable[this]), (groupFilter), ( groupId)) // INLINED!!
            endif
            
            return groupFilter
        endfunction
        
        function s__GroupVersionCatalog__GroupFilter_getFilter takes integer this,integer groupId returns integer
            return (LoadInteger(Table___ht, (s__GroupVersionCatalog__GroupFilter_groupFilterTable[this]), (groupId))) // INLINED!!
        endfunction
        
        function s__GroupVersionCatalog__GroupFilter_getGroupId takes integer this,integer groupFilter returns integer
            return (LoadInteger(Table___ht, (s__GroupVersionCatalog__GroupFilter_groupIdTable[this]), (groupFilter))) // INLINED!!
        endfunction
        
        function s__GroupVersionCatalog__GroupFilter_getCatalog takes integer this,integer groupId returns integer
            return (LoadInteger(Table___ht, (s__GroupVersionCatalog__GroupFilter_groupCatalog), (s__GroupVersionCatalog__GroupFilter_getGroupFilter(this,groupId)))) // INLINED!!
        endfunction
        
        function s__GroupVersionCatalog__GroupFilter_get takes integer this,integer groupId returns integer
            local integer catalog
            local integer looper
            local integer groupFilter
            local boolean array hit
            
            set catalog=s__TempCatalog_create()
            
            set groupFilter=(LoadInteger(Table___ht, (s__GroupVersionCatalog__GroupFilter_groupFilterTable[(this)]), ((groupId)))) // INLINED!!
            set looper=(CatalogLoopCreate((groupFilter ) , ( 1))) // INLINED!!
            loop
                set groupFilter=(CatalogLoopNext((looper) , 1)) // INLINED!!
                exitwhen 0 == groupFilter
                if ( not hit[groupFilter] ) then
                    set hit[groupFilter]=true
                    call CatalogAddCatalog((catalog) , ((LoadInteger(Table___ht, (s__GroupVersionCatalog__GroupFilter_groupCatalog), (groupFilter))))) // INLINED!!
                endif
            endloop
            
            return catalog
        endfunction
        
        function s__GroupVersionCatalog__GroupFilter_addGroup takes integer this,integer groupId,integer groupId2 returns nothing
            call CatalogAddCatalog((s__GroupVersionCatalog__GroupFilter_getGroupFilter(this,groupId)) , (s__GroupVersionCatalog__GroupFilter_getGroupFilter(this,groupId2))) // INLINED!!
        endfunction
        
        function s__GroupVersionCatalog__GroupFilter_create takes nothing returns integer
            local integer this
            
            set this=s__GroupVersionCatalog__GroupFilter_instanceCount + 1
            set s__GroupVersionCatalog__GroupFilter_instanceCount=this
            
            set s__GroupVersionCatalog__GroupFilter_groupFilterTable[this]=s__Table_create()
            set s__GroupVersionCatalog__GroupFilter_groupIdTable[this]=s__Table_create()
            
            return this
        endfunction
        
//Implemented from module GroupVersionCatalog__GroupFilterInit:
        function s__GroupVersionCatalog__GroupFilter_GroupVersionCatalog__GroupFilterInit___onInit takes nothing returns nothing
            set s__GroupVersionCatalog__GroupFilter_groupCatalog=s__Table_create()
        endfunction
        
        
        function s__GroupVersionCatalog__VersionFilter_get takes integer this,integer ver,integer groupId returns integer
            local integer catalog= s__TempCatalog_create()
            call CatalogAddCatalog((catalog) , (s__GroupVersionCatalog__GroupFilter_get(((LoadInteger(Table___ht, (s__GroupVersionCatalog__VersionFilter_groupFilterTable[this]), (ver)))),groupId))) // INLINED!!
            return catalog
        endfunction
        
        function s__GroupVersionCatalog__VersionFilter_getGroup takes integer this,integer ver returns integer
            if ( 0 == (LoadInteger(Table___ht, (s__GroupVersionCatalog__VersionFilter_groupFilterTable[this]), (ver))) ) then // INLINED!!
                call SaveInteger(Table___ht, (s__GroupVersionCatalog__VersionFilter_groupFilterTable[this]), (ver), ( s__GroupVersionCatalog__GroupFilter_create())) // INLINED!!
            endif
            
            return (LoadInteger(Table___ht, (s__GroupVersionCatalog__VersionFilter_groupFilterTable[this]), (ver))) // INLINED!!
        endfunction
        
        function s__GroupVersionCatalog__VersionFilter_getCatalog takes integer this,integer ver,integer groupId returns integer
            return (LoadInteger(Table___ht, (s__GroupVersionCatalog__GroupFilter_groupCatalog), (s__GroupVersionCatalog__GroupFilter_getGroupFilter((s__GroupVersionCatalog__VersionFilter_getGroup(this,ver)),(groupId))))) // INLINED!!
        endfunction
        
        function s__GroupVersionCatalog__VersionFilter_create takes nothing returns integer
            local integer this= s__GroupVersionCatalog__VersionFilter_instanceCount + 1
            set s__GroupVersionCatalog__VersionFilter_instanceCount=this
            
            set s__GroupVersionCatalog__VersionFilter_groupFilterTable[this]=s__Table_create()
            
            return this
        endfunction
    
    
        
        
        
        
        function s__GroupVersionCatalog_update takes nothing returns boolean
            local integer this= s__GroupVersionCatalog_toUpdate
            local integer xver= s__GroupVersionCatalog_ver[this] - 1
            local integer c= s__GroupVersionCatalog_groupCount[this]
            local integer looper
            local integer groupId
            local integer catalog
            local integer catalogNew
            loop
                exitwhen 0 == c
                set c=c - 1
                
                call CatalogAddCatalog((s__GroupVersionCatalog__GroupFilter_getGroupFilter(s__GroupVersionCatalog__VersionFilter_getGroup(s__GroupVersionCatalog_versionFilter[this],s__GroupVersionCatalog_ver[this]),(LoadInteger(Table___ht, (s__GroupVersionCatalog_groups[this]), (c))))) , (s__GroupVersionCatalog__GroupFilter_getGroupFilter(s__GroupVersionCatalog__VersionFilter_getGroup(s__GroupVersionCatalog_versionFilter[this],xver),(LoadInteger(Table___ht, (s__GroupVersionCatalog_groups[this]), (c)))))) // INLINED!!
                
                set looper=(CatalogLoopCreate(((LoadInteger(Table___ht, (s__GroupVersionCatalog_groupAddTable[this]), ((LoadInteger(Table___ht, (s__GroupVersionCatalog_groups[this]), (c)))))) ) , ( 1))) // INLINED!!
                loop
                    set groupId=(CatalogLoopNext((looper) , 1)) // INLINED!!
                    exitwhen 0 == groupId
                    call s__GroupVersionCatalog__GroupFilter_addGroup(s__GroupVersionCatalog__VersionFilter_getGroup(s__GroupVersionCatalog_versionFilter[this],s__GroupVersionCatalog_ver[this]),(LoadInteger(Table___ht, (s__GroupVersionCatalog_groups[this]), (c))) , groupId) // INLINED!!
                endloop
            endloop
            return false
        endfunction
        
        function s__GroupVersionCatalog_addGroup takes integer this,integer ver,integer groupId,integer groupId2 returns nothing
            call s__GroupVersionCatalog__GroupFilter_addGroup(s__GroupVersionCatalog__VersionFilter_getGroup(s__GroupVersionCatalog_versionFilter[this],ver),groupId , groupId2)
            if ( s__GroupVersionCatalog_ver[this] < ver ) then
                set s__GroupVersionCatalog_ver[this]=ver
                if ( 1 < ver ) then
                    set s__GroupVersionCatalog_toUpdate=this
                    call TriggerEvaluate(s__GroupVersionCatalog_eUpdate)
                endif
            endif
            if ( not (HaveSavedBoolean(Table___ht, (((s__GroupVersionCatalog_groupTable[this]))), (groupId))) ) then // INLINED!!
                call SaveInteger(Table___ht, (s__GroupVersionCatalog_groupAddTable[this]), (groupId), ( (CatalogCreate()))) // INLINED!!
                call SaveBoolean(Table___ht, (((s__GroupVersionCatalog_groupTable[this]))), (groupId), ( true)) // INLINED!!
                call SaveInteger(Table___ht, (s__GroupVersionCatalog_groups[this]), (s__GroupVersionCatalog_groupCount[this]), ( groupId)) // INLINED!!
                set s__GroupVersionCatalog_groupCount[this]=s__GroupVersionCatalog_groupCount[this] + 1
            endif
            if ( not (HaveSavedBoolean(Table___ht, (((s__GroupVersionCatalog_groupTable[this]))), (groupId2))) ) then // INLINED!!
                call SaveInteger(Table___ht, (s__GroupVersionCatalog_groupAddTable[this]), (groupId2), ( (CatalogCreate()))) // INLINED!!
                call SaveBoolean(Table___ht, (((s__GroupVersionCatalog_groupTable[this]))), (groupId2), ( true)) // INLINED!!
                call SaveInteger(Table___ht, (s__GroupVersionCatalog_groups[this]), (s__GroupVersionCatalog_groupCount[this]), ( groupId2)) // INLINED!!
                set s__GroupVersionCatalog_groupCount[this]=s__GroupVersionCatalog_groupCount[this] + 1
            endif
            call CatalogAdd((LoadInteger(Table___ht, (s__GroupVersionCatalog_groupAddTable[this]), (groupId))) , groupId2) // INLINED!!
        endfunction
        
        function s__GroupVersionCatalog_get takes integer this,integer ver,integer groupId returns integer
            return s__GroupVersionCatalog__VersionFilter_get(s__GroupVersionCatalog_versionFilter[this],ver , groupId)
        endfunction
    
        function s__GroupVersionCatalog_add takes integer this,integer rawId,integer ver,integer groupId returns nothing
            local integer catalog= s__GroupVersionCatalog__VersionFilter_getCatalog(s__GroupVersionCatalog_versionFilter[this],ver , groupId)
            
            if ( s__GroupVersionCatalog_ver[this] < ver ) then
                set s__GroupVersionCatalog_ver[this]=ver
                if ( 1 < ver ) then
                    set s__GroupVersionCatalog_toUpdate=this
                    call TriggerEvaluate(s__GroupVersionCatalog_eUpdate)
                endif
            endif
            if ( not (HaveSavedBoolean(Table___ht, (((s__GroupVersionCatalog_groupTable[this]))), (groupId))) ) then // INLINED!!
                call SaveInteger(Table___ht, (s__GroupVersionCatalog_groupAddTable[this]), (groupId), ( (CatalogCreate()))) // INLINED!!
                call SaveBoolean(Table___ht, (((s__GroupVersionCatalog_groupTable[this]))), (groupId), ( true)) // INLINED!!
                call SaveInteger(Table___ht, (s__GroupVersionCatalog_groups[this]), (s__GroupVersionCatalog_groupCount[this]), ( groupId)) // INLINED!!
                set s__GroupVersionCatalog_groupCount[this]=s__GroupVersionCatalog_groupCount[this] + 1
            endif
            
            call CatalogAdd((catalog) , (rawId)) // INLINED!!
        endfunction
        
        function s__GroupVersionCatalog_create takes nothing returns integer
            local integer this= s__GroupVersionCatalog_instanceCount + 1
            set s__GroupVersionCatalog_instanceCount=this
            
            set s__GroupVersionCatalog_versionFilter[this]=s__GroupVersionCatalog__VersionFilter_create()
            
            set s__GroupVersionCatalog_groupTable[this]=s__Table_create()
            set s__GroupVersionCatalog_groups[this]=s__Table_create()
            set s__GroupVersionCatalog_groupAddTable[this]=s__Table_create()
            
            return this
        endfunction
    
//Implemented from module GroupVersionCatalog__ItemCatalogInit:
        function s__GroupVersionCatalog_GroupVersionCatalog__ItemCatalogInit___onInit takes nothing returns nothing
            set s__GroupVersionCatalog_eUpdate=CreateTrigger()
            call TriggerAddCondition(s__GroupVersionCatalog_eUpdate, Condition(function s__GroupVersionCatalog_update))
        endfunction

//library GroupVersionCatalog ends
//library ItemInventory:

        function getInventoryRect takes nothing returns rect
            return ItemInventory__inRect
        endfunction
        function ItemInventory__setDestructableIds takes nothing returns nothing
            set ItemInventory__currentlySelectedIcon=gg_dest_B010_13377
            set ItemInventory__currentlySelectedItem=sc__T2InvB_create()
            set ItemInventory__lastHoveredIcon=gg_dest_B010_0883
            set ItemInventory__lastHoveredItem=sc__T2InvB_create()
            
            set ItemInventory__crntX=GetDestructableX(ItemInventory__currentlySelectedIcon)
            set ItemInventory__crntY=GetDestructableY(ItemInventory__currentlySelectedIcon)
            set ItemInventory__lstX=GetDestructableX(ItemInventory__lastHoveredIcon)
            set ItemInventory__lstY=GetDestructableY(ItemInventory__lastHoveredIcon)
            
            set ItemInventory__itemLinks=s__Table_create()
        endfunction
        
        function AddUnitInventory takes unit u returns nothing
            if ItemInventory__unitHashData == 0 then
                set ItemInventory__unitHashData=s__Table_create()
            endif
            call SaveInteger(Table___ht, (ItemInventory__unitHashData), (GetHandleId(u)), ( ItemInventory__nextHash)) // INLINED!!
            set ItemInventory__nextHash=ItemInventory__nextHash + 1
        endfunction
    
        function ItemInventory__getCurrentUnitForPlayer takes player p returns unit
            return udg_PlayerUnit[GetPlayerId(p) + 1]
        endfunction
        
        function ItemInventory__hndl4p takes player p returns integer
            return GetHandleId((udg_PlayerUnit[GetPlayerId((p)) + 1])) // INLINED!!
        endfunction
//textmacro instance: ICI()
    
//Implemented from module ICI_init:
            function s__ICI_ICI_init___onInit takes nothing returns nothing
                set s__ICI_opConTitle[0]="View Set Data"
                set s__ICI_opConDesc[0]="Views the set data for the currently selected item"
                set s__ICI_opIds[0]='B00Q'
            endfunction
        
        
        function s__ICI_applyTraitToUnit takes integer t,unit u returns nothing
            call sc__StatHandler_addUnitBonus(u , t)
        endfunction
        function s__ICI_removeTraitFromUnit takes integer t,unit u returns nothing
            call sc__StatHandler_removeUnitBonus(u , t)
        endfunction
        function s__ICI_getSlotEmptyBackground takes integer slot returns integer
            if slot == SLOT_BELT then
                return 'B028'
            elseif slot == SLOT_HELM then
                return 'B022'
            elseif slot == SLOT_GLOVE then
                return 'B01Y'
            elseif slot == SLOT_WING then
                return 'B020'
            elseif slot == SLOT_MAINHAND then
                return 'B00Z'
            elseif slot == SLOT_OFFHAND then
                return 'B021'
            elseif slot == SLOT_RINGLEFT then
                return 'B01Z'
            elseif slot == SLOT_RINGRIGHT then
                return 'B024'
            elseif slot == SLOT_BOOTS then
                return 'B025'
            elseif slot == SLOT_NECKLACE then
                return 'B026'
            elseif slot == SLOT_PANTS then
                return 'B027'
            elseif slot == SLOT_ARMOR then
                return 'B031'
            else
                return ItemInventory__EMPTY_BAG_SLOT
            endif
            return 0
        endfunction
        
        function s__ICI_getTraitDescription takes string color,integer t returns string
            if s__Trait_typeOfTrait[t] == TRAIT_TYPE_DAMAGE then
                return color + "Damage|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_ARMOR then
                return color + "Armor |r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_STATIC_ARMOR then
                return color + "Static Armor|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_FIRE_DAMAGE then
                return color + "Fire Damage |r: " + I2S(R2I(s__Trait_a[t])) + " - " + I2S(R2I(s__Trait_b[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_LIGHTNING_DAMAGE then
                return color + "Electric Damage |r: 1 - " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_STRENGTH then
                return color + "Strength|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_AGILITY then
                return color + "Agility |r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_INTELLIGENCE then
                return color + "Inteligence |r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_MANA then
                return color + "Mana|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_MANA_REGEN then
                return color + "Mana Regen |r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_SPIKE_ARMOR then
                return color + "Spike Armor |r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_STATIC_DAMAGE then
                return color + "Chaos Damage |r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_LIFE then
                return color + "Life |r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_LIFE_REGEN then
                return color + "Life Regen |r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_ATTACK_SPEED then
                return color + "Attack Speed|r: " + I2S(R2I(s__Trait_a[t])) + "%"
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_ALL_STATS then
                return color + "All Stats|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_LIFE_LEECH then
                return color + "Life Leech|r: " + I2S(R2I(s__Trait_a[t])) + "%"
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_ARMOR_REDUCTION then
                return color + "On-hit Armor Reduction|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_SPELL_CRIT_RATE then
                return color + "Spell Critical Strike Rate|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_CRIT_POW then
                return color + "Critical Strike Power|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_CRIT_RATE then
                return color + "Critical Strike Rate|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_SPELL_CRIT_POW then
                return color + "Spell Critical Strike Power|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_MOVEMENT_SPEED then
                return color + "Movement Speed|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_FIRE_RESISTANCE then
                return color + "Fire Resistance|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_COLD_RESISTANCE then
                return color + "Cold Resistance|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_LIGHTNING_RESISTANCE then
                return color + "Lightning Resistance|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_POISON_RESISTANCE then
                return color + "Poison Resistance|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_DARKNESS_RESISTANCE then
                return color + "Darkness Resistance|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_HOLY_RESISTANCE then
                return color + "Holy Resistance|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_PHYSICAL_RESISTANCE then
                return color + "Physical Resistance|r: " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_ALL_RESISTANCE then
                return color + "All Resistance|r: " + I2S(R2I(s__Trait_a[t]))
            endif
            return ""
        endfunction
        
        //0 - cannot be in slot
        //1 - can be in slot but do not replace the item in slot
        //2 - replace item in slot
        function s__ICI_getItemSlotPriority takes integer i,integer slot returns integer
            if s__Item_slot[i] == slot then
                return 2
            elseif ( ( s__Item_slot[i] == SLOT_RINGLEFT or s__Item_slot[i] == SLOT_RINGRIGHT ) and ( slot == SLOT_RINGLEFT or slot == SLOT_RINGRIGHT ) ) or ( s__Item_slot[i] == SLOT_OFFHAND and slot == SLOT_MAINHAND ) then
                return 1
            elseif s__Item_slot[i] == TYPE_RECIPE then
                return 3
            elseif s__Item_slot[i] == SLOT_OFFHANDONLY and slot == SLOT_OFFHAND then
                return 2
            elseif s__Item_slot[i] == TYPE_MATERIAL then
                return 4
            else
                return 0
            endif
                
        endfunction
        
        function s__ICI_doesHostFulfillReq takes integer t,unit host returns boolean
            if s__Trait_typeOfTrait[t] == TRAIT_REQ_LEVEL then
                return GetHeroLevel(host) >= s__Trait_a[t]
            elseif s__Trait_typeOfTrait[t] == TRAIT_REQ_WARR then
                return GetUnitTypeId(host) == 'H003'
            elseif s__Trait_typeOfTrait[t] == TRAIT_REQ_WIZ_WITCH then
                return GetUnitTypeId(host) == 'H013' or GetUnitTypeId(host) == 'H005'
            endif
            return false
        endfunction
        
        function s__ICI_getReqDescription takes integer t,string color returns string
            if s__Trait_typeOfTrait[t] == TRAIT_REQ_LEVEL then
                return color + "Level Requirement|r : " + I2S(R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_REQ_WARR then
                return color + "Class Requirement|r : Warrior"
            elseif s__Trait_typeOfTrait[t] == TRAIT_REQ_WIZ_WITCH then
                return color + "Class Requirement|r : Runemaster, Witch"
            endif
            return ""
        endfunction
        
        function s__ICI_onOperatorClick takes integer selected,integer opSlot,player p returns nothing
            if opSlot == 1 then
                call sc__ICI_displaySetData(selected , opSlot , p)
            endif
        endfunction
        
        function s__ICI_getOpConTitle takes integer slot returns string
            if s__ICI_opConTitle[slot] == "" or s__ICI_opConTitle[slot] == null then
                return "No Function"
            endif
            return s__ICI_opConTitle[slot]
        endfunction
        function s__ICI_getOpConDesc takes integer slot returns string
            return s__ICI_opConDesc[slot]
        endfunction
        function s__ICI_getOpConButton takes integer slto returns integer
            if s__ICI_opIds[slto] == 0 then
                return ItemInventory__EMPTY_BAG_SLOT
            else
                return s__ICI_opIds[slto]
            endif
        endfunction
        
        function s__ICI_displaySetData takes integer it,integer os,player p returns nothing
            local integer tempid
            local string title
            local string desc
            if s__Item_setv[it] == 0 then
                set title="No Set Data"
                set desc=title
            else
                set title="Set Description : " + s__Set_title[s__Item_setv[it]]
                set desc=s__Set_desc[s__Item_setv[it]]
            endif
            if GetLocalPlayer() == p then
                set tempid='B00I'
            else
                set tempid=GetDestructableTypeId(ItemInventory__lastHoveredIcon)
            endif
            call RemoveDestructable(ItemInventory__lastHoveredIcon)
            set ItemInventory__lastHoveredIcon=CreateDestructable(tempid, ItemInventory__lstX, ItemInventory__lstY, 0, 1, 0)
            if ItemInventory__lstTTtitle == null then
                set ItemInventory__lstTTtitle=CreateTextTag()
                set ItemInventory__lstTTdesc=CreateTextTag()
                call SetTextTagPos(ItemInventory__lstTTtitle, GetRectMinX(ItemInventory__hoverTitleRect), GetRectMinY(ItemInventory__hoverTitleRect), 0)
                call SetTextTagVisibility(ItemInventory__lstTTtitle, true)
                call SetTextTagPos(ItemInventory__lstTTdesc, GetRectMinX(ItemInventory__hoverDescRect), GetRectMinY(ItemInventory__hoverDescRect), 0)
                call SetTextTagVisibility(ItemInventory__lstTTdesc, true)
            endif
            if GetLocalPlayer() == p then
                call SetTextTagTextBJ(ItemInventory__lstTTtitle, title, 10)
                call SetTextTagTextBJ(ItemInventory__lstTTdesc, desc, 10)
            endif
        endfunction
//end of: ICI()
//Implemented from module Alloc:
    
    function s__Item_allocate takes nothing returns integer
        local integer this= s__Item_Alloc___recycler[0]
        
        
        if ( this == 0 ) then
        
            set this=s__Item_Alloc___instanceCount + 1
            set s__Item_Alloc___instanceCount=this
        else
            set s__Item_Alloc___recycler[0]=s__Item_Alloc___recycler[this]
        endif
        
        
        return this
    endfunction
    
    function s__Item_deallocate takes integer this returns nothing
        
        
        set s__Item_Alloc___recycler[this]=s__Item_Alloc___recycler[0]
        set s__Item_Alloc___recycler[0]=this
    endfunction
        
        
        function s__Item_destroy takes integer this returns nothing
            call RemoveItem(s__Item_link[this])
            call FlushChildHashtable(Table___ht, (s__Item_traits[this])) // INLINED!!
            call s__Table_destroy(s__Item_traits[this])
            call s__Table_destroy(s__Item_reqs[this])
            call s__Item_deallocate(this)
        endfunction
        
        function s__Item_generateDescription takes integer it returns string
            local string s= s__Item_desc[it] + "\n"
            local integer i= 0
            if sc__Item_getTrait(it,0) != 0 then
                loop
                    set s=s + "\n" + s__ICI_getTraitDescription(ItemInventory__COLOR , sc__Item_getTrait(it,i))
                    set i=i + 1
                    exitwhen sc__Item_getTrait(it,i) == null
                endloop
            endif
            if sc__Item_getReq(it,0) != 0 then
                set s=s + "\n"
                set i=0
                loop
                    set s=s + "\n" + s__ICI_getReqDescription(sc__Item_getReq(it,i) , ItemInventory__COLOR)
                    set i=i + 1
                    exitwhen sc__Item_getReq(it,i) == null
                endloop
            endif
            return s
        endfunction
        
        function s__Item_create takes integer buttonIdV,integer equipmentSlot,string titleV,string description,item linkedItem returns integer
            local integer this= s__Item_allocate()
            
            set s__Item_buttonId[this]=buttonIdV
            set s__Item_slot[this]=equipmentSlot
            set s__Item_title[this]=titleV
            set s__Item_desc[this]=description
            set s__Item_link[this]=linkedItem
            set s__Item_traits[this]=s__Table_create()
            set s__Item_reqs[this]=s__Table_create()
            set s__Item_reqCount[this]=0
            set s__Item_current[this]=0
            set s__Item_genDesc[this]=s__Item_generateDescription(this)
            return this
        endfunction
        
        function s__Item_addSet takes integer this,integer s returns nothing
            set s__Item_setv[this]=s
        endfunction
        function s__Item_addRecipe takes integer this,integer s returns nothing
            call sc__RecipeGroup_add(s__Item_possibleRecipe[this],s)
        endfunction
        
        function s__Item_refreshTool takes integer this,unit u returns nothing
            set s__InventoryButton_title[s__Item_button[this]]=s__Item_title[this]
            set s__Item_desc[this]=sc__InventoryButton_desc(s__Item_button[this],u)
        endfunction
        
        function s__Item_linkButton takes integer this,integer invButton returns nothing
            set s__Item_button[this]=invButton
        endfunction
        
        function s__Item_getRecipe takes integer this returns integer
            return s__Item_possibleRecipe[this]
        endfunction
        
        function s__Item_addTrait takes integer this,integer trait returns nothing
            call SaveInteger(Table___ht, (s__Item_traits[this]), (s__Item_current[this]), ( (trait))) // INLINED!!
            set s__Item_current[this]=s__Item_current[this] + 1
            set s__Item_genDesc[this]=s__Item_generateDescription(this)
        endfunction
        
        function s__Item_addReq takes integer this,integer t returns nothing
            call SaveInteger(Table___ht, (s__Item_reqs[this]), (s__Item_reqCount[this]), ( t)) // INLINED!!
            set s__Item_reqCount[this]=s__Item_reqCount[this] + 1
            set s__Item_genDesc[this]=s__Item_generateDescription(this)
        endfunction
        
        function s__Item_willHostFulfillReqs takes integer this,unit u returns boolean
            local integer i= 0
            loop
                exitwhen i == s__Item_reqCount[this]
                if not s__ICI_doesHostFulfillReq((LoadInteger(Table___ht, (s__Item_reqs[this]), (i))) , u) then // INLINED!!
                    return false
                endif
                set i=i + 1
            endloop
            return true
        endfunction
        
        function s__Item_getTrait takes integer this,integer at returns integer
            return ((LoadInteger(Table___ht, (s__Item_traits[this]), (at)))) // INLINED!!
        endfunction
        function s__Item_getReq takes integer this,integer at returns integer
            return (LoadInteger(Table___ht, (s__Item_reqs[this]), (at))) // INLINED!!
        endfunction
        function s__Item_setTooltip takes integer this,string titlev,string descv returns nothing
            set s__Item_title[this]=titlev
            set s__Item_desc[this]=descv
        endfunction
        function s__ItemInventory__link2table_create takes nothing returns integer
            local integer this= s__ItemInventory__link2table__allocate()
            set s__ItemInventory__link2table_t[this]=s__Table_create()
            return this
        endfunction
        function s__ItemInventory__link2table__getindex takes integer this,integer i returns integer
            return ((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[this]), (i)))) // INLINED!!
        endfunction
        function s__ItemInventory__link2table__setindex takes integer this,integer i2,integer i returns nothing
            call SaveInteger(Table___ht, (s__ItemInventory__link2table_t[this]), (i2), ( i)) // INLINED!!
        endfunction
        function s__T2InvB_create takes nothing returns integer
            local integer this= s__T2InvB__allocate()
            set s__T2InvB_t[this]=s__Table_create()
            return this
        endfunction
        function s__T2InvB__getindex takes integer this,integer i returns integer
            return ((LoadInteger(Table___ht, (s__T2InvB_t[this]), (i)))) // INLINED!!
        endfunction
        function s__T2InvB__setindex takes integer this,integer i2,integer i returns nothing
            call SaveInteger(Table___ht, (s__T2InvB_t[this]), (i2), ( i)) // INLINED!!
        endfunction
        
        
        
        function s__InventoryButton_create takes real xVal,real yVal,destructable currentVal,integer buttonVal returns integer
            local integer this= s__InventoryButton__allocate()
            
            set s__InventoryButton_x[this]=xVal
            set s__InventoryButton_y[this]=yVal
            set s__InventoryButton_current[this]=currentVal
            set s__InventoryButton_button[this]=buttonVal
            set s__InventoryButton_occupied[this]=false
            set s__InventoryButton_info[this]=" "
            set s__InventoryButton_title[this]=" "
            set s__InventoryButton_description[this]=" "
            set s__InventoryButton_showOnTooltip[this]=false
            set s__InventoryButton_link[this]=s__ItemInventory__link2table_create()
            set s__InventoryButton_defaultDestPic[this]=GetDestructableTypeId(currentVal)

            return this
        endfunction
        function s__InventoryButton_reset takes integer this,unit u returns nothing
            call sc__InventoryButton_noTooltip(this)
            call s__Item_destroy((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[this])]), ((GetHandleId(u)))))) // INLINED!!
            call sc__InventoryButton_removeItem(this,u)
        endfunction
        function s__InventoryButton_removeItem takes integer this,unit u returns nothing
            local integer tempid
            if GetLocalPlayer() == GetOwningPlayer(u) then
                set tempid=s__InventoryButton_defaultDestPic[this]
            else
                set tempid=GetDestructableTypeId(s__InventoryButton_current[this])
            endif
            call RemoveDestructable(s__InventoryButton_current[this])
            set s__InventoryButton_current[this]=CreateDestructable(tempid, s__InventoryButton_x[this], s__InventoryButton_y[this], 0, 1, 0)
            call SaveInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[this])]), ((GetHandleId(u))), ( ( 0))) // INLINED!!
            //if GetDestructableTypeId(current) == GetDestructableTypeId(currentlySelectedIcon) then
                call sc__CustomInventory_wipeSelected(GetOwningPlayer(u))
            //endif
            //if GetDestructableTypeId(current) == GetDestructableTypeId(lastHoveredIcon) then
                call sc__CustomInventory_wipeHovered(GetOwningPlayer(u))
            //endif
        endfunction
        function s__InventoryButton_tooltip takes integer this,string titleV,string descriptionV returns nothing
            set s__InventoryButton_title[this]=titleV
            set s__InventoryButton_description[this]=descriptionV
            set s__InventoryButton_showOnTooltip[this]=true
        endfunction
        
        function s__InventoryButton_noTooltip takes integer this returns nothing
            set s__InventoryButton_title[this]=""
            set s__InventoryButton_description[this]=""
            set s__InventoryButton_showOnTooltip[this]=false
        endfunction
        function s__InventoryButton_destroy takes integer this returns nothing
            //add to recycle stack
            call s__InventoryButton_deallocate(this)
        endfunction
        function s__InventoryButton_recreate takes integer this,player p returns nothing
            local integer tempid
            local integer tempid2
            local integer applicableId
            local player localp= GetLocalPlayer()
         //   if GetLocalPlayer() == p then
            if (LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[this])]), (((GetHandleId((udg_PlayerUnit[GetPlayerId(((p))) + 1]))))))) == 0 then // INLINED!!
                set tempid=s__InventoryButton_defaultDestPic[this]
            else
                set tempid=s__Item_buttonId[(LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[this])]), (((GetHandleId((udg_PlayerUnit[GetPlayerId(((p))) + 1])))))))] // INLINED!!
            endif
            
            set tempid2=GetDestructableTypeId(s__InventoryButton_current[this])
            
            if localp == p then
                set applicableId=tempid
            else
                set applicableId=tempid2
            endif
            
            call RemoveDestructable(s__InventoryButton_current[this])
            set s__InventoryButton_current[this]=CreateDestructable(applicableId, s__InventoryButton_x[this], s__InventoryButton_y[this], 0, 1, 0)
        endfunction
        
        function s__InventoryButton_setLink takes integer this,integer i,unit u returns nothing
            call SaveInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[this])]), ((GetHandleId(u))), ( ( i))) // INLINED!!
            set s__Item_button[((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[this])]), ((GetHandleId(u))))))]=(this) // INLINED!!
        endfunction
        function s__InventoryButton_setLinkId takes integer this,integer i,integer id returns nothing
            call SaveInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[this])]), ((id)), ( ( i))) // INLINED!!
            set s__Item_button[(i)]=(this) // INLINED!!
        endfunction
        
        
        function s__InventoryButton_desc takes integer this,unit u returns string
            return s__Item_genDesc[(LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[this])]), ((GetHandleId(u)))))] // INLINED!!
        endfunction
        
        function s__Set_create takes string titlee,string descc returns integer
            local integer this= s__Set__allocate()
            set s__Set_itemIds[this]=s__Table_create()
            set s__Set_traitData[this]=s__TableArray__staticgetindex(2)
            set s__Set_applied[this]=s__Table_create()
            set s__Set_starter[this]="Current progress on " + titlee + " : "
            set s__Set_title[this]=titlee
            set s__Set_desc[this]=descc
            return this
        endfunction
        
        function s__Set_addTrait takes integer this,integer typeOfTraitx,real value,integer numReq returns nothing
            local integer trait= s__Trait_create(value , 0 , 0 , 0 , typeOfTraitx)
            
            call SaveInteger(Table___ht, (((s__Set_traitData[this]) + (0))), (s__Set_currentTrait[this]), ( (trait))) // INLINED!!
            call SaveInteger(Table___ht, (((s__Set_traitData[this]) + (1))), (s__Set_currentTrait[this]), ( numReq)) // INLINED!!
            set s__Set_currentTrait[this]=s__Set_currentTrait[this] + 1
        endfunction
        
        function s__Set_addItem takes integer this,integer itemId returns nothing
            call SaveInteger(Table___ht, (s__Set_itemIds[this]), (s__Set_currentItem[this]), ( itemId)) // INLINED!!
            set s__Set_currentItem[this]=s__Set_currentItem[this] + 1
        endfunction
        
        
        function s__Set_remove takes integer this,unit u returns nothing
            local integer i= 0
            local integer num= (LoadInteger(Table___ht, (s__Set_applied[this]), (GetHandleId(u)))) // INLINED!!
            if num == 0 then
                return
            endif
            loop
                exitwhen (LoadInteger(Table___ht, (((s__Set_traitData[this]) + (0))), (i))) == 0 // INLINED!!
                if (LoadInteger(Table___ht, (((s__Set_traitData[this]) + (1))), (i))) <= num then // INLINED!!
                    call s__ICI_removeTraitFromUnit(((LoadInteger(Table___ht, (((s__Set_traitData[this]) + (0))), (i)))) , u) // INLINED!!
                endif
                set i=i + 1
            endloop
        endfunction
        
        
        
        function s__Set_checkForSetData takes integer this,unit u returns nothing
            local integer i= 0
            local integer num= 0
            local integer i2= 0
            local integer compare= 0
            local string toShow= s__Set_starter[this]
            local integer t
            call s__Set_remove(this,u)
            loop
                exitwhen (LoadInteger(Table___ht, (s__Set_itemIds[this]), (i))) == 0 // INLINED!!
                if sc__CustomInventory_doesUnitHaveItemInEq((LoadInteger(Table___ht, (s__Set_itemIds[this]), (i))) , u) != 0 then // INLINED!!
                    set num=num + 1
                endif
                set i=i + 1
            endloop
            set i=0
            loop
                set t=(LoadInteger(Table___ht, (((s__Set_traitData[this]) + (0))), (i))) // INLINED!!
                exitwhen t == 0
                if (LoadInteger(Table___ht, (((s__Set_traitData[this]) + (1))), (i))) <= num then // INLINED!!
                    call s__ICI_applyTraitToUnit(t , u)
                    set toShow=toShow + "\n    - " + (sc__ICI_getTraitDescription("|cffffcc00" , (t))) // INLINED!!
                endif
                set i=i + 1
            endloop
            if toShow != s__Set_starter[this] and GetLocalPlayer() == GetOwningPlayer(u) then
                call ClearTextMessages()
                call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, 15, toShow)
            endif
            call SaveInteger(Table___ht, (s__Set_applied[this]), (GetHandleId(u)), ( num)) // INLINED!!
        endfunction
        
//Implemented from module Alloc:
    
    function s__InventoryGrouping_allocate takes nothing returns integer
        local integer this= s__InventoryGrouping_Alloc___recycler[0]
        
        
        if ( this == 0 ) then
        
            set this=s__InventoryGrouping_Alloc___instanceCount + 1
            set s__InventoryGrouping_Alloc___instanceCount=this
        else
            set s__InventoryGrouping_Alloc___recycler[0]=s__InventoryGrouping_Alloc___recycler[this]
        endif
        
        
        return this
    endfunction
    
    function s__InventoryGrouping_deallocate takes integer this returns nothing
        
        
        set s__InventoryGrouping_Alloc___recycler[this]=s__InventoryGrouping_Alloc___recycler[0]
        set s__InventoryGrouping_Alloc___recycler[0]=this
    endfunction
        function s__InventoryGrouping_create takes nothing returns integer
            local integer this= s__InventoryGrouping_allocate()
            set s__InventoryGrouping_buttons[this]=s__Table_create()
            set s__InventoryGrouping_count[this]=0
            return this
        endfunction
        function s__InventoryGrouping_add takes integer this,integer b returns nothing
            call SaveInteger(Table___ht, (s__InventoryGrouping_buttons[this]), (s__InventoryGrouping_count[this]), ( b)) // INLINED!!
            set s__InventoryGrouping_count[this]=s__InventoryGrouping_count[this] + 1
        endfunction
        function s__InventoryGrouping_reset takes integer this,unit u returns nothing
            if s__InventoryGrouping_count[this] != 0 then
                call s__InventoryButton_reset(((LoadInteger(Table___ht, (s__InventoryGrouping_buttons[this]), (0)))),u) // INLINED!!
                call SaveInteger(Table___ht, (s__InventoryGrouping_buttons[this]), (0), ( (LoadInteger(Table___ht, (s__InventoryGrouping_buttons[this]), (s__InventoryGrouping_count[this] - 1))))) // INLINED!!
                set s__InventoryGrouping_count[this]=s__InventoryGrouping_count[this] - 1
            endif
        endfunction
        function s__InventoryGrouping_destroy takes integer this returns nothing
            call s__Table_destroy(s__InventoryGrouping_buttons[this])
            set s__InventoryGrouping_count[this]=0
            call s__InventoryGrouping_deallocate(this)
        endfunction
//textmacro instance: RECIPE()
        function s__RecipeGroup_create takes nothing returns integer
            local integer this= s__RecipeGroup__allocate()
            set s__RecipeGroup_recipes[this]=s__Table_create()
            set s__RecipeGroup_recIndex[this]=0
            return this
        endfunction
        function s__RecipeGroup_add takes integer this,integer rec returns nothing
            call SaveInteger(Table___ht, (s__RecipeGroup_recipes[this]), (s__RecipeGroup_recIndex[this]), ( rec)) // INLINED!!
            set s__RecipeGroup_recIndex[this]=s__RecipeGroup_recIndex[this] + 1
        endfunction
        function s__RecipeGroup_check takes integer this,unit u,integer root returns boolean
            local integer i= 0
            local integer r
            loop
                exitwhen (LoadInteger(Table___ht, (s__RecipeGroup_recipes[this]), (i))) == 0 // INLINED!!
                set r=(LoadInteger(Table___ht, (s__RecipeGroup_recipes[this]), (i))) // INLINED!!
                if sc__Recipe2_check(r,u , root , this) then
                    return true
                endif
                set i=i + 1
            endloop
            call DisplayTimedTextToPlayer(GetOwningPlayer(u), 0, 0, 30, "|cffffcc00Notification|r : No completable recipes for this item have been found")
            return false
        endfunction
        function s__Recipe2_create takes nothing returns integer
            local integer this= s__Recipe2__allocate()
            set s__Recipe2_pieces[this]=s__TableArray__staticgetindex(10)
            set s__Recipe2_results[this]=s__Table_create()
            set s__Recipe2_piecesCount[this]=s__Table_create()
            set s__Recipe2_resultsCount[this]=0
            return this
        endfunction
        
        
        function s__Recipe2_setSlots takes integer this,integer number returns nothing
            call s__TableArray_destroy(s__Recipe2_pieces[this])
            set s__Recipe2_pieces[this]=s__TableArray__staticgetindex(number)
        endfunction
        
        function s__Recipe2_addPiece takes integer this,integer slot,integer itemId returns integer
            call SaveInteger(Table___ht, (((s__Recipe2_pieces[this]) + (slot))), ((LoadInteger(Table___ht, (s__Recipe2_piecesCount[this]), (slot)))), ( itemId)) // INLINED!!
            call SaveInteger(Table___ht, (s__Recipe2_piecesCount[this]), (slot), ( (LoadInteger(Table___ht, (s__Recipe2_piecesCount[this]), (slot))) + 1)) // INLINED!!
            return this
        endfunction
        
        function s__Recipe2_addResult takes integer this,integer itemId returns integer
            call SaveInteger(Table___ht, (s__Recipe2_results[this]), (s__Recipe2_resultsCount[this]), ( itemId)) // INLINED!!
            set s__Recipe2_resultsCount[this]=s__Recipe2_resultsCount[this] + 1
            return this
        endfunction
        
        function s__Recipe2_check2 takes integer this,unit u,integer root returns nothing
        endfunction
        function s__Recipe2_check takes integer this,unit u,integer root,integer g returns boolean
            local integer t
            local integer i= 0
            local integer array usedPieces
            local integer usedPiecesCount= 0
            local integer i2= 0
            local integer temp
            local integer temp2
            set t=sc__CustomInventory_gather(u)
            loop
                exitwhen (LoadInteger(Table___ht, (((s__Recipe2_pieces[this]) + (i))), (0))) == 0 // INLINED!!
                set i2=0
                loop
                    set temp2=(LoadInteger(Table___ht, (((s__Recipe2_pieces[this]) + (i))), (i2))) // INLINED!!
                    exitwhen temp2 == 0
                    set temp=(LoadInteger(Table___ht, (((t) + (0))), (temp2))) // INLINED!!
                    if temp != 0 then
                        call SaveInteger(Table___ht, (((t) + (0))), (temp2), ( temp - 1)) // INLINED!!
                        set usedPieces[usedPiecesCount]=(LoadInteger(Table___ht, (((t) + (1))), (temp2))) // INLINED!!
                        set usedPiecesCount=usedPiecesCount + 1
                        exitwhen true
                    endif
                    set i2=i2 + 1
                endloop
                if usedPiecesCount == i then
                    call s__TableArray_destroy(t)
                    return false
                endif
                set i=i + 1
            endloop
            
            set i=0
            loop
                exitwhen usedPieces[i] == 0
                call s__InventoryGrouping_reset((usedPieces[i]),u)
                set i=i + 1
            endloop
            
            call s__InventoryButton_reset(root,u)
            set i=0
            loop
                exitwhen (LoadInteger(Table___ht, (s__Recipe2_results[this]), (i))) == 0 // INLINED!!
                call sc__CustomInventory_generateNewItem(CreateItem((LoadInteger(Table___ht, (s__Recipe2_results[this]), (i))), 0, 0) , u) // INLINED!!
                set i=i + 1
            endloop
            call s__TableArray_destroy(t)
            return true
        endfunction
//end of: RECIPE()
    
        
        function s__CustomInventory_setOnRecipe takes trigger trggah returns nothing
            //local unit u 
            //set UnitIndexer.enabled = FALSE
            //set u = CreateUnit(Player(0), 'H003', 0,0,0)
            //set UnitIndexer.enabled = TRUE
            //call SetUnitUserData(u,GetHandleId(t))
            set s__CustomInventory_onRecipe=trggah
        endfunction
        function s__CustomInventory_getEquipment takes unit host returns integer
            local integer i= 0
            local integer i2= 0
            local integer id= GetHandleId(host)
            local integer b
            local integer t= s__Table_create()
            loop
                exitwhen i > ItemInventory__eqSize
                set b=ItemInventory__equipment[i]
                if (LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((id)))) != 0 then // INLINED!!
                    call SaveInteger(Table___ht, (t), (i2), ( (LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((id)))))) // INLINED!!
                    set i2=i2 + 1
                endif
                set i=i + 1
            endloop
            return t
        endfunction
        
        function s__CustomInventory_clearInventoryButton takes integer b,unit host,boolean removeItem returns nothing
            local integer id= GetHandleId(host)
            local integer i= (LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((id)))) // INLINED!!
            if i != null then
                call s__InventoryButton_removeItem(b,host)
                if removeItem then
                    call SaveInteger(Table___ht, (ItemInventory__itemLinks), (GetHandleId(s__Item_link[i])), ( 0)) // INLINED!!
                    call s__Item_destroy(i)
                endif
                call SaveInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((id)), ( ( 0))) // INLINED!!
            endif
        endfunction
        
        function s__CustomInventory_clearEquipmentButton takes integer b,unit host,boolean removeItem returns nothing
            local integer id= GetHandleId(host)
            local integer i= (LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((id)))) // INLINED!!
            if i != null then
                call sc__CustomInventory_removeEqWithoutAdd(b , GetOwningPlayer(host))
                call s__InventoryButton_removeItem(b,host)
                if removeItem then
                    call SaveInteger(Table___ht, (ItemInventory__itemLinks), (GetHandleId(s__Item_link[i])), ( 0)) // INLINED!!
                    call s__Item_destroy(i)
                endif
                call SaveInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((id)), ( ( 0))) // INLINED!!
            endif
        endfunction
        
        function s__CustomInventory_destroyEverything takes unit host returns nothing
            local integer i= 0
            local integer i2= 0
            local integer id= GetHandleId(host)
            local integer b
            local integer it
            loop
                exitwhen i > ItemInventory__eqSize
                set b=ItemInventory__equipment[i]
                if (LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((id)))) != 0 then // INLINED!!
                    call s__CustomInventory_clearInventoryButton(b , host , true)
                endif
                set i=i + 1
            endloop
            set i=0
            loop
                exitwhen i > ItemInventory__inSize
                set b=ItemInventory__inventory[i]
                if (LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((id)))) != 0 then // INLINED!!
                    call s__CustomInventory_clearEquipmentButton(b , host , true)
                endif
                set i=i + 1
            endloop
        endfunction
        
        function s__CustomInventory_getInventory takes unit host returns integer
            local integer i= 0
            local integer i2= 0
            local integer id= GetHandleId(host)
            local integer b
            local integer t= s__Table_create()
            loop
                exitwhen i > ItemInventory__inSize
                set b=ItemInventory__inventory[i]
                if (LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((id)))) != 0 then // INLINED!!
                    call SaveInteger(Table___ht, (t), (i2), ( (LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((id)))))) // INLINED!!
                    set i2=i2 + 1
                endif
                set i=i + 1
            endloop
            return t
        endfunction
        
    
        function s__CustomInventory_rects takes nothing returns nothing
            
            set ItemInventory__inRect=Rect(29088, 26368, 30400, 26880)
            set ItemInventory__opRect=Rect(29920, 26912, 30368, 27392)
            set ItemInventory__eqRect=Rect(29120, 26880, 29632, 27392)
            set ItemInventory__coRect=Rect(30464, 26368, 31104, 26624)
            set ItemInventory__selectedRect=Rect(30624, 26656, 31062, 26720)
            set ItemInventory__hoverTitleRect=Rect(30592, 27296, 31072, 27360)
            set ItemInventory__hoverDescRect=Rect(30496, 26816, 31072, 27232)
        endfunction
        function s__CustomInventory_linkItemTraitData takes integer buttonIdV,integer equipmentSlot,string titleV,string description,item linkedItem returns nothing
            call SaveInteger(Table___ht, (ItemInventory__itemLinks), (GetHandleId(linkedItem)), ( (s__Item_create(buttonIdV , equipmentSlot , titleV , description , linkedItem)))) // INLINED!!
        endfunction
        
        function s__CustomInventory_getItemTraitData takes item i returns integer
            return ((LoadInteger(Table___ht, (ItemInventory__itemLinks), (GetHandleId(i))))) // INLINED!!
        endfunction
        
        function s__CustomInventory_addItemToBag takes integer i,unit u returns integer
            local integer i2= 0
            local integer i3= GetHandleId(u)
            call SetItemVisible(s__Item_link[i], false)
            loop
                if (LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[ItemInventory__inventory[i2]])]), ((i3)))) == null then // INLINED!!
                    call s__InventoryButton_setLink(ItemInventory__inventory[i2],i , u)
                    call s__InventoryButton_recreate(ItemInventory__inventory[i2],GetOwningPlayer(u))
                    return ItemInventory__inventory[i2]
                endif
                set i2=i2 + 1
                exitwhen i2 == ItemInventory__inSize
            endloop
            return 0
        endfunction
        
        function s__CustomInventory_doesUnitHaveItemInEq takes integer itemId,unit host returns integer
            local integer i= 0
            local integer itid= itemId
            local integer hoid= GetHandleId(host)
            loop
                if GetItemTypeId(s__Item_link[(LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[ItemInventory__equipment[i]])]), ((hoid))))]) == itid then // INLINED!!
                    return (LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[ItemInventory__equipment[i]])]), ((hoid)))) // INLINED!!
                else
                    set i=i + 1
                    exitwhen i > ItemInventory__eqSize
                endif
            endloop
            return 0
        endfunction
        
        function s__CustomInventory_gather takes unit host returns integer
            local integer t= s__TableArray__staticgetindex(2)
            local integer i= 0
            local integer i2= 0
            local integer id= GetHandleId(host)
            local integer temp
            loop
                exitwhen i > ItemInventory__opSize
                if (LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[ItemInventory__recipeArea[i]])]), ((id)))) != 0 then // INLINED!!
                    set temp=GetItemTypeId(s__Item_link[(LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[ItemInventory__recipeArea[i]])]), ((id))))]) // INLINED!!
                    call SaveInteger(Table___ht, (((t) + (0))), (temp), ( (LoadInteger(Table___ht, (((t) + (0))), (temp))) + 1)) // INLINED!!
                    if (LoadInteger(Table___ht, (((t) + (0))), (temp))) == 1 then // INLINED!!
                    
                        call SaveInteger(Table___ht, (((t) + (1))), (temp), ( s__InventoryGrouping_create())) // INLINED!!
                    endif
                    call s__InventoryGrouping_add(((LoadInteger(Table___ht, (((t) + (1))), (temp)))),ItemInventory__recipeArea[i]) // INLINED!!
                endif
                set i=i + 1
            endloop
            return t
        endfunction
        
        function s__CustomInventory_doesUnitHaveItemInInv takes integer itemId,unit host returns integer
            local integer i= 0
            local integer itid= itemId
            local integer hoid= GetHandleId(host)
            loop
                if GetItemTypeId(s__Item_link[(LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[ItemInventory__inventory[i]])]), ((hoid))))]) == itid then // INLINED!!
                    return (LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[ItemInventory__inventory[i]])]), ((hoid)))) // INLINED!!
                else
                    set i=i + 1
                    exitwhen i > ItemInventory__eqSize
                endif
            endloop
            return 0
        endfunction
        function s__CustomInventory_onItemPickup takes integer it,unit u returns nothing
        
            local integer i= 0
            local integer i2
            local integer i3= 0
            local integer i4= GetHandleId(u)
            local integer tempid
            local integer trait
            if it == 0 then
                return
            endif
            if s__ICI_getItemSlotPriority(it , 1) == 3 or s__ICI_getItemSlotPriority(it , 1) == 4 or not s__Item_willHostFulfillReqs(it,u) then
                call s__CustomInventory_addItemToBag(it , u) //.tooltip("1","2")
                return
            endif
            loop
                set i2=s__ICI_getItemSlotPriority(it , i + 1)
                if (LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[ItemInventory__equipment[i]])]), ((i4)))) == null and ( i2 == 2 or i2 == 1 ) then // INLINED!!
                    if (LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[ItemInventory__equipment[i]])]), ((i4)))) != null then // INLINED!!
                        if (LoadInteger(Table___ht, (s__Item_traits[((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[ItemInventory__equipment[i]])]), ((i4)))))]), ((0)))) != 0 then // INLINED!!
                            loop
                                call s__ICI_removeTraitFromUnit((LoadInteger(Table___ht, (s__Item_traits[((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[ItemInventory__equipment[i]])]), ((i4)))))]), ((i3)))) , u) // INLINED!!
                                set i3=i3 + 1
                                exitwhen (LoadInteger(Table___ht, (s__Item_traits[((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[ItemInventory__equipment[i]])]), ((i4)))))]), ((i3)))) == 0 // INLINED!!
                            endloop
                        endif
                        call s__CustomInventory_addItemToBag((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[ItemInventory__equipment[i]])]), ((i4)))) , u) //.tooltip(equipment[i].link[i4].title, equipment[i].link[i4].desc) // INLINED!!
                        call s__InventoryButton_removeItem(ItemInventory__equipment[i],u)
                    endif
                    if GetLocalPlayer() == GetOwningPlayer(u) then
                        set tempid=s__Item_buttonId[it]
                    else
                        set tempid=GetDestructableTypeId(s__InventoryButton_current[ItemInventory__equipment[i]])
                    endif
                    set trait=it
                    call SaveInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[ItemInventory__equipment[i]])]), ((i4)), ( ( it))) // INLINED!!
                    call RemoveDestructable(s__InventoryButton_current[ItemInventory__equipment[i]])
                    set s__InventoryButton_current[ItemInventory__equipment[i]]=CreateDestructable(tempid, s__InventoryButton_x[ItemInventory__equipment[i]], s__InventoryButton_y[ItemInventory__equipment[i]], 0, 1, 0)
                    set i3=0
                    if (LoadInteger(Table___ht, (s__Item_traits[(it)]), ((0)))) != 0 then // INLINED!!
                        loop
                            call s__ICI_applyTraitToUnit((LoadInteger(Table___ht, (s__Item_traits[(it)]), ((i3)))) , u) // INLINED!!
                            set i3=i3 + 1
                            exitwhen (LoadInteger(Table___ht, (s__Item_traits[(it)]), ((i3)))) == 0 // INLINED!!
                        endloop
                    endif
                    if s__Item_setv[trait] != 0 then
                        call s__Set_checkForSetData(s__Item_setv[trait],u)
                    endif
                    exitwhen true
                elseif i2 == 3 then
                    exitwhen true
                endif
                set i=i + 1
                exitwhen i == 16
            endloop
            if i == 16 then
                call s__CustomInventory_addItemToBag(it , u)
            endif
        endfunction
        function s__CustomInventory_addItemToEquipment takes integer b,unit u returns nothing
            local integer i= 0
            local integer i2
            local integer i3= 0
            local integer i4= GetHandleId(u)
            local integer tempid
            local integer trait
            if (LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i4)))) == 0 then // INLINED!!
                return
            endif
            if not s__Item_willHostFulfillReqs((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i4)))),u) then // INLINED!!
                call DisplayTimedTextToPlayer(GetOwningPlayer(u), 0, 0, 30, "|cffffcc00Information|r: The hero cannot equip this due to requirements on the item")
                return
            endif
            loop
                set i2=s__ICI_getItemSlotPriority((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i4)))) , i + 1) // INLINED!!
                if i2 == 2 or ( i2 == 1 and (LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[ItemInventory__equipment[i]])]), ((i4)))) == null ) then // INLINED!!
                    if (LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[ItemInventory__equipment[i]])]), ((i4)))) != null then // INLINED!!
                        if (LoadInteger(Table___ht, (s__Item_traits[((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[ItemInventory__equipment[i]])]), ((i4)))))]), ((0)))) != 0 then // INLINED!!
                            loop
                                call s__ICI_removeTraitFromUnit((LoadInteger(Table___ht, (s__Item_traits[((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[ItemInventory__equipment[i]])]), ((i4)))))]), ((i3)))) , u) // INLINED!!
                                set i3=i3 + 1
                                exitwhen (LoadInteger(Table___ht, (s__Item_traits[((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[ItemInventory__equipment[i]])]), ((i4)))))]), ((i3)))) == 0 // INLINED!!
                            endloop
                        endif
                        call s__CustomInventory_addItemToBag((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[ItemInventory__equipment[i]])]), ((i4)))) , u) //.tooltip(equipment[i].link[i4].title, equipment[i].link[i4].desc) // INLINED!!
                        call s__InventoryButton_removeItem(ItemInventory__equipment[i],u)
                    endif
                    if GetLocalPlayer() == GetOwningPlayer(u) then
                        set tempid=s__Item_buttonId[(LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i4))))] // INLINED!!
                    else
                        set tempid=GetDestructableTypeId(s__InventoryButton_current[ItemInventory__equipment[i]])
                    endif
                    set trait=(LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i4)))) // INLINED!!
                    call SaveInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[ItemInventory__equipment[i]])]), ((i4)), ( ( (LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i4))))))) // INLINED!!
                    call RemoveDestructable(s__InventoryButton_current[ItemInventory__equipment[i]])
                    set s__InventoryButton_current[ItemInventory__equipment[i]]=CreateDestructable(tempid, s__InventoryButton_x[ItemInventory__equipment[i]], s__InventoryButton_y[ItemInventory__equipment[i]], 0, 1, 0)
                    set i3=0
                    if (LoadInteger(Table___ht, (s__Item_traits[((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i4)))))]), ((0)))) != 0 then // INLINED!!
                        loop
                            call s__ICI_applyTraitToUnit((LoadInteger(Table___ht, (s__Item_traits[((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i4)))))]), ((i3)))) , u) // INLINED!!
                            set i3=i3 + 1
                            exitwhen (LoadInteger(Table___ht, (s__Item_traits[((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i4)))))]), ((i3)))) == 0 // INLINED!!
                        endloop
                    endif
                    call s__InventoryButton_removeItem(b,u)
                    if s__Item_setv[trait] != 0 then
                        call s__Set_checkForSetData(s__Item_setv[trait],u)
                    endif
                    exitwhen true
                elseif i2 == 3 then
                   // call b.link[i4].getRecipe().check(u,b)
                    exitwhen true
                endif
                set i=i + 1
                exitwhen i == 16
            endloop
        endfunction
        
        function s__CustomInventory_wipeSelected takes player p returns nothing
            local integer tempid
            if GetLocalPlayer() == p then
                set tempid=ItemInventory__EMPTY_BAG_SLOT
            else
                set tempid=GetDestructableTypeId(ItemInventory__currentlySelectedIcon)
            endif
            call RemoveDestructable(ItemInventory__currentlySelectedIcon)
            set ItemInventory__currentlySelectedIcon=CreateDestructable(tempid, ItemInventory__crntX, ItemInventory__crntY, 0, 1, 0)
            call SaveInteger(Table___ht, (s__T2InvB_t[(ItemInventory__currentlySelectedItem)]), (((GetHandleId((udg_PlayerUnit[GetPlayerId(((p))) + 1]))))), ( ( 0))) // INLINED!!
            if ItemInventory__crntTT == null then
                set ItemInventory__crntTT=CreateTextTag()
                call SetTextTagPos(ItemInventory__crntTT, GetRectMinX(ItemInventory__selectedRect), GetRectMinY(ItemInventory__selectedRect), 0)
                call SetTextTagVisibility(ItemInventory__crntTT, true)
            endif
            if GetLocalPlayer() == p then
                call SetTextTagTextBJ(ItemInventory__crntTT, "", 10)
            endif
            call sc__CustomInventory_wipeHovered(p)
        endfunction
        
        function s__CustomInventory_wipeHovered takes player p returns nothing
            local integer tempid
                if GetLocalPlayer() == p then
                    set tempid=ItemInventory__EMPTY_BAG_SLOT
                else
                    set tempid=GetDestructableTypeId(ItemInventory__lastHoveredIcon)
                endif
                call RemoveDestructable(ItemInventory__lastHoveredIcon)
                set ItemInventory__lastHoveredIcon=CreateDestructable(tempid, ItemInventory__lstX, ItemInventory__lstY, 0, 1, 0)
                call SaveInteger(Table___ht, (s__T2InvB_t[(ItemInventory__lastHoveredItem)]), (((GetHandleId((udg_PlayerUnit[GetPlayerId(((p))) + 1]))))), ( ( 0))) // INLINED!!
                if ItemInventory__lstTTtitle == null then
                    set ItemInventory__lstTTtitle=CreateTextTag()
                    set ItemInventory__lstTTdesc=CreateTextTag()
                    call SetTextTagPos(ItemInventory__lstTTtitle, GetRectMinX(ItemInventory__hoverTitleRect), GetRectMinY(ItemInventory__hoverTitleRect), 0)
                    call SetTextTagVisibility(ItemInventory__lstTTtitle, true)
                    call SetTextTagPos(ItemInventory__lstTTdesc, GetRectMinX(ItemInventory__hoverDescRect), GetRectMinY(ItemInventory__hoverDescRect), 0)
                    call SetTextTagVisibility(ItemInventory__lstTTdesc, true)
                endif
                if GetLocalPlayer() == p then
                    call SetTextTagTextBJ(ItemInventory__lstTTtitle, "", 10)
                    call SetTextTagTextBJ(ItemInventory__lstTTdesc, "", 10)
                endif
        endfunction
        
        function s__CustomInventory_getSelected takes unit u returns integer
            return (LoadInteger(Table___ht, (s__T2InvB_t[(ItemInventory__currentlySelectedItem)]), ((GetHandleId(u))))) // INLINED!!
        endfunction
        function s__CustomInventory_setLastClicked takes integer b,player p returns nothing
            local integer tempid
            if GetLocalPlayer() == p then
                set tempid=GetDestructableTypeId(s__InventoryButton_current[b])
            else
                set tempid=GetDestructableTypeId(ItemInventory__currentlySelectedIcon)
            endif
            call RemoveDestructable(ItemInventory__currentlySelectedIcon)
            set ItemInventory__currentlySelectedIcon=CreateDestructable(tempid, ItemInventory__crntX, ItemInventory__crntY, 0, 1, 0)
            call SaveInteger(Table___ht, (s__T2InvB_t[(ItemInventory__currentlySelectedItem)]), (((GetHandleId((udg_PlayerUnit[GetPlayerId(((p))) + 1]))))), ( ( b))) // INLINED!!
            if ItemInventory__crntTT == null then
                set ItemInventory__crntTT=CreateTextTag()
                call SetTextTagPos(ItemInventory__crntTT, GetRectMinX(ItemInventory__selectedRect), GetRectMinY(ItemInventory__selectedRect), 0)
                call SetTextTagVisibility(ItemInventory__crntTT, true)
            endif
            if GetLocalPlayer() == p then
                call SetTextTagTextBJ(ItemInventory__crntTT, s__Item_title[(LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), (((GetHandleId((udg_PlayerUnit[GetPlayerId(((p))) + 1])))))))], 10) // INLINED!!
            endif
        endfunction
        function s__CustomInventory_setLastHovered takes integer b,player p,integer id returns nothing
            local integer tempid
            if (LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((id)))) != 0 then // INLINED!!
                if GetLocalPlayer() == p then
                    set tempid=GetDestructableTypeId(s__InventoryButton_current[b])
                else
                    set tempid=GetDestructableTypeId(ItemInventory__lastHoveredIcon)
                endif
                call RemoveDestructable(ItemInventory__lastHoveredIcon)
                set ItemInventory__lastHoveredIcon=CreateDestructable(tempid, ItemInventory__lstX, ItemInventory__lstY, 0, 1, 0)
                call SaveInteger(Table___ht, (s__T2InvB_t[(ItemInventory__lastHoveredItem)]), ((id)), ( ( b))) // INLINED!!
                if ItemInventory__lstTTtitle == null then
                    set ItemInventory__lstTTtitle=CreateTextTag()
                    set ItemInventory__lstTTdesc=CreateTextTag()
                    call SetTextTagPos(ItemInventory__lstTTtitle, GetRectMinX(ItemInventory__hoverTitleRect), GetRectMinY(ItemInventory__hoverTitleRect), 0)
                    call SetTextTagVisibility(ItemInventory__lstTTtitle, true)
                    call SetTextTagPos(ItemInventory__lstTTdesc, GetRectMinX(ItemInventory__hoverDescRect), GetRectMinY(ItemInventory__hoverDescRect), 0)
                    call SetTextTagVisibility(ItemInventory__lstTTdesc, true)
                endif
                if GetLocalPlayer() == p then
                    call SetTextTagTextBJ(ItemInventory__lstTTtitle, s__Item_title[(LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((id))))], 10) // INLINED!!
                    call SetTextTagTextBJ(ItemInventory__lstTTdesc, s__Item_genDesc[(LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((id))))], 10) // INLINED!!
                endif
            endif
        endfunction
        function s__CustomInventory_moveToRecipe takes integer b,integer slot,unit host returns nothing
            local integer id= GetHandleId(host)
            local integer target= b
            set b=(LoadInteger(Table___ht, (s__T2InvB_t[(ItemInventory__currentlySelectedItem)]), ((id)))) // INLINED!!
            if (LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[target])]), ((id)))) != 0 then // INLINED!!
                call sc__CustomInventory_moveFromRecipe(target , host)
            endif
            call s__InventoryButton_setLink(target,(LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((id)))) , host) // INLINED!!
            call s__InventoryButton_recreate(target,GetOwningPlayer(host))
            call s__InventoryButton_setLink(b,0 , host)
            call s__InventoryButton_recreate(b,GetOwningPlayer(host))
        endfunction
        function s__CustomInventory_moveFromRecipe takes integer b,unit host returns nothing
            local integer id= GetHandleId(host)
            call s__CustomInventory_addItemToBag((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[(LoadInteger(Table___ht, (s__T2InvB_t[(ItemInventory__currentlySelectedItem)]), ((id))))])]), ((id)))) , host) // INLINED!!
            call s__InventoryButton_setLink((LoadInteger(Table___ht, (s__T2InvB_t[(ItemInventory__currentlySelectedItem)]), ((id)))),0 , host) // INLINED!!
            call s__InventoryButton_recreate((LoadInteger(Table___ht, (s__T2InvB_t[(ItemInventory__currentlySelectedItem)]), ((id)))),GetOwningPlayer(host)) // INLINED!!
        endfunction
        function s__CustomInventory_removeItemFromEquipment takes integer b,player click returns nothing
            local integer i3= 0
            local integer i= (GetHandleId((udg_PlayerUnit[GetPlayerId(((click))) + 1]))) // INLINED!!
            local integer tempid
            local integer trait
            set trait=(LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i)))) // INLINED!!
            if (LoadInteger(Table___ht, (s__Item_traits[((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i)))))]), ((0)))) != 0 then // INLINED!!
                loop
                    call s__ICI_removeTraitFromUnit((LoadInteger(Table___ht, (s__Item_traits[((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i)))))]), ((i3)))) , (udg_PlayerUnit[GetPlayerId((click)) + 1])) // INLINED!!
                    set i3=i3 + 1
                    exitwhen (LoadInteger(Table___ht, (s__Item_traits[((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i)))))]), ((i3)))) == 0 // INLINED!!
                endloop
            endif
            call s__CustomInventory_addItemToBag((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i)))) , (udg_PlayerUnit[GetPlayerId((click)) + 1])) //.tooltip(b.link[i].title, b.link[i].desc) // INLINED!!
            call s__InventoryButton_removeItem(b,(udg_PlayerUnit[GetPlayerId((click)) + 1])) // INLINED!!
           // call b.noTooltip()
            set tempid=s__ICI_getSlotEmptyBackground(R2I(( ( ( s__InventoryButton_x[b] - ItemInventory__eqminx ) / ItemInventory__eqxbetween ) + ItemInventory__eqwidth * ( RAbsBJ(( s__InventoryButton_y[b] - ItemInventory__eqmaxy )) / ItemInventory__eqybetween ) )))
            if GetLocalPlayer() != click then
                set tempid=GetDestructableTypeId(s__InventoryButton_current[b])
            endif
            call RemoveDestructable(s__InventoryButton_current[b])
            set s__InventoryButton_current[b]=CreateDestructable(tempid, s__InventoryButton_x[b], s__InventoryButton_y[b], 0, 1, 0)
            if s__Item_setv[trait] != 0 then
                call s__Set_checkForSetData(s__Item_setv[trait],(udg_PlayerUnit[GetPlayerId((click)) + 1])) // INLINED!!
            endif
        endfunction
        function s__CustomInventory_removeEqWithoutAdd takes integer b,player click returns nothing
            local integer i3= 0
            local integer i= (GetHandleId((udg_PlayerUnit[GetPlayerId(((click))) + 1]))) // INLINED!!
            local integer tempid
            local integer trait
            set trait=(LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i)))) // INLINED!!
            if (LoadInteger(Table___ht, (s__Item_traits[((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i)))))]), ((0)))) != 0 then // INLINED!!
                loop
                    call s__ICI_removeTraitFromUnit((LoadInteger(Table___ht, (s__Item_traits[((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i)))))]), ((i3)))) , (udg_PlayerUnit[GetPlayerId((click)) + 1])) // INLINED!!
                    set i3=i3 + 1
                    exitwhen (LoadInteger(Table___ht, (s__Item_traits[((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i)))))]), ((i3)))) == 0 // INLINED!!
                endloop
            endif
            call s__InventoryButton_removeItem(b,(udg_PlayerUnit[GetPlayerId((click)) + 1])) // INLINED!!
           // call b.noTooltip()
            set tempid=s__ICI_getSlotEmptyBackground(R2I(( ( ( s__InventoryButton_x[b] - ItemInventory__eqminx ) / ItemInventory__eqxbetween ) + ItemInventory__eqwidth * ( RAbsBJ(( s__InventoryButton_y[b] - ItemInventory__eqmaxy )) / ItemInventory__eqybetween ) )))
            if GetLocalPlayer() != click then
                set tempid=GetDestructableTypeId(s__InventoryButton_current[b])
            endif
            call RemoveDestructable(s__InventoryButton_current[b])
            set s__InventoryButton_current[b]=CreateDestructable(tempid, s__InventoryButton_x[b], s__InventoryButton_y[b], 0, 1, 0)
            if s__Item_setv[trait] != 0 then
                call s__Set_checkForSetData(s__Item_setv[trait],(udg_PlayerUnit[GetPlayerId((click)) + 1])) // INLINED!!
            endif
        endfunction
        //public static method putItemInBag takes item i returns n
        function s__CustomInventory_destEnum takes nothing returns boolean
            local destructable d= GetFilterDestructable()
            local integer b
            if GetDestructableTypeId(d) != ItemInventory__INVISIBLE_ICON then
                set d=null
                return false
            endif
            set b=s__InventoryButton_create(GetDestructableX(d) , GetDestructableY(d) , d , (s__Track_createTrack((("war3mapImported\\64x64Track.mdl" ) ) , (( (( GetDestructableX(d) )*1.0) )*1.0) , (( (( GetDestructableY(d) )*1.0) )*1.0) , (( (( 0 )*1.0) )*1.0) , (( (( 0)*1.0))*1.0) , null))) // INLINED!!
            //call b.tooltip("helloer", "hellllllloer/nhellloer\nhlelllllllloer|nlolusdf")
            set d=CreateDestructable(ItemInventory__EMPTY_BAG_SLOT, s__InventoryButton_x[b], s__InventoryButton_y[b], 0, 1, 0)
            call RemoveDestructable(s__InventoryButton_current[b])
            set s__InventoryButton_current[b]=d
            set ItemInventory__tempTable[ItemInventory__tpSize]=b
            set d=null
            set ItemInventory__tpSize=ItemInventory__tpSize + 1
            return false
        endfunction
        function s__CustomInventory_destEnum2 takes nothing returns nothing
            local destructable d= GetEnumDestructable()
            local integer b
            if GetDestructableTypeId(d) != ItemInventory__INVISIBLE_ICON then
                set d=null
                return
            endif
            set b=s__InventoryButton_create(GetDestructableX(d) , GetDestructableY(d) , d , (s__Track_createTrack((("war3mapImported\\64x64Track.mdl" ) ) , (( (( GetDestructableX(d) )*1.0) )*1.0) , (( (( GetDestructableY(d) )*1.0) )*1.0) , (( (( 0 )*1.0) )*1.0) , (( (( 0)*1.0))*1.0) , null))) // INLINED!!
            //call b.tooltip("helloer", "hellllllloer/nhellloer\nhlelllllllloer|nlolusdf")
            set d=CreateDestructable(ItemInventory__EMPTY_BAG_SLOT, s__InventoryButton_x[b], s__InventoryButton_y[b], 0, 1, 0)
            call RemoveDestructable(s__InventoryButton_current[b])
            set s__InventoryButton_current[b]=d
            set ItemInventory__tempTable[ItemInventory__tpSize]=b
            set d=null
            set ItemInventory__tpSize=ItemInventory__tpSize + 1
            return
        endfunction
        function s__CustomInventory_onTrackableClick takes nothing returns boolean
            local integer t= (s__Track_instance) // INLINED!!
            local player p= (s__Track_tracker) // INLINED!!
            local integer b
            local integer b2
            local integer i= 0
            local integer i2
            local integer i3= (GetHandleId((udg_PlayerUnit[GetPlayerId(((p))) + 1]))) // INLINED!!
            local integer tempid
            local integer slot
            if RectContainsCoords(ItemInventory__inRect, s__Track_x[t], s__Track_y[t]) then
                set i=R2I(( ( ( s__Track_x[t] - ItemInventory__inminx ) / ItemInventory__inxbetween ) + ItemInventory__inwidth * ( RAbsBJ(( s__Track_y[t] - ItemInventory__inmaxy )) / ItemInventory__inybetween ) ))
                set b=ItemInventory__inventory[i]
                if (LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i3)))) == 0 then // INLINED!!
                    if (LoadInteger(Table___ht, (s__T2InvB_t[(ItemInventory__currentlySelectedItem)]), ((i3)))) != b then // INLINED!!
                        set b2=(LoadInteger(Table___ht, (s__T2InvB_t[(ItemInventory__currentlySelectedItem)]), ((i3)))) // INLINED!!
                        if RectContainsCoords(ItemInventory__opRect, s__InventoryButton_x[b2], s__InventoryButton_y[b2]) then
                            call s__CustomInventory_moveFromRecipe(b , (udg_PlayerUnit[GetPlayerId((p)) + 1])) // INLINED!!
                            call s__CustomInventory_wipeSelected(p)
                        elseif RectContainsCoords(ItemInventory__eqRect, s__InventoryButton_x[b2], s__InventoryButton_y[b2]) then
                            call s__CustomInventory_removeItemFromEquipment(b , p)
                            call s__CustomInventory_wipeSelected(p)
                        endif
                    endif
                else
                    if (LoadInteger(Table___ht, (s__T2InvB_t[(ItemInventory__currentlySelectedItem)]), ((i3)))) != b then // INLINED!!
                        call s__CustomInventory_setLastClicked(b , p)
                    else
                        call s__CustomInventory_addItemToEquipment(b , (udg_PlayerUnit[GetPlayerId((p)) + 1])) // INLINED!!
                        call s__CustomInventory_wipeSelected(p)
                    endif
                endif
            elseif RectContainsCoords(ItemInventory__eqRect, s__Track_x[t], s__Track_y[t]) then
                set b=ItemInventory__equipment[R2I(( ( ( s__Track_x[t] - ItemInventory__eqminx ) / ItemInventory__eqxbetween ) + ItemInventory__eqwidth * ( RAbsBJ(( s__Track_y[t] - ItemInventory__eqmaxy )) / ItemInventory__eqybetween ) ))]
                if (LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i3)))) != 0 then // INLINED!!
                    call s__CustomInventory_removeItemFromEquipment(b , p)
                    call s__CustomInventory_wipeSelected(p)
                endif
            elseif RectContainsCoords(ItemInventory__opRect, s__Track_x[t], s__Track_y[t]) then
                set slot=R2I(( ( ( s__Track_x[t] - ItemInventory__opminx ) / ItemInventory__opxbetween ) + ItemInventory__opwidth * ( RAbsBJ(( s__Track_y[t] - ItemInventory__opmaxy )) / ItemInventory__opybetween ) ))
                set b=ItemInventory__recipeArea[slot]
                if (LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i3)))) != 0 then // INLINED!!
                    if (LoadInteger(Table___ht, (s__T2InvB_t[(ItemInventory__currentlySelectedItem)]), ((i3)))) != b then // INLINED!!
                        call s__CustomInventory_setLastClicked(b , p)
                    else
                        if s__ICI_getItemSlotPriority((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i3)))) , 0) == 3 then // INLINED!!
                            set applicablePlayer=p
                            if s__RecipeGroup_check((s__Item_possibleRecipe[((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i3)))))]),(udg_PlayerUnit[GetPlayerId((p)) + 1]) , b) then // INLINED!!
                                if s__CustomInventory_onRecipe != null then
                                    call TriggerEvaluate(s__CustomInventory_onRecipe)
                                endif
                            endif
                        else
                            call s__CustomInventory_moveFromRecipe(b , (udg_PlayerUnit[GetPlayerId((p)) + 1])) // INLINED!!
                            call s__CustomInventory_wipeSelected(p)
                        endif
                    endif
                elseif (LoadInteger(Table___ht, (s__T2InvB_t[(ItemInventory__currentlySelectedItem)]), ((i3)))) != 0 then // INLINED!!
                    call s__CustomInventory_moveToRecipe(b , slot , (udg_PlayerUnit[GetPlayerId((p)) + 1])) // INLINED!!
                    call s__CustomInventory_wipeSelected(p)
                endif
            endif
            return false
        endfunction
        function s__CustomInventory_onTrackableHover takes nothing returns boolean
            local integer t= (s__Track_instance) // INLINED!!
            local player p= (s__Track_tracker) // INLINED!!
            local integer b
            local string title
            local string desc
            local integer tempid
            local integer n= (GetHandleId((udg_PlayerUnit[GetPlayerId(((p))) + 1]))) // INLINED!!
            if RectContainsCoords(ItemInventory__inRect, s__Track_x[t], s__Track_y[t]) or RectContainsCoords(ItemInventory__eqRect, s__Track_x[t], s__Track_y[t]) or RectContainsCoords(ItemInventory__opRect, s__Track_x[t], s__Track_y[t]) then
                if RectContainsCoords(ItemInventory__inRect, s__Track_x[t], s__Track_y[t]) then
                    set b=ItemInventory__inventory[R2I(( ( ( s__Track_x[t] - ItemInventory__inminx ) / ItemInventory__inxbetween ) + ItemInventory__inwidth * ( RAbsBJ(( s__Track_y[t] - ItemInventory__inmaxy )) / ItemInventory__inybetween ) ))]
                elseif RectContainsCoords(ItemInventory__eqRect, s__Track_x[t], s__Track_y[t]) then
                    set b=ItemInventory__equipment[R2I(( ( ( s__Track_x[t] - ItemInventory__eqminx ) / ItemInventory__eqxbetween ) + ItemInventory__eqwidth * ( RAbsBJ(( s__Track_y[t] - ItemInventory__eqmaxy )) / ItemInventory__eqybetween ) ))]
                else
                    set b=ItemInventory__recipeArea[R2I(( ( ( s__Track_x[t] - ItemInventory__opminx ) / ItemInventory__opxbetween ) + ItemInventory__opwidth * ( RAbsBJ(( s__Track_y[t] - ItemInventory__opmaxy )) / ItemInventory__opybetween ) ))]
                endif
                call s__CustomInventory_setLastHovered(b , p , n)
            endif
            return false
        endfunction
            
        
        function s__CustomInventory_Initalize takes nothing returns nothing
            local integer i= 0
            local integer a= 0
            local real x= 0
            local real x2= 0
            local integer x3= 0
            local real x4= 0
            local real y= 0
            local real y2= 0
            local integer y3= 0
            local real y4= 0

            
            local item it
            local integer b
            local integer c
            call ItemInventory__setDestructableIds()
            call TriggerAddCondition(s__Track_anyClick, Filter(((function s__CustomInventory_onTrackableClick)))) // INLINED!!
            call TriggerAddCondition(s__Track_anyHover, Filter(((function s__CustomInventory_onTrackableHover)))) // INLINED!!
//textmacro instance: INIT_MAIN_LOOP("in","inventory")
            set i=0
            set a=0
            set x=0
            set x2=0
            set x3=0
            set x4=0
            set y=0
            set y2=0
            set y3=0
            set y4=0
            
            set it=null
            set b=0
            set c=0
            loop
            //    call EnumDestructablesInRectAll(inRect, Filter(function thistype.destEnum), null)
                call EnumDestructablesInRectAll(ItemInventory__inRect, function s__CustomInventory_destEnum2)
                exitwhen ItemInventory__tpSize > 0
            endloop
            //Now lets get the width, height, and the distance between equipment buttons 
            if ItemInventory__tpSize > 0 then //making sure theres atleast one destructable to sort
                loop
                    set b=ItemInventory__tempTable[i] //get the destructable to shuffle
                    if y == 0 then //if no destructables have been shuffled, set this one to the destructable to be compared to
                        set y=s__InventoryButton_y[b] //y and x shouldnt change as they are the values
                        set x=s__InventoryButton_x[b] //to be compared to
                        set y4=y //min y = this y
                        set x4=x //min x = this x
                        set x3=1 //its 1 wide
                        set y3=1 //and 1 highv
                    else //making sure the comparables are on the same Y axis
                        if ( RAbsBJ(s__InventoryButton_x[b] - x) < x2 or x2 == 0 ) and y == s__InventoryButton_y[b] then //checking if the X distance between is less than the previous x distance between
                            set x2=RAbsBJ(s__InventoryButton_x[b] - x) //to get the x distance between equipment buttons
                        endif
                        if ( RAbsBJ(s__InventoryButton_y[b] - y) < y2 or y2 == 0 ) and x == s__InventoryButton_x[b] then //checking if the y distance between is less than the previous y distance between
                            set y2=RAbsBJ(s__InventoryButton_y[b] - y) //to get the y distance between equipment buttons
                        endif
                        if s__InventoryButton_x[b] < x4 then
                            set x4=s__InventoryButton_x[b]
                        endif
                        if s__InventoryButton_y[b] > y4 then
                            set y4=s__InventoryButton_y[b] //x4 and y4 are the min x and min y of the table
                        endif
                        if s__InventoryButton_y[b] == y then
                            set x3=x3 + 1 //adding 1 to the width of the table
                        endif
                        if s__InventoryButton_x[b] == x then
                            set y3=y3 + 1 //adding 1 to the height of the table
                        endif
                    endif
                    set i=i + 1
                    exitwhen ItemInventory__tpSize == i //tpSize is always 1 above the array
                endloop
                //Now that we've gotten those values, we can loop through the buttons and assign them
                //x3 = width
                //y3 = height
                //x2 = x distnace between
                //y2 = y distance between
                //x4 = min x
                //y4 = max y
                set ItemInventory__inwidth=x3
                set ItemInventory__inxbetween=x2
                set ItemInventory__inybetween=y2
                set ItemInventory__inminx=x4
                set ItemInventory__inmaxy=y4
                //Note : the buttons MUST be in a consistent grid with all of the x and y distances equal
                set i=0
                 loop
                    set ItemInventory__inventory[R2I(( ( s__InventoryButton_x[ItemInventory__tempTable[i]] - x4 ) / x2 ) + x3 * ( RAbsBJ(( s__InventoryButton_y[ItemInventory__tempTable[i]] - y4 )) / y2 ))]=ItemInventory__tempTable[i]
                  set s__InventoryButton_defaultDestPic[ItemInventory__tempTable[i]]=GetDestructableTypeId(s__InventoryButton_current[ItemInventory__tempTable[i]])
                  set i=i + 1
                  exitwhen ItemInventory__tpSize == i
                endloop
                
                //now that the equipment is set, lets undo tempTable for the next loop
                set i=0
                loop
                    set ItemInventory__tempTable[i]=0
                    set i=i + 1
                    exitwhen ItemInventory__tpSize == i
                endloop
                set ItemInventory__inSize=ItemInventory__tpSize
                set ItemInventory__tpSize=0
            endif
            set i=0
            set a=0
            set x=0
            set x2=0
            set x3=0
            set x4=0
            set y=0
            set y2=0
            set y3=0
            set y4=0
            
            set it=null
            set b=0
            set c=0
//end of: INIT_MAIN_LOOP("in","inventory")
//textmacro instance: INIT_MAIN_LOOP("eq","equipment")
            set i=0
            set a=0
            set x=0
            set x2=0
            set x3=0
            set x4=0
            set y=0
            set y2=0
            set y3=0
            set y4=0
            
            set it=null
            set b=0
            set c=0
            loop
            //    call EnumDestructablesInRectAll(eqRect, Filter(function thistype.destEnum), null)
                call EnumDestructablesInRectAll(ItemInventory__eqRect, function s__CustomInventory_destEnum2)
                exitwhen ItemInventory__tpSize > 0
            endloop
            //Now lets get the width, height, and the distance between equipment buttons 
            if ItemInventory__tpSize > 0 then //making sure theres atleast one destructable to sort
                loop
                    set b=ItemInventory__tempTable[i] //get the destructable to shuffle
                    if y == 0 then //if no destructables have been shuffled, set this one to the destructable to be compared to
                        set y=s__InventoryButton_y[b] //y and x shouldnt change as they are the values
                        set x=s__InventoryButton_x[b] //to be compared to
                        set y4=y //min y = this y
                        set x4=x //min x = this x
                        set x3=1 //its 1 wide
                        set y3=1 //and 1 highv
                    else //making sure the comparables are on the same Y axis
                        if ( RAbsBJ(s__InventoryButton_x[b] - x) < x2 or x2 == 0 ) and y == s__InventoryButton_y[b] then //checking if the X distance between is less than the previous x distance between
                            set x2=RAbsBJ(s__InventoryButton_x[b] - x) //to get the x distance between equipment buttons
                        endif
                        if ( RAbsBJ(s__InventoryButton_y[b] - y) < y2 or y2 == 0 ) and x == s__InventoryButton_x[b] then //checking if the y distance between is less than the previous y distance between
                            set y2=RAbsBJ(s__InventoryButton_y[b] - y) //to get the y distance between equipment buttons
                        endif
                        if s__InventoryButton_x[b] < x4 then
                            set x4=s__InventoryButton_x[b]
                        endif
                        if s__InventoryButton_y[b] > y4 then
                            set y4=s__InventoryButton_y[b] //x4 and y4 are the min x and min y of the table
                        endif
                        if s__InventoryButton_y[b] == y then
                            set x3=x3 + 1 //adding 1 to the width of the table
                        endif
                        if s__InventoryButton_x[b] == x then
                            set y3=y3 + 1 //adding 1 to the height of the table
                        endif
                    endif
                    set i=i + 1
                    exitwhen ItemInventory__tpSize == i //tpSize is always 1 above the array
                endloop
                //Now that we've gotten those values, we can loop through the buttons and assign them
                //x3 = width
                //y3 = height
                //x2 = x distnace between
                //y2 = y distance between
                //x4 = min x
                //y4 = max y
                set ItemInventory__eqwidth=x3
                set ItemInventory__eqxbetween=x2
                set ItemInventory__eqybetween=y2
                set ItemInventory__eqminx=x4
                set ItemInventory__eqmaxy=y4
                //Note : the buttons MUST be in a consistent grid with all of the x and y distances equal
                set i=0
                 loop
                    set ItemInventory__equipment[R2I(( ( s__InventoryButton_x[ItemInventory__tempTable[i]] - x4 ) / x2 ) + x3 * ( RAbsBJ(( s__InventoryButton_y[ItemInventory__tempTable[i]] - y4 )) / y2 ))]=ItemInventory__tempTable[i]
                  set s__InventoryButton_defaultDestPic[ItemInventory__tempTable[i]]=GetDestructableTypeId(s__InventoryButton_current[ItemInventory__tempTable[i]])
                  set i=i + 1
                  exitwhen ItemInventory__tpSize == i
                endloop
                
                //now that the equipment is set, lets undo tempTable for the next loop
                set i=0
                loop
                    set ItemInventory__tempTable[i]=0
                    set i=i + 1
                    exitwhen ItemInventory__tpSize == i
                endloop
                set ItemInventory__eqSize=ItemInventory__tpSize
                set ItemInventory__tpSize=0
            endif
            set i=0
            set a=0
            set x=0
            set x2=0
            set x3=0
            set x4=0
            set y=0
            set y2=0
            set y3=0
            set y4=0
            
            set it=null
            set b=0
            set c=0
//end of: INIT_MAIN_LOOP("eq","equipment")
            loop
                call RemoveDestructable(s__InventoryButton_current[ItemInventory__equipment[i]])
                set s__InventoryButton_current[ItemInventory__equipment[i]]=CreateDestructable(s__ICI_getSlotEmptyBackground(i + 1), s__InventoryButton_x[ItemInventory__equipment[i]], s__InventoryButton_y[ItemInventory__equipment[i]], 0, 1, 0)
                set s__InventoryButton_defaultDestPic[ItemInventory__equipment[i]]=GetDestructableTypeId(s__InventoryButton_current[ItemInventory__equipment[i]])
                set i=i + 1
                exitwhen GetDestructableTypeId(s__InventoryButton_current[ItemInventory__equipment[i]]) == 0 or i > 20
            endloop
//textmacro instance: INIT_MAIN_LOOP("op","recipeArea")
            set i=0
            set a=0
            set x=0
            set x2=0
            set x3=0
            set x4=0
            set y=0
            set y2=0
            set y3=0
            set y4=0
            
            set it=null
            set b=0
            set c=0
            loop
            //    call EnumDestructablesInRectAll(opRect, Filter(function thistype.destEnum), null)
                call EnumDestructablesInRectAll(ItemInventory__opRect, function s__CustomInventory_destEnum2)
                exitwhen ItemInventory__tpSize > 0
            endloop
            //Now lets get the width, height, and the distance between equipment buttons 
            if ItemInventory__tpSize > 0 then //making sure theres atleast one destructable to sort
                loop
                    set b=ItemInventory__tempTable[i] //get the destructable to shuffle
                    if y == 0 then //if no destructables have been shuffled, set this one to the destructable to be compared to
                        set y=s__InventoryButton_y[b] //y and x shouldnt change as they are the values
                        set x=s__InventoryButton_x[b] //to be compared to
                        set y4=y //min y = this y
                        set x4=x //min x = this x
                        set x3=1 //its 1 wide
                        set y3=1 //and 1 highv
                    else //making sure the comparables are on the same Y axis
                        if ( RAbsBJ(s__InventoryButton_x[b] - x) < x2 or x2 == 0 ) and y == s__InventoryButton_y[b] then //checking if the X distance between is less than the previous x distance between
                            set x2=RAbsBJ(s__InventoryButton_x[b] - x) //to get the x distance between equipment buttons
                        endif
                        if ( RAbsBJ(s__InventoryButton_y[b] - y) < y2 or y2 == 0 ) and x == s__InventoryButton_x[b] then //checking if the y distance between is less than the previous y distance between
                            set y2=RAbsBJ(s__InventoryButton_y[b] - y) //to get the y distance between equipment buttons
                        endif
                        if s__InventoryButton_x[b] < x4 then
                            set x4=s__InventoryButton_x[b]
                        endif
                        if s__InventoryButton_y[b] > y4 then
                            set y4=s__InventoryButton_y[b] //x4 and y4 are the min x and min y of the table
                        endif
                        if s__InventoryButton_y[b] == y then
                            set x3=x3 + 1 //adding 1 to the width of the table
                        endif
                        if s__InventoryButton_x[b] == x then
                            set y3=y3 + 1 //adding 1 to the height of the table
                        endif
                    endif
                    set i=i + 1
                    exitwhen ItemInventory__tpSize == i //tpSize is always 1 above the array
                endloop
                //Now that we've gotten those values, we can loop through the buttons and assign them
                //x3 = width
                //y3 = height
                //x2 = x distnace between
                //y2 = y distance between
                //x4 = min x
                //y4 = max y
                set ItemInventory__opwidth=x3
                set ItemInventory__opxbetween=x2
                set ItemInventory__opybetween=y2
                set ItemInventory__opminx=x4
                set ItemInventory__opmaxy=y4
                //Note : the buttons MUST be in a consistent grid with all of the x and y distances equal
                set i=0
                 loop
                    set ItemInventory__recipeArea[R2I(( ( s__InventoryButton_x[ItemInventory__tempTable[i]] - x4 ) / x2 ) + x3 * ( RAbsBJ(( s__InventoryButton_y[ItemInventory__tempTable[i]] - y4 )) / y2 ))]=ItemInventory__tempTable[i]
                  set s__InventoryButton_defaultDestPic[ItemInventory__tempTable[i]]=GetDestructableTypeId(s__InventoryButton_current[ItemInventory__tempTable[i]])
                  set i=i + 1
                  exitwhen ItemInventory__tpSize == i
                endloop
                
                //now that the equipment is set, lets undo tempTable for the next loop
                set i=0
                loop
                    set ItemInventory__tempTable[i]=0
                    set i=i + 1
                    exitwhen ItemInventory__tpSize == i
                endloop
                set ItemInventory__opSize=ItemInventory__tpSize
                set ItemInventory__tpSize=0
            endif
            set i=0
            set a=0
            set x=0
            set x2=0
            set x3=0
            set x4=0
            set y=0
            set y2=0
            set y3=0
            set y4=0
            
            set it=null
            set b=0
            set c=0
//end of: INIT_MAIN_LOOP("op","recipeArea")
            //loop
                
             //   call RemoveDestructable(recipeArea[i].current)
             //   set recipeArea[i].current = CreateDestructable(ICI.getOpConButton(i), recipeArea[i].x,recipeArea[i].y,1,1,1)
               
              //      set i = i + 1
              //  exitwhen GetDestructableTypeId(recipeArea[i].current) == 0 or i > 20
           // endloop
//textmacro instance: INIT_MAIN_LOOP("co","console")
            set i=0
            set a=0
            set x=0
            set x2=0
            set x3=0
            set x4=0
            set y=0
            set y2=0
            set y3=0
            set y4=0
            
            set it=null
            set b=0
            set c=0
            loop
            //    call EnumDestructablesInRectAll(coRect, Filter(function thistype.destEnum), null)
                call EnumDestructablesInRectAll(ItemInventory__coRect, function s__CustomInventory_destEnum2)
                exitwhen ItemInventory__tpSize > 0
            endloop
            //Now lets get the width, height, and the distance between equipment buttons 
            if ItemInventory__tpSize > 0 then //making sure theres atleast one destructable to sort
                loop
                    set b=ItemInventory__tempTable[i] //get the destructable to shuffle
                    if y == 0 then //if no destructables have been shuffled, set this one to the destructable to be compared to
                        set y=s__InventoryButton_y[b] //y and x shouldnt change as they are the values
                        set x=s__InventoryButton_x[b] //to be compared to
                        set y4=y //min y = this y
                        set x4=x //min x = this x
                        set x3=1 //its 1 wide
                        set y3=1 //and 1 highv
                    else //making sure the comparables are on the same Y axis
                        if ( RAbsBJ(s__InventoryButton_x[b] - x) < x2 or x2 == 0 ) and y == s__InventoryButton_y[b] then //checking if the X distance between is less than the previous x distance between
                            set x2=RAbsBJ(s__InventoryButton_x[b] - x) //to get the x distance between equipment buttons
                        endif
                        if ( RAbsBJ(s__InventoryButton_y[b] - y) < y2 or y2 == 0 ) and x == s__InventoryButton_x[b] then //checking if the y distance between is less than the previous y distance between
                            set y2=RAbsBJ(s__InventoryButton_y[b] - y) //to get the y distance between equipment buttons
                        endif
                        if s__InventoryButton_x[b] < x4 then
                            set x4=s__InventoryButton_x[b]
                        endif
                        if s__InventoryButton_y[b] > y4 then
                            set y4=s__InventoryButton_y[b] //x4 and y4 are the min x and min y of the table
                        endif
                        if s__InventoryButton_y[b] == y then
                            set x3=x3 + 1 //adding 1 to the width of the table
                        endif
                        if s__InventoryButton_x[b] == x then
                            set y3=y3 + 1 //adding 1 to the height of the table
                        endif
                    endif
                    set i=i + 1
                    exitwhen ItemInventory__tpSize == i //tpSize is always 1 above the array
                endloop
                //Now that we've gotten those values, we can loop through the buttons and assign them
                //x3 = width
                //y3 = height
                //x2 = x distnace between
                //y2 = y distance between
                //x4 = min x
                //y4 = max y
                set ItemInventory__cowidth=x3
                set ItemInventory__coxbetween=x2
                set ItemInventory__coybetween=y2
                set ItemInventory__cominx=x4
                set ItemInventory__comaxy=y4
                //Note : the buttons MUST be in a consistent grid with all of the x and y distances equal
                set i=0
                 loop
                    set ItemInventory__console[R2I(( ( s__InventoryButton_x[ItemInventory__tempTable[i]] - x4 ) / x2 ) + x3 * ( RAbsBJ(( s__InventoryButton_y[ItemInventory__tempTable[i]] - y4 )) / y2 ))]=ItemInventory__tempTable[i]
                  set s__InventoryButton_defaultDestPic[ItemInventory__tempTable[i]]=GetDestructableTypeId(s__InventoryButton_current[ItemInventory__tempTable[i]])
                  set i=i + 1
                  exitwhen ItemInventory__tpSize == i
                endloop
                
                //now that the equipment is set, lets undo tempTable for the next loop
                set i=0
                loop
                    set ItemInventory__tempTable[i]=0
                    set i=i + 1
                    exitwhen ItemInventory__tpSize == i
                endloop
                set ItemInventory__coSize=ItemInventory__tpSize
                set ItemInventory__tpSize=0
            endif
            set i=0
            set a=0
            set x=0
            set x2=0
            set x3=0
            set x4=0
            set y=0
            set y2=0
            set y3=0
            set y4=0
            
            set it=null
            set b=0
            set c=0
//end of: INIT_MAIN_LOOP("co","console")
            call TriggerEvaluate(st__CustomInventory_initsiesss) // INLINED!!
        endfunction
       // implement initModule
//Implemented from module ITEM_GENERATION:
        function s__CustomInventory_PRIVATEOUTCAST_add takes integer i,integer itemId returns nothing
            call SaveInteger(Table___ht, (s__CustomInventory_t), (itemId), ( (i))) // INLINED!!
        endfunction
        function s__CustomInventory_ITEM_GENERATION___onPickup takes nothing returns boolean
            local item m= GetManipulatedItem()
            local unit u= GetTriggerUnit()
            call SetItemCharges(m, GetItemCharges(m) + 1)
            if (LoadInteger(Table___ht, (ItemInventory__itemLinks), (GetHandleId((m))))) == 0 and (LoadInteger(Table___ht, (s__CustomInventory_t), (GetItemTypeId(m)))) != 0 then // INLINED!!
                call s__FullItemGenerator_generate(((LoadInteger(Table___ht, (s__CustomInventory_t), (GetItemTypeId(m))))),m) // INLINED!!
                call UnitRemoveItem(u, m)
                call s__CustomInventory_onItemPickup((LoadInteger(Table___ht, (ItemInventory__itemLinks), (GetHandleId((m))))) , u) // INLINED!!
                call SetItemVisible(m, false)
            elseif (LoadInteger(Table___ht, (ItemInventory__itemLinks), (GetHandleId((m))))) != 0 then // INLINED!!
                call s__CustomInventory_onItemPickup((LoadInteger(Table___ht, (ItemInventory__itemLinks), (GetHandleId((m))))) , u) // INLINED!!
                call UnitRemoveItem(u, m)
                call SetItemVisible(m, false)
            endif
            set m=null
            set u=null
            return false
        endfunction
        
        function s__CustomInventory_generateNewItem takes item i,unit u returns nothing
            if (LoadInteger(Table___ht, (ItemInventory__itemLinks), (GetHandleId((i))))) == 0 and (LoadInteger(Table___ht, (s__CustomInventory_t), (GetItemTypeId(i)))) != 0 then // INLINED!!
                call s__FullItemGenerator_generate(((LoadInteger(Table___ht, (s__CustomInventory_t), (GetItemTypeId(i))))),i) // INLINED!!
                call UnitRemoveItem(u, i)
                call s__CustomInventory_onItemPickup((LoadInteger(Table___ht, (ItemInventory__itemLinks), (GetHandleId((i))))) , u) // INLINED!!
                call SetItemVisible(i, false)
            elseif (LoadInteger(Table___ht, (ItemInventory__itemLinks), (GetHandleId((i))))) != 0 then // INLINED!!
                call s__CustomInventory_onItemPickup((LoadInteger(Table___ht, (ItemInventory__itemLinks), (GetHandleId((i))))) , u) // INLINED!!
                call UnitRemoveItem(u, i)
                call SetItemVisible(i, false)
            endif
        endfunction
        
        function s__CustomInventory_initsiesss takes nothing returns nothing
            local item i
            local integer fullItemGenerator
            local integer r
            local integer s
            local integer i3= 0
            local trigger tr= CreateTrigger()
            
    //INITIALIZATION SCRIPT
            set s__CustomInventory_t=s__Table_create()
            call TriggerAddCondition(tr, Filter(function s__CustomInventory_ITEM_GENERATION___onPickup))
            call TriggerRegisterAnyUnitEventBJ(tr, EVENT_PLAYER_UNIT_USE_ITEM)
            set tr=null
    //END INITIALIZATION SCRIPT
    //TROLL WIZZY
            set s=s__Set_create("Troll Wizard's Armaments" , "|cffffcc00Description|r : The many pieces of the Troll Wizard's wardrobe which were constantlyrun with energy while the Troll Wizard was in combat.\n\n|cffffcc00Pieces|r\n|cffffcc00    -|r Troll Wizard's Brilliant Essence\n|cffffcc00    -|r Troll Wizard's Luminescent Gloves\n|cffffcc00    -|r Troll Wizard's Silk Robez\n|cffffcc00    -|r Troll Wizard's Shining Ring\n|cffffcc00    -|r Troll Wizard's Shimmering Amulet\n|cffffcc00    -|r Troll Wizard's Long Staff\n|cffffcc00    -|r Troll Wizard's Floating Orb\n\n|cffffcc00Bonuses|r\n|cffffcc00    (3) Intelligence|r : 15\n|cffffcc00    (5) Spell Critical Rate|r : 5%\n|cffffcc00    (7) |r10% chance to renanimate as: Troll Wizard\n|cffffcc00    (7) Spell Critical Damage|r : 50%\n|cffffcc00    (7) Intelligence|r : 20")
            call s__Set_addTrait(s,TRAIT_TYPE_INTELLIGENCE , 15 , 3)
            call s__Set_addTrait(s,TRAIT_TYPE_SPELL_CRIT_RATE , 5 , 5)
            call s__Set_addTrait(s,TRAIT_TYPE_SPELL_CRIT_POW , 50 , 7)
            //call s.addTrait(TRAIT_TYPE_INTELLIGENCE, 20, 7)
            call s__Set_addTrait(s,TRAIT_TYPE_PHYSICAL_RESISTANCE , 40 , 7)
            
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll Wizard's Brillant Essence|r" , "|cffffcc00Description|r : The Troll Wizard would collect the souls of its victim and embottle them in order to gain their strength.|n|cff008000|nPart of the Troll Wizard's Armaments set|r" , 'B02W' , SLOT_WING),'I00M'),TRAIT_TYPE_ALL_STATS , 5 , 0 , 0 , 0),TRAIT_TYPE_MOVEMENT_SPEED , 30 , 0 , 0 , 0),s)
            
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll Wizard's Luminescent Gloves|r" , "|cffffcc00Description|r : Every hand needs a glove.|n|cff008000|nPart of the Troll Wizard's Armaments set|r" , 'B02X' , SLOT_GLOVE),'I02D'),TRAIT_TYPE_ATTACK_SPEED , 10 , 0 , 0 , 0),TRAIT_TYPE_INTELLIGENCE , 5 , 0 , 0 , 0),s)
            
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll Wizard's Silk Robes|r" , "|cffffcc00Description|r : The Troll's robes leached the energy that was coming from his staff and enchanted themselves.|n|cff008000|nPart of the Troll Wizard's Armaments set|r" , 'B02N' , SLOT_ARMOR),'I026'),TRAIT_TYPE_ARMOR , 4 , 0 , 0 , 0),TRAIT_TYPE_INTELLIGENCE , 9 , 0 , 0 , 0),s)
            
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll Wizard's Shining Ring|r" , "|cffffcc00Description|r : Rather than the Troll King's ring, this ring embodies the mind and spirit.|n|cff008000|nPart of the Troll Wizard's Armaments set|r" , 'B02L' , SLOT_RINGRIGHT),'I01V'),TRAIT_TYPE_INTELLIGENCE , 9 , 0 , 0 , 0),TRAIT_TYPE_STRENGTH , 4 , 0 , 0 , 0),TRAIT_TYPE_AGILITY , 4 , 0 , 0 , 0),s)
 
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll Wizard's Long Staff|r" , "|cffffcc00Description|r : This staff is glowing with energy through so much use from the Troll Wizard.|n|cff008000|nPart of the Troll Wizard's Armaments set|r" , 'B02M' , SLOT_MAINHAND),'I01W'),TRAIT_TYPE_DAMAGE , 20 , 0 , 0 , 0),TRAIT_TYPE_INTELLIGENCE , 10 , 0 , 0 , 0),s)
            
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll Wizard's Floating Orb|r" , "|cffffcc00Description|r : Acted as a battery for the Troll Wizard's magic.|n|cff008000|nPart of the Troll Wizard's Armaments set|r" , 'B02B' , SLOT_OFFHANDONLY),'I01X'),TRAIT_TYPE_DAMAGE , 10 , 0 , 0 , 0),TRAIT_TYPE_INTELLIGENCE , 10 , 0 , 0 , 0),s)
            
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll Wizard's Shimmering Amulet|r" , "|cffffcc00Description|r : The coup-de-gras of the Troll Wizard's armaments, this amulet was used as the eye of energy, making the Wizard's magic able to focus itself.|n|cff008000|nPart of the Troll Wizard's Armaments set|r" , 'B02T' , SLOT_NECKLACE),'I01Y'),TRAIT_TYPE_INTELLIGENCE , 15 , 0 , 0 , 0),TRAIT_TYPE_STRENGTH , 5 , 0 , 0 , 0),TRAIT_TYPE_AGILITY , 5 , 0 , 0 , 0),s)
    //END TROLLWIZY
    //TROLL KING 
            set s=s__Set_create("Troll King's Garments" , "|cffffcc00Description|r : The many parts of the Troll King that made him once so great.\n\n|cffffcc00Pieces\n    - |r Troll King's Belt\n|cffffcc00    - |rTroll King's Crown\n|cffffcc00    - |rTroll King's Chest Protector\n|cffffcc00    - |rTroll King's Majestic Ring\n|cffffcc00    - |rTroll King's Emerald Amulet\n|cffffcc00    - |rTroll King's Bronze Sword\n|cffffcc00    - |rTroll King's Broken Dagger\n\n|cffffcc00Bonuses|r\n|cffffcc00    (3)|r |cffffcc00Strength/Agility\r : 10\n|cffffcc00    (5)|cffffcc00Attack Speed|r : 15%\n|cffffcc00    (7)|r 15% of slain enemies reanimate as: Troll Warrior\n        |cffffcc00Armor|r : 5\n        |cffffcc00All Stats|r : 15")
            call s__Set_addTrait(s,TRAIT_TYPE_STRENGTH , 10 , 3)
            call s__Set_addTrait(s,TRAIT_TYPE_AGILITY , 10 , 3)
            call s__Set_addTrait(s,TRAIT_TYPE_ATTACK_SPEED , 15 , 5)
            call s__Set_addTrait(s,TRAIT_TYPE_ALL_STATS , 10 , 7)
            call s__Set_addTrait(s,TRAIT_TYPE_ARMOR , 5 , 7)
            call s__Set_addTrait(s,TRAIT_TYPE_ALL_RESISTANCE , 20 , 7)
            
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll King's Belt|r" , "|cffffcc00Description|r : Held the legendary stomach of the Troll King|n|n|cff008000Part of the Troll King's Equipment set|r" , 'B02W' , SLOT_BELT),'I020'),TRAIT_TYPE_ARMOR , 2 , 0 , 0 , 0),TRAIT_TYPE_STRENGTH , 5 , 0 , 0 , 0),s)
            
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll King's Crown|r" , "|cffffcc00Description|r : Once protected the head of the Troll King. Once.|n|n|cff008000Part of the Troll King's Equipment set|r" , 'B02U' , SLOT_HELM),'I00D'),TRAIT_TYPE_ARMOR , 2 , 0 , 0 , 0),TRAIT_TYPE_ALL_STATS , 3 , 0 , 0 , 0),s)
            
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll King's Chest Protector|r" , "|cffffcc00Description|r : Protected the stomach of the Troll King.|n|n|cff008000Part of the Troll King's Equipment set|r" , 'B02F' , SLOT_ARMOR),'I00E'),TRAIT_TYPE_ARMOR , 5 , 0 , 0 , 0),TRAIT_TYPE_STRENGTH , 7 , 0 , 0 , 0),TRAIT_TYPE_AGILITY , 4 , 0 , 0 , 0),s)
            
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll King's Majestic Ring|r" , "|cffffcc00Description|r : One of many on the Troll King's fingers which he stole from the women of plundered villages.|n|n|cff008000Part of the Troll King's Equipment set|r" , 'B02C' , SLOT_RINGRIGHT),'I025'),TRAIT_TYPE_INTELLIGENCE , 5 , 0 , 0 , 0),TRAIT_TYPE_STRENGTH , 8 , 0 , 0 , 0),TRAIT_TYPE_AGILITY , 8 , 0 , 0 , 0),s)
            
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll King's Emerald Amulet|r" , "|cffffcc00Description|r : The Troll King's favorite, which was taken from a widow who tried to steal from the Troll King.|n|n|cff008000Part of the Troll King's Equipment set|r" , 'B02T' , SLOT_NECKLACE),'I01Z'),TRAIT_TYPE_ALL_STATS , 6 , 0 , 0 , 0),s)
            
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll King's Bronze Sword|r" , "|cffffcc00Description|r : One of the discarded swords of the Troll King.|n|n|cff008000Part of the Troll King's Equipment set|r" , 'B02I' , SLOT_MAINHAND),'I021'),TRAIT_TYPE_DAMAGE , 20 , 0 , 0 , 0),TRAIT_TYPE_STRENGTH , 5 , 0 , 0 , 0),s)
            
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll King's Broken Dagger|r" , "|cffffcc00Description|r : Kept in a holster of the Troll King in case his sword broke.|n|n|cff008000Part of the Troll King's Equipment set|r" , 'B02V' , SLOT_OFFHAND),'I024'),TRAIT_TYPE_DAMAGE , 10 , 0 , 0 , 0),TRAIT_TYPE_STRENGTH , 5 , 0 , 0 , 0),TRAIT_TYPE_AGILITY , 5 , 0 , 0 , 0),TRAIT_TYPE_ATTACK_SPEED , 10 , 0 , 0 , 0),s)
            
    //END TROLL KING
    //WEAK IRON SCRAP
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_create("Weak Iron Scrap" , "|cffffcc00Description|r : Used in various blacksmithing recipes" , 'B02O' , TYPE_MATERIAL),'I00U')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_create("Iron Scrap" , "|cffffcc00Description|r : Used in various blacksmithing recipes" , 'B02O' , TYPE_MATERIAL),'I01M')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_create("Hand-sharpened Iron Scrap" , "|cffffcc00Description|r : Used in various blacksmithing recipes" , 'B02O' , TYPE_MATERIAL),'I01N')
    //END WIS
    
    //FLIMSY SWORD
            //FIG Creation
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Flimsy Sword" , "|cffffcc00Item Type |r- 1-H Weapon|n|cffffcc00Class Requirement|r : Warrior" , 'B02I' , SLOT_OFFHAND),TRAIT_TYPE_DAMAGE , 2 , 0 , 0 , 0),'I002')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Flimsy Sword +" , "|cffffcc00Item Type |r- 1-H Weapon|n|cffffcc00Class Requirement|r : Warrior" , 'B02I' , SLOT_OFFHAND),TRAIT_TYPE_DAMAGE , 3 , 0 , 0 , 0),'I00Y')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Flimsy Sword ++" , "|cffffcc00Item Type |r- 1-H Weapon|n|cffffcc00Class Requirement|r : Warrior" , 'B02I' , SLOT_OFFHAND),TRAIT_TYPE_DAMAGE , 5 , 0 , 0 , 0),'I017')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Flimsy Sword +++" , "|cffffcc00Item Type |r- 1-H Weapon|n|cffffcc00Class Requirement|r : Warrior" , 'B02I' , SLOT_OFFHAND),TRAIT_TYPE_DAMAGE , 7 , 0 , 0 , 0),'I01G')
    //END FLIMSY SWORD
    //BRANCH
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Flimsy Branch" , "|cffffcc00Item Type|r : 2-Handed Weapon|n|cffffcc00Class Requirement|r : Wizard, Witch" , 'B02P' , SLOT_MAINHAND),TRAIT_TYPE_DAMAGE , 2 , 0 , 0 , 0),TRAIT_TYPE_INTELLIGENCE , 2 , 0 , 0 , 0),'I00O')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Flimsy Branch +" , "|cffffcc00Item Type|r : 2-Handed Weapon|n|cffffcc00Class Requirement|r : Wizard, Witch" , 'B02P' , SLOT_MAINHAND),TRAIT_TYPE_DAMAGE , 3 , 0 , 0 , 0),TRAIT_TYPE_INTELLIGENCE , 3 , 0 , 0 , 0),'I00V')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Flimsy Branch ++" , "|cffffcc00Item Type|r : 2-Handed Weapon|n|cffffcc00Class Requirement|r : Wizard, Witch" , 'B02P' , SLOT_MAINHAND),TRAIT_TYPE_DAMAGE , 3 , 0 , 0 , 0),TRAIT_TYPE_INTELLIGENCE , 3 , 0 , 0 , 0),'I01D')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Flimsy Branch +++" , "|cffffcc00Item Type|r : 2-Handed Weapon|n|cffffcc00Class Requirement|r : Wizard, Witch" , 'B02P' , SLOT_MAINHAND),TRAIT_TYPE_DAMAGE , 4 , 0 , 0 , 0),TRAIT_TYPE_INTELLIGENCE , 4 , 0 , 0 , 0),'I014')
    //END BRANCH
    //CRACKED RING
    
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Cracked Ring" , "|cffffcc00Item Type|r : Ring" , 'B02E' , SLOT_RINGRIGHT),TRAIT_TYPE_ALL_STATS , 2 , 0 , 0 , 0),TRAIT_TYPE_PHYSICAL_RESISTANCE , 20 , 0 , 0 , 0),'I00S')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Cracked Ring +" , "|cffffcc00Item Type|r : Ring" , 'B02E' , SLOT_RINGRIGHT),TRAIT_TYPE_ALL_STATS , 3 , 0 , 0 , 0),'I016')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Cracked Ring ++" , "|cffffcc00Item Type|r : Ring" , 'B02E' , SLOT_RINGRIGHT),TRAIT_TYPE_ALL_STATS , 4 , 0 , 0 , 0),'I01E')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Cracked Ring +++" , "|cffffcc00Item Type|r : Ring" , 'B02E' , SLOT_RINGRIGHT),TRAIT_TYPE_ALL_STATS , 6 , 0 , 0 , 0),'I00W')
    //END CRACKED RING
    
    //FLIMSY ARMOR
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Flimsy Armor" , "|cffffcc00Item Type |r: Armor" , 'B02F' , SLOT_ARMOR),TRAIT_TYPE_ARMOR , 1 , 0 , 0 , 0),'I004')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Flimsy Armor +" , "|cffffcc00Item Type |r: Armor" , 'B02F' , SLOT_ARMOR),TRAIT_TYPE_ARMOR , 1 , 0 , 0 , 0),'I00X')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Flimsy Armor ++" , "|cffffcc00Item Type |r: Armor" , 'B02F' , SLOT_ARMOR),TRAIT_TYPE_ARMOR , 2 , 0 , 0 , 0),'I01F')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Flimsy Armor +++" , "|cffffcc00Item Type |r: Armor" , 'B02F' , SLOT_ARMOR),TRAIT_TYPE_ARMOR , 3 , 0 , 0 , 0),'I015')
    //END FLIMSY ARMOR
    
    //LEATHER QUIVER
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Leather Quiver" , "|cffffcc00Item Type |r: Offhand|n|cffffcc00Class Requirement|r : Archer" , 'B02Q' , SLOT_OFFHANDONLY),TRAIT_TYPE_ATTACK_SPEED , 2 , 0 , 0 , 0),'I00F')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Leather Quiver +" , "|cffffcc00Item Type |r: Offhand|n|cffffcc00Class Requirement|r : Archer" , 'B02Q' , SLOT_OFFHANDONLY),TRAIT_TYPE_ATTACK_SPEED , 3 , 0 , 0 , 0),'I00Z')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Leather Quiver ++" , "|cffffcc00Item Type |r: Offhand|n|cffffcc00Class Requirement|r : Archer" , 'B02Q' , SLOT_OFFHANDONLY),TRAIT_TYPE_ATTACK_SPEED , 5 , 0 , 0 , 0),'I018')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Leather Quiver +++" , "|cffffcc00Item Type |r: Offhand|n|cffffcc00Class Requirement|r : Archer" , 'B02Q' , SLOT_OFFHANDONLY),TRAIT_TYPE_ATTACK_SPEED , 7 , 0 , 0 , 0),'I01H')
    //END LEATHER QUIVER
    
    //ROUGH SLIPPERS
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Rough Slippers" , "|cffffcc00Item Type |r: Boots" , 'B02G' , SLOT_BOOTS),TRAIT_TYPE_MOVEMENT_SPEED , 5 , 0 , 0 , 0),'I00K')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Rough Slippers +" , "|cffffcc00Item Type |r: Boots" , 'B02G' , SLOT_BOOTS),TRAIT_TYPE_MOVEMENT_SPEED , 7 , 0 , 0 , 0),'I010')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Rough Slippers ++" , "|cffffcc00Item Type |r: Boots" , 'B02G' , SLOT_BOOTS),TRAIT_TYPE_MOVEMENT_SPEED , 12 , 0 , 0 , 0),TRAIT_TYPE_ARMOR , 1 , 0 , 0 , 0),'I019')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Rough Slippers +++" , "|cffffcc00Item Type |r: Boots" , 'B02G' , SLOT_BOOTS),TRAIT_TYPE_MOVEMENT_SPEED , 15 , 0 , 0 , 0),TRAIT_TYPE_ARMOR , 2 , 0 , 0 , 0),'I01I')
    //END ROUGH SLIPPERS
    
    //TWIG BOW
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Twig Bow" , "|cffffcc00Item Type |r: 1-H Mainhand|n|cffffcc00Class Requirement|r : Archer" , 'B02R' , SLOT_MAINHAND),TRAIT_TYPE_DAMAGE , 3 , 0 , 0 , 0),TRAIT_TYPE_ATTACK_SPEED , - 15 , - 0 , 0 , 0),'I00G')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Twig Bow +" , "|cffffcc00Item Type |r: 1-H Mainhand|n|cffffcc00Class Requirement|r : Archer" , 'B02R' , SLOT_MAINHAND),TRAIT_TYPE_DAMAGE , 5 , 0 , 0 , 0),TRAIT_TYPE_ATTACK_SPEED , - 15 , 0 , 0 , 0),'I012')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Twig Bow ++" , "|cffffcc00Item Type |r: 1-H Mainhand|n|cffffcc00Class Requirement|r : Archer" , 'B02R' , SLOT_MAINHAND),TRAIT_TYPE_DAMAGE , 7 , 0 , 0 , 0),TRAIT_TYPE_ATTACK_SPEED , - 15 , 0 , 0 , 0),'I01A')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Twig Bow +++" , "|cffffcc00Item Type |r: 1-H Mainhand|n|cffffcc00Class Requirement|r : Archer" , 'B02R' , SLOT_MAINHAND),TRAIT_TYPE_DAMAGE , 11 , 0 , 0 , 0),TRAIT_TYPE_ATTACK_SPEED , - 15 , 0 , 0 , 0),'I01J')
    //END TWIG BOW
    
    //WEAK GLOVES
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Weak Gloves" , "|cffffcc00Item Type |r: Gloves" , 'B02H' , SLOT_GLOVE),TRAIT_TYPE_ATTACK_SPEED , 1 , 0 , 0 , 0),'I00H')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Weak Gloves +" , "|cffffcc00Item Type |r: Gloves" , 'B02H' , SLOT_GLOVE),TRAIT_TYPE_ATTACK_SPEED , 1 , 0 , 0 , 0),'I011')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Weak Gloves ++" , "|cffffcc00Item Type |r: Gloves" , 'B02H' , SLOT_GLOVE),TRAIT_TYPE_ATTACK_SPEED , 2 , 0 , 0 , 0),'I01B')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Weak Gloves +++" , "|cffffcc00Item Type |r: Gloves" , 'B02H' , SLOT_GLOVE),TRAIT_TYPE_ATTACK_SPEED , 3 , 0 , 0 , 0),'I01K')
    //END WEAK GLOVES
    
    //WEAK MASK
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Weak Mask" , "|cffffcc00Item Type |r: Helmet" , 'B02S' , SLOT_HELM),TRAIT_TYPE_ARMOR , 1 , 0 , 0 , 0),'I00J')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Weak Mask +" , "|cffffcc00Item Type |r: Helmet" , 'B02S' , SLOT_HELM),TRAIT_TYPE_ARMOR , 1 , 0 , 0 , 0),'I013')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Weak Mask ++" , "|cffffcc00Item Type |r: Helmet" , 'B02S' , SLOT_HELM),TRAIT_TYPE_ARMOR , 2 , 0 , 0 , 0),TRAIT_TYPE_ALL_STATS , 1 , 0 , 0 , 0),'I01C')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Weak Mask +++" , "|cffffcc00Item Type |r: Helmet" , 'B02S' , SLOT_HELM),TRAIT_TYPE_ARMOR , 3 , 0 , 0 , 0),TRAIT_TYPE_ALL_STATS , 2 , 0 , 0 , 0),'I01L')
    //END WEAK MASK
    
    //SUN FRAGMENT OF HELIOS
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addReq(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("|cffff4500Sun Fragment of Helios|r" , "Contains the blazing heat by which Helios created the Sun." , 'B01H' , 8),TRAIT_TYPE_ALL_STATS , 13371337 , 0 , 0 , 0),TRAIT_TYPE_MANA_REGEN , 13371337 , 0 , 0 , 0),TRAIT_TYPE_LIFE_REGEN , 13371337 , 0 , 0 , 0),TRAIT_TYPE_ATTACK_SPEED , 13371337 , 0 , 0 , 0),TRAIT_TYPE_MOVEMENT_SPEED , 13371337 , 0 , 0 , 0),TRAIT_TYPE_ARMOR , 13371337 , 0 , 0 , 0),TRAIT_TYPE_STATIC_ARMOR , 13371337 , 0 , 0 , 0),TRAIT_TYPE_SPIKE_ARMOR , 13371337 , 0 , 0 , 0),TRAIT_TYPE_LIFE_LEECH , 13371337 , 0 , 0 , 0),TRAIT_TYPE_ARMOR_REDUCTION , 13371337 , 0 , 0 , 0),TRAIT_TYPE_FIRE_DAMAGE , 13371337 , 14443346 , 0 , 0),TRAIT_TYPE_LIGHTNING_DAMAGE , 13371337 , 14443346 , 0 , 0),TRAIT_TYPE_STATIC_DAMAGE , 13371337 , 14443346 , 0 , 0),TRAIT_TYPE_COLD_DAMAGE , 13371337 , 14443346 , 0 , 0),TRAIT_TYPE_POISON_DAMAGE , 13371337 , 14443346 , 0 , 0),TRAIT_TYPE_CRIT_RATE , 13371337 , 0 , 0 , 0),TRAIT_TYPE_CRIT_POW , 13371337 , 0 , 0 , 0),TRAIT_TYPE_SPELL_CRIT_RATE , 13371337 , 0 , 0 , 0),TRAIT_TYPE_SPELL_CRIT_POW , 13371337 , 0 , 0 , 0),TRAIT_TYPE_ALL_RESISTANCE , 13371337 , 0 , 0 , 0),TRAIT_TYPE_DAMAGE , 131313 , 0 , 0 , 0),TRAIT_REQ_LEVEL , 2),'I000')
    //END SUN FRAGMENT OF HELIOS
    
            
    ////SWORD OF TRUTH
    //        set fullItemGenerator = FullItemGenerator.create("|cffff4500The Sword of Truth|r", "The one and only.", 'B029', 6)/*
    //        */.addGroupChangingTrait(TRAIT_TYPE_DAMAGE,500000,1000000,0,15)/*
    //        */.addGCT(TRAIT_TYPE_STATIC_DAMAGE, 500000, 1000000,0,5)/*
    //        */.closeGroup()/*
    //        */.addGCT(TRAIT_TYPE_STRENGTH, 75000, 150000,0,5)/*
    //        */.addGCT(TRAIT_TYPE_AGILITY, 75000, 150000,0,5)/*
    //        */.addGCT(TRAIT_TYPE_ALL_STATS, 50000, 100000,0,5)/*
    //        */.closeGroup()/*
    //        */.addGCT(TRAIT_TYPE_LIFE, 500000, 1000000,0,5)/*
    //        */.addGCT(TRAIT_TYPE_MANA, 150, 250,0,5)/*
    //        */.closeGroup()/*
    //        */.addGCT(TRAIT_TYPE_ARMOR_REDUCTION, 750,1250,0,5)/*
    //        */.addGCT(TRAIT_TYPE_ATTACK_SPEED, 50, 100,0,5)/*
    //        */.closeGroup()/*
    //        */.register('I00L')
    ////END SWORD OF TRUTH
            
    //GOTUMGEAR
    
            set fullItemGenerator=s__FullItemGenerator_create("[Recipe] Gotum Gear +" , "|cffffcc00Description|r : Upgrades any piece of gear from the weapon salesman in Gotum.|n|n|cffffcc00Recipe|r : Recipe + Any piece of gear + Weak Iron Scrap + Corresponding Material|n|n|cffffcc00Hint|r : 'Corresponding Material' is sold at the Materials Salesman" , 'B02A' , TYPE_RECIPE)
            
            call s__Recipe2_addResult(s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(s__FullItemGenerator_register(fullItemGenerator,'I006')),0 , 'I00O'),1 , 'I00U'),'I00V'),'I006')
            
            
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I00S'),1 , 'I00U'),'I016')
            
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I004'),1 , 'I00U'),'I00X')
            
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I002'),1 , 'I00U'),'I00Y')

            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I00F'),1 , 'I00U'),'I00Z')
            
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I00K'),1 , 'I00U'),'I010')

            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I00G'),1 , 'I00U'),'I012')

            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I00H'),1 , 'I00U'),'I011')

            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I00J'),1 , 'I00U'),'I013')
    //ENDGOTUM
    
    //GOTUM+
    
    
            set fullItemGenerator=s__FullItemGenerator_create("[Recipe] Gotum Gear ++" , "|cffffcc00Description|r : Upgrades any piece of gear from the weapon salesman in Gotum.|n|n|cffffcc00Recipe|r : Recipe + Any single-plus piece of gear + Iron Scrap + Corresponding Material|n|n|cffffcc00Hint|r : 'Corresponding Material' is sold at the Materials Salesman" , 'B02A' , TYPE_RECIPE)
            
            call s__FullItemGenerator_register(fullItemGenerator,'I007')
            
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I00V'),1 , 'I01M'),'I01D')
            
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I016'),1 , 'I01M'),'I01E')
            
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I00X'),1 , 'I01M'),'I01F')
            
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I00Y'),1 , 'I01M'),'I017')

            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I00Z'),1 , 'I01M'),'I018')
            
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I010'),1 , 'I01M'),'I019')

            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I012'),1 , 'I01M'),'I01A')

            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I011'),1 , 'I01M'),'I01B')

            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I013'),1 , 'I01M'),'I01C')
    //ENDGOTUM+
    //GOTUM++
    
    
            set fullItemGenerator=s__FullItemGenerator_create("[Recipe] Gotum Gear +++" , "|cffffcc00Description|r : Upgrades any piece of gear from the weapon salesman in Gotum.|n|n|cffffcc00Recipe|r : Recipe + Any double-plus piece of gear + Hand-sharpened Iron Scrap + Corresponding Material|n|n|cffffcc00Hint|r : 'Corresponding Material' is sold at the Materials Salesman" , 'B02A' , TYPE_RECIPE)
            
            call s__FullItemGenerator_register(fullItemGenerator,'I00C')
            
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I01D'),1 , 'I01N'),'I014')
            
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I01E'),1 , 'I01N'),'I00W')
            
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I01F'),1 , 'I01N'),'I015')
            
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I017'),1 , 'I01N'),'I01G')

            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I018'),1 , 'I01N'),'I01H')
            
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I019'),1 , 'I01N'),'I01I')

            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I01A'),1 , 'I01N'),'I01J')

            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I01B'),1 , 'I01N'),'I01K')

            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I01C'),1 , 'I01N'),'I01L')
    //ENDGOTUM++
        endfunction
        function s__CustomInventory_register takes integer i,integer itemId returns nothing
            call s__CustomInventory_PRIVATEOUTCAST_add(i , itemId)
        endfunction

//library ItemInventory ends
//library KnuthChecksum:
    function GetKnuthChecksum takes integer k,integer m returns integer
        local integer c= s__BigInt_copy(k)
        
        call s__BigInt_add(c,3)
        call s__BigInt_multiplyBig(c,k)
        set k=s__BigInt_modBig(c,m)
        
        call s__BigInt_destroy(c)
        
        return s__BigInt_copy(k)
    endfunction

//library KnuthChecksum ends
//library LevelFilter:
        
        function s__LevelFilter_get takes integer this,integer minLevel,integer maxLevel returns integer
            local integer catalog
            local integer level
            
            set level=s__LevelTree_searchClose(s__LevelFilter_tree[this],minLevel , false)
            if ( 0 != level ) then
                set catalog=s__TempCatalog_create()
                
                loop
                    exitwhen (0 == s__LevelTree_AVL___p[(level)]) or ((s__LevelTree_AVL___v[(level)])) > maxLevel // INLINED!!
                    call CatalogAddCatalog((catalog) , ((LoadInteger(Table___ht, (s__LevelFilter_catalogTable[this]), (level))))) // INLINED!!
                    set level=(s__LevelTree_AVL___nn[(level)]) // INLINED!!
                endloop
                
                return catalog
            endif
            
            return 0
        endfunction
        
        function s__LevelFilter_getCatalog takes integer this,integer level returns integer
            local integer levelCatalog
            
            set levelCatalog=(LoadInteger(Table___ht, (s__LevelTree_AVL___table[s__LevelTree_AVL___ro[(s__LevelFilter_tree[this])]]), ((level)))) // INLINED!!
            
            if ( 0 == levelCatalog ) then
                set level=s__LevelTree_add(s__LevelFilter_tree[this],level)
                
                set levelCatalog=(CatalogCreate()) // INLINED!!
                call SaveInteger(Table___ht, (s__LevelFilter_catalogTable[this]), (level), ( levelCatalog)) // INLINED!!
                
                return levelCatalog
            endif
            
            return (LoadInteger(Table___ht, (s__LevelFilter_catalogTable[this]), (levelCatalog))) // INLINED!!
        endfunction
        
        function s__LevelFilter_create takes nothing returns integer
            local integer this
            
            set this=s__LevelTree_create()
            
            set s__LevelFilter_tree[this]=this
            set s__LevelFilter_catalogTable[this]=s__Table_create()
            
            return this
        endfunction

//library LevelFilter ends
//library Missile:

    
//Implemented from module LinkedList:


        
        function s__MissileList_allocate takes nothing returns integer
            local integer this= s__MissileList_prev[(0)]
            if this == 0 then
                set s__MissileList_LinkedListLite___instanceCount=s__MissileList_LinkedListLite___instanceCount + 1
                return s__MissileList_LinkedListLite___instanceCount
            endif
            set s__MissileList_prev[(0)]=s__MissileList_prev[this]
            return this
        endfunction
        
        function s__MissileList_deallocate takes integer this returns nothing
            set s__MissileList_prev[this]=s__MissileList_prev[(0)]
            set s__MissileList_prev[(0)]=this
            set s__MissileList_head[this]=false
        endfunction

        
        function s__MissileList__get_base takes nothing returns integer
            return 8190
        endfunction
        
        function s__MissileList_createNode takes nothing returns integer
            local integer this=s__MissileList_allocate()
//textmacro instance: LINKED_LIST_HEAD("this")
        set s__MissileList_next[this]=this
        set s__MissileList_prev[this]=this
        set s__MissileList_head[this]=true
//end of: LINKED_LIST_HEAD("this")
            return this
        endfunction
        
        function s__MissileList_clearNode takes integer this returns nothing
//textmacro instance: LINKED_LIST_CLEAR("this")
        if this != s__MissileList_next[this] then
            set s__MissileList_prev[s__MissileList_next[this]]=s__MissileList_prev[(0)]
            set s__MissileList_prev[(0)]=s__MissileList_prev[this]
            set s__MissileList_next[this]=this
            set s__MissileList_prev[this]=this
        endif
//end of: LINKED_LIST_CLEAR("this")
        endfunction
        
        function s__MissileList_flushNode takes integer this returns nothing
//textmacro instance: LINKED_LIST_FLUSH("this")
        set s__MissileList_prev[s__MissileList_next[this]]=s__MissileList_prev[(0)]
        set s__MissileList_prev[(0)]=this
        set s__MissileList_head[this]=false
//end of: LINKED_LIST_FLUSH("this")
        endfunction
        
        function s__MissileList_insertNode takes integer this,integer toInsert returns nothing
//textmacro instance: LINKED_LIST_INSERT("this","toInsert")
        set s__MissileList_next[s__MissileList_prev[this]]=toInsert
        set s__MissileList_prev[toInsert]=s__MissileList_prev[this]
        set s__MissileList_prev[this]=toInsert
        set s__MissileList_next[toInsert]=this
//end of: LINKED_LIST_INSERT("this","toInsert")
        endfunction
        
        function s__MissileList_removeNode takes integer this returns nothing
//textmacro instance: LINKED_LIST_REMOVE("this")
        set s__MissileList_next[s__MissileList_prev[this]]=s__MissileList_next[this]
        set s__MissileList_prev[s__MissileList_next[this]]=s__MissileList_prev[this]
//end of: LINKED_LIST_REMOVE("this")
        endfunction
        
        function s__MissileList_LinkedList___onInit takes nothing returns nothing
            set s__MissileList_next[(8190)]=8190
            set s__MissileList_prev[(8190)]=8190
            set s__MissileList_head[(8190)]=true
        endfunction
        













        
    
    
        //***********************************************************************
        //  Why LinkedList? In order to reach a high level of dynamism i'm basing
        //  this system on iterating through multiple linked lists, each struct
        //  has one and each struct iterates through it.
//Implemented from module LinkedList:


        
        function s__Missile_allocate takes nothing returns integer
            local integer this= s__Missile_prev[(0)]
            if this == 0 then
                set s__Missile_LinkedListLite___instanceCount=s__Missile_LinkedListLite___instanceCount + 1
                return s__Missile_LinkedListLite___instanceCount
            endif
            set s__Missile_prev[(0)]=s__Missile_prev[this]
            return this
        endfunction
        
        function s__Missile_deallocate takes integer this returns nothing
            set s__Missile_prev[this]=s__Missile_prev[(0)]
            set s__Missile_prev[(0)]=this
            set s__Missile_head[this]=false
        endfunction

        
        function s__Missile__get_base takes nothing returns integer
            return 8190
        endfunction
        
        function s__Missile_createNode takes nothing returns integer
            local integer this=s__Missile_allocate()
//textmacro instance: LINKED_LIST_HEAD("this")
        set s__Missile_next[this]=this
        set s__Missile_prev[this]=this
        set s__Missile_head[this]=true
//end of: LINKED_LIST_HEAD("this")
            return this
        endfunction
        
        function s__Missile_clearNode takes integer this returns nothing
//textmacro instance: LINKED_LIST_CLEAR("this")
        if this != s__Missile_next[this] then
            set s__Missile_prev[s__Missile_next[this]]=s__Missile_prev[(0)]
            set s__Missile_prev[(0)]=s__Missile_prev[this]
            set s__Missile_next[this]=this
            set s__Missile_prev[this]=this
        endif
//end of: LINKED_LIST_CLEAR("this")
        endfunction
        
        function s__Missile_flushNode takes integer this returns nothing
//textmacro instance: LINKED_LIST_FLUSH("this")
        set s__Missile_prev[s__Missile_next[this]]=s__Missile_prev[(0)]
        set s__Missile_prev[(0)]=this
        set s__Missile_head[this]=false
//end of: LINKED_LIST_FLUSH("this")
        endfunction
        
        function s__Missile_insertNode takes integer this,integer toInsert returns nothing
//textmacro instance: LINKED_LIST_INSERT("this","toInsert")
        set s__Missile_next[s__Missile_prev[this]]=toInsert
        set s__Missile_prev[toInsert]=s__Missile_prev[this]
        set s__Missile_prev[this]=toInsert
        set s__Missile_next[toInsert]=this
//end of: LINKED_LIST_INSERT("this","toInsert")
        endfunction
        
        function s__Missile_removeNode takes integer this returns nothing
//textmacro instance: LINKED_LIST_REMOVE("this")
        set s__Missile_next[s__Missile_prev[this]]=s__Missile_next[this]
        set s__Missile_prev[s__Missile_next[this]]=s__Missile_prev[this]
//end of: LINKED_LIST_REMOVE("this")
        endfunction
        
        function s__Missile_LinkedList___onInit takes nothing returns nothing
            set s__Missile_next[(8190)]=8190
            set s__Missile_prev[(8190)]=8190
            set s__Missile_head[(8190)]=true
        endfunction
        













        
        
        
        
        
        
        
    //    real lastCollideX
    //    real lastCollideY
        
        function s__Missile__set_model takes integer this,string path returns nothing
            call DestroyEffect(s__Missile_fx[this])
            set s__Missile_fP[this]=path
            set s__Missile_fx[this]=AddSpecialEffectTarget(path, s__Missile_dummy[this], "origin")
        endfunction
        
        function s__Missile__get_model takes integer this returns string
            return s__Missile_fP[this]
        endfunction
        
        function s__Missile__set_curve takes integer this,real value returns nothing
            set s__Missile_open[this]=Tan(value) * s__AdvLoc_distance[s__Missile_origin[this]]
        endfunction
        
        function s__Missile__get_curve takes integer this returns real
            return Atan(s__Missile_open[this] / s__AdvLoc_distance[s__Missile_origin[this]])
        endfunction
        
        function s__Missile__set_arc takes integer this,real value returns nothing
            set s__Missile_height[this]=Tan(value) * s__AdvLoc_distance[s__Missile_origin[this]] / 4
        endfunction
        
        function s__Missile__get_arc takes integer this returns real
            return Atan(4 * s__Missile_height[this] / s__AdvLoc_distance[s__Missile_origin[this]])
        endfunction
        
        function s__Missile__set_scale takes integer this,real v returns nothing
            call SetUnitScale(s__Missile_dummy[this], v, v, v)
            set s__Missile_dS[this]=v
        endfunction
        
        function s__Missile__get_scale takes integer this returns real
            return s__Missile_dS[this]
        endfunction
        
        function s__Missile_createEx takes unit whichUnit,integer o,integer i returns integer
            local integer this=s__Missile_allocate()
            
            set s__Missile_source[this]=null
            set s__Missile_target[this]=null
            set s__Missile_acceleration[this]=0
            set s__Missile_height[this]=0
            set s__Missile_turn[this]=0
            set s__Missile_open[this]=0
            set s__Missile_unitsHit[this]=CreateGroup()
            set s__Missile_collision[this]=0
            set s__Missile_recycle[this]=false
            set s__Missile_wantDestroy[this]=false
            set s__Missile_fP[this]=""
            set s__Missile_terminated[this]=false
            set s__Missile_x[this]=(s__Loc_x[((o))]) // INLINED!!
            set s__Missile_y[this]=(s__Loc_y[((o))]) // INLINED!!
            set s__Missile_z[this]=(s__Loc_z[((o))]) // INLINED!!
            set s__Missile_origin[this]=o
            set s__Missile_impact[this]=i
        //   set lastCollideX = -1
        //    set lastCollideY = -1
            set s__Missile_cA[this]=s__AdvLoc_angle[s__Missile_origin[this]]
            set s__Missile_slide[this]=0
            
            set s__Missile_dummy[this]=whichUnit
            call MoveLocation(s__Loc_global, (s__Loc_x[((o))]), (s__Loc_y[((o))])) // INLINED!!
            call SetUnitFlyHeight(s__Missile_dummy[this], (s__Loc_z[((o))]) - GetLocationZ(s__Loc_global), 0) // INLINED!!
            
            call s__MissileList_insertNode((8190),this) // INLINED!!
            
            return this
        endfunction
        
        function s__Missile_createLoc takes integer o,integer i returns integer
            call s__AdvLoc_link(o , i)

                return s__Missile_createEx(GetRecycledMissile((s__Loc_x[((o))]) , (s__Loc_y[((o))]) , (s__Loc_z[((o))]) , s__AdvLoc_angle[o] * bj_RADTODEG) , o , i) // INLINED!!



        endfunction
        
        function s__Missile_create takes real ox,real oy,real oz,real a,real d,real iz returns integer
            local integer o= s__AdvLoc_create(ox , oy , oz)
            local integer i= s__AdvLoc_create(ox + d * Cos(a) , oy + d * Sin(a) , iz)
            call s__AdvLoc_link(o , i)

                return s__Missile_createEx(GetRecycledMissile((s__Loc_x[((o))]) , (s__Loc_y[((o))]) , (s__Loc_z[((o))]) , s__AdvLoc_angle[o] * bj_RADTODEG) , o , i) // INLINED!!



        endfunction
        
        function s__Missile_bounce takes integer this returns nothing
            call s__AdvLoc_move(s__Missile_origin[this],s__Missile_x[this] , s__Missile_y[this] , s__Missile_z[this])
            set s__Missile_slide[this]=0
        endfunction
        
        function s__Missile_deflect takes integer this,real tx,real ty returns nothing
            local real a= 2 * Atan2(ty - s__Missile_y[this], tx - s__Missile_x[this]) + bj_PI - s__Missile_cA[this]
            call s__AdvLoc_move(s__Missile_impact[this],s__Missile_x[this] + ( s__AdvLoc_distance[s__Missile_origin[this]] - s__Missile_slide[this] ) * Cos(a) , s__Missile_y[this] + ( s__AdvLoc_distance[s__Missile_origin[this]] - s__Missile_slide[this] ) * Sin(a) , (s__Loc_z[((s__Missile_impact[this]))])) // INLINED!!
            call s__Missile_bounce(this)
        endfunction
        
        function s__Missile_destroy takes integer this returns nothing
            set s__Missile_wantDestroy[this]=true
        endfunction
        
        function s__Missile_terminate takes integer this returns nothing
            call DestroyEffect(s__Missile_fx[this])
            call DestroyGroup(s__Missile_unitsHit[this])
          //  if lastCollideX + lastCollideY != -2 then
         //       call SetUnitX(dummy, lastCollideX)
         //       call SetUnitY(dummy, lastCollideY)
         //       call DestroyEffect(AddSpecialEffectTarget(fP,dummy,"origin"))
          //  else
            
          //  endif
            set s__Missile_recycle[this]=false
            set s__Missile_fx[this]=null
            

                call RecycleMissile(s__Missile_dummy[this])



            
            call s__AdvLoc_unlock(s__Missile_impact[this])
            call s__AdvLoc_unlock(s__Missile_origin[this])
            
            call s__MissileList_removeNode((this))
            
            call s__Missile_removeNode(this)
            call s__Missile_deallocate(this)
        endfunction
        
        function s__Missile_move takes integer this returns nothing
        
            local real a
            local real d
            local real s
            local real h
            local real tx
            local real ty
            local real ox
            local real oy
            local integer o
            
            loop
                exitwhen s__Missile_head[this]
                set o=s__Missile_origin[this]
                set ox=(s__Loc_x[((o))]) // INLINED!!
                set oy=(s__Loc_y[((o))]) // INLINED!!
                set h=s__Missile_height[this]
                
                if s__Missile_target[this] != null and GetUnitTypeId(s__Missile_target[this]) != 0 then
                    call s__AdvLoc_move(s__Missile_impact[this],GetUnitX(s__Missile_target[this]) , GetUnitY(s__Missile_target[this]) , GetUnitFlyHeight(s__Missile_target[this]))
                    set a=Atan2((s__Loc_y[((s__Missile_impact[this]))]) - s__Missile_y[this], (s__Loc_x[((s__Missile_impact[this]))]) - s__Missile_x[this]) // INLINED!!
                    set s__Missile_slide[this]=s__AdvLoc_distance[s__Missile_origin[this]] - SquareRoot(( (s__Loc_x[((s__Missile_impact[this]))]) - s__Missile_x[this] ) * ( (s__Loc_x[((s__Missile_impact[this]))]) - s__Missile_x[this] ) + ( (s__Loc_y[((s__Missile_impact[this]))]) - s__Missile_y[this] ) * ( (s__Loc_y[((s__Missile_impact[this]))]) - s__Missile_y[this] )) // INLINED!!
                else
                    set a=s__AdvLoc_angle[o]
                    set s__Missile_target[this]=null
                endif
                
                if s__Missile_turn[this] != 0 and not ( Cos(s__Missile_cA[this] - a) >= Cos(s__Missile_turn[this]) ) then
                    if Sin(a - s__Missile_cA[this]) >= 0 then
                        set s__Missile_cA[this]=s__Missile_cA[this] + s__Missile_turn[this]
                    else
                        set s__Missile_cA[this]=s__Missile_cA[this] - s__Missile_turn[this]
                    endif
                else
                    set s__Missile_cA[this]=a
                endif
                
                set d=s__AdvLoc_distance[o]
                set s=s__Missile_slide[this] + s__Missile_speed[this]
                set s__Missile_slide[this]=s
                call SetUnitFacing(s__Missile_dummy[this], s__Missile_cA[this] * bj_RADTODEG)
                
                set tx=s__Missile_x[this] + s__Missile_speed[this] * Cos(s__Missile_cA[this])
                set ty=s__Missile_y[this] + s__Missile_speed[this] * Sin(s__Missile_cA[this])
                set s__Missile_speed[this]=s__Missile_speed[this] + s__Missile_acceleration[this]
                set s__Missile_x[this]=tx
                set s__Missile_y[this]=ty

                if h != 0 or s__AdvLoc_slope[o] != 0 then
                    call MoveLocation(s__Loc_global, tx, ty)
                    set s__Missile_z[this]=4 * h * s * ( d - s ) / ( d * d ) + s__AdvLoc_slope[o] * s + (s__Loc_z[((o))]) // INLINED!!
                    call SetUnitFlyHeight(s__Missile_dummy[this], s__Missile_z[this] - GetLocationZ(s__Loc_global), 0)
                    call SetUnitAnimationByIndex(s__Missile_dummy[this], R2I(Atan(s__AdvLoc_slope[s__Missile_origin[this]]) - Atan(( 8 * h * s - 4 * d * h ) / ( d * d )) * bj_RADTODEG) + 90)
                endif
                
                if s__Missile_open[this] != 0 then
                    set a=4 * s__Missile_open[this] * s * ( d - s ) / ( d * d )
                    set tx=tx + a * Cos(s__Missile_cA[this] + 1.57)
                    set ty=ty + a * Sin(s__Missile_cA[this] + 1.57)
                    call SetUnitFacing(s__Missile_dummy[this], ( s__Missile_cA[this] + Atan(- ( 8 * s__Missile_open[this] * s - 4 * d * s__Missile_open[this] ) / ( d * d )) ) * bj_RADTODEG)
                endif
                

                    if tx > s__WorldBounds_maxX or tx < s__WorldBounds_minX or ty > s__WorldBounds_maxY or ty < s__WorldBounds_minY then
                        set s__Missile_wantDestroy[(this)]=true // INLINED!!
                    else
                        call SetUnitX(s__Missile_dummy[this], tx)
                        call SetUnitY(s__Missile_dummy[this], ty)
                    endif




                
                
                if s >= d then
                    set s__Missile_recycle[this]=true
                endif
                
                set this=s__Missile_next[this]
                
            endloop
        endfunction
    
    
    
    //***********************************************************************
    //  This function runs periodically. Can you see the trigger evaluation
    //  at the end? If you've read T32 then you know exactly what it does.
    //  The loop above is for cleaning up, the SIZE variable keeps track of
    //  how many instances have been deallocated by the user, if higher than
    //  0 then some of them need to be removed. STACK[SIZE] stores the value
    //  of the deallocated instances.
    function Missile___Execute takes nothing returns nothing
        loop
            exitwhen Missile___SIZE == 0
            set Missile___ACTIVE=Missile___ACTIVE - 1
            set Missile___SIZE=Missile___SIZE - 1
            set Missile___INSTANCES[Missile___STACK[Missile___SIZE]]=Missile___INSTANCES[Missile___STACK[Missile___SIZE]] - 1
            if Missile___INSTANCES[Missile___STACK[Missile___SIZE]] == 0 then
                call CTL___SR32((Missile___TIMER[Missile___STACK[Missile___SIZE]])) // INLINED!!
                if Missile___ACTIVE == 0 then
                    return
                endif
            endif
        endloop
        call TriggerEvaluate(Missile___FIRE)
    endfunction
    
    //***********************************************************************
    //  Adds a new instance to the given struct index (This system attaches
    //  indexes to every struct you implement MissileStruct to) If the amount
    //  of INSTANCES[index] was 0 then it adds the struct's iterate method to
    //  the FIRE trigger for it's evaluation. ACTIVE keeps track of all
    //  allocated instances, if it was 0 that means the timer isn't even
    //  running yet, it needs to be started.
function Missile___StartPeriodic takes integer l__index returns nothing
        if Missile___INSTANCES[l__index] == 0 then
            call CTL___A32((Missile___TIMER[l__index])) // INLINED!!
        endif
        set Missile___ACTIVE=Missile___ACTIVE + 1
        set Missile___INSTANCES[l__index]=Missile___INSTANCES[l__index] + 1
    endfunction
    
    //***********************************************************************
    //  Adds the struct's index to the stack to clear it in the Execute
    //  function above.
function Missile___StopPeriodic takes integer l__index returns nothing
        set Missile___STACK[Missile___SIZE]=l__index
        set Missile___SIZE=Missile___SIZE + 1
    endfunction
    

//library Missile ends
//library NumberStack:
    
    
        
        function s__NumberStack_create takes integer base returns integer
            local integer this= s__BigInt_create()
            set s__NumberStack_baset[this]=base
            return this
        endfunction
        function s__NumberStack__get_internalBase takes integer this returns integer
            return s__NumberStack_baset[this]
        endfunction
        function s__NumberStack__set_internalBase takes integer this,integer b returns nothing
            set s__NumberStack_baset[this]=b
        endfunction
        function s__NumberStack_convert takes string str,integer base returns integer
            local integer this= s__BigInt_convertString(str , base)
            call s__BigInt__set_base((this),0)
            set s__NumberStack_baset[this]=base
            return this
        endfunction
        function s__NumberStack_epush takes nothing returns boolean
            call s__BigInt_multiply(s__NumberStack_epushThis,s__NumberStack_epushMaxValue + 1)
            call s__BigInt_add(s__NumberStack_epushThis,s__NumberStack_epushValue)
            return false
        endfunction
        function s__NumberStack_push takes integer this,integer value,integer maxValue returns nothing
            set s__NumberStack_epushThis=this
            set s__NumberStack_epushValue=value
            set s__NumberStack_epushMaxValue=maxValue
            call TriggerEvaluate(s__NumberStack_epusht)
        endfunction
        function s__NumberStack_pop takes integer this,integer maxValue returns integer
            return s__BigInt_divide((this),maxValue + 1)
        endfunction
        function s__NumberStack__get_string takes integer this returns string
            call s__BigInt__set_base((this),s__NumberStack_baset[this])
            return s__BigInt_toString((this))
        endfunction
        function s__NumberStack_destroy takes integer this returns nothing
            call s__BigInt_destroy((this))
        endfunction
        function s__NumberStack__get_remaining takes integer this returns integer
            return s__BigInt_toInt((this))
        endfunction
        
//Implemented from module NumberStack__NumberStackInit:
        function s__NumberStack_NumberStack__NumberStackInit___onInit takes nothing returns nothing
            set s__NumberStack_epusht=CreateTrigger()
            call TriggerAddCondition(s__NumberStack_epusht, Condition(function s__NumberStack_epush))
        endfunction

//library NumberStack ends
//library QuestListener:
        function s__Listener_addGold takes player p,integer amount,unit turnIn,unit lastInteractedUnitForPlayer returns nothing
            call SetPlayerState(p, PLAYER_STATE_RESOURCE_GOLD, GetPlayerState(p, PLAYER_STATE_RESOURCE_GOLD) + amount)
        endfunction
        function s__Listener_addExp takes player p,integer amount,unit turnIn,unit lastInteractedUnitForPlayer returns nothing
            call SetHeroXP(turnIn, GetHeroXP(turnIn) + amount, true)
        endfunction
        function s__Listener_addLumber takes player p,integer amount,unit turnIn,unit lastInteractedUnitForPlayer returns nothing
            call SetPlayerState(p, PLAYER_STATE_RESOURCE_LUMBER, GetPlayerState(p, PLAYER_STATE_RESOURCE_LUMBER) + amount)
        endfunction
        function s__Listener_addItem takes integer itemType,unit turnIn,unit lastInteractedUnitForPlayer,integer amount returns nothing
            local item i= CreateItem(itemType, 0, 0)
            call UnitAddItem(lastInteractedUnitForPlayer, i)
            call SetItemCharges(i, amount)
            set i=null
        endfunction
        function s__Listener_createUnits takes integer unitType,integer amount,unit turnIn,unit lastInteractedUnitForPlayer returns nothing
        
        endfunction
        function s__Listener_addEventToInteractTrigger takes trigger interactTrigger returns nothing
            call TriggerRegisterAnyUnitEventBJ(interactTrigger, EVENT_PLAYER_UNIT_ISSUED_UNIT_ORDER)
            call TriggerAddCondition(interactTrigger, Filter(function sc__Listener_interactCondition))
        endfunction
        
        function s__Listener_interactCondition takes nothing returns boolean
            return RAbsBJ(GetUnitX(GetTriggerUnit()) - GetWidgetX(GetOrderTarget())) < 250 and RAbsBJ(GetUnitY(GetTriggerUnit()) - GetWidgetY(GetOrderTarget())) < 250
        endfunction
        
        function s__Listener_getInteractTrigger takes nothing returns unit
            return GetTriggerUnit()
        endfunction
        
        function s__Listener_getInteractVictim takes nothing returns widget
            return GetOrderTarget()
        endfunction
//Implemented from module QuestListenerModule:
        function s__Listener_QuestListenerModule___response takes nothing returns boolean
            if Quest_QUESTSYSTEM_RESPONSETYPE == 1 then
                call s__Listener_addGold(Quest_QUESTSYSTEM_PLAYER , Quest_QUESTSYSTEM_GOLDTOADD , Quest_QUESTSYSTEM_TRIGGERUNIT , Quest_QUESTSYSTEM_TRIGGERPLAYERUNIT)
            elseif Quest_QUESTSYSTEM_RESPONSETYPE == 2 then
                call s__Listener_addLumber(Quest_QUESTSYSTEM_PLAYER , Quest_QUESTSYSTEM_LUMBTOADD , Quest_QUESTSYSTEM_TRIGGERUNIT , Quest_QUESTSYSTEM_TRIGGERPLAYERUNIT)
            elseif Quest_QUESTSYSTEM_RESPONSETYPE == 3 then
            elseif Quest_QUESTSYSTEM_RESPONSETYPE == 4 then
                call s__Listener_addItem(Quest_QUESTSYSTEM_ITEMTYPE , Quest_QUESTSYSTEM_TRIGGERUNIT , Quest_QUESTSYSTEM_TRIGGERPLAYERUNIT , Quest_QUESTSYSTEM_ITEMAMOUNT)
            elseif Quest_QUESTSYSTEM_RESPONSETYPE == 5 then
                call s__Listener_addEventToInteractTrigger(Quest_QUESTSYSTEM_TEMPTRIGGER)
            elseif Quest_QUESTSYSTEM_RESPONSETYPE == 6 then
                call s__Listener_addExp(Quest_QUESTSYSTEM_PLAYER , Quest_QUESTSYSTEM_EXPTOADD , Quest_QUESTSYSTEM_TRIGGERUNIT , Quest_QUESTSYSTEM_TRIGGERPLAYERUNIT)
            elseif Quest_QUESTSYSTEM_RESPONSETYPE == 7 then
                set Quest_QUESTSYSTEM_TEMPUNIT=(GetTriggerUnit()) // INLINED!!
            elseif Quest_QUESTSYSTEM_RESPONSETYPE == 8 then
                set Quest_QUESTSYSTEM_TEMPWIDGET=(GetOrderTarget()) // INLINED!!
            elseif Quest_QUESTSYSTEM_RESPONSETYPE == 9 then
            elseif Quest_QUESTSYSTEM_RESPONSETYPE == 10 then
            endif
            return false
        endfunction
        function s__Listener_QuestListenerModule___onInit takes nothing returns nothing
            set Quest_QUESTSYSTEM_MAINTRIGGER=CreateTrigger()
            call TriggerAddCondition(Quest_QUESTSYSTEM_MAINTRIGGER, Filter(function s__Listener_QuestListenerModule___response))
        endfunction

//library QuestListener ends
//library Scrambler:
    
    
    function Scrambler__SetShuffleOrder takes nothing returns integer
        
        set Scrambler__so[0]=5
        set Scrambler__so[1]=2
        set Scrambler__so[2]=3
        set Scrambler__so[3]=11
        set Scrambler__so[4]=2
        set Scrambler__so[5]=7
        set Scrambler__so[6]=3
        
        
        return 7
    endfunction

    function Scrambler__LNF takes integer int,boolean i0 returns nothing
        set Scrambler__dc=0
        if ( i0 ) then
            loop
                set int=s__BigInt_next[int]
                exitwhen s__BigInt_head[int]
                set Scrambler__d[Scrambler__dc]=int
                set Scrambler__dc=Scrambler__dc + 1
            endloop
        else
            loop
                set int=s__BigInt_next[int]
                exitwhen s__BigInt_head[s__BigInt_next[int]]
                set Scrambler__d[Scrambler__dc]=int
                set Scrambler__dc=Scrambler__dc + 1
            endloop
            set int=s__BigInt_next[int]
        endif
    endfunction
    function Scrambler__LNB takes integer int,boolean i0 returns nothing
        set Scrambler__dc=0
        if ( not i0 ) then
            set int=s__BigInt_prev[int]
        endif
        loop
            set int=s__BigInt_prev[int]
            exitwhen s__BigInt_head[int]
            set Scrambler__d[Scrambler__dc]=int
            set Scrambler__dc=Scrambler__dc + 1
        endloop
    endfunction
    function Scrambler__FLP takes integer id,integer i2 returns nothing
        //find last position
        loop
            exitwhen 0 == i2
            set Scrambler__s1=Scrambler__dc
            loop
                exitwhen 0 == Scrambler__s1
                set Scrambler__s1=Scrambler__s1 - 1
                if ( Scrambler__se[Scrambler__k] ) then
                    set Scrambler__k=Scrambler__ss[id]
                else
                    set Scrambler__k=Scrambler__k + 1
                endif
            endloop
            set i2=i2 - 1
        endloop
    endfunction
    function Scramble takes integer int,integer id,integer shuffles,integer bb,boolean i0 returns nothing
        local integer b=(s__BigInt_bm[(int)]) // INLINED!!
        set Scrambler__pid=id
        set Scrambler__k=Scrambler__ss[id]
        set Scrambler__i=shuffles
            if ( b != bb ) then
                call s__BigInt__set_base(int,bb)
            endif
            //load number
            call Scrambler__LNF(int , i0)
            //scramble
            call TriggerEvaluate(Scrambler__st)
            if ( b != bb ) then
                call s__BigInt__set_base(int,b)
            endif
    endfunction
    function Unscramble takes integer int,integer id,integer shuffles,integer bb,boolean i0 returns nothing
        local integer b=(s__BigInt_bm[(int)]) // INLINED!!
        set Scrambler__i=shuffles
        set Scrambler__pid=id
        set Scrambler__k=Scrambler__ss[id]
            if ( b != bb ) then
                call s__BigInt__set_base(int,bb)
            endif
            //load number
            call Scrambler__LNB(int , i0)
            //retrieve last position
            call Scrambler__FLP(id , shuffles)
            //unscramble
            call TriggerEvaluate(Scrambler__ut)
            if ( b != bb ) then
                call s__BigInt__set_base(int,b)
            endif
    endfunction
    //scramble
    function Scrambler__St takes nothing returns boolean
        loop
            exitwhen 0 == Scrambler__i //exitwhen no more shuffles
            set Scrambler__s1=Scrambler__dc //loop through digits from left-1 to right
                            //don't shuffle left most to save a bit as
                            //left most must be 1
            loop
                exitwhen 0 == Scrambler__s1 //exitwhen no more digits
                set Scrambler__s1=Scrambler__s1 - 1 //shift down as array ends at n-1
                //current digit slot - hash digit (shift right)
                set Scrambler__s2=Scrambler__s1 - Scrambler__ss[Scrambler__k]
                //if s2 is negative, add total digits until positive
                loop
                    exitwhen 0 <= Scrambler__s2
                    set Scrambler__s2=Scrambler__dc + Scrambler__s2
                endloop
                //swap s2 and s1
                set Scrambler__s3=s__BigInt_digit[Scrambler__d[Scrambler__s2]]
                set s__BigInt_digit[Scrambler__d[Scrambler__s2]]=s__BigInt_digit[Scrambler__d[Scrambler__s1]]
                set s__BigInt_digit[Scrambler__d[Scrambler__s1]]=Scrambler__s3
                //if out of digits, go back to first digit on hash
                //otherwise, go to next digit
                //last existing digit is marked as end
                if ( Scrambler__se[Scrambler__k] ) then
                    set Scrambler__k=Scrambler__ss[Scrambler__pid]
                else
                    set Scrambler__k=Scrambler__k + 1
                endif
            endloop
            set Scrambler__i=Scrambler__i - 1
        endloop
        return false
    endfunction
    //unscramble
    function Scrambler__Ut takes nothing returns boolean
        //go backwards
        loop
            exitwhen 0 == Scrambler__i
            set Scrambler__s1=Scrambler__dc
            loop
                exitwhen 0 == Scrambler__s1
                set Scrambler__s1=Scrambler__s1 - 1
                set Scrambler__k=Scrambler__k - 1
                if ( 0 == Scrambler__ss[Scrambler__k] ) then
                    set Scrambler__k=Scrambler__ss[Scrambler__pid + 12]
                endif
                set Scrambler__s2=Scrambler__s1 + Scrambler__ss[Scrambler__k]
                loop
                    exitwhen Scrambler__s2 < Scrambler__dc
                    set Scrambler__s2=Scrambler__s2 - Scrambler__dc
                endloop
                set Scrambler__s3=s__BigInt_digit[Scrambler__d[Scrambler__s2]]
                set s__BigInt_digit[Scrambler__d[Scrambler__s2]]=s__BigInt_digit[Scrambler__d[Scrambler__s1]]
                set s__BigInt_digit[Scrambler__d[Scrambler__s1]]=Scrambler__s3
            endloop
            set Scrambler__i=Scrambler__i - 1
        endloop
        return false
    endfunction
    //shuffle
    function Scrambler__Mt takes nothing returns boolean
        local integer sh=0
        set Scrambler__k=Scrambler__ss[Scrambler__pid]
        loop
            exitwhen sh == Scrambler__sc
            set Scrambler__i=1
            call s__BigInt__set_base(Scrambler__bi,Scrambler__bs[Scrambler__so[sh]])
            call Scrambler__LNF(Scrambler__bi , false)
            call Scrambler__St()
            set sh=sh + 1
            set Scrambler__k=Scrambler__ss[Scrambler__pid]
        endloop
        return false
    endfunction
    //unshuffle
    function Scrambler__Dt takes nothing returns boolean
        local integer sh=Scrambler__sc
        set Scrambler__k=Scrambler__ss[Scrambler__pid]
        loop
            exitwhen 0 == sh
            set sh=sh - 1
            set Scrambler__i=1
            call s__BigInt__set_base(Scrambler__bi,Scrambler__bs[Scrambler__so[sh]])
            call Scrambler__LNB(Scrambler__bi , false)
            call Scrambler__FLP(Scrambler__pid , 1)
            call Scrambler__Ut()
            set Scrambler__k=Scrambler__ss[Scrambler__pid]
        endloop
        return false
    endfunction
    
    function Shuffle takes integer int,integer id,integer h returns nothing
        local integer b=(s__BigInt_bm[(int)]) // INLINED!!
            set Scrambler__bi=int
            set Scrambler__pid=id
            loop
                exitwhen 0 == h
                call TriggerEvaluate(Scrambler__mt)
                set h=h - 1
            endloop
            call s__BigInt__set_base(int,b)
    endfunction
    function Unshuffle takes integer int,integer id,integer h returns nothing
        local integer b=(s__BigInt_bm[(int)]) // INLINED!!
            set Scrambler__bi=int
            set Scrambler__pid=id
            loop
                exitwhen 0 == h
                call TriggerEvaluate(Scrambler__dt)
                set h=h - 1
            endloop
            call s__BigInt__set_base(int,b)
    endfunction
//Implemented from module Scrambler__Init:
        function s__Scrambler__Inits_Scrambler__Init___onInit takes nothing returns nothing
            local integer is=11
            local integer hh
            local integer ks=25
            local integer b8=s__Base__staticgetindex("012345678")
            local integer bg
            call TriggerAddCondition(Scrambler__mt, Condition(function Scrambler__Mt))
            call TriggerAddCondition(Scrambler__dt, Condition(function Scrambler__Dt))
            call TriggerAddCondition(Scrambler__st, Condition(function Scrambler__St))
            call TriggerAddCondition(Scrambler__ut, Condition(function Scrambler__Ut))
            set Scrambler__bs[2]=s__Base__staticgetindex("01")
            set Scrambler__bs[3]=s__Base__staticgetindex("012")
            set Scrambler__bs[5]=s__Base__staticgetindex("01234")
            set Scrambler__bs[7]=s__Base__staticgetindex("0123456")
            set Scrambler__bs[11]=s__Base__staticgetindex("0123456789A")
            set Scrambler__sc=Scrambler__SetShuffleOrder()
            loop
                if ( GetPlayerSlotState(Player(is)) == PLAYER_SLOT_STATE_PLAYING and GetPlayerController(Player(is)) == MAP_CONTROL_USER ) then
                    set Scrambler__ss[is]=ks
                    set hh=StringHash(StringCase(GetPlayerName(Player(is)) + Scrambler__SALT, false))
                    if ( 0 > hh ) then
                        set hh=- hh
                    endif
                    set bg=s__BigInt_create()
                    call s__BigInt__set_base(bg,b8)
                    call s__BigInt_add(bg,hh)
                    set bg=s__BigInt_prev[bg]
                    loop
                        set Scrambler__ss[ks]=s__BigInt_digit[bg] + 1
                        set bg=s__BigInt_prev[bg]
                        exitwhen s__BigInt_head[bg]
                        set ks=ks + 1
                    endloop
                    set Scrambler__se[ks]=true
                    set Scrambler__ss[is + 12]=ks
                    call s__BigInt_destroy(bg)
                    set ks=ks + 2
                endif
                exitwhen 0 == is
                set is=is - 1
            endloop
        endfunction

//library Scrambler ends
//library StatHandler:
        function s__StatHandler_addUnitBonus takes unit u,integer t returns nothing
            local real undo
            local integer id= GetUnitUserData(u)
            
            if s__Trait_typeOfTrait[t] == TRAIT_TYPE_DAMAGE then
                
                call AddUnitBonus(u , BONUS_DAMAGE , R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_ARMOR then
                call AddUnitBonus(u , BONUS_ARMOR , R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_STRENGTH then
            
                call AddUnitBonus(u , BONUS_STRENGTH , R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_AGILITY then
                call AddUnitBonus(u , BONUS_AGILITY , R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_INTELLIGENCE then
                call AddUnitBonus(u , BONUS_INTELLIGENCE , R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_MANA then
                call AddUnitBonus(u , BONUS_MANA , R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_MANA_REGEN then
                call AddUnitBonus(u , BONUS_MANA_REGEN , R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_LIFE then
                call AddUnitBonus(u , BONUS_LIFE , R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_LIFE_REGEN then
                call AddUnitBonus(u , BONUS_LIFE_REGEN , R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_ATTACK_SPEED then
                call AddUnitBonus(u , BONUS_ATTACK_SPEED , R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_MOVEMENT_SPEED then
                call print("default" + R2S(GetUnitDefaultMoveSpeed(u)) + "cb : " + R2S((LoadReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_MOVEMENT_SPEED))))), (GetUnitUserData(u))))) + " t.a : " + R2S(s__Trait_a[t])) // INLINED!!
                call SetUnitMoveSpeed(u, GetUnitDefaultMoveSpeed(u) + (LoadReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_MOVEMENT_SPEED))))), (GetUnitUserData(u)))) + s__Trait_a[t]) // INLINED!!
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_ALL_STATS then
                call AddUnitBonus(u , BONUS_STRENGTH , R2I(s__Trait_a[t]))
                call AddUnitBonus(u , BONUS_AGILITY , R2I(s__Trait_a[t]))
                call AddUnitBonus(u , BONUS_INTELLIGENCE , R2I(s__Trait_a[t]))
                call SaveReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_STRENGTH))))), (GetUnitUserData(u)), (( (LoadReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_STRENGTH))))), (GetUnitUserData(u)))) + s__Trait_a[t])*1.0)) // INLINED!!
                call SaveReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_AGILITY))))), (GetUnitUserData(u)), (( (LoadReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_AGILITY))))), (GetUnitUserData(u)))) + s__Trait_a[t])*1.0)) // INLINED!!
                call SaveReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_INTELLIGENCE))))), (GetUnitUserData(u)), (( (LoadReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_INTELLIGENCE))))), (GetUnitUserData(u)))) + s__Trait_a[t])*1.0)) // INLINED!!
                return
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_FIRE_DAMAGE then
                call SaveReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_FIRE_MAX_DAMAGE))))), (GetUnitUserData(u)), (( (LoadReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_FIRE_MAX_DAMAGE))))), (GetUnitUserData(u)))) + s__Trait_b[t])*1.0)) // INLINED!!
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_POISON_DAMAGE then
                call SaveReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_POISON_MAX_DAMAGE))))), (GetUnitUserData(u)), (( (LoadReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_POISON_MAX_DAMAGE))))), (GetUnitUserData(u)))) + s__Trait_b[t])*1.0)) // INLINED!!
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_COLD_DAMAGE then
                call SaveReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_COLD_MAX_DAMAGE))))), (GetUnitUserData(u)), (( (LoadReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_COLD_MAX_DAMAGE))))), (GetUnitUserData(u)))) + s__Trait_b[t])*1.0)) // INLINED!!
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_STATIC_DAMAGE then
                call SaveReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_STATIC_MAX_DAMAGE))))), (GetUnitUserData(u)), (( (LoadReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_STATIC_MAX_DAMAGE))))), (GetUnitUserData(u)))) + s__Trait_b[t])*1.0)) // INLINED!!
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_LIGHTNING_DAMAGE then
                call SaveReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_LIGHTNING_MAX_DAMAGE))))), (GetUnitUserData(u)), (( (LoadReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_LIGHTNING_MAX_DAMAGE))))), (GetUnitUserData(u)))) + s__Trait_b[t])*1.0)) // INLINED!!
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_FIRE_RESISTANCE then
            
                call SaveReal(Table___ht, (((((StatHandler__resistances) + (0))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (0 + id * 8192))) + id * 8192), (( s__Trait_a[t])*1.0)) // INLINED!!
                call SaveInteger(Table___ht, (StatHandler__currentResistancePoint), (0 + id * 8192), ( (LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (0 + id * 8192))) + 1)) // INLINED!!
                call sc__StatHandler_r_compile(u , 0)
                return
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_LIGHTNING_RESISTANCE then
                call SaveReal(Table___ht, (((((StatHandler__resistances) + (1))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (1 + id * 8192))) + id * 8192), (( s__Trait_a[t])*1.0)) // INLINED!!
                call SaveInteger(Table___ht, (StatHandler__currentResistancePoint), (1 + id * 8192), ( (LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (1 + id * 8192))) + 1)) // INLINED!!
                call sc__StatHandler_r_compile(u , 1)
                return
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_COLD_RESISTANCE then
                call SaveReal(Table___ht, (((((StatHandler__resistances) + (2))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (2 + id * 8192))) + id * 8192), (( s__Trait_a[t])*1.0)) // INLINED!!
                call SaveInteger(Table___ht, (StatHandler__currentResistancePoint), (2 + id * 8192), ( (LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (2 + id * 8192))) + 1)) // INLINED!!
                call sc__StatHandler_r_compile(u , 2)
                return
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_POISON_RESISTANCE then
                call SaveReal(Table___ht, (((((StatHandler__resistances) + (3))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (3 + id * 8192))) + id * 8192), (( s__Trait_a[t])*1.0)) // INLINED!!
                call SaveInteger(Table___ht, (StatHandler__currentResistancePoint), (3 + id * 8192), ( (LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (3 + id * 8192))) + 1)) // INLINED!!
                call sc__StatHandler_r_compile(u , 3)
                return
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_DARKNESS_RESISTANCE then
                call SaveReal(Table___ht, (((((StatHandler__resistances) + (4))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (4 + id * 8192))) + id * 8192), (( s__Trait_a[t])*1.0)) // INLINED!!
                call SaveInteger(Table___ht, (StatHandler__currentResistancePoint), (4 + id * 8192), ( (LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (4 + id * 8192))) + 1)) // INLINED!!
                call sc__StatHandler_r_compile(u , 4)
                return
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_HOLY_RESISTANCE then
                call SaveReal(Table___ht, (((((StatHandler__resistances) + (5))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (5 + id * 8192))) + id * 8192), (( s__Trait_a[t])*1.0)) // INLINED!!
                call SaveInteger(Table___ht, (StatHandler__currentResistancePoint), (5 + id * 8192), ( (LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (5 + id * 8192))) + 1)) // INLINED!!
                call sc__StatHandler_r_compile(u , 5)
                return
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_PHYSICAL_RESISTANCE then
                call SaveReal(Table___ht, (((((StatHandler__resistances) + (6))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (6 + id * 8192))) + id * 8192), (( s__Trait_a[t])*1.0)) // INLINED!!
                call SaveInteger(Table___ht, (StatHandler__currentResistancePoint), (6 + id * 8192), ( (LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (6 + id * 8192))) + 1)) // INLINED!!
                call sc__StatHandler_r_compile(u , 6)
                return
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_ALL_RESISTANCE then
                call SaveReal(Table___ht, (((((StatHandler__resistances) + (7))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (7 + id * 8192))) + id * 8192), (( s__Trait_a[t])*1.0)) // INLINED!!
                call SaveInteger(Table___ht, (StatHandler__currentResistancePoint), (7 + id * 8192), ( (LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (7 + id * 8192))) + 1)) // INLINED!!
                call sc__StatHandler_r_compile(u , 7)
                return
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_SPELL_RESISTANCE then
                call SaveReal(Table___ht, (((((StatHandler__resistances) + (8))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (8 + id * 8192))) + id * 8192), (( s__Trait_a[t])*1.0)) // INLINED!!
                call SaveInteger(Table___ht, (StatHandler__currentResistancePoint), (8 + id * 8192), ( (LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (8 + id * 8192))) + 1)) // INLINED!!
                call sc__StatHandler_r_compile(u , 8)
                return
            endif
            if s__Trait_typeOfTrait[t] < TRAIT_AMOUNTS then
                call SaveReal(Table___ht, (((((StatHandler__customBonuses) + (s__Trait_typeOfTrait[t]))))), (GetUnitUserData(u)), (( (LoadReal(Table___ht, (((((StatHandler__customBonuses) + (s__Trait_typeOfTrait[t]))))), (GetUnitUserData(u)))) + s__Trait_a[t])*1.0)) // INLINED!!
            endif
        endfunction
        
        function s__StatHandler_convert takes integer i returns integer
            if i == 0 then
                return TRAIT_TYPE_FIRE_RESISTANCE
            elseif i == 1 then
                return TRAIT_TYPE_LIGHTNING_RESISTANCE
            elseif i == 2 then
                return TRAIT_TYPE_COLD_RESISTANCE
            elseif i == 3 then
                return TRAIT_TYPE_POISON_RESISTANCE
            elseif i == 4 then
                return TRAIT_TYPE_DARKNESS_RESISTANCE
            elseif i == 5 then
                return TRAIT_TYPE_HOLY_RESISTANCE
            elseif i == 6 then
                return TRAIT_TYPE_PHYSICAL_RESISTANCE
            elseif i == 7 then
                return TRAIT_TYPE_ALL_RESISTANCE
            elseif i == 8 then
                return TRAIT_TYPE_SPELL_RESISTANCE
            endif
            return - 1
        endfunction
        
        function s__StatHandler_r_compile takes unit u,integer r returns nothing
            local integer i= 0
            local integer id= GetUnitUserData(u)
            local integer id2= id * 8192
            local integer max= (LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (r + id2))) // INLINED!!
            local real ti
            local real tt= 1
            local real array n
            loop
                exitwhen i > max
                set ti=(LoadReal(Table___ht, (((((StatHandler__resistances) + (r))))), (i + id2))) // INLINED!!
                set tt=( ( 100 - ti ) / 100 ) * tt
                set i=i + 1
            endloop
            call SaveReal(Table___ht, (((((StatHandler__customBonuses) + (s__StatHandler_convert(r)))))), (id), (( 100 - ( ( tt ) * 100 ))*1.0)) // INLINED!!
        endfunction
        
        function s__StatHandler_removeUnitBonus takes unit u,integer t returns nothing
            local integer i= 0
            local integer id= GetUnitUserData(u)
            if s__Trait_typeOfTrait[t] == TRAIT_TYPE_DAMAGE then
                call RemoveUnitBonus(u , BONUS_DAMAGE , R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_ARMOR then
                call RemoveUnitBonus(u , BONUS_ARMOR , R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_STRENGTH then
                call RemoveUnitBonus(u , BONUS_STRENGTH , R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_AGILITY then
                call RemoveUnitBonus(u , BONUS_AGILITY , R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_INTELLIGENCE then
                call RemoveUnitBonus(u , BONUS_INTELLIGENCE , R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_MANA then
                call RemoveUnitBonus(u , BONUS_MANA , R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_MANA_REGEN then
                call RemoveUnitBonus(u , BONUS_MANA_REGEN , R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_LIFE then
                call RemoveUnitBonus(u , BONUS_LIFE , R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_LIFE_REGEN then
                call RemoveUnitBonus(u , BONUS_LIFE_REGEN , R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_ATTACK_SPEED then
                call RemoveUnitBonus(u , BONUS_ATTACK_SPEED , R2I(s__Trait_a[t]))
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_ALL_STATS then
                call RemoveUnitBonus(u , BONUS_STRENGTH , R2I(s__Trait_a[t]))
                call RemoveUnitBonus(u , BONUS_AGILITY , R2I(s__Trait_a[t]))
                call RemoveUnitBonus(u , BONUS_INTELLIGENCE , R2I(s__Trait_a[t]))
                call SaveReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_STRENGTH))))), (id), (( (LoadReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_STRENGTH))))), (id))) - s__Trait_a[t])*1.0)) // INLINED!!
                call SaveReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_AGILITY))))), (id), (( (LoadReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_AGILITY))))), (id))) - s__Trait_a[t])*1.0)) // INLINED!!
                call SaveReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_INTELLIGENCE))))), (id), (( (LoadReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_INTELLIGENCE))))), (id))) - s__Trait_a[t])*1.0)) // INLINED!!
                return
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_FIRE_DAMAGE then
                call SaveReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_FIRE_MAX_DAMAGE))))), (id), (( (LoadReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_FIRE_MAX_DAMAGE))))), (id))) - s__Trait_b[t])*1.0)) // INLINED!!
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_POISON_DAMAGE then
                call SaveReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_POISON_MAX_DAMAGE))))), (id), (( (LoadReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_POISON_MAX_DAMAGE))))), (id))) - s__Trait_b[t])*1.0)) // INLINED!!
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_COLD_DAMAGE then
                call SaveReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_COLD_MAX_DAMAGE))))), (id), (( (LoadReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_COLD_MAX_DAMAGE))))), (id))) - s__Trait_b[t])*1.0)) // INLINED!!
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_STATIC_DAMAGE then
                call SaveReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_STATIC_MAX_DAMAGE))))), (id), (( (LoadReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_STATIC_MAX_DAMAGE))))), (id))) - s__Trait_b[t])*1.0)) // INLINED!!
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_LIGHTNING_DAMAGE then
                call SaveReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_LIGHTNING_MAX_DAMAGE))))), (id), (( (LoadReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_LIGHTNING_MAX_DAMAGE))))), (id))) - s__Trait_b[t])*1.0)) // INLINED!!
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_MOVEMENT_SPEED then
                call SetUnitMoveSpeed(u, GetUnitDefaultMoveSpeed(u) + (LoadReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_MOVEMENT_SPEED))))), (GetUnitUserData(u)))) - s__Trait_a[t]) // INLINED!!
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_FIRE_RESISTANCE then
//textmacro instance: RESISTANCE_MACRO("0")
                set i=0
                loop
                    if (LoadReal(Table___ht, (((((StatHandler__resistances) + (0))))), (i + id * 8192))) == s__Trait_a[t] then // INLINED!!
                        call SaveReal(Table___ht, (((((StatHandler__resistances) + (0))))), (i + id * 8192), (( (LoadReal(Table___ht, (((((StatHandler__resistances) + (0))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (0 + id * 8192))) + id * 8192))))*1.0)) // INLINED!!
                        call SaveReal(Table___ht, (((((StatHandler__resistances) + (0))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (0 + id * 8192))) + id * 8192), (( 0)*1.0)) // INLINED!!
                        call SaveInteger(Table___ht, (StatHandler__currentResistancePoint), (0 + id * 8192), ( (LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (0 + id * 8192))) - 1)) // INLINED!!
                        call s__StatHandler_r_compile(u , 0)
                        //set resistances[0].real[0] = resistances[0][0]-1
                        return
                    endif
                    set i=i + 1
                    if (LoadReal(Table___ht, (((((StatHandler__resistances) + (0))))), (i))) == 0 then // INLINED!!
                        call SimError(GetOwningPlayer(u) , "STAT HANDLER: A RESISTANCE REMOVED MUST BE PREVIOUSLY ADDED TO BE REMOVED")
                        return
                    endif
                endloop
//end of: RESISTANCE_MACRO("0")
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_LIGHTNING_RESISTANCE then
//textmacro instance: RESISTANCE_MACRO("1")
                set i=0
                loop
                    if (LoadReal(Table___ht, (((((StatHandler__resistances) + (1))))), (i + id * 8192))) == s__Trait_a[t] then // INLINED!!
                        call SaveReal(Table___ht, (((((StatHandler__resistances) + (1))))), (i + id * 8192), (( (LoadReal(Table___ht, (((((StatHandler__resistances) + (1))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (1 + id * 8192))) + id * 8192))))*1.0)) // INLINED!!
                        call SaveReal(Table___ht, (((((StatHandler__resistances) + (1))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (1 + id * 8192))) + id * 8192), (( 0)*1.0)) // INLINED!!
                        call SaveInteger(Table___ht, (StatHandler__currentResistancePoint), (1 + id * 8192), ( (LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (1 + id * 8192))) - 1)) // INLINED!!
                        call s__StatHandler_r_compile(u , 1)
                        //set resistances[1].real[0] = resistances[1][0]-1
                        return
                    endif
                    set i=i + 1
                    if (LoadReal(Table___ht, (((((StatHandler__resistances) + (1))))), (i))) == 0 then // INLINED!!
                        call SimError(GetOwningPlayer(u) , "STAT HANDLER: A RESISTANCE REMOVED MUST BE PREVIOUSLY ADDED TO BE REMOVED")
                        return
                    endif
                endloop
//end of: RESISTANCE_MACRO("1")
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_COLD_RESISTANCE then
//textmacro instance: RESISTANCE_MACRO("2")
                set i=0
                loop
                    if (LoadReal(Table___ht, (((((StatHandler__resistances) + (2))))), (i + id * 8192))) == s__Trait_a[t] then // INLINED!!
                        call SaveReal(Table___ht, (((((StatHandler__resistances) + (2))))), (i + id * 8192), (( (LoadReal(Table___ht, (((((StatHandler__resistances) + (2))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (2 + id * 8192))) + id * 8192))))*1.0)) // INLINED!!
                        call SaveReal(Table___ht, (((((StatHandler__resistances) + (2))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (2 + id * 8192))) + id * 8192), (( 0)*1.0)) // INLINED!!
                        call SaveInteger(Table___ht, (StatHandler__currentResistancePoint), (2 + id * 8192), ( (LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (2 + id * 8192))) - 1)) // INLINED!!
                        call s__StatHandler_r_compile(u , 2)
                        //set resistances[2].real[0] = resistances[2][0]-1
                        return
                    endif
                    set i=i + 1
                    if (LoadReal(Table___ht, (((((StatHandler__resistances) + (2))))), (i))) == 0 then // INLINED!!
                        call SimError(GetOwningPlayer(u) , "STAT HANDLER: A RESISTANCE REMOVED MUST BE PREVIOUSLY ADDED TO BE REMOVED")
                        return
                    endif
                endloop
//end of: RESISTANCE_MACRO("2")
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_POISON_RESISTANCE then
//textmacro instance: RESISTANCE_MACRO("3")
                set i=0
                loop
                    if (LoadReal(Table___ht, (((((StatHandler__resistances) + (3))))), (i + id * 8192))) == s__Trait_a[t] then // INLINED!!
                        call SaveReal(Table___ht, (((((StatHandler__resistances) + (3))))), (i + id * 8192), (( (LoadReal(Table___ht, (((((StatHandler__resistances) + (3))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (3 + id * 8192))) + id * 8192))))*1.0)) // INLINED!!
                        call SaveReal(Table___ht, (((((StatHandler__resistances) + (3))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (3 + id * 8192))) + id * 8192), (( 0)*1.0)) // INLINED!!
                        call SaveInteger(Table___ht, (StatHandler__currentResistancePoint), (3 + id * 8192), ( (LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (3 + id * 8192))) - 1)) // INLINED!!
                        call s__StatHandler_r_compile(u , 3)
                        //set resistances[3].real[0] = resistances[3][0]-1
                        return
                    endif
                    set i=i + 1
                    if (LoadReal(Table___ht, (((((StatHandler__resistances) + (3))))), (i))) == 0 then // INLINED!!
                        call SimError(GetOwningPlayer(u) , "STAT HANDLER: A RESISTANCE REMOVED MUST BE PREVIOUSLY ADDED TO BE REMOVED")
                        return
                    endif
                endloop
//end of: RESISTANCE_MACRO("3")
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_DARKNESS_RESISTANCE then
//textmacro instance: RESISTANCE_MACRO("4")
                set i=0
                loop
                    if (LoadReal(Table___ht, (((((StatHandler__resistances) + (4))))), (i + id * 8192))) == s__Trait_a[t] then // INLINED!!
                        call SaveReal(Table___ht, (((((StatHandler__resistances) + (4))))), (i + id * 8192), (( (LoadReal(Table___ht, (((((StatHandler__resistances) + (4))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (4 + id * 8192))) + id * 8192))))*1.0)) // INLINED!!
                        call SaveReal(Table___ht, (((((StatHandler__resistances) + (4))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (4 + id * 8192))) + id * 8192), (( 0)*1.0)) // INLINED!!
                        call SaveInteger(Table___ht, (StatHandler__currentResistancePoint), (4 + id * 8192), ( (LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (4 + id * 8192))) - 1)) // INLINED!!
                        call s__StatHandler_r_compile(u , 4)
                        //set resistances[4].real[0] = resistances[4][0]-1
                        return
                    endif
                    set i=i + 1
                    if (LoadReal(Table___ht, (((((StatHandler__resistances) + (4))))), (i))) == 0 then // INLINED!!
                        call SimError(GetOwningPlayer(u) , "STAT HANDLER: A RESISTANCE REMOVED MUST BE PREVIOUSLY ADDED TO BE REMOVED")
                        return
                    endif
                endloop
//end of: RESISTANCE_MACRO("4")
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_HOLY_RESISTANCE then
//textmacro instance: RESISTANCE_MACRO("5")
                set i=0
                loop
                    if (LoadReal(Table___ht, (((((StatHandler__resistances) + (5))))), (i + id * 8192))) == s__Trait_a[t] then // INLINED!!
                        call SaveReal(Table___ht, (((((StatHandler__resistances) + (5))))), (i + id * 8192), (( (LoadReal(Table___ht, (((((StatHandler__resistances) + (5))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (5 + id * 8192))) + id * 8192))))*1.0)) // INLINED!!
                        call SaveReal(Table___ht, (((((StatHandler__resistances) + (5))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (5 + id * 8192))) + id * 8192), (( 0)*1.0)) // INLINED!!
                        call SaveInteger(Table___ht, (StatHandler__currentResistancePoint), (5 + id * 8192), ( (LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (5 + id * 8192))) - 1)) // INLINED!!
                        call s__StatHandler_r_compile(u , 5)
                        //set resistances[5].real[0] = resistances[5][0]-1
                        return
                    endif
                    set i=i + 1
                    if (LoadReal(Table___ht, (((((StatHandler__resistances) + (5))))), (i))) == 0 then // INLINED!!
                        call SimError(GetOwningPlayer(u) , "STAT HANDLER: A RESISTANCE REMOVED MUST BE PREVIOUSLY ADDED TO BE REMOVED")
                        return
                    endif
                endloop
//end of: RESISTANCE_MACRO("5")
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_PHYSICAL_RESISTANCE then
//textmacro instance: RESISTANCE_MACRO("6")
                set i=0
                loop
                    if (LoadReal(Table___ht, (((((StatHandler__resistances) + (6))))), (i + id * 8192))) == s__Trait_a[t] then // INLINED!!
                        call SaveReal(Table___ht, (((((StatHandler__resistances) + (6))))), (i + id * 8192), (( (LoadReal(Table___ht, (((((StatHandler__resistances) + (6))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (6 + id * 8192))) + id * 8192))))*1.0)) // INLINED!!
                        call SaveReal(Table___ht, (((((StatHandler__resistances) + (6))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (6 + id * 8192))) + id * 8192), (( 0)*1.0)) // INLINED!!
                        call SaveInteger(Table___ht, (StatHandler__currentResistancePoint), (6 + id * 8192), ( (LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (6 + id * 8192))) - 1)) // INLINED!!
                        call s__StatHandler_r_compile(u , 6)
                        //set resistances[6].real[0] = resistances[6][0]-1
                        return
                    endif
                    set i=i + 1
                    if (LoadReal(Table___ht, (((((StatHandler__resistances) + (6))))), (i))) == 0 then // INLINED!!
                        call SimError(GetOwningPlayer(u) , "STAT HANDLER: A RESISTANCE REMOVED MUST BE PREVIOUSLY ADDED TO BE REMOVED")
                        return
                    endif
                endloop
//end of: RESISTANCE_MACRO("6")
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_ALL_RESISTANCE then
//textmacro instance: RESISTANCE_MACRO("7")
                set i=0
                loop
                    if (LoadReal(Table___ht, (((((StatHandler__resistances) + (7))))), (i + id * 8192))) == s__Trait_a[t] then // INLINED!!
                        call SaveReal(Table___ht, (((((StatHandler__resistances) + (7))))), (i + id * 8192), (( (LoadReal(Table___ht, (((((StatHandler__resistances) + (7))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (7 + id * 8192))) + id * 8192))))*1.0)) // INLINED!!
                        call SaveReal(Table___ht, (((((StatHandler__resistances) + (7))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (7 + id * 8192))) + id * 8192), (( 0)*1.0)) // INLINED!!
                        call SaveInteger(Table___ht, (StatHandler__currentResistancePoint), (7 + id * 8192), ( (LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (7 + id * 8192))) - 1)) // INLINED!!
                        call s__StatHandler_r_compile(u , 7)
                        //set resistances[7].real[0] = resistances[7][0]-1
                        return
                    endif
                    set i=i + 1
                    if (LoadReal(Table___ht, (((((StatHandler__resistances) + (7))))), (i))) == 0 then // INLINED!!
                        call SimError(GetOwningPlayer(u) , "STAT HANDLER: A RESISTANCE REMOVED MUST BE PREVIOUSLY ADDED TO BE REMOVED")
                        return
                    endif
                endloop
//end of: RESISTANCE_MACRO("7")
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_SPELL_RESISTANCE then
//textmacro instance: RESISTANCE_MACRO("8")
                set i=0
                loop
                    if (LoadReal(Table___ht, (((((StatHandler__resistances) + (8))))), (i + id * 8192))) == s__Trait_a[t] then // INLINED!!
                        call SaveReal(Table___ht, (((((StatHandler__resistances) + (8))))), (i + id * 8192), (( (LoadReal(Table___ht, (((((StatHandler__resistances) + (8))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (8 + id * 8192))) + id * 8192))))*1.0)) // INLINED!!
                        call SaveReal(Table___ht, (((((StatHandler__resistances) + (8))))), ((LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (8 + id * 8192))) + id * 8192), (( 0)*1.0)) // INLINED!!
                        call SaveInteger(Table___ht, (StatHandler__currentResistancePoint), (8 + id * 8192), ( (LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (8 + id * 8192))) - 1)) // INLINED!!
                        call s__StatHandler_r_compile(u , 8)
                        //set resistances[8].real[0] = resistances[8][0]-1
                        return
                    endif
                    set i=i + 1
                    if (LoadReal(Table___ht, (((((StatHandler__resistances) + (8))))), (i))) == 0 then // INLINED!!
                        call SimError(GetOwningPlayer(u) , "STAT HANDLER: A RESISTANCE REMOVED MUST BE PREVIOUSLY ADDED TO BE REMOVED")
                        return
                    endif
                endloop
//end of: RESISTANCE_MACRO("8")
            endif
            //if t.typeOfTrait < TRAIT_AMOUNTS then
                call SaveReal(Table___ht, (((((StatHandler__customBonuses) + (s__Trait_typeOfTrait[t]))))), (id), (( (LoadReal(Table___ht, (((((StatHandler__customBonuses) + (s__Trait_typeOfTrait[t]))))), (id))) - s__Trait_a[t])*1.0)) // INLINED!!
            //endif
        endfunction
        function s__StatHandler_onTimerFinish takes nothing returns nothing
            local integer i= GetHandleId(GetExpiredTimer())
            call s__StatHandler_removeUnitBonus((LoadUnitHandle(Table___ht, (((((StatHandler__attachedTimerData) + (1))))), (i))) , (LoadInteger(Table___ht, (((StatHandler__attachedTimerData) + (0))), (i)))) // INLINED!!
            call DestroyTimer(GetExpiredTimer())
        endfunction
        function s__StatHandler_temporaryBonus takes unit u,integer t,real duration returns timer
            local timer t2= CreateTimer()
            call s__StatHandler_addUnitBonus(u , t)
            call SaveInteger(Table___ht, (((StatHandler__attachedTimerData) + (0))), (GetHandleId(t2)), ( t)) // INLINED!!
            call SaveUnitHandle(Table___ht, (((((StatHandler__attachedTimerData) + (1))))), (GetHandleId(t2)), ( u)) // INLINED!!
            call TimerStart(t2, duration, false, function s__StatHandler_onTimerFinish)
            return t2
        endfunction
        function s__StatHandler_getScaledDamage takes unit u,real armor,real amount returns real
            local real ARMOR_REDUCTION_MULTIPLIER= 0.06
            if armor >= 0. then
                return amount * ( 1. - ( ( armor * ARMOR_REDUCTION_MULTIPLIER ) / ( 1. + ARMOR_REDUCTION_MULTIPLIER * armor ) ) )
            else
                return amount * ( 2. - Pow(0.94, - armor) )
            endif
        endfunction
        
        function s__StatHandler_getUnitBonus takes unit u,integer bonus returns real
            return (LoadReal(Table___ht, (((((StatHandler__customBonuses) + (bonus))))), (GetUnitUserData(u)))) // INLINED!!
        endfunction
        //get unit bonus doesn't add all resistance
        function s__StatHandler_getUnitResistance takes unit u,integer resistance returns real
            local real a= ( 100 - (LoadReal(Table___ht, (((((StatHandler__customBonuses) + (resistance))))), (GetUnitUserData(u)))) ) / 100 // INLINED!!
            local real b= ( 100 - (LoadReal(Table___ht, (((((StatHandler__customBonuses) + (TRAIT_TYPE_ALL_RESISTANCE))))), (GetUnitUserData(u)))) ) / 100 // INLINED!!
            return 100 - ( ( a * b ) * 100 )
        endfunction
        function s__StatHandler_getUnitArmor takes unit u returns real
            local real r= GetUnitState(u, UNIT_STATE_LIFE)
            local real damage
            local real armor
            call UnitDamageTarget(udg_PlayerUnit[1], u, 0.1, true, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_NORMAL, WEAPON_TYPE_WHOKNOWS)
            set damage=r - GetUnitState(u, UNIT_STATE_LIFE)
            if damage > 0.1 then
                set armor=( ( - 1.00 * ( 0.1 - damage ) ) / ( damage * 0.06 ) )
            else
                set armor=( ( 0.1 - damage ) / ( damage * 0.06 ) )
            endif
            call SetUnitState(u, UNIT_STATE_LIFE, r)
            return armor
        endfunction
        
        function s__StatHandler_fixDamage takes unit source,unit target,real amount returns real
            local integer i= GetUnitUserData(source)
            local real armor= s__StatHandler_getUnitArmor(target)
            if (LoadInteger(Table___ht, (((StatHandler__customBonuses) + (TRAIT_TYPE_FIRE_DAMAGE))), (i))) != 0 then // INLINED!!
                set amount=amount + s__StatHandler_getScaledDamage(source , armor , GetRandomInt((LoadInteger(Table___ht, (((StatHandler__customBonuses) + (TRAIT_TYPE_FIRE_DAMAGE))), (i))), (LoadInteger(Table___ht, (((StatHandler__customBonuses) + (TRAIT_TYPE_FIRE_MAX_DAMAGE))), (i))))) // INLINED!!
            elseif (LoadInteger(Table___ht, (((StatHandler__customBonuses) + (TRAIT_TYPE_LIGHTNING_DAMAGE))), (i))) != 0 then // INLINED!!
                set amount=amount + s__StatHandler_getScaledDamage(source , armor , GetRandomInt((LoadInteger(Table___ht, (((StatHandler__customBonuses) + (TRAIT_TYPE_LIGHTNING_DAMAGE))), (i))), (LoadInteger(Table___ht, (((StatHandler__customBonuses) + (TRAIT_TYPE_LIGHTNING_MAX_DAMAGE))), (i))))) // INLINED!!
            elseif (LoadInteger(Table___ht, (((StatHandler__customBonuses) + (TRAIT_TYPE_POISON_DAMAGE))), (i))) != 0 then // INLINED!!
                set amount=amount + s__StatHandler_getScaledDamage(source , armor , GetRandomInt((LoadInteger(Table___ht, (((StatHandler__customBonuses) + (TRAIT_TYPE_POISON_DAMAGE))), (i))), (LoadInteger(Table___ht, (((StatHandler__customBonuses) + (TRAIT_TYPE_POISON_MAX_DAMAGE))), (i))))) // INLINED!!
            elseif (LoadInteger(Table___ht, (((StatHandler__customBonuses) + (TRAIT_TYPE_STATIC_DAMAGE))), (i))) != 0 then // INLINED!!
                set amount=amount + GetRandomInt((LoadInteger(Table___ht, (((StatHandler__customBonuses) + (TRAIT_TYPE_STATIC_DAMAGE))), (i))), (LoadInteger(Table___ht, (((StatHandler__customBonuses) + (TRAIT_TYPE_STATIC_MAX_DAMAGE))), (i)))) // INLINED!!
            elseif (LoadInteger(Table___ht, (((StatHandler__customBonuses) + (TRAIT_TYPE_COLD_DAMAGE))), (i))) != 0 then // INLINED!!
                set amount=amount + s__StatHandler_getScaledDamage(source , armor , GetRandomInt((LoadInteger(Table___ht, (((StatHandler__customBonuses) + (TRAIT_TYPE_COLD_DAMAGE))), (i))), (LoadInteger(Table___ht, (((StatHandler__customBonuses) + (TRAIT_TYPE_COLD_MAX_DAMAGE))), (i))))) // INLINED!!
            endif
            return amount
        endfunction
        
    function StatHandler__ond takes nothing returns boolean
        local unit u= GetFilterUnit()
        local integer id= GetUnitUserData(u)
        local integer i= 0
        local integer p
        local integer i2
        
        loop
            exitwhen i > TRAIT_AMOUNTS
            call SaveReal(Table___ht, (((((StatHandler__customBonuses) + (i))))), (id), (( 0.)*1.0)) // INLINED!!
            set i=i + 1
        endloop
        set i=0
        loop
            exitwhen i > TRAIT_RESISTANCES
            set i2=0
            set p=(LoadInteger(Table___ht, (StatHandler__currentResistancePoint), (i + id * 8192))) // INLINED!!
            loop
                exitwhen i2 >= p
                call SaveReal(Table___ht, (((((StatHandler__resistances) + (i))))), (i2 + id * 8192), (( 0.)*1.0)) // INLINED!!
                set i2=i2 + 1
            endloop
            set i=i + 1
        endloop
        set i=0
        loop
            exitwhen i > TRAIT_CRITS
            
            set i=i + 1
        endloop
        set u=null
        return false
    endfunction
    function StatHandler__onInit takes nothing returns nothing
        call RegisterUnitIndexEvent(Filter(function StatHandler__ond) , s__UnitIndexer_DEINDEX)
        set StatHandler__customBonuses=s__TableArray__staticgetindex(TRAIT_AMOUNTS)
        set StatHandler__resistances=s__TableArray__staticgetindex(TRAIT_RESISTANCES)
        set StatHandler__crits=s__TableArray__staticgetindex(TRAIT_CRITS)
        set StatHandler__attachedTimerData=s__TableArray__staticgetindex(2)
        set StatHandler__currentResistances=s__Table_create()
        set StatHandler__currentResistancePoint=s__Table_create()
    endfunction

//library StatHandler ends
//library fuuulibrary:
    // hiveworkshop.com/forums/jass-functions-413/snippet-new-table-188084/
        //addButton takes int heroIndex, integer buttonId ,int x, int y //DataIndex1//
        //addMaxLevel takes int heroIndex, int level, int x, int y //DataIndex2//
        //addInitPointReq takes int heroIndex, int number, int x, int y //DataIndex3//
        //addPointReq takes int heroIndex, int number, int x, int y //DataIndex4//
        //addMultiButton takes int heroIndex, string iconFileName, int x, int y //DataIndex5//
        //addMultiName takes int heroIndex, string name, int x, int y  //DataIndex6//
        //addMultiDescription takes int heroIndex, string description, int x, int y //DataIndex7//
        //       "Multi" refers to "Multiboard"//
        //addLink takes int heroIndex, int x, int y, int linkx, int linky, int level, boolean require //DataIndex8 for link, DataIndex9 for level//
        //        if require == false, than linkx,linky requires x,y
        //        if require == true, than x,y requires linkx,linky
        //GetHeroIndex takes integer heroID returns integer//
        //   Takes the ID of the hero and returns the hero index//
        //AllocHeroIndex takes integer heroID returns integer (the heroIndex that it was assigned)//
        //boolean forced = x,y MUST require linkx,linky
        //if a skill requires 2 skills and theyre both forced = false, than only one is required
        //if one of the skills has forced, than it is required
        //if both have forced, than they are both require
        
            //* = must be set in InitGlobals
            //@ = Set Here
            //$ = do not edit
            //Destructables
    function fuuulibrary__getIndex takes integer data,integer heroIndex returns integer
        return data + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )
    endfunction
    function fuuulibrary__getLocation takes integer x,integer y returns integer
        return ( fuuulibrary__WIDTH * ( y ) ) + x
    endfunction
    
        //Use this function to pan the camera to the hero select region
        function s__VJassTalentTree_cameraPan takes player p returns nothing
            //local real addX = -350
            local real addX= - 450
            local real addY= 0
            call SetCameraFieldForPlayer(p, CAMERA_FIELD_ANGLE_OF_ATTACK, 270.00, 0) // dont touch
            call SetCameraFieldForPlayer(p, CAMERA_FIELD_TARGET_DISTANCE, 2000, 0) //change this depending on the size of your talent tree
            if GetLocalPlayer() == p then
                call PanCameraToTimed(( ( GetRectMinX(fuuulibrary__treeRect) + GetRectMinY(fuuulibrary__treeRect) ) / 2 ) + addX, ( GetRectMaxY(fuuulibrary__treeRect) + GetRectMinY(fuuulibrary__treeRect) ) / 2, 0) //this is the actual camera pan
          //      call SetCameraBoundsToRect(regionLock)
            endif
        endfunction
        
        function s__VJassTalentTree_getHeroForPlayer takes player p returns unit
            return udg_PlayerUnit[GetPlayerId(p) + 1]
        endfunction
        
        //Begin User Functions
        
        //The button thats displayed in the main region
        function s__VJassTalentTree_addButton takes integer heroIndex,integer buttonId,integer x,integer y returns nothing
            call SaveInteger(Table___ht, (((fuuulibrary__tree) + (fuuulibrary__getLocation(x , y)))), (((1 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))), ( buttonId)) // INLINED!!
        endfunction
            //The max level of the talent
        function s__VJassTalentTree_addMaxLevel takes integer heroIndex,integer level,integer x,integer y returns nothing
            call SaveInteger(Table___ht, (((fuuulibrary__tree) + (fuuulibrary__getLocation(x , y)))), (((2 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))), ( level)) // INLINED!!
        endfunction
            //The # of points required to learn that talent
        function s__VJassTalentTree_addInitPointReq takes integer heroIndex,integer number,integer x,integer y returns nothing
            call SaveInteger(Table___ht, (((fuuulibrary__tree) + (fuuulibrary__getLocation(x , y)))), (((3 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))), ( number)) // INLINED!!
        endfunction
            //The # of points required to upgrade that talent
        function s__VJassTalentTree_addPointReq takes integer heroIndex,integer number,integer x,integer y returns nothing
            call SaveInteger(Table___ht, (((fuuulibrary__tree) + (fuuulibrary__getLocation(x , y)))), (((4 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))), ( number)) // INLINED!!
        endfunction
            //The destructable displayed in the information panel. Usualy the same as the tree button
        function s__VJassTalentTree_addDisabledButton takes integer heroIndex,integer iconId,integer x,integer y returns nothing
            call SaveInteger(Table___ht, (((fuuulibrary__tree) + (fuuulibrary__getLocation(x , y)))), (((5 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))), ( iconId)) // INLINED!!
        endfunction
            //The title of the ability in the information panel
        function s__VJassTalentTree_addMultiName takes integer heroIndex,string name,integer x,integer y returns nothing
            call SaveStr(Table___ht, (((((fuuulibrary__tree) + (fuuulibrary__getLocation(x , y)))))), (((6 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))), ( name)) // INLINED!!
        endfunction
            //The description of the ablity in the information panel
        function s__VJassTalentTree_addMultiDescription takes integer heroIndex,string description,integer x,integer y returns nothing
            call SaveStr(Table___ht, (((((fuuulibrary__tree) + (fuuulibrary__getLocation(x , y)))))), (((7 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))), ( description)) // INLINED!!
        endfunction
        
        function s__VJassTalentTree_setAsMenu takes integer heroIndex,boolean is,integer x,integer y returns nothing
            call SaveBoolean(Table___ht, (((((fuuulibrary__tree) + (fuuulibrary__getLocation(x , y)))))), (((33 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))), ( is)) // INLINED!!
        endfunction
            //x,y requires linkx,linky to be at level (level) before x,y can be learned
            //max of 3x linkx/linky
            //i have no intention of making this inline-friendly
            //if autoallocate, then it sets it to the next available link spot
            //if autoallocate = false, than it sets it to lightningIndex rater than autoallocate
//textmacro instance: ADDSWAP()
    function s__VJassTalentTree_addReverseLink takes integer heroIndex,integer x,integer y,integer linkx,integer linky returns nothing
        if (LoadInteger(Table___ht, (((fuuulibrary__tree) + (( fuuulibrary__WIDTH * ( linky ) ) + linkx))), (16 + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )))) <= 0 then // INLINED!!
            call SaveInteger(Table___ht, (((fuuulibrary__tree) + (linkx + fuuulibrary__WIDTH * linky))), (16 + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )), ( fuuulibrary__getLocation(x , y) + 1)) // INLINED!!
        elseif (LoadInteger(Table___ht, (((fuuulibrary__tree) + (( fuuulibrary__WIDTH * ( linky ) ) + linkx))), (17 + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )))) <= 0 then // INLINED!!
            call SaveInteger(Table___ht, (((fuuulibrary__tree) + (linkx + fuuulibrary__WIDTH * linky))), (17 + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )), ( fuuulibrary__getLocation(x , y) + 1)) // INLINED!!
        elseif (LoadInteger(Table___ht, (((fuuulibrary__tree) + (( fuuulibrary__WIDTH * ( linky ) ) + linkx))), (18 + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )))) <= 0 then // INLINED!!
            call SaveInteger(Table___ht, (((fuuulibrary__tree) + (linkx + fuuulibrary__WIDTH * linky))), (18 + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )), ( fuuulibrary__getLocation(x , y) + 1)) // INLINED!!
        endif
    endfunction
//end of: ADDSWAP()
        function s__VJassTalentTree_addLink takes integer heroIndex,integer x,integer y,integer linkx,integer linky,integer level,integer lightningIndex,boolean autoallocate returns nothing
            if autoallocate then
                if (LoadInteger(Table___ht, (((fuuulibrary__tree) + (fuuulibrary__getLocation(x , y)))), (((8 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))))) <= 0 then // INLINED!!
                    call SaveInteger(Table___ht, (((fuuulibrary__tree) + (fuuulibrary__getLocation(x , y)))), (((8 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))), ( fuuulibrary__getLocation(linkx , linky) + 1)) // INLINED!!
                    call SaveInteger(Table___ht, (((fuuulibrary__tree) + (linkx + fuuulibrary__WIDTH * linky))), (((16 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))), ( fuuulibrary__getLocation(x , y))) // INLINED!!
                    call SaveInteger(Table___ht, (((fuuulibrary__tree) + (fuuulibrary__getLocation(x , y)))), (((9 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))), ( level)) // INLINED!!
                    call s__VJassTalentTree_addReverseLink(heroIndex , x , y , linkx , linky)
                elseif (LoadInteger(Table___ht, (((fuuulibrary__tree) + (fuuulibrary__getLocation(x , y)))), (((10 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))))) <= 0 then // INLINED!!
                    call SaveInteger(Table___ht, (((fuuulibrary__tree) + (fuuulibrary__getLocation(x , y)))), (((10 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))), ( fuuulibrary__getLocation(linkx , linky) + 1)) // INLINED!!
                    call SaveInteger(Table___ht, (((fuuulibrary__tree) + (linkx + fuuulibrary__WIDTH * linky))), (((17 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))), ( fuuulibrary__getLocation(x , y))) // INLINED!!
                    call SaveInteger(Table___ht, (((fuuulibrary__tree) + (fuuulibrary__getLocation(x , y)))), (((11 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))), ( level)) // INLINED!!
                    call s__VJassTalentTree_addReverseLink(heroIndex , x , y , linkx , linky)
                elseif (LoadInteger(Table___ht, (((fuuulibrary__tree) + (fuuulibrary__getLocation(x , y)))), (((12 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))))) <= 0 then // INLINED!!
                    call SaveInteger(Table___ht, (((fuuulibrary__tree) + (fuuulibrary__getLocation(x , y)))), (((12 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))), ( fuuulibrary__getLocation(linkx , linky) + 1)) // INLINED!!
                    call SaveInteger(Table___ht, (((fuuulibrary__tree) + (linkx + fuuulibrary__WIDTH * linky))), (((18 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))), ( fuuulibrary__getLocation(x , y))) // INLINED!!
                    call SaveInteger(Table___ht, (((fuuulibrary__tree) + (fuuulibrary__getLocation(x , y)))), (((13 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))), ( level)) // INLINED!!
                    call s__VJassTalentTree_addReverseLink(heroIndex , x , y , linkx , linky)
                endif
            else
                call SaveInteger(Table___ht, (((fuuulibrary__tree) + (fuuulibrary__getLocation(x , y)))), (( 8 + ( lightningIndex * 2 ) ) + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )), ( ( linkx + fuuulibrary__WIDTH * linky ) + 1)) // INLINED!!
                call SaveInteger(Table___ht, (((fuuulibrary__tree) + (fuuulibrary__getLocation(x , y)))), (( 9 + ( lightningIndex * 2 ) ) + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )), ( level)) // INLINED!!
            endif
        endfunction
        function s__VJassTalentTree_attachData takes integer heroIndex,integer x,integer y,integer data returns nothing
            call SaveInteger(Table___ht, (((fuuulibrary__tree) + (fuuulibrary__getLocation(x , y)))), (15 + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )), ( data + 1)) // INLINED!!
        endfunction
        function s__VJassTalentTree_newHeroIndex takes nothing returns integer
            set fuuulibrary__currentHeroArray=fuuulibrary__currentHeroArray + 1
            return fuuulibrary__currentHeroArray
        endfunction
        function s__VJassTalentTree_addStartLvlReq takes integer heroIndex,integer x,integer y,integer level returns nothing
            call SaveInteger(Table___ht, (((fuuulibrary__tree) + (fuuulibrary__getLocation(x , y)))), (20 + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )), ( level)) // INLINED!!
        endfunction
        function s__VJassTalentTree_addUpgLvlReq takes integer heroIndex,integer x,integer y,integer increment returns nothing
            call SaveInteger(Table___ht, (((fuuulibrary__tree) + (fuuulibrary__getLocation(x , y)))), (21 + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )), ( increment)) // INLINED!!
        endfunction
        //10 = 2nd linkx/linky
        //11 = 2nd levl
        //12 = 3rd linkx/linky
        //13 = 3rd level
        //14 = current level of the talent
        //15 = attached data
        //16 = 1st reverse link
        //17 = 2nd reverse link
        //18 = 3rd reverse link
        //19 = attached data
        //20 = required lvl to learn
        //21 = required lvl per increment to upgrade
        //22 - 32 = level of talent for player
        //showUI takes player p, integer heroIndex returns nothing
        //hideUI takes player p returns nothing
        //Shows the UI for the specified player at the specified index
        function s__VJassTalentTree_lightningCreate takes player p,integer start,integer end returns nothing
            local string lightningModel= ""
            local real x1
            local real x2
            local real y1
            local real y2
            local integer l__index= 0
            if fuuulibrary__LIGHTNING_PATH == "CHNS" then
                set fuuulibrary__LIGHTNING_PATH="CHNS"
            else
                set fuuulibrary__LIGHTNING_PATH="CHNS"
            endif
            set lightningModel=fuuulibrary__LIGHTNING_PATH
            if GetLocalPlayer() != p then
                set lightningModel=""
            endif
            set x1=fuuulibrary__X[start] //.x is psuedocode for x of destructible
            set y1=fuuulibrary__Y[start]
            set x2=fuuulibrary__X[end]
            set y2=fuuulibrary__Y[end]
            
            if x1 > x2 then
                set x1=x1 - 32
                set x2=x2 + 32
            elseif x1 < x2 then
                set x1=x1 + 32
                set x2=x2 - 32
            endif
            if y1 > y2 then
                set y1=y1 - 32
                set y2=y2 + 32
            elseif y1 < y2 then
                set y1=y1 + 32
                set y2=y2 - 32
            endif
            if (LoadLightningHandle(Table___ht, (((fuuulibrary__staticTree))), (start))) != null then // INLINED!!
                set l__index=0
            elseif (LoadLightningHandle(Table___ht, (((fuuulibrary__staticTree))), (start + 10000))) != null then // INLINED!!
                set l__index=1
            else
                set l__index=2
            endif
            //Don't even remember when i made these formulas lol
            call SaveLightningHandle(Table___ht, (((fuuulibrary__staticTree))), (start + ( 10000 * l__index )), ( AddLightning(lightningModel, false, x1, y1, x2, y2))) // INLINED!!
        endfunction
        function s__VJassTalentTree_hideUI takes player p returns nothing
            local integer heroIndex= fuuulibrary__currentHeroIndex[GetPlayerId(p)]
            local integer forLoop= ( fuuulibrary__WIDTH * 8 ) + 1
            local integer linkLoop= 0
            local integer start
            local integer end
            local integer i
            call SetCameraBoundsToRect(bj_mapInitialPlayableArea)
            set fuuulibrary__currentHeroIndex[GetPlayerId(p)]=- 1
            loop
                set forLoop=forLoop - 1
                exitwhen forLoop == - 1
                if (LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (((1 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))))) >= 5 then // INLINED!!
                    set i=0
                    if i <= 5 or GetLocalPlayer() == p then
                        set i=fuuulibrary__invisible
                    endif
                    if fuuulibrary__buttons[forLoop] != null and fuuulibrary__X[forLoop] != 0 then
                        call RemoveDestructable(fuuulibrary__buttons[forLoop])
                        set fuuulibrary__buttons[forLoop]=CreateDestructable(i, fuuulibrary__X[forLoop], fuuulibrary__Y[forLoop], 0, 1, 0)
                        call ShowDestructable(fuuulibrary__buttons[forLoop], true)
                        loop
                            if (LoadLightningHandle(Table___ht, (((fuuulibrary__staticTree))), (forLoop + 10000 * linkLoop))) != null then // INLINED!!
                                call DestroyLightning((LoadLightningHandle(Table___ht, (((fuuulibrary__staticTree))), (forLoop + 10000 * linkLoop)))) // INLINED!!
                            else
                                exitwhen true
                            endif
                            set linkLoop=linkLoop + 1
                        endloop
                    else
                        call BJDebugMsg("TALENT TREE ERROR : INVALID INDEX")
                    endif
                    set linkLoop=0
                endif
                
            endloop
            set VJTT_heroIndex=heroIndex
            set VJTT_interactingPlayer=p
            call TriggerEvaluate(VJTT_onHideModule)
        endfunction
        function s__VJassTalentTree_showUI takes player p,integer heroIndex returns nothing
            local integer forLoop= fuuulibrary__WIDTH * 15
            local integer linkLoop= 0
            local integer i
            local integer i2
            local integer i3
            local integer i4= 0
            if fuuulibrary__currentHeroIndex[GetPlayerId(p)] != - 1 then
                call s__VJassTalentTree_hideUI(p) //if its shown when it already shown, it just refreshes it.
            endif
            set fuuulibrary__currentHeroIndex[GetPlayerId(p)]=heroIndex
            call s__VJassTalentTree_cameraPan(p)
            loop
                set forLoop=forLoop - 1
                exitwhen forLoop == - 1
                if (LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (((1 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))))) >= 5 then // INLINED!!
                    loop
                        if (LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (((8 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))))) > 0 then // INLINED!!
                            call s__VJassTalentTree_lightningCreate(p , forLoop , (LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (( 8 + linkLoop * 2 ) + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )))) - 1) // INLINED!!
                            set i2=(LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (( 8 + linkLoop * 2 ) + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )))) - 1 // INLINED!!
                            set i2=(LoadInteger(Table___ht, (((fuuulibrary__tree) + (i2))), (( 22 + GetPlayerId(p) ) + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )))) // INLINED!!
                            set i3=(LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (( 9 + linkLoop * 2 ) + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )))) // INLINED!!
                            if i2 < i3 then
                                set i4=i4 + 1
                            endif
                        else
                            exitwhen true
                        endif
                        set linkLoop=linkLoop + 1
                    endloop
                    if i4 < linkLoop then
                        set i=(LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (1 + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )))) // INLINED!!
                    else
                        set i=(LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (5 + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )))) // INLINED!!
                    endif
                    set i4=0
                    set linkLoop=0
                    if GetLocalPlayer() != p then
                        set i=GetDestructableTypeId(fuuulibrary__buttons[forLoop])
                    endif
                    if i < 5 then
                        set i=fuuulibrary__invisible
                    endif
                    call RemoveDestructable(fuuulibrary__buttons[forLoop])
                    
                    set fuuulibrary__buttons[forLoop]=CreateDestructable(i, fuuulibrary__X[forLoop], fuuulibrary__Y[forLoop], 0, 1, 0)
                    call BJDebugMsg("i : " + I2S(i) + ", forLoop : " + I2S(forLoop) + ", X[] : " + R2S(fuuulibrary__X[forLoop]) + ", Y[] : " + R2S(fuuulibrary__Y[forLoop]) + "\n         NAME: " + GetDestructableName(fuuulibrary__buttons[forLoop]) + ", BO1O : " + I2S('B010'))
                    call ShowDestructable(fuuulibrary__buttons[forLoop], true)
                endif
                
            endloop
            set VJTT_heroIndex=heroIndex
            set VJTT_interactingPlayer=p
            call TriggerEvaluate(VJTT_onShowModule)
        endfunction
        
        ////////////////////////
        // USER SETUP END     //
        ////////////////////////
        
        function s__VJassTalentTree_onTrackableHover takes nothing returns boolean
            local integer i= 0
            local player p= GetLocalPlayer()
            local player p2= (s__Track_tracker) // INLINED!!
            local integer i2
            local string s
            local string s2
            if fuuulibrary__currentHeroIndex[GetPlayerId(p2)] == - 1 then
                return false
            endif
            loop
                if (s__Track_instance) == fuuulibrary__TrackTable[i] then // INLINED!!
                    call RemoveDestructable(fuuulibrary__buttons[fuuulibrary__BUTTON_INDENT + 7])
                    set i2=(LoadInteger(Table___ht, (((fuuulibrary__tree) + (i))), (1 + ( ( fuuulibrary__NUM_OF_DATA + 1 ) * fuuulibrary__currentHeroIndex[GetPlayerId(p2)] )))) // INLINED!!
                    if p != p2 then
                        set i2=GetDestructableTypeId(fuuulibrary__buttons[fuuulibrary__BUTTON_INDENT + 7])
                    endif
                    if i2 <= 5 then
                        set i2=fuuulibrary__invisible
                    endif
                    set fuuulibrary__buttons[fuuulibrary__BUTTON_INDENT + 7]=CreateDestructable(i2, fuuulibrary__X[fuuulibrary__BUTTON_INDENT + 7], fuuulibrary__Y[fuuulibrary__BUTTON_INDENT + 7], 0, 1, 0)
                    set s=(LoadStr(Table___ht, (((((fuuulibrary__tree) + (i))))), (6 + ( ( fuuulibrary__NUM_OF_DATA + 1 ) * fuuulibrary__currentHeroIndex[GetPlayerId(p2)] )))) // INLINED!!
                    set s=fuuulibrary__TITLE_COLOR + s + "|r  " + fuuulibrary__REQUIREMENT_COLOR + "(" + I2S((LoadInteger(Table___ht, (((fuuulibrary__tree) + (i))), (( 22 + GetPlayerId(p2) ) + ( fuuulibrary__currentHeroIndex[GetPlayerId(p2)] * ( fuuulibrary__NUM_OF_DATA + 1 ) ))))) + "/" + I2S((LoadInteger(Table___ht, (((fuuulibrary__tree) + (i))), (2 + ( ( fuuulibrary__NUM_OF_DATA + 1 ) * fuuulibrary__currentHeroIndex[GetPlayerId(p2)] ))))) + ")|r" // INLINED!!
                    if GetLocalPlayer() != p2 then
                        set s=""
                    endif
                    if GetLocalPlayer() == p2 then
                        call DestroyTextTag(fuuulibrary__descTextTag[0])
                        set fuuulibrary__descTextTag[0]=CreateTextTag()
                        call SetTextTagTextBJ(fuuulibrary__descTextTag[0], s, 10)
                        call SetTextTagPos(fuuulibrary__descTextTag[0], GetRectMinX(fuuulibrary__titleRect), GetRectCenterY(fuuulibrary__titleRect), 0)
                        call SetTextTagVisibility(fuuulibrary__descTextTag[0], true)
                    endif
                    set s2=""
                    set s=""
                    set s=(LoadStr(Table___ht, (((((fuuulibrary__tree) + (i))))), (7 + ( ( fuuulibrary__NUM_OF_DATA + 1 ) * fuuulibrary__currentHeroIndex[GetPlayerId(p2)] )))) // INLINED!!
             //       call WordWrapString(s,450,true) 
                    if null == s then
                        set s=""
                    endif
                    if GetLocalPlayer() == p2 then
                        call DestroyTextTag(fuuulibrary__descTextTag[1])
                        set fuuulibrary__descTextTag[1]=CreateTextTag()
                        call SetTextTagTextBJ(fuuulibrary__descTextTag[1], s, 10)
                        call SetTextTagPos(fuuulibrary__descTextTag[1], GetRectMinX(fuuulibrary__descriptionRect), GetRectMinY(fuuulibrary__descriptionRect), 0)
                        call SetTextTagVisibility(fuuulibrary__descTextTag[1], true)
                    endif
                    set VJTT_heroIndex=fuuulibrary__currentHeroIndex[GetPlayerId(p2)]
                    set VJTT_interactingPlayer=p2
                    set VJTT_buttonId=i
                    set VJTT_attachedData=(LoadInteger(Table___ht, (((fuuulibrary__tree) + (i))), (15 + ( ( fuuulibrary__NUM_OF_DATA + 1 ) * fuuulibrary__currentHeroIndex[GetPlayerId(p2)] )))) - 1 // INLINED!!
                    call TriggerEvaluate(VJTT_onHoverModule)
                    exitwhen true
                endif
                set i=i + 1
                exitwhen i == fuuulibrary__NUM_BUTTONS + 1
            endloop
            set p2=null
            set p=null
            return false
        endfunction
        function s__VJassTalentTree_onTrackableClick takes nothing returns boolean
            local integer forLoop= 0
            local player p= GetLocalPlayer()
            local player p2= (s__Track_tracker) // INLINED!!
            local integer heroIndex=  fuuulibrary__currentHeroIndex[GetPlayerId(p2)]
            local integer playerId= GetPlayerId(p2)
            local integer i= 0
            local integer i2= 0
            local integer i3= 0
            local integer i4= 0
            local integer i5= 0
            local integer i6= 0
            local integer linkLoop= 0
            local boolean b= false
            if fuuulibrary__currentHeroIndex[GetPlayerId(p2)] == - 1 then
                return false
            endif
            set VJTT_heroIndex=heroIndex
            set VJTT_interactingPlayer=p2
                            
            set fuuulibrary__currentTalentPoints[playerId]=99
            loop
                if (s__Track_instance) == fuuulibrary__TrackTable[forLoop] then // INLINED!!
                set VJTT_attachedData=(LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (15 + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )))) - 1 // INLINED!!
                    set VJTT_buttonId=forLoop
                    if not TriggerEvaluate(VJTT_externalRequirementModule) then
                        set VJTT_rejected=true
                        call TriggerEvaluate(VJTT_onClickModule)
                        return false
                    endif
                    if (LoadBoolean(Table___ht, (((((fuuulibrary__tree) + (forLoop))))), (33 + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )))) == true then // INLINED!!
                        set VJTT_rejected=false
                        call TriggerEvaluate(VJTT_onClickModule)
                        return false
                    endif
                    if ((LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (2 + ( ( fuuulibrary__NUM_OF_DATA + 1 ) * heroIndex ))))) != (LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (( 22 + playerId ) + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )))) then // INLINED!!
                        loop
                            set i2=(LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (( 8 + i * 2 ) + ( ( fuuulibrary__NUM_OF_DATA + 1 ) * heroIndex )))) - 1 // INLINED!!
                            set i2=(LoadInteger(Table___ht, (((fuuulibrary__tree) + (i2))), (( 22 + GetPlayerId(p2) ) + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )))) // INLINED!!
                            set i3=(LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (( 9 + i * 2 ) + ( ( fuuulibrary__NUM_OF_DATA + 1 ) * heroIndex )))) // INLINED!!
                            set b=i2 < i3
                            if i2 < i3 then
                                set linkLoop=linkLoop + 1
                            endif
                            set i=i + 1
                            exitwhen i >= 3 or (LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (( 8 + i * 2 ) + ( ( fuuulibrary__NUM_OF_DATA + 1 ) * heroIndex )))) - 1 < 0 // INLINED!!
                        endloop
                      //  set i = tree[forLoop][4+ ((NUM_OF_DATA + 1) * heroIndex)]
                      //  if i == null then
                      //      set i = 0
                      //  endi
                        if ((LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (4 + ( ( fuuulibrary__NUM_OF_DATA + 1 ) * heroIndex ))))) > fuuulibrary__currentTalentPoints[playerId] or linkLoop == i then // INLINED!!
                            call TriggerEvaluate(VJTT_onClickModule)
                            exitwhen true
                        else
                            set i=0
                            set fuuulibrary__currentTalentPoints[playerId]=fuuulibrary__currentTalentPoints[playerId] - (LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (4 + ( ( fuuulibrary__NUM_OF_DATA + 1 ) * heroIndex )))) // INLINED!!
                            call SaveInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (( 22 + GetPlayerId(p2) ) + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )), ( (LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (( 22 + GetPlayerId(p2) ) + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )))) + 1)) // INLINED!!
                            loop
                                set i2=(LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (( 16 + i ) + ( ( fuuulibrary__NUM_OF_DATA + 1 ) * heroIndex )))) - 1 // INLINED!!
                                set i3=(LoadInteger(Table___ht, (((fuuulibrary__tree) + (i2))), (( 9 ) + ( ( fuuulibrary__NUM_OF_DATA + 1 ) * heroIndex )))) // INLINED!!
                                set i4=(LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (( 22 + GetPlayerId(p2) ) + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )))) // INLINED!!
                                if i3 == i4 then
                                    set i5=(LoadInteger(Table___ht, (((fuuulibrary__tree) + (i2))), (1 + ( ( fuuulibrary__NUM_OF_DATA + 1 ) * heroIndex )))) // INLINED!!
                                    if GetLocalPlayer() != p2 then
                                        set i5=GetDestructableTypeId(fuuulibrary__buttons[i2])
                                    endif
                                    call RemoveDestructable(fuuulibrary__buttons[i2])
                                    set fuuulibrary__buttons[i2]=CreateDestructable(i5, fuuulibrary__X[i2], fuuulibrary__Y[i2], 0, 1, 0)
                                endif
                                set i=i + 1
                                exitwhen i == 3 or (LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (( 16 + i ) + ( ( fuuulibrary__NUM_OF_DATA + 1 ) * heroIndex )))) - 1 < 0 // INLINED!!
                            endloop
                            set VJTT_rejected=false
                            call TriggerEvaluate(VJTT_onClickModule)
                            exitwhen true
                        endif
                    else
                        set VJTT_rejected=true
                        call TriggerEvaluate(VJTT_onClickModule)
                    endif
                        
                endif
                set forLoop=forLoop + 1
                exitwhen forLoop == fuuulibrary__NUM_BUTTONS + 1
            endloop
            set p=null
            set p2=null
            return false
        endfunction
        function s__VJassTalentTree_DestructableEnum takes nothing returns boolean
            local destructable dest= GetFilterDestructable()
            local real destx= GetDestructableX(dest)
            local real desty= GetDestructableY(dest)
            local real dx= RAbsBJ(GetDestructableX(fuuulibrary__topLeftAnchor) - destx) / fuuulibrary__distanceBetween
            local real dy= RAbsBJ(GetDestructableY(fuuulibrary__topLeftAnchor) - desty) / fuuulibrary__distanceBetween
            local integer x= R2I(dx)
            local integer y= R2I(dy)
            local integer track
            if GetDestructableTypeId(dest) != fuuulibrary__invisible and dest != fuuulibrary__descriptionAnchor then
                set dest=null
                return false
            else
                set fuuulibrary__X[fuuulibrary__getLocation(x , y)]=destx
                set fuuulibrary__Y[fuuulibrary__getLocation(x , y)]=desty
                set fuuulibrary__TrackTable[fuuulibrary__getLocation(x , y)]=(s__Track_createTrack(((fuuulibrary__TRACKABLE_PATH ) ) , (( (( destx )*1.0) )*1.0) , (( (( desty )*1.0) )*1.0) , (( (( 0 )*1.0) )*1.0) , (( (( 0)*1.0))*1.0) , null)) // INLINED!!
                set dest=null
                return false
            endif
        endfunction
//Implemented from module fuuulibrary__initModule:
            function s__VJassTalentTree_fuuulibrary__initModule___onInit takes nothing returns nothing
            local location l
            local location l2
            local integer a
            local integer i= 0
            set fuuulibrary__tree=s__TableArray__staticgetindex(fuuulibrary__NUM_BUTTONS - 1)
            set fuuulibrary__titleRect=gg_rct_TalentTitleRect
            set fuuulibrary__descriptionRect=gg_rct_TalentDescRect
            set fuuulibrary__topLeftAnchor=gg_dest_B010_12893
            set fuuulibrary__invisible=GetDestructableTypeId(fuuulibrary__topLeftAnchor)
            set fuuulibrary__topMidAnchor=gg_dest_B010_12894
            set fuuulibrary__descriptionAnchor=gg_dest_B010_12864
            set fuuulibrary__treeRect=gg_rct_Tree_Area
            set fuuulibrary__menuRect=gg_rct_Menu_Area
            set fuuulibrary__regionLock=Rect(GetRectMaxX(fuuulibrary__treeRect) - 350, ( GetRectMaxY(fuuulibrary__treeRect) + GetRectMinY(fuuulibrary__treeRect) ) / 2, GetRectMaxX(fuuulibrary__treeRect) - 350, ( GetRectMaxY(fuuulibrary__treeRect) + GetRectMinY(fuuulibrary__treeRect) ) / 2)
            
            /// dont touchy ///
            set VJTT_onHoverModule=CreateTrigger()
            set VJTT_onClickModule=CreateTrigger()
            set VJTT_onShowModule=CreateTrigger()
            set VJTT_onHideModule=CreateTrigger()
            set VJTT_externalRequirementModule=CreateTrigger()
            loop
                set fuuulibrary__currentTalentPoints[i]=0
                set fuuulibrary__currentHeroIndex[i]=- 1
                set i=i + 1
                exitwhen i == 13
            endloop
            set fuuulibrary__X[fuuulibrary__BUTTON_INDENT + 7]=GetDestructableX(fuuulibrary__descriptionAnchor)
            set fuuulibrary__Y[fuuulibrary__BUTTON_INDENT + 7]=GetDestructableY(fuuulibrary__descriptionAnchor)
            call RemoveDestructable(fuuulibrary__descriptionAnchor)
            set l=GetDestructableLoc(fuuulibrary__topLeftAnchor)
              set l2=GetDestructableLoc(fuuulibrary__topMidAnchor)
            set fuuulibrary__distanceBetween=RAbsBJ(GetDestructableX(fuuulibrary__topLeftAnchor) - GetDestructableX(fuuulibrary__topMidAnchor))
            set fuuulibrary__staticTree=s__Table_create()
            call RemoveLocation(l)
            call RemoveLocation(l2)
            set l=null
            set l2=null
            call EnumDestructablesInRect(fuuulibrary__treeRect, Filter(function s__VJassTalentTree_DestructableEnum), null)
            call TriggerAddCondition(s__Track_anyHover, Filter(((function s__VJassTalentTree_onTrackableHover)))) // INLINED!!
            call TriggerAddCondition(s__Track_anyClick, Filter(((function s__VJassTalentTree_onTrackableClick)))) // INLINED!!
            call CreateUnit(Player(0), 'hmpr', 0, 0, 0)
        //    call VJassTalentTree.ShowUI(Player(0),0)
       //     call ShowUI(Player(0),0)
            endfunction

//library fuuulibrary ends
//library noleavegotum:
    function Trig_NoLeaveGotum_Actions takes nothing returns nothing
        if GetPlayerId(GetOwningPlayer(GetTriggerUnit())) < 10 and not s__QuestAPI_isInStage(bountyQuest,GetOwningPlayer(GetTriggerUnit()) , 1) then
            call SetUnitX(GetTriggerUnit(), GetRectCenterX(gg_rct_ReturnGotum))
            call SetUnitY(GetTriggerUnit(), GetRectCenterY(gg_rct_ReturnGotum))
            call DisplayTimedTextToPlayer((GetOwningPlayer(GetTriggerUnit()) ), 0, 0, (( 30 )*1.0), ( "|cffffcc00Notice:|r You cannot leave the town untill you proceed through the questline")) // INLINED!!
        endif
    endfunction

    //===========================================================================
    function noleavegotum__init takes nothing returns nothing
        local trigger t= CreateTrigger()
        local region r= CreateRegion()
        call RegionAddRect(r, gg_rct_ExitGotum)
        call TriggerRegisterEnterRegion(t, r, null)
        call TriggerAddAction(t, function Trig_NoLeaveGotum_Actions)
        set r=null
        set t=null
    endfunction

//library noleavegotum ends
//library ApplyChecksum:
    
    function ApplyCRC takes integer number,integer crc returns nothing
        call s__BigInt_add(number,crc)
    endfunction
    function ValidateCRC takes integer number,integer crc returns boolean
        return s__BigInt_size[number] < 10 and s__BigInt_size[number] > 0 and s__BigInt_toInt(number) == crc
    endfunction
    function ApplyChecksum__GetChecksumMax takes integer security returns integer
        return security
    endfunction
    function ApplyChecksum__GetVersionChecksumMax takes integer security,integer maxVersion returns integer
        local integer maximum
        
        set maximum=s__BigInt_copy(security)
        call s__BigInt_add(maximum,maxVersion)
        
        return maximum
    endfunction
    function ApplyChecksum__GetChecksum takes integer number,integer security returns integer
        return GetKnuthChecksum(number , security)
    endfunction
    function ApplyChecksum__GetVersionChecksum takes integer stack,integer security,integer ver returns integer
        local integer checksum
        
        set checksum=(GetKnuthChecksum((stack ) , ( security))) // INLINED!!
        call s__BigInt_add(checksum,ver)
        
        return checksum
    endfunction
    function ApplyChecksum takes integer number,integer security returns nothing
        local integer checksum= (GetKnuthChecksum((number ) , ( security))) // INLINED!!
        call s__BigInt_multiplyBig(number,security)
        call s__BigInt_addBig(number,checksum)
        call s__BigInt_destroy(checksum)
    endfunction
    function ApplyVersionChecksum takes integer number,integer security,integer ver,integer maxVer returns nothing
        local integer maxChecksum= ApplyChecksum__GetVersionChecksumMax(security , maxVer)
        local integer checksum= ApplyChecksum__GetVersionChecksum(number , security , ver)
        call s__BigInt_multiplyBig(number,maxChecksum)
        call s__BigInt_addBig(number,checksum)
        call s__BigInt_destroy(maxChecksum)
        call s__BigInt_destroy(checksum)
    endfunction
    function ValidateChecksum takes integer number,integer security returns boolean
        local integer checksum= s__BigInt_divideBig(number,security)
        local integer actualChecksum= GetKnuthChecksum(number , security)
        local boolean valid= s__BigInt_eq(checksum,actualChecksum)
        
        call s__BigInt_destroy(checksum)
        call s__BigInt_destroy(actualChecksum)
        
        return valid
    endfunction
    function ValidateChecksumVersion takes integer number,integer security,integer maxVer returns integer
        local integer checksum
        local integer actualChecksum
        local integer ver
        
        local integer checksumMax= s__BigInt_copy(security)
        call s__BigInt_add(checksumMax,maxVer)
        
        set checksum=s__BigInt_divideBig(number,checksumMax)
        set actualChecksum=GetKnuthChecksum(number , security)
        call s__BigInt_subtractBig(checksum,actualChecksum)
        set ver=s__BigInt_toInt(checksum)
        
        call s__BigInt_destroy(checksum)
        call s__BigInt_destroy(actualChecksum)
        call s__BigInt_destroy(checksumMax)
        
        if ( 1 > ver or maxVer < ver ) then
            return 0
        endif
        
        return ver
    endfunction

//library ApplyChecksum ends
//library DamageEvent:

//library DamageEvent ends
//library EncryptNumber:
    
    function EncryptNumber__GetPlayerBase takes integer base,integer pid returns integer
        local string b
        local integer i
        if ( not (HaveSavedInteger(Table___ht, (EncryptNumber__bases[pid]), (base))) ) then // INLINED!!
            set b=(Base__b[(base)]) // INLINED!!
            set i=s__BigInt_convertString((Base__b[(base)]) , s__Base__staticgetindex(SubString(b, 1, 2) + SubString(b, 0, 1) + SubString(b, 2, (Base__s[(base)])))) // INLINED!!
            call Scramble(i , pid , 3 , (s__BigInt_bm[(i)]) , true) // INLINED!!
            call SaveInteger(Table___ht, (EncryptNumber__bases[pid]), (base), ( s__Base__staticgetindex(s__BigInt_toString(i)))) // INLINED!!
            call s__BigInt_destroy(i)
        endif
        return (LoadInteger(Table___ht, (EncryptNumber__bases[pid]), (base))) // INLINED!!
    endfunction
    function EncryptNumber takes integer number,integer security,integer forPlayerId returns nothing
        local integer checksum
        
        //apply player unique shuffle
        if ( 0 < security ) then
            call Shuffle(number , forPlayerId , security)
        endif
        
        //get player unique base
        set s__NumberStack_baset[(number)]=(EncryptNumber__GetPlayerBase((s__NumberStack_baset[(number)]) , forPlayerId)) // INLINED!!
    endfunction
    function DecryptNumber takes string saveCode,integer base,integer security,integer forPlayerId returns integer
        //convert to BigInt using player unique base
        local integer number
        set base=EncryptNumber__GetPlayerBase(base , forPlayerId)
        
        if ( not s__Base_isValid(base,saveCode) ) then
            return 0
        endif
        
        set number=s__BigInt_convertString(saveCode , base)
        call s__BigInt__set_base(number,0)
        
        //remove player unique shuffle
        if ( 0 < security ) then
            call Unshuffle(number , forPlayerId , security)
        endif
        
        return number
    endfunction
//Implemented from module EncryptNumber__I:
        function s__EncryptNumber__N_EncryptNumber__I___onInit takes nothing returns nothing
            local integer i=11
            loop
                set EncryptNumber__bases[i]=s__Table_create()
                exitwhen 0 == i
                set i=i - 1
            endloop
        endfunction

//library EncryptNumber ends
//library LevelGroupSlotVersionCatalog:
    
        
        function s__LevelGroupSlotVersionCatalog__GroupFilter_getFilter takes integer this,integer groupId returns integer
            return (LoadInteger(Table___ht, (s__LevelGroupSlotVersionCatalog__GroupFilter_groupFilterTable[this]), (groupId))) // INLINED!!
        endfunction
        
        function s__LevelGroupSlotVersionCatalog__GroupFilter_getGroupId takes integer this,integer groupFilter returns integer
            return (LoadInteger(Table___ht, (s__LevelGroupSlotVersionCatalog__GroupFilter_groupIdTable[this]), (groupFilter))) // INLINED!!
        endfunction
        
        function s__LevelGroupSlotVersionCatalog__GroupFilter_getGroupFilter takes integer this,integer groupId returns integer
            local integer groupFilter= (LoadInteger(Table___ht, (s__LevelGroupSlotVersionCatalog__GroupFilter_groupFilterTable[this]), (groupId))) // INLINED!!
            
            if ( 0 == groupFilter ) then
                set groupFilter=(CatalogCreate()) // INLINED!!
                call SaveInteger(Table___ht, (s__LevelGroupSlotVersionCatalog__GroupFilter_levelFilter), (groupFilter), ( s__LevelFilter_create())) // INLINED!!
                
                call CatalogAdd(((groupFilter)) , (groupFilter)) // INLINED!!
                call SaveInteger(Table___ht, (s__LevelGroupSlotVersionCatalog__GroupFilter_groupFilterTable[this]), (groupId), ( groupFilter)) // INLINED!!
                
                call SaveInteger(Table___ht, (s__LevelGroupSlotVersionCatalog__GroupFilter_groupIdTable[this]), (groupFilter), ( groupId)) // INLINED!!
            endif
            
            return groupFilter
        endfunction
    
        function s__LevelGroupSlotVersionCatalog__GroupFilter_getCatalog takes integer this,integer groupId,integer level returns integer
            return s__LevelFilter_getCatalog(((LoadInteger(Table___ht, (s__LevelGroupSlotVersionCatalog__GroupFilter_levelFilter), (s__LevelGroupSlotVersionCatalog__GroupFilter_getGroupFilter(this,groupId))))),level) // INLINED!!
        endfunction
        
        function s__LevelGroupSlotVersionCatalog__GroupFilter_get takes integer this,integer groupId,integer minLevel,integer maxLevel returns integer
            local integer catalog
            local integer looper
            local integer groupFilter
            local boolean array hit
            
            set catalog=s__TempCatalog_create()
            
            set groupFilter=(LoadInteger(Table___ht, (s__LevelGroupSlotVersionCatalog__GroupFilter_groupFilterTable[(this)]), ((groupId)))) // INLINED!!
            set looper=(CatalogLoopCreate((groupFilter ) , ( 1))) // INLINED!!
            loop
                set groupFilter=(CatalogLoopNext((looper) , 1)) // INLINED!!
                exitwhen 0 == groupFilter
                if ( not hit[groupFilter] ) then
                    set hit[groupFilter]=true
                    call CatalogAddCatalog((catalog) , (s__LevelFilter_get(((LoadInteger(Table___ht, (s__LevelGroupSlotVersionCatalog__GroupFilter_levelFilter), (groupFilter)))),minLevel , maxLevel))) // INLINED!!
                endif
            endloop
            
            return catalog
        endfunction
        
        function s__LevelGroupSlotVersionCatalog__GroupFilter_create takes nothing returns integer
            local integer this
            
            set this=s__LevelGroupSlotVersionCatalog__GroupFilter_instanceCount + 1
            set s__LevelGroupSlotVersionCatalog__GroupFilter_instanceCount=this
            
            set s__LevelGroupSlotVersionCatalog__GroupFilter_groupFilterTable[this]=s__Table_create()
            set s__LevelGroupSlotVersionCatalog__GroupFilter_groupIdTable[this]=s__Table_create()
            
            return this
        endfunction
        
        function s__LevelGroupSlotVersionCatalog__GroupFilter_addGroup takes integer this,integer groupId,integer groupId2 returns nothing
            call CatalogAddCatalog((s__LevelGroupSlotVersionCatalog__GroupFilter_getGroupFilter(this,groupId)) , (s__LevelGroupSlotVersionCatalog__GroupFilter_getGroupFilter(this,groupId2))) // INLINED!!
        endfunction
        
//Implemented from module LevelGroupSlotVersionCatalog__GroupFilterInit:
        function s__LevelGroupSlotVersionCatalog__GroupFilter_LevelGroupSlotVersionCatalog__GroupFilterInit___onInit takes nothing returns nothing
            set s__LevelGroupSlotVersionCatalog__GroupFilter_levelFilter=s__Table_create()
        endfunction
    
        
        
        function s__LevelGroupSlotVersionCatalog__VersionFilter_get takes integer this,integer ver,integer groupId,integer minLevel,integer maxLevel returns integer
            local integer catalog= s__TempCatalog_create()
            call CatalogAddCatalog((catalog) , (s__LevelGroupSlotVersionCatalog__GroupFilter_get(((LoadInteger(Table___ht, (s__LevelGroupSlotVersionCatalog__VersionFilter_groupFilterTable[this]), (ver)))),groupId , minLevel , maxLevel))) // INLINED!!
            return catalog
        endfunction
        
        function s__LevelGroupSlotVersionCatalog__VersionFilter_getGroup takes integer this,integer ver returns integer
            if ( 0 == (LoadInteger(Table___ht, (s__LevelGroupSlotVersionCatalog__VersionFilter_groupFilterTable[this]), (ver))) ) then // INLINED!!
                call SaveInteger(Table___ht, (s__LevelGroupSlotVersionCatalog__VersionFilter_groupFilterTable[this]), (ver), ( s__LevelGroupSlotVersionCatalog__GroupFilter_create())) // INLINED!!
            endif
            
            return (LoadInteger(Table___ht, (s__LevelGroupSlotVersionCatalog__VersionFilter_groupFilterTable[this]), (ver))) // INLINED!!
        endfunction
        
        function s__LevelGroupSlotVersionCatalog__VersionFilter_getCatalog takes integer this,integer ver,integer groupId,integer level returns integer
            return s__LevelGroupSlotVersionCatalog__GroupFilter_getCatalog(s__LevelGroupSlotVersionCatalog__VersionFilter_getGroup(this,ver),groupId , level)
        endfunction
        
        function s__LevelGroupSlotVersionCatalog__VersionFilter_create takes nothing returns integer
            local integer this= s__LevelGroupSlotVersionCatalog__VersionFilter_instanceCount + 1
            set s__LevelGroupSlotVersionCatalog__VersionFilter_instanceCount=this
            
            set s__LevelGroupSlotVersionCatalog__VersionFilter_groupFilterTable[this]=s__Table_create()
            
            return this
        endfunction
    
        function s__LevelGroupSlotVersionCatalog__SlotFilter__getindex takes integer this,integer slot returns integer
            if ( 0 == s__LevelGroupSlotVersionCatalog__SlotFilter_slotId[this] ) then
                set s__LevelGroupSlotVersionCatalog__SlotFilter_slotId[this]=s__Table_create()
            endif
            if ( not (HaveSavedInteger(Table___ht, (s__LevelGroupSlotVersionCatalog__SlotFilter_slotId[this]), (slot))) ) then // INLINED!!
                set s__LevelGroupSlotVersionCatalog__SlotFilter_slotCount=s__LevelGroupSlotVersionCatalog__SlotFilter_slotCount + 1
                call SaveInteger(Table___ht, (s__LevelGroupSlotVersionCatalog__SlotFilter_slotId[this]), (slot), ( s__LevelGroupSlotVersionCatalog__SlotFilter_slotCount)) // INLINED!!
            endif
            return (LoadInteger(Table___ht, (s__LevelGroupSlotVersionCatalog__SlotFilter_slotId[this]), (slot))) // INLINED!!
        endfunction
    
    
        
        function s__LevelGroupSlotVersionCatalog__GroupHashFilter__getindex takes integer this,integer i returns integer
            if ( not (HaveSavedInteger(Table___ht, (s__LevelGroupSlotVersionCatalog__GroupHashFilter_groupHash[this]), (i))) ) then // INLINED!!
                set s__LevelGroupSlotVersionCatalog__GroupHashFilter_groupHashCount=s__LevelGroupSlotVersionCatalog__GroupHashFilter_groupHashCount + 1
                call SaveInteger(Table___ht, (s__LevelGroupSlotVersionCatalog__GroupHashFilter_groupHash[this]), (i), ( s__LevelGroupSlotVersionCatalog__GroupHashFilter_groupHashCount)) // INLINED!!
            endif
            return (LoadInteger(Table___ht, (s__LevelGroupSlotVersionCatalog__GroupHashFilter_groupHash[this]), (i))) // INLINED!!
        endfunction
        
        function s__LevelGroupSlotVersionCatalog__GroupHashFilter_create takes nothing returns integer
            local integer this= s__LevelGroupSlotVersionCatalog__GroupHashFilter_instanceCount + 1
            set s__LevelGroupSlotVersionCatalog__GroupHashFilter_instanceCount=this
            
            set s__LevelGroupSlotVersionCatalog__GroupHashFilter_groupHash[this]=s__Table_create()
            
            return this
        endfunction
    
    
        
        
        
        
        function s__LevelGroupSlotVersionCatalog_update takes nothing returns boolean
            local integer this= s__LevelGroupSlotVersionCatalog_toUpdate
            local integer xver= s__LevelGroupSlotVersionCatalog_ver[this] - 1
            local integer c= s__LevelGroupSlotVersionCatalog_groupCount[this]
            local integer looper
            local integer groupId
            local integer catalog
            local integer catalogNew
            loop
                exitwhen 0 == c
                set c=c - 1
                
                call CatalogAddCatalog((s__LevelGroupSlotVersionCatalog__GroupFilter_getGroupFilter(s__LevelGroupSlotVersionCatalog__VersionFilter_getGroup(s__LevelGroupSlotVersionCatalog_versionFilter[this],s__LevelGroupSlotVersionCatalog_ver[this]),(LoadInteger(Table___ht, (s__LevelGroupSlotVersionCatalog_groups[this]), (c))))) , (s__LevelGroupSlotVersionCatalog__GroupFilter_getGroupFilter(s__LevelGroupSlotVersionCatalog__VersionFilter_getGroup(s__LevelGroupSlotVersionCatalog_versionFilter[this],xver),(LoadInteger(Table___ht, (s__LevelGroupSlotVersionCatalog_groups[this]), (c)))))) // INLINED!!
                
                set looper=(CatalogLoopCreate(((LoadInteger(Table___ht, (s__LevelGroupSlotVersionCatalog_groupAddTable[this]), ((LoadInteger(Table___ht, (s__LevelGroupSlotVersionCatalog_groups[this]), (c)))))) ) , ( 1))) // INLINED!!
                loop
                    set groupId=(CatalogLoopNext((looper) , 1)) // INLINED!!
                    exitwhen 0 == groupId
                    call s__LevelGroupSlotVersionCatalog__GroupFilter_addGroup(s__LevelGroupSlotVersionCatalog__VersionFilter_getGroup(s__LevelGroupSlotVersionCatalog_versionFilter[this],s__LevelGroupSlotVersionCatalog_ver[this]),(LoadInteger(Table___ht, (s__LevelGroupSlotVersionCatalog_groups[this]), (c))) , groupId) // INLINED!!
                endloop
            endloop
            return false
        endfunction
        
        function s__LevelGroupSlotVersionCatalog_addGroup takes integer this,integer ver,integer groupId,integer groupId2,integer slot returns nothing
            set groupId=s__LevelGroupSlotVersionCatalog__SlotFilter__getindex(s__LevelGroupSlotVersionCatalog__GroupHashFilter__getindex(s__LevelGroupSlotVersionCatalog_slotFilter[this],groupId),slot)
            set groupId2=s__LevelGroupSlotVersionCatalog__SlotFilter__getindex(s__LevelGroupSlotVersionCatalog__GroupHashFilter__getindex(s__LevelGroupSlotVersionCatalog_slotFilter[this],groupId2),slot)
            
            call s__LevelGroupSlotVersionCatalog__GroupFilter_addGroup(s__LevelGroupSlotVersionCatalog__VersionFilter_getGroup(s__LevelGroupSlotVersionCatalog_versionFilter[this],ver),groupId , groupId2)
            if ( s__LevelGroupSlotVersionCatalog_ver[this] < ver ) then
                set s__LevelGroupSlotVersionCatalog_ver[this]=ver
                if ( 1 < ver ) then
                    set s__LevelGroupSlotVersionCatalog_toUpdate=this
                    call TriggerEvaluate(s__LevelGroupSlotVersionCatalog_eUpdate)
                endif
            endif
            if ( not (HaveSavedBoolean(Table___ht, (((s__LevelGroupSlotVersionCatalog_groupTable[this]))), (groupId))) ) then // INLINED!!
                call SaveInteger(Table___ht, (s__LevelGroupSlotVersionCatalog_groupAddTable[this]), (groupId), ( (CatalogCreate()))) // INLINED!!
                call SaveBoolean(Table___ht, (((s__LevelGroupSlotVersionCatalog_groupTable[this]))), (groupId), ( true)) // INLINED!!
                call SaveInteger(Table___ht, (s__LevelGroupSlotVersionCatalog_groups[this]), (s__LevelGroupSlotVersionCatalog_groupCount[this]), ( groupId)) // INLINED!!
                set s__LevelGroupSlotVersionCatalog_groupCount[this]=s__LevelGroupSlotVersionCatalog_groupCount[this] + 1
            endif
            if ( not (HaveSavedBoolean(Table___ht, (((s__LevelGroupSlotVersionCatalog_groupTable[this]))), (groupId2))) ) then // INLINED!!
                call SaveInteger(Table___ht, (s__LevelGroupSlotVersionCatalog_groupAddTable[this]), (groupId2), ( (CatalogCreate()))) // INLINED!!
                call SaveBoolean(Table___ht, (((s__LevelGroupSlotVersionCatalog_groupTable[this]))), (groupId2), ( true)) // INLINED!!
                call SaveInteger(Table___ht, (s__LevelGroupSlotVersionCatalog_groups[this]), (s__LevelGroupSlotVersionCatalog_groupCount[this]), ( groupId2)) // INLINED!!
                set s__LevelGroupSlotVersionCatalog_groupCount[this]=s__LevelGroupSlotVersionCatalog_groupCount[this] + 1
            endif
            call CatalogAdd((LoadInteger(Table___ht, (s__LevelGroupSlotVersionCatalog_groupAddTable[this]), (groupId))) , groupId2) // INLINED!!
        endfunction
        
        function s__LevelGroupSlotVersionCatalog_get takes integer this,integer ver,integer groupId,integer slot,integer minLevel,integer maxLevel returns integer
            return s__LevelGroupSlotVersionCatalog__VersionFilter_get(s__LevelGroupSlotVersionCatalog_versionFilter[this],ver , s__LevelGroupSlotVersionCatalog__SlotFilter__getindex(s__LevelGroupSlotVersionCatalog__GroupHashFilter__getindex(s__LevelGroupSlotVersionCatalog_slotFilter[this],groupId),slot) , minLevel , maxLevel)
        endfunction
    
        function s__LevelGroupSlotVersionCatalog_add takes integer this,integer rawId,integer ver,integer groupId,integer slot,integer level returns nothing
            local integer catalog
            
            set groupId=s__LevelGroupSlotVersionCatalog__SlotFilter__getindex(s__LevelGroupSlotVersionCatalog__GroupHashFilter__getindex(s__LevelGroupSlotVersionCatalog_slotFilter[this],groupId),slot)
            
            set catalog=s__LevelGroupSlotVersionCatalog__VersionFilter_getCatalog(s__LevelGroupSlotVersionCatalog_versionFilter[this],ver , groupId , level)
            
            if ( s__LevelGroupSlotVersionCatalog_ver[this] < ver ) then
                set s__LevelGroupSlotVersionCatalog_ver[this]=ver
                if ( 1 < ver ) then
                    set s__LevelGroupSlotVersionCatalog_toUpdate=this
                    call TriggerEvaluate(s__LevelGroupSlotVersionCatalog_eUpdate)
                endif
            endif
            if ( not (HaveSavedBoolean(Table___ht, (((s__LevelGroupSlotVersionCatalog_groupTable[this]))), (groupId))) ) then // INLINED!!
                call SaveInteger(Table___ht, (s__LevelGroupSlotVersionCatalog_groupAddTable[this]), (groupId), ( (CatalogCreate()))) // INLINED!!
                call SaveBoolean(Table___ht, (((s__LevelGroupSlotVersionCatalog_groupTable[this]))), (groupId), ( true)) // INLINED!!
                call SaveInteger(Table___ht, (s__LevelGroupSlotVersionCatalog_groups[this]), (s__LevelGroupSlotVersionCatalog_groupCount[this]), ( groupId)) // INLINED!!
                set s__LevelGroupSlotVersionCatalog_groupCount[this]=s__LevelGroupSlotVersionCatalog_groupCount[this] + 1
            endif
            
            call CatalogAdd((catalog) , (rawId)) // INLINED!!
        endfunction
        
        function s__LevelGroupSlotVersionCatalog_create takes nothing returns integer
            local integer this= s__LevelGroupSlotVersionCatalog_instanceCount + 1
            set s__LevelGroupSlotVersionCatalog_instanceCount=this
            
            set s__LevelGroupSlotVersionCatalog_slotFilter[this]=s__LevelGroupSlotVersionCatalog__GroupHashFilter_create()
            set s__LevelGroupSlotVersionCatalog_versionFilter[this]=s__LevelGroupSlotVersionCatalog__VersionFilter_create()
            set s__LevelGroupSlotVersionCatalog_groupTable[this]=s__Table_create()
            set s__LevelGroupSlotVersionCatalog_groups[this]=s__Table_create()
            set s__LevelGroupSlotVersionCatalog_groupAddTable[this]=s__Table_create()
            
            return this
        endfunction
    
//Implemented from module LevelGroupSlotVersionCatalog__LevelGroupSlotVersionCatalogInit:
        function s__LevelGroupSlotVersionCatalog_LevelGroupSlotVersionCatalog__LevelGroupSlotVersionCatalogInit___onInit takes nothing returns nothing
            set s__LevelGroupSlotVersionCatalog_eUpdate=CreateTrigger()
            call TriggerAddCondition(s__LevelGroupSlotVersionCatalog_eUpdate, Condition(function s__LevelGroupSlotVersionCatalog_update))
        endfunction

//library LevelGroupSlotVersionCatalog ends
//library LevelGroupVersionCatalog:
    
        
        function s__LevelGroupVersionCatalog__GroupFilter_getFilter takes integer this,integer groupId returns integer
            return (LoadInteger(Table___ht, (s__LevelGroupVersionCatalog__GroupFilter_groupFilterTable[this]), (groupId))) // INLINED!!
        endfunction
        
        function s__LevelGroupVersionCatalog__GroupFilter_getGroupId takes integer this,integer groupFilter returns integer
            return (LoadInteger(Table___ht, (s__LevelGroupVersionCatalog__GroupFilter_groupIdTable[this]), (groupFilter))) // INLINED!!
        endfunction
        
        function s__LevelGroupVersionCatalog__GroupFilter_getGroupFilter takes integer this,integer groupId returns integer
            local integer groupFilter= (LoadInteger(Table___ht, (s__LevelGroupVersionCatalog__GroupFilter_groupFilterTable[this]), (groupId))) // INLINED!!
            
            if ( 0 == groupFilter ) then
                set groupFilter=(CatalogCreate()) // INLINED!!
                call SaveInteger(Table___ht, (s__LevelGroupVersionCatalog__GroupFilter_levelFilter), (groupFilter), ( s__LevelFilter_create())) // INLINED!!
                
                call CatalogAdd(((groupFilter)) , (groupFilter)) // INLINED!!
                call SaveInteger(Table___ht, (s__LevelGroupVersionCatalog__GroupFilter_groupFilterTable[this]), (groupId), ( groupFilter)) // INLINED!!
                
                call SaveInteger(Table___ht, (s__LevelGroupVersionCatalog__GroupFilter_groupIdTable[this]), (groupFilter), ( groupId)) // INLINED!!
            endif
            
            return groupFilter
        endfunction
    
        function s__LevelGroupVersionCatalog__GroupFilter_getCatalog takes integer this,integer groupId,integer level returns integer
            return s__LevelFilter_getCatalog(((LoadInteger(Table___ht, (s__LevelGroupVersionCatalog__GroupFilter_levelFilter), (s__LevelGroupVersionCatalog__GroupFilter_getGroupFilter(this,groupId))))),level) // INLINED!!
        endfunction
        
        function s__LevelGroupVersionCatalog__GroupFilter_get takes integer this,integer groupId,integer minLevel,integer maxLevel returns integer
            local integer catalog
            local integer looper
            local integer groupFilter
            local boolean array hit
            
            set catalog=s__TempCatalog_create()
            
            set groupFilter=(LoadInteger(Table___ht, (s__LevelGroupVersionCatalog__GroupFilter_groupFilterTable[(this)]), ((groupId)))) // INLINED!!
            set looper=(CatalogLoopCreate((groupFilter ) , ( 1))) // INLINED!!
            loop
                set groupFilter=(CatalogLoopNext((looper) , 1)) // INLINED!!
                exitwhen 0 == groupFilter
                if ( not hit[groupFilter] ) then
                    set hit[groupFilter]=true
                    call CatalogAddCatalog((catalog) , (s__LevelFilter_get(((LoadInteger(Table___ht, (s__LevelGroupVersionCatalog__GroupFilter_levelFilter), (groupFilter)))),minLevel , maxLevel))) // INLINED!!
                endif
            endloop
            
            return catalog
        endfunction
        
        function s__LevelGroupVersionCatalog__GroupFilter_create takes nothing returns integer
            local integer this
            
            set this=s__LevelGroupVersionCatalog__GroupFilter_instanceCount + 1
            set s__LevelGroupVersionCatalog__GroupFilter_instanceCount=this
            
            set s__LevelGroupVersionCatalog__GroupFilter_groupFilterTable[this]=s__Table_create()
            set s__LevelGroupVersionCatalog__GroupFilter_groupIdTable[this]=s__Table_create()
            
            return this
        endfunction
        
        function s__LevelGroupVersionCatalog__GroupFilter_addGroup takes integer this,integer groupId,integer groupId2 returns nothing
            call CatalogAddCatalog((s__LevelGroupVersionCatalog__GroupFilter_getGroupFilter(this,groupId)) , (s__LevelGroupVersionCatalog__GroupFilter_getGroupFilter(this,groupId2))) // INLINED!!
        endfunction
        
//Implemented from module LevelGroupVersionCatalog__GroupFilterInit:
        function s__LevelGroupVersionCatalog__GroupFilter_LevelGroupVersionCatalog__GroupFilterInit___onInit takes nothing returns nothing
            set s__LevelGroupVersionCatalog__GroupFilter_levelFilter=s__Table_create()
        endfunction
    
        
        
        function s__LevelGroupVersionCatalog__VersionFilter_get takes integer this,integer ver,integer groupId,integer minLevel,integer maxLevel returns integer
            local integer catalog= s__TempCatalog_create()
            call CatalogAddCatalog((catalog) , (s__LevelGroupVersionCatalog__GroupFilter_get(((LoadInteger(Table___ht, (s__LevelGroupVersionCatalog__VersionFilter_groupFilterTable[this]), (ver)))),groupId , minLevel , maxLevel))) // INLINED!!
            return catalog
        endfunction
        
        function s__LevelGroupVersionCatalog__VersionFilter_getGroup takes integer this,integer ver returns integer
            if ( 0 == (LoadInteger(Table___ht, (s__LevelGroupVersionCatalog__VersionFilter_groupFilterTable[this]), (ver))) ) then // INLINED!!
                call SaveInteger(Table___ht, (s__LevelGroupVersionCatalog__VersionFilter_groupFilterTable[this]), (ver), ( s__LevelGroupVersionCatalog__GroupFilter_create())) // INLINED!!
            endif
            
            return (LoadInteger(Table___ht, (s__LevelGroupVersionCatalog__VersionFilter_groupFilterTable[this]), (ver))) // INLINED!!
        endfunction
        
        function s__LevelGroupVersionCatalog__VersionFilter_getCatalog takes integer this,integer ver,integer groupId,integer level returns integer
            return s__LevelGroupVersionCatalog__GroupFilter_getCatalog(s__LevelGroupVersionCatalog__VersionFilter_getGroup(this,ver),groupId , level)
        endfunction
        
        function s__LevelGroupVersionCatalog__VersionFilter_create takes nothing returns integer
            local integer this= s__LevelGroupVersionCatalog__VersionFilter_instanceCount + 1
            set s__LevelGroupVersionCatalog__VersionFilter_instanceCount=this
            
            set s__LevelGroupVersionCatalog__VersionFilter_groupFilterTable[this]=s__Table_create()
            
            return this
        endfunction
    
    
        
        
        
        
        function s__LevelGroupVersionCatalog_update takes nothing returns boolean
            local integer this= s__LevelGroupVersionCatalog_toUpdate
            local integer xver= s__LevelGroupVersionCatalog_ver[this] - 1
            local integer c= s__LevelGroupVersionCatalog_groupCount[this]
            local integer looper
            local integer groupId
            local integer catalog
            local integer catalogNew
            loop
                exitwhen 0 == c
                set c=c - 1
                
                call CatalogAddCatalog((s__LevelGroupVersionCatalog__GroupFilter_getGroupFilter(s__LevelGroupVersionCatalog__VersionFilter_getGroup(s__LevelGroupVersionCatalog_versionFilter[this],s__LevelGroupVersionCatalog_ver[this]),(LoadInteger(Table___ht, (s__LevelGroupVersionCatalog_groups[this]), (c))))) , (s__LevelGroupVersionCatalog__GroupFilter_getGroupFilter(s__LevelGroupVersionCatalog__VersionFilter_getGroup(s__LevelGroupVersionCatalog_versionFilter[this],xver),(LoadInteger(Table___ht, (s__LevelGroupVersionCatalog_groups[this]), (c)))))) // INLINED!!
                
                set looper=(CatalogLoopCreate(((LoadInteger(Table___ht, (s__LevelGroupVersionCatalog_groupAddTable[this]), ((LoadInteger(Table___ht, (s__LevelGroupVersionCatalog_groups[this]), (c)))))) ) , ( 1))) // INLINED!!
                loop
                    set groupId=(CatalogLoopNext((looper) , 1)) // INLINED!!
                    exitwhen 0 == groupId
                    call s__LevelGroupVersionCatalog__GroupFilter_addGroup(s__LevelGroupVersionCatalog__VersionFilter_getGroup(s__LevelGroupVersionCatalog_versionFilter[this],s__LevelGroupVersionCatalog_ver[this]),(LoadInteger(Table___ht, (s__LevelGroupVersionCatalog_groups[this]), (c))) , groupId) // INLINED!!
                endloop
            endloop
            return false
        endfunction
        
        function s__LevelGroupVersionCatalog_addGroup takes integer this,integer ver,integer groupId,integer groupId2 returns nothing
            call s__LevelGroupVersionCatalog__GroupFilter_addGroup(s__LevelGroupVersionCatalog__VersionFilter_getGroup(s__LevelGroupVersionCatalog_versionFilter[this],ver),groupId , groupId2)
            if ( s__LevelGroupVersionCatalog_ver[this] < ver ) then
                set s__LevelGroupVersionCatalog_ver[this]=ver
                if ( 1 < ver ) then
                    set s__LevelGroupVersionCatalog_toUpdate=this
                    call TriggerEvaluate(s__LevelGroupVersionCatalog_eUpdate)
                endif
            endif
            if ( not (HaveSavedBoolean(Table___ht, (((s__LevelGroupVersionCatalog_groupTable[this]))), (groupId))) ) then // INLINED!!
                call SaveInteger(Table___ht, (s__LevelGroupVersionCatalog_groupAddTable[this]), (groupId), ( (CatalogCreate()))) // INLINED!!
                call SaveBoolean(Table___ht, (((s__LevelGroupVersionCatalog_groupTable[this]))), (groupId), ( true)) // INLINED!!
                call SaveInteger(Table___ht, (s__LevelGroupVersionCatalog_groups[this]), (s__LevelGroupVersionCatalog_groupCount[this]), ( groupId)) // INLINED!!
                set s__LevelGroupVersionCatalog_groupCount[this]=s__LevelGroupVersionCatalog_groupCount[this] + 1
            endif
            if ( not (HaveSavedBoolean(Table___ht, (((s__LevelGroupVersionCatalog_groupTable[this]))), (groupId2))) ) then // INLINED!!
                call SaveInteger(Table___ht, (s__LevelGroupVersionCatalog_groupAddTable[this]), (groupId2), ( (CatalogCreate()))) // INLINED!!
                call SaveBoolean(Table___ht, (((s__LevelGroupVersionCatalog_groupTable[this]))), (groupId2), ( true)) // INLINED!!
                call SaveInteger(Table___ht, (s__LevelGroupVersionCatalog_groups[this]), (s__LevelGroupVersionCatalog_groupCount[this]), ( groupId2)) // INLINED!!
                set s__LevelGroupVersionCatalog_groupCount[this]=s__LevelGroupVersionCatalog_groupCount[this] + 1
            endif
            call CatalogAdd((LoadInteger(Table___ht, (s__LevelGroupVersionCatalog_groupAddTable[this]), (groupId))) , groupId2) // INLINED!!
        endfunction
        
        function s__LevelGroupVersionCatalog_get takes integer this,integer ver,integer groupId,integer minLevel,integer maxLevel returns integer
            return s__LevelGroupVersionCatalog__VersionFilter_get(s__LevelGroupVersionCatalog_versionFilter[this],ver , groupId , minLevel , maxLevel)
        endfunction
    
        function s__LevelGroupVersionCatalog_add takes integer this,integer rawId,integer ver,integer groupId,integer level returns nothing
            local integer catalog
            
            set catalog=s__LevelGroupVersionCatalog__VersionFilter_getCatalog(s__LevelGroupVersionCatalog_versionFilter[this],ver , groupId , level)
            
            if ( s__LevelGroupVersionCatalog_ver[this] < ver ) then
                set s__LevelGroupVersionCatalog_ver[this]=ver
                if ( 1 < ver ) then
                    set s__LevelGroupVersionCatalog_toUpdate=this
                    call TriggerEvaluate(s__LevelGroupVersionCatalog_eUpdate)
                endif
            endif
            if ( not (HaveSavedBoolean(Table___ht, (((s__LevelGroupVersionCatalog_groupTable[this]))), (groupId))) ) then // INLINED!!
                call SaveInteger(Table___ht, (s__LevelGroupVersionCatalog_groupAddTable[this]), (groupId), ( (CatalogCreate()))) // INLINED!!
                call SaveBoolean(Table___ht, (((s__LevelGroupVersionCatalog_groupTable[this]))), (groupId), ( true)) // INLINED!!
                call SaveInteger(Table___ht, (s__LevelGroupVersionCatalog_groups[this]), (s__LevelGroupVersionCatalog_groupCount[this]), ( groupId)) // INLINED!!
                set s__LevelGroupVersionCatalog_groupCount[this]=s__LevelGroupVersionCatalog_groupCount[this] + 1
            endif
            
            call CatalogAdd((catalog) , (rawId)) // INLINED!!
        endfunction
        
        function s__LevelGroupVersionCatalog_create takes nothing returns integer
            local integer this= s__LevelGroupVersionCatalog_instanceCount + 1
            set s__LevelGroupVersionCatalog_instanceCount=this
            
            set s__LevelGroupVersionCatalog_versionFilter[this]=s__LevelGroupVersionCatalog__VersionFilter_create()
            set s__LevelGroupVersionCatalog_groupTable[this]=s__Table_create()
            set s__LevelGroupVersionCatalog_groups[this]=s__Table_create()
            set s__LevelGroupVersionCatalog_groupAddTable[this]=s__Table_create()
            
            return this
        endfunction
    
//Implemented from module LevelGroupVersionCatalog__LevelGroupVersionCatalogInit:
        function s__LevelGroupVersionCatalog_LevelGroupVersionCatalog__LevelGroupVersionCatalogInit___onInit takes nothing returns nothing
            set s__LevelGroupVersionCatalog_eUpdate=CreateTrigger()
            call TriggerAddCondition(s__LevelGroupVersionCatalog_eUpdate, Condition(function s__LevelGroupVersionCatalog_update))
        endfunction

//library LevelGroupVersionCatalog ends
//library ShowInventory:
    function ShowInventory__onChat takes nothing returns boolean
        if GetItemTypeId(GetManipulatedItem()) != 'I00I' then
            return false
        endif
        if ShowInventory__isInInventory[GetPlayerId(GetTriggerPlayer())] then
            return false
        endif
        set ShowInventory__isInInventory[GetPlayerId(GetTriggerPlayer())]=true
        if GetLocalPlayer() == GetTriggerPlayer() then
            set ShowInventory__currentX=GetCameraTargetPositionX()
            set ShowInventory__currentY=GetCameraTargetPositionY()
            set ShowInventory__currentAA=GetCameraField(CAMERA_FIELD_ANGLE_OF_ATTACK) * bj_RADTODEG
            set ShowInventory__currentD=GetCameraField(CAMERA_FIELD_TARGET_DISTANCE)
            call SetCameraField(CAMERA_FIELD_ANGLE_OF_ATTACK, 270.00, 0) // dont touch
            call SetCameraField(CAMERA_FIELD_TARGET_DISTANCE, 2050, 0) //change this depending on the size of your talent tree
        
            call PanCameraToTimed(GetRectMaxX((ItemInventory__inRect)) - 340, GetRectMaxY((ItemInventory__inRect)), 0) //this is the actual camera pan // INLINED!!
            
            call SetCameraBoundsToRect(ShowInventory__lock)
          //      call SetCameraBoundsToRect(regionLock)
        endif
        return false
    endfunction
    function ShowInventory__onExit takes nothing returns boolean
        if ShowInventory__isInInventory[GetPlayerId(GetTriggerPlayer())] and GetLocalPlayer() == GetTriggerPlayer() then
            call SetCameraBoundsToRect(bj_mapInitialPlayableArea)
            call SetCameraPosition(ShowInventory__currentX, ShowInventory__currentY)
            call SetCameraField(CAMERA_FIELD_ANGLE_OF_ATTACK, ShowInventory__currentAA, 0)
            call SetCameraField(CAMERA_FIELD_TARGET_DISTANCE, ShowInventory__currentD, 0)
            set ShowInventory__isInInventory[GetPlayerId(GetTriggerPlayer())]=false
        endif
        return false
    endfunction
    function ShowInventory__fuc takes nothing returns nothing
        call s__CustomInventory_rects()
        call s__CustomInventory_Initalize()
    endfunction
    function ShowInventory__onInittT takes nothing returns nothing
        local trigger t= CreateTrigger()
        local trigger t2= CreateTrigger()
        local integer i= 0
        call ShowInventory__fuc()
        set ShowInventory__lock=Rect(GetRectMaxX((ItemInventory__inRect)) - 340, GetRectMaxY((ItemInventory__inRect)), GetRectMaxX((ItemInventory__inRect)) - 340, GetRectMaxY((ItemInventory__inRect))) // INLINED!!
        
            call TriggerRegisterAnyUnitEventBJ(t, EVENT_PLAYER_UNIT_USE_ITEM)
            
        loop
            call TriggerRegisterPlayerEventEndCinematic(t2, Player(i))
            set ShowInventory__isInInventory[i]=false
            set i=i + 1
            exitwhen i == 12
        endloop
        call TriggerAddCondition(t, Filter(function ShowInventory__onChat))
        call TriggerAddCondition(t2, Filter(function ShowInventory__onExit))
        set i=0
        set t2=null
        set t=null
    endfunction

//library ShowInventory ends
//library SpellChargedBolt:
            
//Implemented from module MissileStruct:
        
        function s__SpellChargedBolt__CB_MissileStruct___missileTerminate takes integer this returns nothing
            if s__Missile_terminated[this] then
                return
            endif
            set s__Missile_terminated[this]=true



            call s__Missile_terminate(this)
            call Missile___StopPeriodic(si__SpellChargedBolt__CB)
        endfunction
        
        function s__SpellChargedBolt__CB_unpin takes integer this returns nothing
            call s__Missile_removeNode(this)
            call Missile___StopPeriodic(si__SpellChargedBolt__CB)
        endfunction




















        //***********************************************************************
        //  First it takes the struct's first instance, which is the next to the
        //  head (NODE[thistype.typeid].next) and starts iterating through it until it hits
        //  the head again. Then checks if the missile is marked for recycling,
        //  if so it runs the methods and destroys the missile.
        function s__SpellChargedBolt__CB_MissileStruct___missileIterate takes nothing returns nothing
            local unit u
            local boolean finished= false
            local integer this= s__Missile_next[Missile___NODE[si__SpellChargedBolt__CB]]
            call s__Missile_move(this)
            loop
                exitwhen s__Missile_head[this]
                
                if s__Missile_wantDestroy[this] then



                    call s__SpellChargedBolt__CB_MissileStruct___missileTerminate(this)
                    
                else
                    if s__Missile_recycle[this] then






























                                call s__SpellChargedBolt__CB_MissileStruct___missileTerminate(this)


                    else















                    endif
                endif
                



                





                
                set this=s__Missile_next[this]
            endloop
            
            set u=null
        endfunction
        
        function s__SpellChargedBolt__CB_launch takes integer this returns nothing
            call Missile___StartPeriodic(si__SpellChargedBolt__CB)
            call s__Missile_insertNode(Missile___NODE[si__SpellChargedBolt__CB],this)
        endfunction
        
        function s__SpellChargedBolt__CB_MissileStruct___onInit takes nothing returns nothing
            set Missile___NODE[si__SpellChargedBolt__CB]=s__Missile_createNode()
            set Missile___TIMER[si__SpellChargedBolt__CB]=(CTL___A((function s__SpellChargedBolt__CB_MissileStruct___missileIterate))) // INLINED!!
        endfunction
        
        
        function s__SpellChargedBolt__CB_onExpire takes nothing returns nothing
            local real x= GetUnitX(s__SpellChargedBolt__CB_FOOTMAN)
            local real y= GetUnitY(s__SpellChargedBolt__CB_FOOTMAN)
            local real a= GetRandomReal(- bj_PI, bj_PI)
            local integer new= s__Missile_create(x , y , 65 , x + 1000 * Cos(a) , y + 1000 * Sin(a) , 0)
            set s__Missile_speed[new]=10
            call s__Missile__set_model(new,"abilities\\weapons\\WyvernSpear\\WyvernSpearMissile.mdl")
            set s__Missile_height[new]=100
            set s__Missile_source[new]=s__SpellChargedBolt__CB_FOOTMAN
            set s__Missile_collision[new]=80
            call s__SpellChargedBolt__CB_launch(new)
        endfunction
        
        function s__SpellChargedBolt__CB_onEsc takes nothing returns nothing
            if s__SpellChargedBolt__CB_b then
                call PauseTimer(s__SpellChargedBolt__CB_t)
            else
                call TimerStart(s__SpellChargedBolt__CB_t, 0.005, false, function s__SpellChargedBolt__CB_onExpire)
            endif
            set s__SpellChargedBolt__CB_b=not s__SpellChargedBolt__CB_b
        endfunction
        
        function s__SpellChargedBolt__CB_onInit takes nothing returns nothing
            local trigger trig=CreateTrigger()
            call TriggerRegisterPlayerEvent(trig, Player(0), EVENT_PLAYER_END_CINEMATIC)
            call TriggerAddAction(trig, function s__SpellChargedBolt__CB_onEsc)
            set s__SpellChargedBolt__CB_FOOTMAN=CreateUnit(Player(0), 'hfoo', 0, 0, 270)
        endfunction

//library SpellChargedBolt ends
//library WitchFirstSpells:
        function s__WitchFirstSpells__MissileHandler_onCollide takes integer this,unit justHit returns boolean
            if isViableTarget(s__Missile_source[this] , justHit) then
                call SetUnitState(s__Missile_source[this], UNIT_STATE_LIFE, RMinBJ(GetUnitState(s__Missile_source[this], UNIT_STATE_LIFE) + s__Missile_damageDealt[this] * ( WitchFirstSpells__LIFE_LEECHED_BASE + ( WitchFirstSpells__LIFE_LEECHED_LEVEL_FACTOR * GetUnitAbilityLevel(s__Missile_source[this], WitchFirstSpells__SPRITE) ) ), GetUnitState(s__Missile_source[this], UNIT_STATE_MAX_LIFE)))
                call spellDamage(s__Missile_source[this] , justHit , s__Missile_damageDealt[this])
                return true
            endif
            return false
        endfunction
//Implemented from module MissileStruct:
        
        function s__WitchFirstSpells__MissileHandler_MissileStruct___missileTerminate takes integer this returns nothing
            if s__Missile_terminated[this] then
                return
            endif
            set s__Missile_terminated[this]=true



            call s__Missile_terminate(this)
            call Missile___StopPeriodic(si__WitchFirstSpells__MissileHandler)
        endfunction
        
        function s__WitchFirstSpells__MissileHandler_unpin takes integer this returns nothing
            call s__Missile_removeNode(this)
            call Missile___StopPeriodic(si__WitchFirstSpells__MissileHandler)
        endfunction




















        //***********************************************************************
        //  First it takes the struct's first instance, which is the next to the
        //  head (NODE[thistype.typeid].next) and starts iterating through it until it hits
        //  the head again. Then checks if the missile is marked for recycling,
        //  if so it runs the methods and destroys the missile.
        function s__WitchFirstSpells__MissileHandler_MissileStruct___missileIterate takes nothing returns nothing
            local unit u
            local boolean finished= false
            local integer this= s__Missile_next[Missile___NODE[si__WitchFirstSpells__MissileHandler]]
            call s__Missile_move(this)
            loop
                exitwhen s__Missile_head[this]
                
                if s__Missile_wantDestroy[this] then



                    call s__WitchFirstSpells__MissileHandler_MissileStruct___missileTerminate(this)
                    
                else
                    if s__Missile_recycle[this] then














                                if s__Missile_target[this] == null then
                                    call s__WitchFirstSpells__MissileHandler_MissileStruct___missileTerminate(this)
                                elseif s__WitchFirstSpells__MissileHandler_onCollide(this , s__Missile_target[this]) then
                                    call s__WitchFirstSpells__MissileHandler_MissileStruct___missileTerminate(this)
                                else
                                    set s__Missile_recycle[this]=false
                                endif












                    else

                            if s__Missile_collision[this] != 0 then
                                call GroupEnumUnitsInRange(bj_lastCreatedGroup, s__Missile_x[this], s__Missile_y[this], s__Missile_collision[this], null)
                                loop
                                    set u=FirstOfGroup(bj_lastCreatedGroup)
                                    exitwhen u == null or finished
                                    if not ( IsUnitInGroup(u, s__Missile_unitsHit[this]) ) and u != s__Missile_target[this] and s__WitchFirstSpells__MissileHandler_onCollide(this , u) then
                                        call s__WitchFirstSpells__MissileHandler_MissileStruct___missileTerminate(this)
                                        set finished=true
                                    endif
                                    call GroupAddUnit(s__Missile_unitsHit[this], u)
                                    call GroupRemoveUnit(bj_lastCreatedGroup, u)
                                endloop
                            endif

                    endif
                endif
                



                





                
                set this=s__Missile_next[this]
            endloop
            
            set u=null
        endfunction
        
        function s__WitchFirstSpells__MissileHandler_launch takes integer this returns nothing
            call Missile___StartPeriodic(si__WitchFirstSpells__MissileHandler)
            call s__Missile_insertNode(Missile___NODE[si__WitchFirstSpells__MissileHandler],this)
        endfunction
        
        function s__WitchFirstSpells__MissileHandler_MissileStruct___onInit takes nothing returns nothing
            set Missile___NODE[si__WitchFirstSpells__MissileHandler]=s__Missile_createNode()
            set Missile___TIMER[si__WitchFirstSpells__MissileHandler]=(CTL___A((function s__WitchFirstSpells__MissileHandler_MissileStruct___missileIterate))) // INLINED!!
        endfunction
        
    function WitchFirstSpells__Sprite takes nothing returns nothing
        local unit cast= GetTriggerUnit()
        local real casx= GetUnitX(cast)
        local real casy= GetUnitY(cast)
        local real tarx= GetSpellTargetX()
        local real tary= GetSpellTargetY()
        local real data= WitchFirstSpells__SP_DATA
        local integer spellId= WitchFirstSpells__SPRITE
        local integer lvl= GetUnitAbilityLevel(cast, spellId)
        local real ang=  Atan2(( tary - casy ), ( tarx - casx ))
        local integer m
         
         call SetUnitState(cast, UNIT_STATE_LIFE, GetUnitState(cast, UNIT_STATE_LIFE) * ( 1 - WitchFirstSpells__LIFE_CONSUMED ))
        //---------------------------------------------------------
        set m=s__Missile_create(casx , casy , 50 , ang , WitchFirstSpells__SP_RANGE , 50)
        call s__Missile__set_model(m,WitchFirstSpells__SP_EFFECT)
        set s__Missile_speed[m]=30
        set s__Missile_collision[m]=100
        call s__Missile__set_arc(m,0)
        set s__Missile_source[m]=cast
        set s__Missile_damageDealt[m]=( WitchFirstSpells__SP_LEVEL_FLAT_FACTOR * lvl ) + ( ( WitchFirstSpells__SP_INT_FACTOR + ( WitchFirstSpells__SP_INT_LEVEL_FACTOR * lvl ) ) * GetHeroInt(cast, true) )
        call s__WitchFirstSpells__MissileHandler_launch(m)
        set cast=null
    endfunction
    function WitchFirstSpells__Ritual takes nothing returns nothing
    
        local real pointx= GetSpellTargetX()
        local real pointy= GetSpellTargetY()
        local real facing= 0
        local real angle=facing * 3.14159 / 180
        
        local real array x
        local real array y
        local player casterp
        
        local integer i2
        local integer sides= 5
        local integer i= 0
        
        local unit u
        local unit caster= GetTriggerUnit()
        local real inT= GetHeroInt(caster, true)
        local real agi= GetHeroAgi(caster, true)
        local real str= GetHeroStr(caster, true)
        
        local integer level= GetUnitAbilityLevel(caster, WitchFirstSpells__RITUAL)
        local real damage= GetHeroInt(caster, true) * ( WitchFirstSpells__SP_INT_FACTOR + ( WitchFirstSpells__SP_INT_LEVEL_FACTOR * level ) )
        local group g
        set casterp=GetOwningPlayer(caster)
        loop
            exitwhen ( i == sides )
            set x[i]=pointx + Cos(angle) * WitchFirstSpells__RI_RADIUS
            set y[i]=pointy + Sin(angle) * WitchFirstSpells__RI_RADIUS
            set angle=angle + ( 2 * 3.14159 / sides )
            set i=i + 1
        endloop
        set i=0
        loop
            exitwhen i == sides
            set i2=ModuloInteger(i + 2, sides)
            call DestroyEffect(AddSpecialEffect(WitchFirstSpells__RI_EFFECT, x[i], y[i]))
            call s__TimedL_P2P(AddLightning("AFOD", false, x[i], y[i], x[i2], y[i2]) , WitchFirstSpells__RI_DURATION , 1 , 0.5)
            set i=i + 1
        endloop
        set g=CreateGroup()
        call GroupEnumUnitsInRange(g, pointx, pointy, WitchFirstSpells__RI_RADIUS, getTargetFilter(casterp))
        set i=0
        loop
            set u=FirstOfGroup(g)
            exitwhen u == null
            call DestroyEffect(AddSpecialEffectTarget(WitchFirstSpells__RI_EFFECT, u, "origin"))
            call pureDamage(caster , u , damage)
            call GroupRemoveUnit(g, u)
            if GetRandomInt(1, 100) <= 20 then
                set u=CreateUnit(casterp, 'o001', pointx, pointy, bj_UNIT_FACING)
                call UnitApplyTimedLife(u, 'BTLF', 5)
                call SetUnitBonus(u , BONUS_DAMAGE , R2I(inT * ( 1 + ( 0.1 * I2R(level) ) )))
                call SetUnitBonus(u , BONUS_LIFE , R2I(str * ( 3 + ( 0.3 * I2R(level) ) )))
                call SetUnitBonus(u , BONUS_ARMOR , R2I(agi * ( 0.05 + ( 0.0125 * I2R(level) ) )))
                call SetUnitBonus(u , BONUS_ATTACK_SPEED , 10 + ( 2 * level ))
            endif
            set i=i + 1
        endloop
        call DestroyGroup(g)
        set g=null
        set u=null
        set caster=null
        set casterp=null
    endfunction
    
        
//Implemented from module T32Interface:
        
        function s__WitchFirstSpells__ChampTimer_T32Interface___onInit takes nothing returns nothing
            set s__WitchFirstSpells__ChampTimer_T32Interface___timers=(CTL___A((function sc__WitchFirstSpells__ChampTimer_T32Interface___expire))) // INLINED!!
        endfunction
        
        function s__WitchFirstSpells__ChampTimer_T32Interface___expire takes nothing returns nothing
            local integer i= 0
            local integer array recycle
            local integer recycleCount= 0
            local integer temp
            local boolean running= false
            loop
                exitwhen s__WitchFirstSpells__ChampTimer_T32Interface___list[i] == 0
                if not sc__WitchFirstSpells__ChampTimer_onLoop(s__WitchFirstSpells__ChampTimer_T32Interface___list[i]) then
                   set recycle[recycleCount]=s__WitchFirstSpells__ChampTimer_T32Interface___list[i]
                   set recycleCount=recycleCount + 1
                   call sc__WitchFirstSpells__ChampTimer_onExpire(s__WitchFirstSpells__ChampTimer_T32Interface___list[i])
                else
                    set running=true
                endif
                set i=i + 1
            endloop
            if recycleCount != 0 then
                set i=0
                loop
                    exitwhen recycle[i] == 0
                    set temp=recycle[i]
                    set s__WitchFirstSpells__ChampTimer_recyclePosition[s__WitchFirstSpells__ChampTimer_T32Interface___list[s__WitchFirstSpells__ChampTimer_T32Interface___count]]=s__WitchFirstSpells__ChampTimer_recyclePosition[temp]
                    set s__WitchFirstSpells__ChampTimer_T32Interface___list[s__WitchFirstSpells__ChampTimer_recyclePosition[temp]]=s__WitchFirstSpells__ChampTimer_T32Interface___list[s__WitchFirstSpells__ChampTimer_T32Interface___count]
                    set s__WitchFirstSpells__ChampTimer_T32Interface___list[s__WitchFirstSpells__ChampTimer_T32Interface___count]=0
                    //call temp.deallocate()
                    set s__WitchFirstSpells__ChampTimer_T32Interface___count=s__WitchFirstSpells__ChampTimer_T32Interface___count - 1
                    set i=i + 1
                endloop
            endif
            if not running then
                call CTL___SR32((s__WitchFirstSpells__ChampTimer_T32Interface___timers)) // INLINED!!
            endif
        endfunction
        
        function s__WitchFirstSpells__ChampTimer_add takes integer this returns nothing
            local integer i= 0
            loop
                exitwhen s__WitchFirstSpells__ChampTimer_T32Interface___list[i] == 0
                set i=i + 1
            endloop
            set s__WitchFirstSpells__ChampTimer_T32Interface___list[i]=this
            set s__WitchFirstSpells__ChampTimer_recyclePosition[this]=i
            set s__WitchFirstSpells__ChampTimer_T32Interface___count=s__WitchFirstSpells__ChampTimer_T32Interface___count + 1
            call CTL___A32((s__WitchFirstSpells__ChampTimer_T32Interface___timers)) // INLINED!!
        endfunction
        
        
        function s__WitchFirstSpells__ChampTimer_onLoop takes integer this returns boolean
            local group g
            local unit u
            
            if s__WitchFirstSpells__ChampTimer_startTime[this] < (TimerGetElapsed(gameTimer)) - s__WitchFirstSpells__ChampTimer_duration then // INLINED!!
                return false
            endif
            if GetUnitCurrentOrder(s__WitchFirstSpells__ChampTimer_toHide[this]) != OrderId("attack") then
                set g=CreateGroup()
                set filterHost=s__WitchFirstSpells__ChampTimer_toHide[this]
                call GroupEnumUnitsInRange(g, GetUnitX(s__WitchFirstSpells__ChampTimer_toHide[this]), GetUnitY(s__WitchFirstSpells__ChampTimer_toHide[this]), 350, getTargetFilter(GetOwningPlayer(s__WitchFirstSpells__ChampTimer_toShow[this])))
                set u=FirstOfGroup(g)
                if u != null then
                    call IssueTargetOrderById(s__WitchFirstSpells__ChampTimer_toHide[this], 851983, u)
                endif
                set u=null
                call DestroyGroup(g)
                set g=null
            endif
            return true
        endfunction
        
        function s__WitchFirstSpells__ChampTimer_onExpire takes integer this returns nothing
            call RemoveUnit(s__WitchFirstSpells__ChampTimer_toHide[this])
            //call ShowUnit(this.toShow, true)
            set s__WitchFirstSpells__ChampTimer_toHide[this]=null
            set s__WitchFirstSpells__ChampTimer_toShow[this]=null
            call s__WitchFirstSpells__ChampTimer_deallocate(this)
        endfunction
        
        function s__WitchFirstSpells__ChampTimer_create takes unit caster,unit dummy returns integer
            local integer this= s__WitchFirstSpells__ChampTimer__allocate()
            set s__WitchFirstSpells__ChampTimer_toHide[this]=dummy
            set s__WitchFirstSpells__ChampTimer_toShow[this]=caster
            call SetUnitVertexColor(s__WitchFirstSpells__ChampTimer_toHide[this], 255, 100, 100, 150)
            set s__WitchFirstSpells__ChampTimer_startTime[this]=(TimerGetElapsed(gameTimer)) // INLINED!!
            call s__WitchFirstSpells__ChampTimer_add(this)
            return this
        endfunction
    
    function WitchFirstSpells__Champion takes nothing returns nothing
        local unit caster= GetTriggerUnit()
        local integer level= GetUnitAbilityLevel(caster, WitchFirstSpells__CHAMP)
        local player casterP= GetOwningPlayer(caster)
        local real angle= GetUnitFacing(caster) * bj_DEGTORAD
        //call ShowUnit(caster,false)
        
        call s__WitchFirstSpells__ChampTimer_create(caster , CreateUnit(casterP, WitchFirstSpells__CHAMP_ID, GetUnitX(caster) + ( 200 * Cos(angle) ), GetUnitY(caster) + ( 200 * Sin(angle) ), 0))
    endfunction
    
        function s__WitchFirstSpells__BathMain_onInit takes nothing returns nothing
            set s__WitchFirstSpells__BathMain_timers=(CTL___A((function sc__WitchFirstSpells__BathMain_expire))) // INLINED!!
        endfunction
        function s__WitchFirstSpells__BathMain_expire takes nothing returns nothing
            local integer i= 0
            local integer array recycle
            local integer recycleCount= 0
            local integer temp
            local boolean running= false
            loop
                exitwhen s__WitchFirstSpells__BathMain_list[i] == 0
                if not sc__WitchFirstSpells__BathMain_onLoop(s__WitchFirstSpells__BathMain_list[i]) then
                   set recycle[recycleCount]=s__WitchFirstSpells__BathMain_list[i]
                   set recycleCount=recycleCount + 1
                else
                    set running=true
                endif
                set i=i + 1
            endloop
            if recycleCount != 0 then
                set i=0
                loop
                    exitwhen recycle[i] == 0
                    set temp=recycle[i]
                    set s__WitchFirstSpells__BathMain_recyclePosition[s__WitchFirstSpells__BathMain_list[s__WitchFirstSpells__BathMain_count]]=s__WitchFirstSpells__BathMain_recyclePosition[temp]
                    set s__WitchFirstSpells__BathMain_list[s__WitchFirstSpells__BathMain_recyclePosition[temp]]=s__WitchFirstSpells__BathMain_list[s__WitchFirstSpells__BathMain_count]
                    set s__WitchFirstSpells__BathMain_list[s__WitchFirstSpells__BathMain_count]=0
                    call s__WitchFirstSpells__BathMain_deallocate(temp)
                    set s__WitchFirstSpells__BathMain_count=s__WitchFirstSpells__BathMain_count - 1
                    set i=i + 1
                endloop
            endif
            if not running then
                call CTL___SR32((s__WitchFirstSpells__BathMain_timers)) // INLINED!!
            endif
        endfunction
        function s__WitchFirstSpells__BathMain_onLoop takes integer this returns boolean
            local real angle
            local real distance
            local integer i= 0
            local group toHit= CreateGroup()
            local unit hit
            local integer check
            if (TimerGetElapsed(gameTimer)) - s__WitchFirstSpells__BathMain_timeOnStart[this] >= WitchFirstSpells__BA_DURATION then // INLINED!!
                return false
            endif
            call GroupEnumUnitsInRange(toHit, s__WitchFirstSpells__BathMain_castx[this], s__WitchFirstSpells__BathMain_casty[this], WitchFirstSpells__BA_RADIUS, getTargetFilter(GetOwningPlayer(s__WitchFirstSpells__BathMain_caster[this])))
            loop
                set hit=FirstOfGroup(toHit)
                exitwhen hit == null
                call pureDamage(s__WitchFirstSpells__BathMain_caster[this] , hit , s__WitchFirstSpells__BathMain_damagePer32[this])
                call GroupRemoveUnit(toHit, hit)
            endloop
            loop
                exitwhen i == WitchFirstSpells__BA_BLOOD_PER_32
                set angle=(GetRandomReal(- bj_PI, bj_PI)) // INLINED!!
                set distance=GetRandomReal(0, WitchFirstSpells__BA_RADIUS)
                set check=GetRandomInt(1, 5)
                if check == 1 then
                    call DestroyEffect(AddSpecialEffect(WitchFirstSpells__BA_EFFECT2, s__WitchFirstSpells__BathMain_castx[this] + Cos(angle) * distance, s__WitchFirstSpells__BathMain_casty[this] + Sin(angle) * distance))
                elseif check == 2 then
                    call DestroyEffect(AddSpecialEffect(WitchFirstSpells__BA_EFFECT2, s__WitchFirstSpells__BathMain_castx[this] + Cos(angle) * distance, s__WitchFirstSpells__BathMain_casty[this] + Sin(angle) * distance))
                elseif check == 3 then
                    call DestroyEffect(AddSpecialEffect(WitchFirstSpells__BA_EFFECT3, s__WitchFirstSpells__BathMain_castx[this] + Cos(angle) * distance, s__WitchFirstSpells__BathMain_casty[this] + Sin(angle) * distance))
                elseif check == 4 then
                    call DestroyEffect(AddSpecialEffect(WitchFirstSpells__BA_EFFECT4, s__WitchFirstSpells__BathMain_castx[this] + Cos(angle) * distance, s__WitchFirstSpells__BathMain_casty[this] + Sin(angle) * distance))
                elseif check == 5 then
                    call DestroyEffect(AddSpecialEffect(WitchFirstSpells__BA_EFFECT5, s__WitchFirstSpells__BathMain_castx[this] + Cos(angle) * distance, s__WitchFirstSpells__BathMain_casty[this] + Sin(angle) * distance))
                endif
                set i=i + 1
            endloop
            call DestroyGroup(toHit)
            set toHit=null
            set hit=null
            return true
        endfunction
        
        function s__WitchFirstSpells__BathMain_create takes unit cast returns integer
            local integer this= s__WitchFirstSpells__BathMain__allocate()
            local integer i= 0
            set s__WitchFirstSpells__BathMain_caster[this]=cast
            set s__WitchFirstSpells__BathMain_castx[this]=GetUnitX(cast)
            set s__WitchFirstSpells__BathMain_casty[this]=GetUnitY(cast)
            set s__WitchFirstSpells__BathMain_damagePer32[this]=( ( WitchFirstSpells__BA_INT_FACTOR + ( WitchFirstSpells__BA_INT_LEVEL_FACTOR * GetUnitAbilityLevel(cast, WitchFirstSpells__BATH) ) ) * GetHeroInt(cast, true) ) / 32
            set s__WitchFirstSpells__BathMain_timeOnStart[this]=(TimerGetElapsed(gameTimer)) // INLINED!!
            loop
                exitwhen s__WitchFirstSpells__BathMain_list[i] == 0
                set i=i + 1
            endloop
            set s__WitchFirstSpells__BathMain_list[i]=this
            set s__WitchFirstSpells__BathMain_recyclePosition[this]=i
            set s__WitchFirstSpells__BathMain_count=s__WitchFirstSpells__BathMain_count + 1
            call CTL___A32((s__WitchFirstSpells__BathMain_timers)) // INLINED!!
            return this
        endfunction
        
    function WitchFirstSpells__Bath takes nothing returns nothing
        call s__WitchFirstSpells__BathMain_create(GetTriggerUnit())
    endfunction
    function WitchFirstSpells__OnSpell takes nothing returns boolean
        if GetSpellAbilityId() == WitchFirstSpells__SPRITE then
            call WitchFirstSpells__Sprite()
        elseif GetSpellAbilityId() == WitchFirstSpells__RITUAL then
            call WitchFirstSpells__Ritual()
        elseif GetSpellAbilityId() == WitchFirstSpells__CHAMP then
            call WitchFirstSpells__Champion()
        elseif GetSpellAbilityId() == WitchFirstSpells__BATH then
            call s__WitchFirstSpells__BathMain_create(GetTriggerUnit()) // INLINED!!
        endif
        return false
    endfunction

    function WitchFirstSpells__onInit takes nothing returns nothing
        local trigger trig= CreateTrigger()
        
        call TriggerRegisterAnyUnitEventBJ(trig, EVENT_PLAYER_UNIT_SPELL_EFFECT)
        call TriggerAddCondition(trig, Condition(function WitchFirstSpells__OnSpell))
        set trig=null
    endfunction

//library WitchFirstSpells ends
//library WizardFireSpells:
    
//Implemented from module T32Interface:
        
        function s__BurningSoul_T32Interface___onInit takes nothing returns nothing
            set s__BurningSoul_T32Interface___timers=(CTL___A((function sc__BurningSoul_T32Interface___expire))) // INLINED!!
        endfunction
        
        function s__BurningSoul_T32Interface___expire takes nothing returns nothing
            local integer i= 0
            local integer array recycle
            local integer recycleCount= 0
            local integer temp
            local boolean running= false
            loop
                exitwhen s__BurningSoul_T32Interface___list[i] == 0
                if not sc__BurningSoul_onLoop(s__BurningSoul_T32Interface___list[i]) then
                   set recycle[recycleCount]=s__BurningSoul_T32Interface___list[i]
                   set recycleCount=recycleCount + 1
                   call sc__BurningSoul_onExpire(s__BurningSoul_T32Interface___list[i])
                else
                    set running=true
                endif
                set i=i + 1
            endloop
            if recycleCount != 0 then
                set i=0
                loop
                    exitwhen recycle[i] == 0
                    set temp=recycle[i]
                    set s__BurningSoul_recyclePosition[s__BurningSoul_T32Interface___list[s__BurningSoul_T32Interface___count]]=s__BurningSoul_recyclePosition[temp]
                    set s__BurningSoul_T32Interface___list[s__BurningSoul_recyclePosition[temp]]=s__BurningSoul_T32Interface___list[s__BurningSoul_T32Interface___count]
                    set s__BurningSoul_T32Interface___list[s__BurningSoul_T32Interface___count]=0
                    //call temp.deallocate()
                    set s__BurningSoul_T32Interface___count=s__BurningSoul_T32Interface___count - 1
                    set i=i + 1
                endloop
            endif
            if not running then
                call CTL___SR32((s__BurningSoul_T32Interface___timers)) // INLINED!!
            endif
        endfunction
        
        function s__BurningSoul_add takes integer this returns nothing
            local integer i= 0
            loop
                exitwhen s__BurningSoul_T32Interface___list[i] == 0
                set i=i + 1
            endloop
            set s__BurningSoul_T32Interface___list[i]=this
            set s__BurningSoul_recyclePosition[this]=i
            set s__BurningSoul_T32Interface___count=s__BurningSoul_T32Interface___count + 1
            call CTL___A32((s__BurningSoul_T32Interface___timers)) // INLINED!!
        endfunction
        
//Implemented from module Alloc:
    
    function s__BurningSoul_allocate takes nothing returns integer
        local integer this= s__BurningSoul_Alloc___recycler[0]
        
        
        if ( this == 0 ) then
        
            set this=s__BurningSoul_Alloc___instanceCount + 1
            set s__BurningSoul_Alloc___instanceCount=this
        else
            set s__BurningSoul_Alloc___recycler[0]=s__BurningSoul_Alloc___recycler[this]
        endif
        
        
        return this
    endfunction
    
    function s__BurningSoul_deallocate takes integer this returns nothing
        
        
        set s__BurningSoul_Alloc___recycler[this]=s__BurningSoul_Alloc___recycler[0]
        set s__BurningSoul_Alloc___recycler[0]=this
    endfunction
        
        
        function s__BurningSoul_onLoop takes integer this returns boolean
            set s__BurningSoul_ticksRemaining[this]=s__BurningSoul_ticksRemaining[this] - 1
            if s__BurningSoul_ticksRemaining[this] <= 0 then
                return false
            endif
            call dotDamage(s__BurningSoul_caster[this] , s__BurningSoul_target[this] , s__BurningSoul_damagePer32[this])
            
            return true
        endfunction
        
        function s__BurningSoul_onExpire takes integer this returns nothing
            call SaveInteger(Table___ht, (s__BurningSoul_perHeroInstances), (GetHandleId(s__BurningSoul_target[this])), ( 0)) // INLINED!!
            call UnitRemoveAbility(s__BurningSoul_target[this], WizardFireSpells__BS_FX)
            set s__BurningSoul_caster[this]=null
            set s__BurningSoul_target[this]=null
            call s__BurningSoul_deallocate(this)
        endfunction
        
        function s__BurningSoul_reset takes integer this returns nothing
            set s__BurningSoul_ticksRemaining[this]=R2I(( WizardFireSpells__BS_BURN_DURA + ( WizardFireSpells__BS_BURN_DURA_FACTOR * GetUnitAbilityLevel(s__BurningSoul_caster[this], WizardFireSpells__BS_ID) ) ) * 32)
        endfunction
        
        function s__BurningSoul_applyBurnPercentage takes unit source,unit target returns real
            local integer lvl= GetUnitAbilityLevel(source, WizardFireSpells__BS_ID)
            local integer this= (LoadInteger(Table___ht, (s__BurningSoul_perHeroInstances), (GetHandleId(target)))) // INLINED!!
            if lvl == 0 then
                return 1.
            endif
            if this == 0 then
                if GetRandomReal(0, 100) < ( ( WizardFireSpells__BS_CHANCE + ( WizardFireSpells__BS_CHANCE_FACTOR * lvl ) ) ) then
                    set this=sc__BurningSoul_create(target , source)
                endif
            else
                if GetRandomReal(0, 200) < ( ( WizardFireSpells__BS_CHANCE + ( WizardFireSpells__BS_CHANCE_FACTOR * lvl ) ) ) then
                    call s__BurningSoul_reset(this)
                endif
            endif
            
            if this != 0 then
                return 1 + ( ( WizardFireSpells__BS_EXTRA_DMG + ( WizardFireSpells__BS_EXTRA_DMG_FACTOR * lvl ) ) )
            else
                return 1.
            endif
        endfunction
        
        function s__BurningSoul_create takes unit victim,unit source returns integer
            local integer this= s__BurningSoul_allocate()
            local integer lvl= GetUnitAbilityLevel(source, WizardFireSpells__BS_ID)
            set s__BurningSoul_subTick[this]=0
            set s__BurningSoul_caster[this]=source
            set s__BurningSoul_target[this]=victim
            set s__BurningSoul_ticksRemaining[this]=R2I(( WizardFireSpells__BS_BURN_DURA + ( WizardFireSpells__BS_BURN_DURA_FACTOR * lvl ) ) * 32)
            set s__BurningSoul_damagePer32[this]=( WizardFireSpells__BS_BURN_INT_PS + ( WizardFireSpells__BS_BURN_INT_PS_FACTOR * lvl ) ) * I2R(GetHeroInt(source, true)) * ( 1 / 32 )
            call SaveInteger(Table___ht, (s__BurningSoul_perHeroInstances), (GetHandleId(s__BurningSoul_target[this])), ( this)) // INLINED!!
            call UnitAddAbility(s__BurningSoul_target[this], WizardFireSpells__BS_FX)
            call s__BurningSoul_add(this)
            return this
        endfunction
        
        function s__BurningSoul_init takes nothing returns nothing
            set s__BurningSoul_perHeroInstances=s__Table_create()
        endfunction
        
    
//Implemented from module Alloc:
    
    function s__Firebomb_allocate takes nothing returns integer
        local integer this= s__Firebomb_Alloc___recycler[0]
        
        
        if ( this == 0 ) then
        
            set this=s__Firebomb_Alloc___instanceCount + 1
            set s__Firebomb_Alloc___instanceCount=this
        else
            set s__Firebomb_Alloc___recycler[0]=s__Firebomb_Alloc___recycler[this]
        endif
        
        
        return this
    endfunction
    
    function s__Firebomb_deallocate takes integer this returns nothing
        
        
        set s__Firebomb_Alloc___recycler[this]=s__Firebomb_Alloc___recycler[0]
        set s__Firebomb_Alloc___recycler[0]=this
    endfunction
        
        
        function s__Firebomb_onViableHit takes unit casterv,unit target returns real
            local unit caster= (udg_PlayerUnit[GetPlayerId(GetOwningPlayer((casterv))) + 1]) // INLINED!!
            local integer this= (LoadInteger(Table___ht, (BaseFunction__timers), (GetHandleId((caster))))) // INLINED!!
            if this == 0 then
                return - 1.
            endif
            
            if IsUnitInGroup(target, s__Firebomb_hitGroup[this]) then
                return 0.
            endif
            call GroupAddUnit(s__Firebomb_hitGroup[this], target)
            
            call aggroDamage(casterv , target)
            return ( WizardFireSpells__FB_DMG_INT + ( WizardFireSpells__FB_DMG_INT_FACTOR * GetUnitAbilityLevel(s__Firebomb_casthero[this], WizardFireSpells__FB_ID) ) ) * GetHeroInt(s__Firebomb_casthero[this], true) * s__BurningSoul_applyBurnPercentage(s__Firebomb_casthero[this] , target)
            
        endfunction
        
        function s__Firebomb_onTimerExpire takes integer this returns nothing
            if (LoadInteger(Table___ht, (BaseFunction__timers), (GetHandleId((s__Firebomb_casthero[this]))))) == this then // INLINED!!
                call SaveInteger(Table___ht, (BaseFunction__timers), (GetHandleId((s__Firebomb_casthero[this]))), ( 0)) // INLINED!!
            endif
            set s__Firebomb_casthero[this]=null
            call DestroyGroup(s__Firebomb_hitGroup[this])
            set s__Firebomb_hitGroup[this]=null
            call s__Firebomb_deallocate(this)
        endfunction
        
//Implemented from module FAT:
    function s__Firebomb_FAT___p_onExpire takes nothing returns nothing
        local integer this= TimerDetach(GetExpiredTimer())
        call s__Firebomb_onTimerExpire(this)
        //set this = 0
        call DestroyTimer(GetExpiredTimer())
    endfunction
    
    function s__Firebomb_runTime takes real time,integer this returns nothing
        local timer t= CreateTimer()
        call SaveInteger(Table___ht, (BaseFunction__timers), (GetHandleId((t ))), ( ( this))) // INLINED!!
        call TimerStart(t, time, false, function s__Firebomb_FAT___p_onExpire)
        set t=null
    endfunction
        
        
        function s__Firebomb_onFinish takes integer this returns boolean
            local integer p
            local integer missileCount
            local real curAngle= (GetRandomReal(- bj_PI, bj_PI)) // INLINED!!
            local real increment
            local integer i= 0
            local integer root= this
            
            set this=s__Missile_data[root]
            set p=GetPlayerId(GetOwningPlayer(s__Firebomb_casthero[this]))
            set missileCount=R2I(WizardFireSpells__FB_MISSILES + ( WizardFireSpells__FB_MISSILES_FACTOR * s__Firebomb_lvl[this] ))
            set increment=( ( 2 * bj_PI ) / missileCount )
            
            call DestroyEffect(AddSpecialEffect(WizardFireSpells__PB_BOOM, s__Missile_x[root], s__Missile_y[root]))
            loop
                exitwhen missileCount == i
                //fire towards curAngle
                call FireWave(p , FB_WAVE , s__Missile_x[root] , s__Missile_y[root] , curAngle , this)
                set curAngle=curAngle + increment
                set i=i + 1
            endloop
            return true
        endfunction
        
//Implemented from module MissileStruct:
        
        function s__Firebomb_MissileStruct___missileTerminate takes integer this returns nothing
            if s__Missile_terminated[this] then
                return
            endif
            set s__Missile_terminated[this]=true



            call s__Missile_terminate(this)
            call Missile___StopPeriodic(si__Firebomb)
        endfunction
        
        function s__Firebomb_unpin takes integer this returns nothing
            call s__Missile_removeNode(this)
            call Missile___StopPeriodic(si__Firebomb)
        endfunction




















        //***********************************************************************
        //  First it takes the struct's first instance, which is the next to the
        //  head (NODE[thistype.typeid].next) and starts iterating through it until it hits
        //  the head again. Then checks if the missile is marked for recycling,
        //  if so it runs the methods and destroys the missile.
        function s__Firebomb_MissileStruct___missileIterate takes nothing returns nothing
            local unit u
            local boolean finished= false
            local integer this= s__Missile_next[Missile___NODE[si__Firebomb]]
            call s__Missile_move(this)
            loop
                exitwhen s__Missile_head[this]
                
                if s__Missile_wantDestroy[this] then

                        call s__Firebomb_onFinish(this)

                    call s__Firebomb_MissileStruct___missileTerminate(this)
                    
                else
                    if s__Missile_recycle[this] then
























                                if s__Firebomb_onFinish(this) then
                                    call s__Firebomb_MissileStruct___missileTerminate(this)
                                else
                                    set s__Missile_recycle[this]=false
                                endif




                    else















                    endif
                endif
                



                





                
                set this=s__Missile_next[this]
            endloop
            
            set u=null
        endfunction
        
        function s__Firebomb_launch takes integer this returns nothing
            call Missile___StartPeriodic(si__Firebomb)
            call s__Missile_insertNode(Missile___NODE[si__Firebomb],this)
        endfunction
        
        function s__Firebomb_MissileStruct___onInit takes nothing returns nothing
            set Missile___NODE[si__Firebomb]=s__Missile_createNode()
            set Missile___TIMER[si__Firebomb]=(CTL___A((function s__Firebomb_MissileStruct___missileIterate))) // INLINED!!
        endfunction
        
        
        function s__Firebomb_shoot takes unit caster,real tarx,real tary,boolean isPhoenix returns nothing
            local unit cast= caster
            local real casx= GetUnitX(cast)
            local real casy= GetUnitY(cast)
            local integer spellId= WizardFireSpells__FB_ID
            local real ang=  Atan2(( tary - casy ), ( tarx - casx ))
            local real dist= ( ( tarx - casx ) * ( tarx - casx ) ) + ( ( tary - casy ) * ( tary - casy ) )
            
            local integer this= s__Firebomb_allocate()
            local integer m
            if isPhoenix then
                set cast=(udg_PlayerUnit[GetPlayerId((GetOwningPlayer(caster))) + 1]) // INLINED!!
            endif
            
            set s__Firebomb_casthero[this]=cast
            set s__Firebomb_lvl[this]=GetUnitAbilityLevel(cast, spellId)
            set s__Firebomb_hitGroup[this]=CreateGroup()
            call SaveInteger(Table___ht, (BaseFunction__timers), (GetHandleId((s__Firebomb_casthero[this] ))), ( ( this))) // INLINED!!
             
            //---------------------------------------------------------
            if isPhoenix then
                set m=s__Missile_create(casx , casy , 150 , ang , SquareRoot(dist) , 50)
            else
                set m=s__Missile_create(casx , casy , 50 , ang , SquareRoot(dist) , 50)
            endif
            call s__Missile__set_model(m,WizardFireSpells__FB_FX)
            set s__Missile_speed[m]=( ( dist / ( WizardFireSpells__FB_MAX_DIST * WizardFireSpells__FB_MAX_DIST ) ) / 2 + 1 ) * WizardFireSpells__FB_SPEED
            set s__Missile_collision[m]=0
            set s__Missile_data[m]=this
            call s__Missile__set_arc(m,1)
            set s__Missile_source[m]=cast
            call s__Firebomb_launch(m)
            
            call s__Firebomb_runTime(20 , this)
            
            set cast=null
        endfunction
    
//Implemented from module Alloc:
    
    function s__FlameWave_allocate takes nothing returns integer
        local integer this= s__FlameWave_Alloc___recycler[0]
        
        
        if ( this == 0 ) then
        
            set this=s__FlameWave_Alloc___instanceCount + 1
            set s__FlameWave_Alloc___instanceCount=this
        else
            set s__FlameWave_Alloc___recycler[0]=s__FlameWave_Alloc___recycler[this]
        endif
        
        
        return this
    endfunction
    
    function s__FlameWave_deallocate takes integer this returns nothing
        
        
        set s__FlameWave_Alloc___recycler[this]=s__FlameWave_Alloc___recycler[0]
        set s__FlameWave_Alloc___recycler[0]=this
    endfunction
//Implemented from module StructAttach:
    
    function s__FlameWave_getu takes integer this,unit u returns integer
        return (LoadInteger(Table___ht, (s__FlameWave_StructAttach___t_v), (GetHandleId(u)))) // INLINED!!
    endfunction
    
    function s__FlameWave_setu takes integer this,unit u,integer i returns nothing
        call SaveInteger(Table___ht, (s__FlameWave_StructAttach___t_v), (GetHandleId(u)), ( i)) // INLINED!!
    endfunction
    
    function s__FlameWave_detach takes integer this,unit u returns nothing
        call SaveInteger(Table___ht, (s__FlameWave_StructAttach___t_v), (GetHandleId(u)), ( 0)) // INLINED!!
    endfunction
    
    function s__FlameWave_StructAttach___onInit takes nothing returns nothing
        set s__FlameWave_StructAttach___t_v=s__Table_create()
    endfunction
        
        
        function s__FlameWave_onTimerExpire takes integer this returns nothing
            set s__FlameWave_caster[this]=null
            call s__FlameWave_detach(this,s__FlameWave_caster[this])
            call s__FlameWave_deallocate(this)
        endfunction
        
        function s__FlameWave_onExpire takes integer this returns nothing
        
        endfunction
        
        function s__FlameWave_onLoop takes integer this returns boolean
            local real x
            local real y
            local real angle= (GetRandomReal(- bj_PI, bj_PI)) // INLINED!!
            local group g
            local unit u
            
            if not s__FlameWave_continue[this] then
                //call DestroyGroup(g)
                return false
            endif
           
            set x=s__Missile_x[s__FlameWave_dragon[this]] + ( GetRandomInt(1, 200) * Cos(angle) )
            set y=s__Missile_y[s__FlameWave_dragon[this]] + ( GetRandomInt(1, 200) * Sin(angle) )
            
            call DestroyEffect(AddSpecialEffect(WizardFireSpells__FW_BRANCH_FX, x, y))
            
            set g=CreateGroup()
            
            call GroupEnumUnitsInRange(g, x, y, WizardFireSpells__FW_BRANCH_RADIUS, getTargetFilter(GetOwningPlayer(s__FlameWave_caster[this])))
            set u=FirstOfGroup(g)
            loop
                exitwhen u == null
                call spellDamage(s__FlameWave_caster[this] , u , s__FlameWave_dmgPerSideHit[this])
                call GroupRemoveUnit(g, u)
                set u=FirstOfGroup(g)
            endloop
            call DestroyGroup(g)
            return true
        endfunction
        
//Implemented from module FAT:
    function s__FlameWave_FAT___p_onExpire takes nothing returns nothing
        local integer this= TimerDetach(GetExpiredTimer())
        call s__FlameWave_onTimerExpire(this)
        //set this = 0
        call DestroyTimer(GetExpiredTimer())
    endfunction
    
    function s__FlameWave_runTime takes real time,integer this returns nothing
        local timer t= CreateTimer()
        call SaveInteger(Table___ht, (BaseFunction__timers), (GetHandleId((t ))), ( ( this))) // INLINED!!
        call TimerStart(t, time, false, function s__FlameWave_FAT___p_onExpire)
        set t=null
    endfunction
//Implemented from module T32Interface:
        
        function s__FlameWave_T32Interface___onInit takes nothing returns nothing
            set s__FlameWave_T32Interface___timers=(CTL___A((function sc__FlameWave_T32Interface___expire))) // INLINED!!
        endfunction
        
        function s__FlameWave_T32Interface___expire takes nothing returns nothing
            local integer i= 0
            local integer array recycle
            local integer recycleCount= 0
            local integer temp
            local boolean running= false
            loop
                exitwhen s__FlameWave_T32Interface___list[i] == 0
                if not s__FlameWave_onLoop(s__FlameWave_T32Interface___list[i]) then
                   set recycle[recycleCount]=s__FlameWave_T32Interface___list[i]
                   set recycleCount=recycleCount + 1
                   call s__FlameWave_onExpire(s__FlameWave_T32Interface___list[i])
                else
                    set running=true
                endif
                set i=i + 1
            endloop
            if recycleCount != 0 then
                set i=0
                loop
                    exitwhen recycle[i] == 0
                    set temp=recycle[i]
                    set s__FlameWave_recyclePosition[s__FlameWave_T32Interface___list[s__FlameWave_T32Interface___count]]=s__FlameWave_recyclePosition[temp]
                    set s__FlameWave_T32Interface___list[s__FlameWave_recyclePosition[temp]]=s__FlameWave_T32Interface___list[s__FlameWave_T32Interface___count]
                    set s__FlameWave_T32Interface___list[s__FlameWave_T32Interface___count]=0
                    //call temp.deallocate()
                    set s__FlameWave_T32Interface___count=s__FlameWave_T32Interface___count - 1
                    set i=i + 1
                endloop
            endif
            if not running then
                call CTL___SR32((s__FlameWave_T32Interface___timers)) // INLINED!!
            endif
        endfunction
        
        function s__FlameWave_add takes integer this returns nothing
            local integer i= 0
            loop
                exitwhen s__FlameWave_T32Interface___list[i] == 0
                set i=i + 1
            endloop
            set s__FlameWave_T32Interface___list[i]=this
            set s__FlameWave_recyclePosition[this]=i
            set s__FlameWave_T32Interface___count=s__FlameWave_T32Interface___count + 1
            call CTL___A32((s__FlameWave_T32Interface___timers)) // INLINED!!
        endfunction
        
        
        function s__FlameWave_onFinish takes integer this returns boolean
            set s__FlameWave_continue[(s__Missile_data[this])]=false
            return true
        endfunction
        
        function s__FlameWave_onCollide takes integer this,unit justHit returns boolean
            if isViableTarget(s__Missile_source[this] , justHit) then
                call spellDamage(s__Missile_source[this] , justHit , s__FlameWave_dmgPerMainHit[(s__Missile_data[this])] * s__BurningSoul_applyBurnPercentage(s__Missile_source[this] , justHit))
            endif
            return false
        endfunction
            
            
//Implemented from module MissileStruct:
        
        function s__FlameWave_MissileStruct___missileTerminate takes integer this returns nothing
            if s__Missile_terminated[this] then
                return
            endif
            set s__Missile_terminated[this]=true



            call s__Missile_terminate(this)
            call Missile___StopPeriodic(si__FlameWave)
        endfunction
        
        function s__FlameWave_unpin takes integer this returns nothing
            call s__Missile_removeNode(this)
            call Missile___StopPeriodic(si__FlameWave)
        endfunction




















        //***********************************************************************
        //  First it takes the struct's first instance, which is the next to the
        //  head (NODE[thistype.typeid].next) and starts iterating through it until it hits
        //  the head again. Then checks if the missile is marked for recycling,
        //  if so it runs the methods and destroys the missile.
        function s__FlameWave_MissileStruct___missileIterate takes nothing returns nothing
            local unit u
            local boolean finished= false
            local integer this= s__Missile_next[Missile___NODE[si__FlameWave]]
            call s__Missile_move(this)
            loop
                exitwhen s__Missile_head[this]
                
                if s__Missile_wantDestroy[this] then

                        call s__FlameWave_onFinish(this)

                    call s__FlameWave_MissileStruct___missileTerminate(this)
                    
                else
                    if s__Missile_recycle[this] then


                                if s__Missile_target[this] == null then
                                    if s__FlameWave_onFinish(this) then
                                        call s__FlameWave_MissileStruct___missileTerminate(this)
                                    else
                                        set s__Missile_recycle[this]=false
                                    endif
                                elseif s__FlameWave_onCollide(this , s__Missile_target[this]) then
                                    call s__FlameWave_MissileStruct___missileTerminate(this)
                                else
                                    set s__Missile_recycle[this]=false
                                endif




















                    else

                            if s__Missile_collision[this] != 0 then
                                call GroupEnumUnitsInRange(bj_lastCreatedGroup, s__Missile_x[this], s__Missile_y[this], s__Missile_collision[this], null)
                                loop
                                    set u=FirstOfGroup(bj_lastCreatedGroup)
                                    exitwhen u == null or finished
                                    if not ( IsUnitInGroup(u, s__Missile_unitsHit[this]) ) and u != s__Missile_target[this] and s__FlameWave_onCollide(this , u) then
                                        call s__FlameWave_MissileStruct___missileTerminate(this)
                                        set finished=true
                                    endif
                                    call GroupAddUnit(s__Missile_unitsHit[this], u)
                                    call GroupRemoveUnit(bj_lastCreatedGroup, u)
                                endloop
                            endif

                    endif
                endif
                



                





                
                set this=s__Missile_next[this]
            endloop
            
            set u=null
        endfunction
        
        function s__FlameWave_launch takes integer this returns nothing
            call Missile___StartPeriodic(si__FlameWave)
            call s__Missile_insertNode(Missile___NODE[si__FlameWave],this)
        endfunction
        
        function s__FlameWave_MissileStruct___onInit takes nothing returns nothing
            set Missile___NODE[si__FlameWave]=s__Missile_createNode()
            set Missile___TIMER[si__FlameWave]=(CTL___A((function s__FlameWave_MissileStruct___missileIterate))) // INLINED!!
        endfunction
        
        
        function s__FlameWave_shoot takes unit casterv,real x,real y,boolean isPhoenix returns nothing
            local integer this= s__FlameWave_allocate()
            //local unit       cast = casterv
            local real casx= GetUnitX(casterv)
            local real casy= GetUnitY(casterv)
            local integer spellId= WizardFireSpells__FW_ID
            local real ang=  Atan2(( y - casy ), ( x - casx ))
            local real dist= WizardFireSpells__FW_DIST
            local integer m
            if not isPhoenix then
                set s__FlameWave_caster[this]=casterv
            else
                set s__FlameWave_caster[this]=(udg_PlayerUnit[GetPlayerId((GetOwningPlayer(casterv))) + 1]) // INLINED!!
            endif
            
            set s__FlameWave_lvl[this]=GetUnitAbilityLevel(s__FlameWave_caster[this], spellId)
            call s__FlameWave_setu(this,s__FlameWave_caster[this] , this)
            set s__FlameWave_dmgPerMainHit[this]=( WizardFireSpells__FW_CORE_INT + ( WizardFireSpells__FW_CORE_INT_FACTOR * s__FlameWave_lvl[this] ) ) * GetHeroInt(s__FlameWave_caster[this], true)
            set s__FlameWave_dmgPerSideHit[this]=( WizardFireSpells__FW_BRANCH_INT + ( WizardFireSpells__FW_BRANCH_INT_FACTOR * s__FlameWave_lvl[this] ) ) * GetHeroInt(s__FlameWave_caster[this], true)
            set s__FlameWave_continue[this]=true
             
            //---------------------------------------------------------
            set m=s__Missile_create(casx , casy , 100 , ang , dist , 100)
            call s__Missile__set_model(m,WizardFireSpells__FW_FX)
            set s__Missile_speed[m]=WizardFireSpells__FW_SPEED
            set s__Missile_collision[m]=150
            set s__Missile_data[m]=this
            set s__Missile_source[m]=s__FlameWave_caster[this]
            set s__FlameWave_dragon[this]=m
            call s__FlameWave_launch(m)
            
            call s__FlameWave_runTime(20 , this)
            call s__FlameWave_add(this)
        endfunction
    
    
//Implemented from module Alloc:
    
    function s__DamageOverTime_allocate takes nothing returns integer
        local integer this= s__DamageOverTime_Alloc___recycler[0]
        
        
        if ( this == 0 ) then
        
            set this=s__DamageOverTime_Alloc___instanceCount + 1
            set s__DamageOverTime_Alloc___instanceCount=this
        else
            set s__DamageOverTime_Alloc___recycler[0]=s__DamageOverTime_Alloc___recycler[this]
        endif
        
        
        return this
    endfunction
    
    function s__DamageOverTime_deallocate takes integer this returns nothing
        
        
        set s__DamageOverTime_Alloc___recycler[this]=s__DamageOverTime_Alloc___recycler[0]
        set s__DamageOverTime_Alloc___recycler[0]=this
    endfunction
        
        
        function s__DamageOverTime_onLoop takes integer this returns boolean
            local group g= CreateGroup()
            local unit u
            
            set s__DamageOverTime_t[this]=s__DamageOverTime_t[this] + 1
            if s__DamageOverTime_t[this] == 16 then
                set s__DamageOverTime_t[this]=0
            else
                call DestroyGroup(g)
                return true
            endif
            
            call GroupEnumUnitsInRange(g, s__DamageOverTime_x[this], s__DamageOverTime_y[this], s__DamageOverTime_r[this], getTargetFilter(GetOwningPlayer(s__DamageOverTime_caster[this])))
            loop
                set u=FirstOfGroup(g)
                exitwhen u == null
                
                call dotDamage(s__DamageOverTime_caster[this] , u , s__DamageOverTime_d32[this])
                
                call GroupRemoveUnit(g, u)
            endloop
                
            
            set s__DamageOverTime_tR[this]=s__DamageOverTime_tR[this] - 1
            if s__DamageOverTime_tR[this] <= 0 then
                set s__DamageOverTime_caster[this]=null
                call DestroyGroup(g)
                call s__DamageOverTime_deallocate(this)
                return false
            endif
            call DestroyGroup(g)
            return true
        endfunction
        
        function s__DamageOverTime_create takes unit casterv,real xv,real yv,real radius,real dmgPer32,integer numTicks returns integer
            local integer this= s__DamageOverTime_allocate()
            set s__DamageOverTime_caster[this]=casterv
            set s__DamageOverTime_x[this]=xv
            set s__DamageOverTime_y[this]=yv
            set s__DamageOverTime_r[this]=radius
            set s__DamageOverTime_d32[this]=dmgPer32 * 16
            set s__DamageOverTime_tR[this]=numTicks
            set s__DamageOverTime_t[this]=0
            
            return this
        endfunction
        
    
//Implemented from module Alloc:
    
    function s__Pressure_allocate takes nothing returns integer
        local integer this= s__Pressure_Alloc___recycler[0]
        
        
        if ( this == 0 ) then
        
            set this=s__Pressure_Alloc___instanceCount + 1
            set s__Pressure_Alloc___instanceCount=this
        else
            set s__Pressure_Alloc___recycler[0]=s__Pressure_Alloc___recycler[this]
        endif
        
        
        return this
    endfunction
    
    function s__Pressure_deallocate takes integer this returns nothing
        
        
        set s__Pressure_Alloc___recycler[this]=s__Pressure_Alloc___recycler[0]
        set s__Pressure_Alloc___recycler[0]=this
    endfunction
        
        
        
        //real aoe
        //real errorFactor
       // real timeBetweenHits
        
        function s__Pressure_onLoop takes integer this returns boolean
            local real angle
            local group g
            local unit u
            local boolean b= false
            local boolean exit= false
            local real x
            local real y
            set s__Pressure_tick[this]=s__Pressure_tick[this] + 1
            if s__Pressure_isPhoenyx[this] and s__Pressure_tick[this] == s__Pressure_onFirstFx[this] then
                set angle=(GetRandomReal(- bj_PI, bj_PI)) // INLINED!!
                set s__Pressure_firstX[this]=s__Pressure_posX[this] + ( GetRandomReal(1, WizardFireSpells__PR_ERROR) * Cos(angle) )
                set s__Pressure_firstY[this]=s__Pressure_posY[this] + ( GetRandomReal(1, WizardFireSpells__PR_ERROR) * Sin(angle) )
                call DestroyEffect(AddSpecialEffect(WizardFireSpells__PR_FX, s__Pressure_firstX[this], s__Pressure_firstY[this]))
            elseif s__Pressure_tick[this] == s__Pressure_onSecondFx[this] then
                set angle=(GetRandomReal(- bj_PI, bj_PI)) // INLINED!!
                set s__Pressure_secondX[this]=s__Pressure_posX[this] + ( GetRandomReal(1, WizardFireSpells__PR_ERROR) * Cos(angle) )
                set s__Pressure_secondY[this]=s__Pressure_posY[this] + ( GetRandomReal(1, WizardFireSpells__PR_ERROR) * Sin(angle) )
                call DestroyEffect(AddSpecialEffect(WizardFireSpells__PR_FX, s__Pressure_secondX[this], s__Pressure_secondY[this]))
            elseif s__Pressure_tick[this] == s__Pressure_onThirdFx[this] then
                set angle=(GetRandomReal(- bj_PI, bj_PI)) // INLINED!!
                set s__Pressure_thirdX[this]=s__Pressure_posX[this] + ( GetRandomReal(1, WizardFireSpells__PR_ERROR) * Cos(angle) )
                set s__Pressure_thirdY[this]=s__Pressure_posY[this] + ( GetRandomReal(1, WizardFireSpells__PR_ERROR) * Sin(angle) )
                call DestroyEffect(AddSpecialEffect(WizardFireSpells__PR_FX, s__Pressure_thirdX[this], s__Pressure_thirdY[this]))
            elseif s__Pressure_tick[this] == s__Pressure_onFourthFx[this] and s__Pressure_lvl[this] > 4 then
                set angle=(GetRandomReal(- bj_PI, bj_PI)) // INLINED!!
                set s__Pressure_fourthX[this]=s__Pressure_posX[this] + ( GetRandomReal(1, WizardFireSpells__PR_ERROR) * Cos(angle) )
                set s__Pressure_fourthY[this]=s__Pressure_posY[this] + ( GetRandomReal(1, WizardFireSpells__PR_ERROR) * Sin(angle) )
                call DestroyEffect(AddSpecialEffect(WizardFireSpells__PR_FX, s__Pressure_fourthX[this], s__Pressure_fourthY[this]))
            elseif s__Pressure_tick[this] == s__Pressure_onFifthFx[this] and s__Pressure_lvl[this] > 9 then
                set angle=(GetRandomReal(- bj_PI, bj_PI)) // INLINED!!
                set s__Pressure_fifthX[this]=s__Pressure_posX[this] + ( GetRandomReal(1, WizardFireSpells__PR_ERROR) * Cos(angle) )
                set s__Pressure_fifthY[this]=s__Pressure_posY[this] + ( GetRandomReal(1, WizardFireSpells__PR_ERROR) * Sin(angle) )
                call DestroyEffect(AddSpecialEffect(WizardFireSpells__PR_FX, s__Pressure_fifthX[this], s__Pressure_fifthY[this]))
            endif
            if s__Pressure_tick[this] == s__Pressure_onFirstDmg[this] then
                set b=true
                set x=s__Pressure_firstX[this]
                set y=s__Pressure_firstY[this]
            elseif s__Pressure_tick[this] == s__Pressure_onSecondDmg[this] then
                set b=true
                set x=s__Pressure_secondX[this]
                set y=s__Pressure_secondY[this]
            elseif s__Pressure_tick[this] == s__Pressure_onThirdDmg[this] then
                set b=true
                set exit=s__Pressure_lvl[this] < 5
                set x=s__Pressure_thirdX[this]
                set y=s__Pressure_thirdY[this]
            elseif s__Pressure_tick[this] == s__Pressure_onFourthDmg[this] and s__Pressure_lvl[this] > 4 then
                set b=true
                set exit=s__Pressure_lvl[this] < 10
                set x=s__Pressure_fourthX[this]
                set y=s__Pressure_fourthY[this]
            elseif s__Pressure_tick[this] == s__Pressure_onFifthDmg[this] and s__Pressure_lvl[this] > 9 then
                set b=true
                set exit=true
                set x=s__Pressure_fifthX[this]
                set y=s__Pressure_fifthY[this]
            endif
            
            if b then
                set g=CreateGroup()
                call GroupEnumUnitsInRange(g, x, y, WizardFireSpells__PR_AOE, getTargetFilter(s__Pressure_castOwner[this]))
                set u=FirstOfGroup(g)
                loop
                    exitwhen u == null
                    call spellDamage(s__Pressure_caster[this] , u , s__Pressure_damagePerHit[this])
                    call GroupRemoveUnit(g, u)
                    set u=FirstOfGroup(g)
                endloop
                call DestroyGroup(g)
                set g=null
            endif
            
            
            return not exit
        endfunction
        
        function s__Pressure_onExpire takes integer this returns nothing
            set s__Pressure_caster[this]=null
            set s__Pressure_castOwner[this]=null
            call s__Pressure_deallocate(this)
        endfunction
        
//Implemented from module T32Interface:
        
        function s__Pressure_T32Interface___onInit takes nothing returns nothing
            set s__Pressure_T32Interface___timers=(CTL___A((function sc__Pressure_T32Interface___expire))) // INLINED!!
        endfunction
        
        function s__Pressure_T32Interface___expire takes nothing returns nothing
            local integer i= 0
            local integer array recycle
            local integer recycleCount= 0
            local integer temp
            local boolean running= false
            loop
                exitwhen s__Pressure_T32Interface___list[i] == 0
                if not s__Pressure_onLoop(s__Pressure_T32Interface___list[i]) then
                   set recycle[recycleCount]=s__Pressure_T32Interface___list[i]
                   set recycleCount=recycleCount + 1
                   call s__Pressure_onExpire(s__Pressure_T32Interface___list[i])
                else
                    set running=true
                endif
                set i=i + 1
            endloop
            if recycleCount != 0 then
                set i=0
                loop
                    exitwhen recycle[i] == 0
                    set temp=recycle[i]
                    set s__Pressure_recyclePosition[s__Pressure_T32Interface___list[s__Pressure_T32Interface___count]]=s__Pressure_recyclePosition[temp]
                    set s__Pressure_T32Interface___list[s__Pressure_recyclePosition[temp]]=s__Pressure_T32Interface___list[s__Pressure_T32Interface___count]
                    set s__Pressure_T32Interface___list[s__Pressure_T32Interface___count]=0
                    //call temp.deallocate()
                    set s__Pressure_T32Interface___count=s__Pressure_T32Interface___count - 1
                    set i=i + 1
                endloop
            endif
            if not running then
                call CTL___SR32((s__Pressure_T32Interface___timers)) // INLINED!!
            endif
        endfunction
        
        function s__Pressure_add takes integer this returns nothing
            local integer i= 0
            loop
                exitwhen s__Pressure_T32Interface___list[i] == 0
                set i=i + 1
            endloop
            set s__Pressure_T32Interface___list[i]=this
            set s__Pressure_recyclePosition[this]=i
            set s__Pressure_T32Interface___count=s__Pressure_T32Interface___count + 1
            call CTL___A32((s__Pressure_T32Interface___timers)) // INLINED!!
        endfunction
        
        
        function s__Pressure_onSpell takes unit casterv,real x,real y,boolean isPhoenix returns nothing
            local integer this= s__Pressure_allocate()
            local real addTo= 0
            local real a
            if isPhoenix then
                set addTo=( WizardFireSpells__PR_TIME_BETWEEN_MISSILES ) * 16
                set s__Pressure_caster[this]=(udg_PlayerUnit[GetPlayerId((GetOwningPlayer(casterv))) + 1]) // INLINED!!
            else
                set s__Pressure_caster[this]=casterv
            endif
            
            set s__Pressure_isPhoenyx[this]=isPhoenix
            set s__Pressure_lvl[this]=GetUnitAbilityLevel(s__Pressure_caster[this], WizardFireSpells__PR_ID)
            set s__Pressure_posX[this]=x
            set s__Pressure_posY[this]=y
            set s__Pressure_castOwner[this]=GetOwningPlayer(s__Pressure_caster[this])
            set s__Pressure_damagePerHit[this]=( WizardFireSpells__PR_DAMAGE + ( WizardFireSpells__PR_DAMAGE_FACTOR * s__Pressure_lvl[this] ) ) * GetHeroInt(s__Pressure_caster[this], true)
            set a=(GetRandomReal(- bj_PI, bj_PI)) // INLINED!!
            
            if not isPhoenix then
                set s__Pressure_firstX[this]=x + ( GetRandomReal(1., WizardFireSpells__PR_ERROR) * Cos(a) )
                set s__Pressure_firstY[this]=y + ( GetRandomReal(1., WizardFireSpells__PR_ERROR) * Sin(a) )
                call DestroyEffect(AddSpecialEffect(WizardFireSpells__PR_FX, s__Pressure_firstX[this], s__Pressure_firstY[this]))
                set s__Pressure_onFirstFx[this]=0
            else
                set s__Pressure_firstX[this]=x
                set s__Pressure_firstY[this]=y
                set s__Pressure_onFirstFx[this]=R2I(addTo)
            endif
            
            set s__Pressure_onFirstDmg[this]=R2I(WizardFireSpells__PR_DAMAGE_DELAY * 32 + addTo)
            set s__Pressure_onSecondFx[this]=R2I(WizardFireSpells__PR_TIME_BETWEEN_MISSILES * 32 + addTo)
            set s__Pressure_onSecondDmg[this]=R2I(WizardFireSpells__PR_TIME_BETWEEN_MISSILES * 32 + WizardFireSpells__PR_DAMAGE_DELAY * 32 + addTo)
            set s__Pressure_onThirdFx[this]=R2I(WizardFireSpells__PR_TIME_BETWEEN_MISSILES * 64 + addTo)
            set s__Pressure_onThirdDmg[this]=R2I(WizardFireSpells__PR_TIME_BETWEEN_MISSILES * 64 + WizardFireSpells__PR_DAMAGE_DELAY * 32 + addTo)
            set s__Pressure_onFourthFx[this]=R2I(WizardFireSpells__PR_TIME_BETWEEN_MISSILES * 96 + addTo)
            set s__Pressure_onFourthDmg[this]=R2I(WizardFireSpells__PR_TIME_BETWEEN_MISSILES * 96 + WizardFireSpells__PR_DAMAGE_DELAY * 32 + addTo)
            set s__Pressure_onFifthFx[this]=R2I(WizardFireSpells__PR_TIME_BETWEEN_MISSILES * 128 + addTo)
            set s__Pressure_onFifthDmg[this]=R2I(WizardFireSpells__PR_TIME_BETWEEN_MISSILES * 128 + WizardFireSpells__PR_DAMAGE_DELAY * 32 + addTo)
            set s__Pressure_tick[this]=0
                call s__Pressure_add(this)
        endfunction
        
        
    
    
//Implemented from module Alloc:
    
    function s__FlameConjuration_allocate takes nothing returns integer
        local integer this= s__FlameConjuration_Alloc___recycler[0]
        
        
        if ( this == 0 ) then
        
            set this=s__FlameConjuration_Alloc___instanceCount + 1
            set s__FlameConjuration_Alloc___instanceCount=this
        else
            set s__FlameConjuration_Alloc___recycler[0]=s__FlameConjuration_Alloc___recycler[this]
        endif
        
        
        return this
    endfunction
    
    function s__FlameConjuration_deallocate takes integer this returns nothing
        
        
        set s__FlameConjuration_Alloc___recycler[this]=s__FlameConjuration_Alloc___recycler[0]
        set s__FlameConjuration_Alloc___recycler[0]=this
    endfunction
        
        
        function s__FlameConjuration_doesUnitHavePhoenix takes unit u returns boolean
            return s__FlameConjuration_caster[s__FlameConjuration_forUnit[GetUnitUserData(u)]] == u
        endfunction
        
        function s__FlameConjuration_getUnitPhoenix takes unit u returns unit
            return s__FlameConjuration_dummy[s__FlameConjuration_forUnit[GetUnitUserData(u)]]
        endfunction
        
        function s__FlameConjuration_onLoop takes integer this returns boolean
            call SetUnitFacing(s__FlameConjuration_dummy[this], GetUnitFacing(s__FlameConjuration_caster[this]))
            call SetUnitX(s__FlameConjuration_dummy[this], GetUnitX(s__FlameConjuration_caster[this]) + ( WizardFireSpells__FC_DISTANCE * Cos(GetUnitFacing(s__FlameConjuration_caster[this]) * bj_DEGTORAD + bj_PI / 2) ))
            call SetUnitY(s__FlameConjuration_dummy[this], GetUnitY(s__FlameConjuration_caster[this]) + ( WizardFireSpells__FC_DISTANCE * Sin(GetUnitFacing(s__FlameConjuration_caster[this]) * bj_DEGTORAD + bj_PI / 2) ))
            set s__FlameConjuration_tick[this]=s__FlameConjuration_tick[this] + 1
            return s__FlameConjuration_tick[this] != s__FlameConjuration_finalTick[this]
        endfunction
        
        function s__FlameConjuration_onExpire takes integer this returns nothing
            set s__FlameConjuration_caster[this]=null
            call KillUnit(s__FlameConjuration_dummy[this])
            set s__FlameConjuration_dummy[this]=null
            call s__FlameConjuration_deallocate(this)
        endfunction
//Implemented from module T32Interface:
        
        function s__FlameConjuration_T32Interface___onInit takes nothing returns nothing
            set s__FlameConjuration_T32Interface___timers=(CTL___A((function sc__FlameConjuration_T32Interface___expire))) // INLINED!!
        endfunction
        
        function s__FlameConjuration_T32Interface___expire takes nothing returns nothing
            local integer i= 0
            local integer array recycle
            local integer recycleCount= 0
            local integer temp
            local boolean running= false
            loop
                exitwhen s__FlameConjuration_T32Interface___list[i] == 0
                if not s__FlameConjuration_onLoop(s__FlameConjuration_T32Interface___list[i]) then
                   set recycle[recycleCount]=s__FlameConjuration_T32Interface___list[i]
                   set recycleCount=recycleCount + 1
                   call s__FlameConjuration_onExpire(s__FlameConjuration_T32Interface___list[i])
                else
                    set running=true
                endif
                set i=i + 1
            endloop
            if recycleCount != 0 then
                set i=0
                loop
                    exitwhen recycle[i] == 0
                    set temp=recycle[i]
                    set s__FlameConjuration_recyclePosition[s__FlameConjuration_T32Interface___list[s__FlameConjuration_T32Interface___count]]=s__FlameConjuration_recyclePosition[temp]
                    set s__FlameConjuration_T32Interface___list[s__FlameConjuration_recyclePosition[temp]]=s__FlameConjuration_T32Interface___list[s__FlameConjuration_T32Interface___count]
                    set s__FlameConjuration_T32Interface___list[s__FlameConjuration_T32Interface___count]=0
                    //call temp.deallocate()
                    set s__FlameConjuration_T32Interface___count=s__FlameConjuration_T32Interface___count - 1
                    set i=i + 1
                endloop
            endif
            if not running then
                call CTL___SR32((s__FlameConjuration_T32Interface___timers)) // INLINED!!
            endif
        endfunction
        
        function s__FlameConjuration_add takes integer this returns nothing
            local integer i= 0
            loop
                exitwhen s__FlameConjuration_T32Interface___list[i] == 0
                set i=i + 1
            endloop
            set s__FlameConjuration_T32Interface___list[i]=this
            set s__FlameConjuration_recyclePosition[this]=i
            set s__FlameConjuration_T32Interface___count=s__FlameConjuration_T32Interface___count + 1
            call CTL___A32((s__FlameConjuration_T32Interface___timers)) // INLINED!!
        endfunction
        
        function s__FlameConjuration_create takes unit u returns integer
            local integer this= s__FlameConjuration_allocate()
            set s__FlameConjuration_caster[this]=u
            set s__FlameConjuration_dummy[this]=CreateUnit(GetOwningPlayer(u), WizardFireSpells__FC_DUMMY, 0, 0, 0)
            set s__FlameConjuration_forUnit[GetUnitUserData(u)]=this
            set s__FlameConjuration_finalTick[this]=R2I(( WizardFireSpells__FC_DURATION + ( WizardFireSpells__FC_DURATION_FACTOR * I2R(GetUnitAbilityLevel(u, WizardFireSpells__FC_ID)) ) ) * 32)
            set s__FlameConjuration_tick[this]=0
            call s__FlameConjuration_add(this)
            return this
        endfunction
    
//Implemented from module Alloc:
    
    function s__PhoenixBarrage_allocate takes nothing returns integer
        local integer this= s__PhoenixBarrage_Alloc___recycler[0]
        
        
        if ( this == 0 ) then
        
            set this=s__PhoenixBarrage_Alloc___instanceCount + 1
            set s__PhoenixBarrage_Alloc___instanceCount=this
        else
            set s__PhoenixBarrage_Alloc___recycler[0]=s__PhoenixBarrage_Alloc___recycler[this]
        endif
        
        
        return this
    endfunction
    
    function s__PhoenixBarrage_deallocate takes integer this returns nothing
        
        
        set s__PhoenixBarrage_Alloc___recycler[this]=s__PhoenixBarrage_Alloc___recycler[0]
        set s__PhoenixBarrage_Alloc___recycler[0]=this
    endfunction
        
        function s__PhoenixBarrage_onFinish takes integer this returns boolean
            local real shotAngle= (GetRandomReal(- bj_PI, bj_PI)) // INLINED!!
            local integer data
            local real diffx
            local real targx
            local real targy
            local real diffy
            local real dist
            local real angle
            local real r
            local integer root= this
            local integer toShoot
            local group g
            local unit toHit
            local unit toHit2
            set data=s__Missile_data2[this]
            set this=s__Missile_data[root]
            
            //boom
            set g=CreateGroup()
            call GroupEnumUnitsInRange(g, s__Missile_x[root], s__Missile_y[root], WizardFireSpells__PB_AOE, s__PhoenixBarrage_filter[this])
            call DestroyEffect(AddSpecialEffect(WizardFireSpells__PB_BOOM, s__Missile_x[root], s__Missile_y[root]))
            set toHit=FirstOfGroup(g)
            loop
                exitwhen toHit == null
                call spellDamage(s__PhoenixBarrage_caster[this] , toHit , s__PhoenixBarrage_dmg[this])
                call GroupRemoveUnit(g, toHit)
                set toHit=FirstOfGroup(g)
            endloop
            call DestroyGroup(g)
            
            if data == WizardFireSpells__PB_NUM_SPLITS then
                return true
            else
                set data=data + 1
            endif
            
            set g=CreateGroup()
            
            call GroupEnumUnitsInRange(g, s__PhoenixBarrage_targetX[this], s__PhoenixBarrage_targetY[this], WizardFireSpells__PB_SEARCH, s__PhoenixBarrage_filter[this])
            set toHit=RandomUnitFromGroup(g)
            
            if toHit != null then
                set targx=GetUnitX(toHit) + GetRandomInt(0, 200) - 100
                set targy=GetUnitY(toHit) + GetRandomInt(0, 200) - 100
            else
                set angle=(GetRandomReal(- bj_PI, bj_PI)) // INLINED!!
                set r=GetRandomReal(1, WizardFireSpells__PB_SEARCH)
                set targx=( s__PhoenixBarrage_targetX[this] + r * Cos(angle) )
                set targy=( s__PhoenixBarrage_targetY[this] + r * Sin(angle) )
            endif
            set diffx=targx - s__Missile_x[root]
            set diffy=targy - s__Missile_y[root]
            set angle=Atan2(diffy, diffx)
            set dist=RMaxBJ(SquareRoot(diffx * diffx + diffy * diffy), 50)
            set toShoot=s__Missile_create(s__Missile_x[root] , s__Missile_y[root] , 0 , angle , dist , 0)
            call s__Missile__set_model(toShoot,WizardFireSpells__PB_FX)
            set s__Missile_speed[toShoot]=( dist / WizardFireSpells__PB_OPTIMAL_TIME ) / 32 * GetRandomReal(0.7, 1.4)
            set s__Missile_collision[toShoot]=0
            set s__Missile_data[toShoot]=this
            set s__Missile_data2[toShoot]=data
            call s__Missile__set_arc(toShoot,1.4)
            set s__Missile_source[toShoot]=s__PhoenixBarrage_caster[this]
            call sc__PhoenixBarrage_launch(toShoot)

            //set toHit = RandomUnitFromGroup(g,false)
            set toHit=null
            if toHit != null then
                set diffx=GetUnitX(toHit) - s__Missile_x[root]
                set diffy=GetUnitY(toHit) - s__Missile_y[root]
            else
                set angle=(GetRandomReal(- bj_PI, bj_PI)) // INLINED!!
                set r=GetRandomReal(1, WizardFireSpells__PB_SEARCH)
                set diffx=( s__PhoenixBarrage_targetX[this] + r * Cos(angle) ) - s__Missile_x[root]
                set diffy=( s__PhoenixBarrage_targetY[this] + r * Sin(angle) ) - s__Missile_y[root]
            endif
            set angle=Atan2(diffy, diffx)
            set dist=RMaxBJ(SquareRoot(diffx * diffx + diffy * diffy), 50)
            set toShoot=s__Missile_create(s__Missile_x[root] , s__Missile_y[root] , 0 , angle , dist , 0)
            call s__Missile__set_model(toShoot,WizardFireSpells__PB_FX)
            set s__Missile_speed[toShoot]=( dist / WizardFireSpells__PB_OPTIMAL_TIME ) / 32 * GetRandomReal(0.7, 1.4)
            set s__Missile_collision[toShoot]=0
            set s__Missile_data[toShoot]=this
            set s__Missile_data2[toShoot]=data
            call s__Missile__set_arc(toShoot,1.4)
            set s__Missile_source[toShoot]=s__PhoenixBarrage_caster[this]
            call sc__PhoenixBarrage_launch(toShoot)
            if toHit != null then
            //    set toShoot.target      = toHit
            endif

            
            set toHit=null
            set toHit2=null
            call DestroyGroup(g)
            return true
        endfunction
        
//Implemented from module MissileStruct:
        
        function s__PhoenixBarrage_MissileStruct___missileTerminate takes integer this returns nothing
            if s__Missile_terminated[this] then
                return
            endif
            set s__Missile_terminated[this]=true



            call s__Missile_terminate(this)
            call Missile___StopPeriodic(si__PhoenixBarrage)
        endfunction
        
        function s__PhoenixBarrage_unpin takes integer this returns nothing
            call s__Missile_removeNode(this)
            call Missile___StopPeriodic(si__PhoenixBarrage)
        endfunction




















        //***********************************************************************
        //  First it takes the struct's first instance, which is the next to the
        //  head (NODE[thistype.typeid].next) and starts iterating through it until it hits
        //  the head again. Then checks if the missile is marked for recycling,
        //  if so it runs the methods and destroys the missile.
        function s__PhoenixBarrage_MissileStruct___missileIterate takes nothing returns nothing
            local unit u
            local boolean finished= false
            local integer this= s__Missile_next[Missile___NODE[si__PhoenixBarrage]]
            call s__Missile_move(this)
            loop
                exitwhen s__Missile_head[this]
                
                if s__Missile_wantDestroy[this] then

                        call s__PhoenixBarrage_onFinish(this)

                    call s__PhoenixBarrage_MissileStruct___missileTerminate(this)
                    
                else
                    if s__Missile_recycle[this] then
























                                if s__PhoenixBarrage_onFinish(this) then
                                    call s__PhoenixBarrage_MissileStruct___missileTerminate(this)
                                else
                                    set s__Missile_recycle[this]=false
                                endif




                    else















                    endif
                endif
                



                





                
                set this=s__Missile_next[this]
            endloop
            
            set u=null
        endfunction
        
        function s__PhoenixBarrage_launch takes integer this returns nothing
            call Missile___StartPeriodic(si__PhoenixBarrage)
            call s__Missile_insertNode(Missile___NODE[si__PhoenixBarrage],this)
        endfunction
        
        function s__PhoenixBarrage_MissileStruct___onInit takes nothing returns nothing
            set Missile___NODE[si__PhoenixBarrage]=s__Missile_createNode()
            set Missile___TIMER[si__PhoenixBarrage]=(CTL___A((function s__PhoenixBarrage_MissileStruct___missileIterate))) // INLINED!!
        endfunction
        
        function s__PhoenixBarrage_onTimerExpire takes integer this returns nothing
            set s__PhoenixBarrage_caster[this]=null
            set s__PhoenixBarrage_filter[this]=null
            call s__PhoenixBarrage_deallocate(this)
        endfunction
//Implemented from module FAT:
    function s__PhoenixBarrage_FAT___p_onExpire takes nothing returns nothing
        local integer this= TimerDetach(GetExpiredTimer())
        call s__PhoenixBarrage_onTimerExpire(this)
        //set this = 0
        call DestroyTimer(GetExpiredTimer())
    endfunction
    
    function s__PhoenixBarrage_runTime takes real time,integer this returns nothing
        local timer t= CreateTimer()
        call SaveInteger(Table___ht, (BaseFunction__timers), (GetHandleId((t ))), ( ( this))) // INLINED!!
        call TimerStart(t, time, false, function s__PhoenixBarrage_FAT___p_onExpire)
        set t=null
    endfunction
        function s__PhoenixBarrage_create takes unit source returns integer
            local integer this= s__PhoenixBarrage_allocate()
            local real casx= GetUnitX(source)
            local real casy= GetUnitY(source)
            local integer m
            local real xdiff= casx - GetSpellTargetX()
            local real ydiff= casy - GetSpellTargetY()
            local real dist= SquareRoot(xdiff * xdiff + ydiff * ydiff)
            set s__PhoenixBarrage_caster[this]=source
            set s__PhoenixBarrage_filter[this]=getTargetFilter(GetOwningPlayer(source))
            set s__PhoenixBarrage_lvl[this]=GetUnitAbilityLevel(source, WizardFireSpells__PB_ID)
            set s__PhoenixBarrage_targetX[this]=GetSpellTargetX()
            set s__PhoenixBarrage_targetY[this]=GetSpellTargetY()
            set s__PhoenixBarrage_dmg[this]=( WizardFireSpells__PB_DMG + ( WizardFireSpells__PB_DMG_FACTOR * s__PhoenixBarrage_lvl[this] ) ) * GetHeroInt(s__PhoenixBarrage_caster[this], true)
            //---------------------------------------------------------
            set m=s__Missile_create(casx , casy , 0 , GetUnitFacing(source) * bj_DEGTORAD , dist , 0)
            
            call s__Missile__set_model(m,WizardFireSpells__PB_FX)
            set s__Missile_speed[m]=( dist / WizardFireSpells__PB_OPTIMAL_TIME ) / 32 * GetRandomReal(0.7, 1.4)
            set s__Missile_collision[m]=0
            set s__Missile_data[m]=this
            set s__Missile_data2[m]=0
            call s__Missile__set_arc(m,1.1)
            set s__Missile_source[m]=source
            if GetSpellTargetUnit() != null then
             //   set m.target = GetSpellTargetUnit()
            endif
            call s__PhoenixBarrage_runTime(50 , this)
            call s__PhoenixBarrage_launch(m)
            return this
        endfunction
    
    function WizardFireSpells__OnSpell takes nothing returns boolean
        local integer id= GetSpellAbilityId()
        local unit c= GetTriggerUnit()
        local unit b
        if s__FlameConjuration_doesUnitHavePhoenix(c) then
            set b=(s__FlameConjuration_dummy[s__FlameConjuration_forUnit[GetUnitUserData((c))]]) // INLINED!!
            if id == WizardFireSpells__FB_ID then
                call SetUnitAnimation(b, "attack")
                call s__Firebomb_shoot(GetTriggerUnit() , GetSpellTargetX() , GetSpellTargetY() , false)
                call s__Firebomb_shoot(b , GetSpellTargetX() , GetSpellTargetY() , true)
            elseif id == WizardFireSpells__PR_ID then
                call SetUnitAnimation(b, "attack")
                call s__Pressure_onSpell(GetTriggerUnit() , GetSpellTargetX() , GetSpellTargetY() , false)
                call s__Pressure_onSpell(b , GetSpellTargetX() , GetSpellTargetY() , true)
            elseif id == WizardFireSpells__FW_ID then
                call SetUnitAnimation(b, "attack")
                call s__FlameWave_shoot(GetTriggerUnit() , GetSpellTargetX() , GetSpellTargetY() , false)
                call s__FlameWave_shoot(b , GetSpellTargetX() , GetSpellTargetY() , true)
            elseif id == WizardFireSpells__PB_ID then
                call s__PhoenixBarrage_create(GetTriggerUnit())
            //elseif id == FC_ID then
            //    call FlameConjuration.create(GetTriggerUnit())
            endif
        else
            //set b = FlameConjuration.getUnitPhoenix(c)
            if id == WizardFireSpells__FB_ID then
                call s__Firebomb_shoot(GetTriggerUnit() , GetSpellTargetX() , GetSpellTargetY() , false)
            elseif id == WizardFireSpells__PR_ID then
                call s__Pressure_onSpell(GetTriggerUnit() , GetSpellTargetX() , GetSpellTargetY() , false)
            elseif id == WizardFireSpells__FW_ID then
                call s__FlameWave_shoot(GetTriggerUnit() , GetSpellTargetX() , GetSpellTargetY() , false)
            elseif id == WizardFireSpells__FC_ID then
                call s__FlameConjuration_create(GetTriggerUnit())
            elseif id == WizardFireSpells__PB_ID then
                call s__PhoenixBarrage_create(GetTriggerUnit())
            endif
        endif
        set c=null
        set b=null
        return false
    endfunction
    
    function WizardFireSpells__onInit takes nothing returns nothing
    
        local trigger trig= CreateTrigger()
        
        call TriggerRegisterAnyUnitEventBJ(trig, EVENT_PLAYER_UNIT_SPELL_EFFECT)
        call TriggerAddCondition(trig, Condition(function WizardFireSpells__OnSpell))
        set trig=null
        set s__BurningSoul_perHeroInstances=s__Table_create() // INLINED!!
    endfunction

//library WizardFireSpells ends
//library WizardForceSpells:
    
//Implemented from module Alloc:
    
    function s__ForceBall_allocate takes nothing returns integer
        local integer this= s__ForceBall_Alloc___recycler[0]
        
        
        if ( this == 0 ) then
        
            set this=s__ForceBall_Alloc___instanceCount + 1
            set s__ForceBall_Alloc___instanceCount=this
        else
            set s__ForceBall_Alloc___recycler[0]=s__ForceBall_Alloc___recycler[this]
        endif
        
        
        return this
    endfunction
    
    function s__ForceBall_deallocate takes integer this returns nothing
        
        
        set s__ForceBall_Alloc___recycler[this]=s__ForceBall_Alloc___recycler[0]
        set s__ForceBall_Alloc___recycler[0]=this
    endfunction
    
    
//Implemented from module Alloc:
    
    function s__ForceWall_allocate takes nothing returns integer
        local integer this= s__ForceWall_Alloc___recycler[0]
        
        
        if ( this == 0 ) then
        
            set this=s__ForceWall_Alloc___instanceCount + 1
            set s__ForceWall_Alloc___instanceCount=this
        else
            set s__ForceWall_Alloc___recycler[0]=s__ForceWall_Alloc___recycler[this]
        endif
        
        
        return this
    endfunction
    
    function s__ForceWall_deallocate takes integer this returns nothing
        
        
        set s__ForceWall_Alloc___recycler[this]=s__ForceWall_Alloc___recycler[0]
        set s__ForceWall_Alloc___recycler[0]=this
    endfunction
    
    
//Implemented from module Alloc:
    
    function s__ForceBarrage_allocate takes nothing returns integer
        local integer this= s__ForceBarrage_Alloc___recycler[0]
        
        
        if ( this == 0 ) then
        
            set this=s__ForceBarrage_Alloc___instanceCount + 1
            set s__ForceBarrage_Alloc___instanceCount=this
        else
            set s__ForceBarrage_Alloc___recycler[0]=s__ForceBarrage_Alloc___recycler[this]
        endif
        
        
        return this
    endfunction
    
    function s__ForceBarrage_deallocate takes integer this returns nothing
        
        
        set s__ForceBarrage_Alloc___recycler[this]=s__ForceBarrage_Alloc___recycler[0]
        set s__ForceBarrage_Alloc___recycler[0]=this
    endfunction
        
    
//Implemented from module Alloc:
    
    function s__Powerstone_allocate takes nothing returns integer
        local integer this= s__Powerstone_Alloc___recycler[0]
        
        
        if ( this == 0 ) then
        
            set this=s__Powerstone_Alloc___instanceCount + 1
            set s__Powerstone_Alloc___instanceCount=this
        else
            set s__Powerstone_Alloc___recycler[0]=s__Powerstone_Alloc___recycler[this]
        endif
        
        
        return this
    endfunction
    
    function s__Powerstone_deallocate takes integer this returns nothing
        
        
        set s__Powerstone_Alloc___recycler[this]=s__Powerstone_Alloc___recycler[0]
        set s__Powerstone_Alloc___recycler[0]=this
    endfunction
        
    
//Implemented from module Alloc:
    
    function s__EnergyTap_allocate takes nothing returns integer
        local integer this= s__EnergyTap_Alloc___recycler[0]
        
        
        if ( this == 0 ) then
        
            set this=s__EnergyTap_Alloc___instanceCount + 1
            set s__EnergyTap_Alloc___instanceCount=this
        else
            set s__EnergyTap_Alloc___recycler[0]=s__EnergyTap_Alloc___recycler[this]
        endif
        
        
        return this
    endfunction
    
    function s__EnergyTap_deallocate takes integer this returns nothing
        
        
        set s__EnergyTap_Alloc___recycler[this]=s__EnergyTap_Alloc___recycler[0]
        set s__EnergyTap_Alloc___recycler[0]=this
    endfunction
        
    
    function WizardForceSpells__onInit takes nothing returns nothing
    
    endfunction

//library WizardForceSpells ends
//library qqinit:
function Trig_esc_Conditions takes nothing returns boolean
    if ( not ( IsPlayerInForce(GetTriggerPlayer(), udg_Select_PlayerGroup) == true ) ) then
        return false
    endif
    return true
endfunction

function Trig_esc_Actions takes nothing returns nothing
    local unit u
    
    set udg_TempLoc=GetUnitLoc(gg_unit_ncp3_0027)
    call ResetToGameCameraForPlayer(GetTriggerPlayer(), 0)
    call PanCameraToTimedLocForPlayer(GetTriggerPlayer(), udg_TempLoc, 0)
    call CreateNUnitsAtLoc(1, GetUnitTypeId(udg_Select_Hero[udg_Select_Current[GetConvertedPlayerId(GetTriggerPlayer())]]), GetTriggerPlayer(), udg_TempLoc, bj_UNIT_FACING)
    set udg_PlayerUnit[GetConvertedPlayerId(GetTriggerPlayer())]=GetLastCreatedUnit()
    set u=GetLastCreatedUnit()
        call UnitAddItemToSlotById(GetLastCreatedUnit(), 'I00I', 5)
    call s__CustomInventory_generateNewItem(CreateItem('I00S', 1, 1) , u)
    call s__CustomInventory_generateNewItem(CreateItem('I004', 1, 1) , u)
    call s__CustomInventory_generateNewItem(CreateItem('I00K', 1, 1) , u)
    call s__CustomInventory_generateNewItem(CreateItem('I00H', 1, 1) , u)
    call s__CustomInventory_generateNewItem(CreateItem('I00J', 1, 1) , u)
    if GetUnitTypeId(u) == 'H010' or GetUnitTypeId(u) == 'H003' then
    call s__CustomInventory_generateNewItem(CreateItem('I002', 1, 1) , u)
    
    elseif GetUnitTypeId(u) == 'H005' or GetUnitTypeId(u) == 'H013' then
    call s__CustomInventory_generateNewItem(CreateItem('I00O', 1, 1) , u)
    
    elseif GetUnitTypeId(u) == 'H006' then
    call s__CustomInventory_generateNewItem(CreateItem('I00F', 1, 1) , u)
    call s__CustomInventory_generateNewItem(CreateItem('I00G', 1, 1) , u)
    
    endif
    call RemoveLocation(udg_TempLoc)
    call ClearTextMessagesBJ(GetForceOfPlayer(GetTriggerPlayer()))
    call ForceRemovePlayerSimple(GetTriggerPlayer(), udg_Select_PlayerGroup)
endfunction

//===========================================================================
function InitTrig_esc takes nothing returns nothing
    set gg_trg_esc=CreateTrigger()
    call TriggerAddCondition(gg_trg_esc, Condition(function Trig_esc_Conditions))
    call TriggerAddAction(gg_trg_esc, function Trig_esc_Actions)
endfunction


//library qqinit ends
//library DamageEventModification:

//library DamageEventModification ends
//library DamageEventArchetype:


//library DamageEventArchetype ends
//===========================================================================
// 
// |cff000000Fable of Elohim|r v0.4
// 
//   Warcraft III map script
//   Generated by the Warcraft III World Editor
//   Date: Thu Jun 11 22:36:54 2015
//   Map Author: Arhowk
// 
//===========================================================================

//***************************************************************************
//*
//*  Global Variables
//*
//***************************************************************************


function InitGlobals takes nothing returns nothing
    local integer i= 0
    set udg_DamageEventAmountDummy=0
    set udg_DamageEventAmount=0
    set udg_HeatedBladeBool=false
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_HeatedBladeAvailable[i]=false
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_HeatedBladeTimer[i]=CreateTimer()
        set i=i + 1
    endloop

    set udg_DamageEventType=0
    set udg_Temp_Integer=0
    set udg_ShowCriticalText=false
    set udg_DamageModifierEvent=0
    set udg_DamageEvent=0
    set udg_DamageTypeSpell=0
    set udg_DamageTypeDOT=0
    set udg_DamageTypeRanged=0
    set udg_DmgEvN=0
    set udg_DamageEventPrevAmt=0
    set udg_DamageEventExplodesUnit=false
    set udg_DamageEventOverride=false
    set udg_DmgEvLife=0
    set udg_DmgTypPrev=0
    set udg_UDex=0
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_UnitDamageRegistered[i]=false
        set i=i + 1
    endloop

    set udg_DamageEventsWasted=0
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_UDexNext[i]=0
        set i=i + 1
    endloop

    set udg_UnitIndexEvent=0
    set udg_UnitIndexerEnabled=false
    set udg_DmgEvTimer=CreateTimer()
    set udg_BackpackTimer=CreateTimer()
    set udg_TempBool=false
    set udg_Temp_UnitGroup=CreateGroup()
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_UnitIndexLock[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_UDexPrev[i]=0
        set i=i + 1
    endloop

    set udg_UDexRecycle=0
    set udg_UDexWasted=0
    set udg_UDexGen=0
    set udg_CreepTableBool=false
    set udg_CurrentGameTime=0
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_ElectricityLastHit[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_ElectrictyHitCount[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_TestVariable[i]=0
        set i=i + 1
    endloop

    set udg_DumTimer=CreateTimer()
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_PW_Index[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_PW_WaveInteger[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_PW_Integer[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_PW_Damage[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_PW_Real[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_PW_TempGroup[i]=CreateGroup()
        set i=i + 1
    endloop

    set udg_Item_Boolean=false
    set udg_TempStr=""
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_Select_HeroName[i]=""
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_Select_HeroDescription[i]=""
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_Select_HeroRole[i]=""
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_Select_HeroAbilties[i]=""
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_Select_Evolutions[i]=""
        set i=i + 1
    endloop

    set udg_Select_Hint=""
    set udg_Select_PlayerGroup=CreateForce()
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_Select_HeroActive[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_Select_Current[i]=0
        set i=i + 1
    endloop

    set udg_TBOOL=0
    set udg_TASduration=0
    set udg_TASrefresh=false
    set udg_TASmaxstack=0
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_TASdur[i]=0
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_TASend[i]=false
        set i=i + 1
    endloop

    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_TASids[i]=0
        set i=i + 1
    endloop

    set udg_TASindex=0
    set i=0
    loop
        exitwhen ( i > 1 )
        set udg_TASref[i]=false
        set i=i + 1
    endloop

    set udg_TAStimer=CreateTimer()
    set udg_BTimerRed=CreateTimer()
    set udg_BTimerBlue=CreateTimer()
    set udg_BTimerTeal=CreateTimer()
    set udg_BTimerPurple=CreateTimer()
    set udg_BTimerYellow=CreateTimer()
    set udg_BTimerOrange=CreateTimer()
    set udg_BTimerGreen=CreateTimer()
    set udg_BTimerPink=CreateTimer()
    set udg_BTimerGray=CreateTimer()
    set udg_BTimerLB=CreateTimer()
endfunction

//***************************************************************************
//*
//*  Destructable Objects
//*
//***************************************************************************

function CreateAllDestructables takes nothing returns nothing
    local destructable d
    local trigger t
    local real life
    set gg_dest_B010_13377=CreateDestructable('B010', 30528.0, 26688.0, 270.000, 1.000, 0)
    set gg_dest_B010_12894=CreateDestructable('B010', 27008.0, 30784.0, 270.000, 1.250, 0)
    set gg_dest_B010_0883=CreateDestructable('B010', 30528.0, 27328.0, 270.000, 1.000, 0)
    set gg_dest_B010_12864=CreateDestructable('B010', 28224.0, 30784.0, 270.000, 1.250, 0)
    set gg_dest_B010_12893=CreateDestructable('B010', 26880.0, 30784.0, 270.000, 1.250, 0)
endfunction

//***************************************************************************
//*
//*  Unit Creation
//*
//***************************************************************************

//===========================================================================
function CreateUnitsForPlayer0 takes nothing returns nothing
    local player p= Player(0)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u=CreateUnit(p, 'hwat', 5787.8, - 19612.0, 265.822)
    set u=CreateUnit(p, 'hwat', 5732.4, - 20657.2, 151.473)
    set u=CreateUnit(p, 'hwat', 5766.7, - 19679.1, 230.412)
    set u=CreateUnit(p, 'hwat', 5763.7, - 19753.7, 54.944)
    set u=CreateUnit(p, 'hwat', 5762.1, - 19916.0, 253.374)
    set u=CreateUnit(p, 'hwat', 5753.1, - 19993.9, 94.650)
    set u=CreateUnit(p, 'hwat', 5744.2, - 20087.7, 347.310)
    set u=CreateUnit(p, 'hwat', 5737.8, - 20189.8, 149.276)
    set u=CreateUnit(p, 'hwat', 5729.8, - 20262.3, 79.928)
    set u=CreateUnit(p, 'hwat', 5722.1, - 20380.8, 141.717)
    set u=CreateUnit(p, 'hwat', 5707.7, - 20483.1, 134.828)
    set u=CreateUnit(p, 'hwat', 5760.6, - 20588.3, 308.253)
    set u=CreateUnit(p, 'hwat', 5847.2, - 20670.0, 244.310)
    set u=CreateUnit(p, 'hwat', 5926.5, - 20715.9, 82.817)
    set u=CreateUnit(p, 'hwat', 5992.8, - 20743.1, 13.481)
    set u=CreateUnit(p, 'hwat', 6085.1, - 20758.1, 17.952)
    set u=CreateUnit(p, 'hwat', 6149.7, - 20758.1, 182.774)
    set u=CreateUnit(p, 'hwat', 6233.2, - 20752.1, 263.845)
    set u=CreateUnit(p, 'hwat', 6354.8, - 20743.1, 299.013)
    set gg_unit_h009_0227=CreateUnit(p, 'h009', 28529.6, 22240.3, 189.366)
    set u=CreateUnit(p, 'hwat', 6477.1, - 20728.1, 68.128)
    set u=CreateUnit(p, 'hwat', 6582.3, - 20657.6, 101.297)
    set u=CreateUnit(p, 'hwat', 6629.4, - 20546.5, 69.930)
    set u=CreateUnit(p, 'hwat', 6735.3, - 20284.4, 136.092)
    set u=CreateUnit(p, 'hsor', - 18474.1, - 12705.4, 309.319)
    set u=CreateUnit(p, 'hwat', 6780.0, - 20160.2, 279.819)
    set u=CreateUnit(p, 'hwat', 6810.9, - 20065.3, 185.543)
    set u=CreateUnit(p, 'hwat', 6836.4, - 19939.1, 171.073)
    set u=CreateUnit(p, 'h004', 30302.4, 30975.2, 1.956)
    set u=CreateUnit(p, 'h004', 30160.9, 30976.6, 294.893)
    set gg_unit_h00Y_0504=CreateUnit(p, 'h00Y', 30761.7, 30589.2, 279.215)
    set gg_unit_h00Y_0505=CreateUnit(p, 'h00Y', 30227.8, 30938.3, 267.075)
    set gg_unit_h00Y_0506=CreateUnit(p, 'h00Y', 29616.0, 30419.3, 282.434)
    set gg_unit_h00Y_0515=CreateUnit(p, 'h00Y', 30763.0, 30046.4, 117.502)
    set u=CreateUnit(p, 'h00E', - 23570.4, - 25587.3, 22.973)
    set gg_unit_h00Y_0526=CreateUnit(p, 'h00Y', 30238.4, 29519.6, 16.304)
    set u=CreateUnit(p, 'hwat', 6863.6, - 19802.9, 348.134)
    set u=CreateUnit(p, 'hwat', 6879.3, - 19686.8, 178.819)
    set u=CreateUnit(p, 'hwat', 6894.1, - 19611.3, 240.981)
    set u=CreateUnit(p, 'hwat', 6977.4, - 19601.0, 213.800)
    set u=CreateUnit(p, 'hwat', 6930.9, - 19875.9, 194.563)
    set u=CreateUnit(p, 'hwat', 6923.8, - 19955.2, 331.951)
    set u=CreateUnit(p, 'hwat', 6913.7, - 20040.9, 350.771)
    set u=CreateUnit(p, 'hwat', 6900.6, - 20165.1, 320.866)
    set u=CreateUnit(p, 'hfoo', - 18101.1, - 19906.7, 267.420)
    set u=CreateUnit(p, 'hwat', 6894.2, - 20326.7, 36.520)
    set u=CreateUnit(p, 'hwat', 6891.1, - 20424.8, 139.794)
    set u=CreateUnit(p, 'hwat', 6914.0, - 20648.9, 265.822)
    set u=CreateUnit(p, 'hwat', 6967.8, - 20706.4, 101.726)
    set u=CreateUnit(p, 'hwat', 7193.3, - 20749.5, 239.641)
    set u=CreateUnit(p, 'hwat', 7324.8, - 20765.9, 217.118)
    set u=CreateUnit(p, 'hwat', 7417.1, - 20772.4, 232.291)
    set u=CreateUnit(p, 'hwat', 7688.3, - 20757.1, 275.293)
    set u=CreateUnit(p, 'hwat', 7783.3, - 20760.3, 322.360)
    set u=CreateUnit(p, 'hwat', 7911.3, - 20607.6, 262.955)
    set u=CreateUnit(p, 'hwat', 7954.9, - 20445.8, 23.292)
    set u=CreateUnit(p, 'hsor', 28907.3, 26698.9, 184.400)
    set u=CreateUnit(p, 'hwat', 7974.4, - 20346.2, 184.642)
    set u=CreateUnit(p, 'hwat', 7992.6, - 20227.4, 66.678)
    set u=CreateUnit(p, 'hwat', 8116.5, - 19856.8, 253.836)
    set u=CreateUnit(p, 'hphx', 7484.6, - 20559.4, 24.193)
    set u=CreateUnit(p, 'hphx', 6186.2, - 20519.5, 271.689)
endfunction

//===========================================================================
function CreateUnitsForPlayer1 takes nothing returns nothing
    local player p= Player(1)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set gg_unit_h009_0232=CreateUnit(p, 'h009', 28565.4, 21481.5, 122.330)
endfunction

//===========================================================================
function CreateUnitsForPlayer2 takes nothing returns nothing
    local player p= Player(2)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set gg_unit_h009_0228=CreateUnit(p, 'h009', 28550.1, 20711.0, 61.720)
endfunction

//===========================================================================
function CreateUnitsForPlayer3 takes nothing returns nothing
    local player p= Player(3)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set gg_unit_h009_0229=CreateUnit(p, 'h009', 29295.2, 22273.1, 298.930)
endfunction

//===========================================================================
function CreateUnitsForPlayer4 takes nothing returns nothing
    local player p= Player(4)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set gg_unit_h009_0226=CreateUnit(p, 'h009', 30080.7, 22264.3, 232.250)
endfunction

//===========================================================================
function CreateUnitsForPlayer5 takes nothing returns nothing
    local player p= Player(5)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set gg_unit_h009_0230=CreateUnit(p, 'h009', 29289.8, 20739.9, 211.480)
endfunction

//===========================================================================
function CreateUnitsForPlayer6 takes nothing returns nothing
    local player p= Player(6)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set gg_unit_h009_0225=CreateUnit(p, 'h009', 29999.1, 20912.4, 46.370)
endfunction

//===========================================================================
function CreateUnitsForPlayer7 takes nothing returns nothing
    local player p= Player(7)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set gg_unit_h009_0231=CreateUnit(p, 'h009', 30758.4, 22117.6, 46.440)
endfunction

//===========================================================================
function CreateUnitsForPlayer8 takes nothing returns nothing
    local player p= Player(8)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set gg_unit_h009_0224=CreateUnit(p, 'h009', 30898.4, 20717.2, 41.090)
endfunction

//===========================================================================
function CreateUnitsForPlayer9 takes nothing returns nothing
    local player p= Player(9)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set gg_unit_h009_0233=CreateUnit(p, 'h009', 30834.6, 21445.9, 207.540)
endfunction

//===========================================================================
function CreateBuildingsForPlayer10 takes nothing returns nothing
    local player p= Player(10)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u=CreateUnit(p, 'ncp3', - 7040.0, - 24896.0, 270.000)
    set u=CreateUnit(p, 'ncp3', - 9664.0, - 17344.0, 270.000)
    set u=CreateUnit(p, 'ncp3', - 14272.0, - 24448.0, 270.000)
    set u=CreateUnit(p, 'ncp3', - 19392.0, - 17600.0, 270.000)
    set u=CreateUnit(p, 'ncp3', - 6272.0, - 13760.0, 270.000)
endfunction

//===========================================================================
function CreateUnitsForPlayer10 takes nothing returns nothing
    local player p= Player(10)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set gg_unit_h00C_0139=CreateUnit(p, 'h00C', - 24226.7, - 25870.8, 199.158)
    set u=CreateUnit(p, 'h00N', - 22814.5, - 25667.6, 228.627)
    set u=CreateUnit(p, 'h00N', - 22569.7, - 25862.9, 231.635)
    set gg_unit_h00B_0223=CreateUnit(p, 'h00B', - 23033.0, - 26311.4, 41.780)
    set gg_unit_h00D_0307=CreateUnit(p, 'h00D', - 26047.4, - 26361.2, 86.230)
    set u=CreateUnit(p, 'h00F', - 24883.7, - 26174.5, 358.753)
    set u=CreateUnit(p, 'h00A', - 24639.6, - 25729.3, 341.984)
    set gg_unit_h00H_0310=CreateUnit(p, 'h00H', - 24665.7, - 27798.3, 317.920)
    set u=CreateUnit(p, 'h00I', - 23060.2, - 27747.6, 213.923)
    set u=CreateUnit(p, 'h00I', - 22883.1, - 27964.2, 196.207)
    set u=CreateUnit(p, 'h00I', - 22865.3, - 28355.6, 148.211)
    set u=CreateUnit(p, 'h00B', - 23237.1, - 26305.4, 140.740)
    set u=CreateUnit(p, 'h00B', - 23045.3, - 26478.6, 292.460)
    set u=CreateUnit(p, 'h00K', - 25420.3, - 26117.7, 251.321)
    set u=CreateUnit(p, 'h00K', - 25367.6, - 26112.3, 240.226)
    set gg_unit_h00L_0367=CreateUnit(p, 'h00L', - 25399.4, - 26771.1, 240.766)
    set u=CreateUnit(p, 'h00L', - 25178.7, - 27957.5, 146.562)
    set u=CreateUnit(p, 'h00O', - 22851.5, - 27019.6, 252.012)
    set u=CreateUnit(p, 'h00L', - 22905.8, - 27006.2, 109.295)
    set u=CreateUnit(p, 'h00K', - 23715.8, - 25581.9, 265.240)
    set u=CreateUnit(p, 'h00K', - 24572.0, - 26526.9, 296.357)
    set u=CreateUnit(p, 'h00O', - 24507.6, - 26535.3, 280.440)
    set u=CreateUnit(p, 'h00L', - 24446.5, - 26527.3, 262.825)
    set u=CreateUnit(p, 'h00L', - 23005.0, - 28636.7, 260.558)
    set u=CreateUnit(p, 'h00K', - 24139.9, - 28647.7, 284.790)
    set u=CreateUnit(p, 'h00K', - 24088.4, - 28640.4, 267.597)
    set u=CreateUnit(p, 'h00O', - 23055.8, - 28618.2, 264.634)
    set u=CreateUnit(p, 'h00O', - 23850.1, - 26854.0, 48.874)
    set u=CreateUnit(p, 'h00O', - 23778.7, - 26914.9, 76.868)
    set u=CreateUnit(p, 'h00L', - 23839.4, - 26943.3, 64.564)
    set u=CreateUnit(p, 'h00M', 28531.7, 23529.6, 230.698)
    set gg_unit_h00P_0472=CreateUnit(p, 'h00P', - 7038.8, - 24880.9, 72.336)
    set gg_unit_h00P_0475=CreateUnit(p, 'h00P', - 9661.3, - 17323.9, 276.830)
    set u=CreateUnit(p, 'h00B', 29080.6, 21516.4, 328.743)
    set u=CreateUnit(p, 'h00H', 29065.5, 21432.3, 280.962)
    set u=CreateUnit(p, 'h00A', 29002.9, 21436.1, 261.900)
    set u=CreateUnit(p, 'h00F', 29004.1, 21516.4, 113.910)
    set gg_unit_h011_0520=CreateUnit(p, 'h011', - 26035.2, - 26098.9, 293.200)
    set u=CreateUnit(p, 'h00B', 30395.9, 21522.6, 328.743)
    set u=CreateUnit(p, 'h00H', 30380.8, 21438.6, 280.962)
    set u=CreateUnit(p, 'h00A', 30318.2, 21442.3, 261.900)
    set u=CreateUnit(p, 'h00F', 30319.4, 21522.6, 113.910)
    set gg_unit_h00P_0566=CreateUnit(p, 'h00P', - 14277.6, - 24428.6, 24.511)
    set u=CreateUnit(p, 'h00P', - 19390.8, - 17584.9, 72.336)
    set u=CreateUnit(p, 'h00P', - 6269.3, - 13739.9, 276.830)
endfunction

//===========================================================================
function CreateUnitsForPlayer11 takes nothing returns nothing
    local player p= Player(11)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u=CreateUnit(p, 'n01A', - 28575.6, 22624.6, 221.953)
    set u=CreateUnit(p, 'n01A', - 24649.5, 22050.1, 221.953)
    set u=CreateUnit(p, 'n01A', - 24108.2, 22030.9, 221.953)
    set u=CreateUnit(p, 'n01A', - 28610.2, 24034.4, 221.953)
    set u=CreateUnit(p, 'n01A', - 27218.6, 23920.3, 221.953)
    set u=CreateUnit(p, 'n01A', - 27642.2, 22673.1, 221.953)
    set u=CreateUnit(p, 'n01A', - 26737.9, 22066.5, 221.953)
    set u=CreateUnit(p, 'n01A', - 28668.3, 21676.2, 221.953)
    set u=CreateUnit(p, 'n01A', - 27139.0, 21246.7, 221.953)
    set u=CreateUnit(p, 'n012', - 23844.4, 21484.8, 182.507)
endfunction

//===========================================================================
function CreateNeutralHostile takes nothing returns nothing
    local player p= Player(PLAYER_NEUTRAL_AGGRESSIVE)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u=CreateUnit(p, 'n005', - 27639.6, 30386.1, 160.856)
    set u=CreateUnit(p, 'n005', - 28934.5, 29734.0, 160.856)
    set u=CreateUnit(p, 'n005', - 27950.7, 29519.1, 160.856)
    set u=CreateUnit(p, 'n005', - 27951.0, 29410.5, 160.856)
    set u=CreateUnit(p, 'n005', - 25801.1, 30742.1, 160.856)
    set u=CreateUnit(p, 'n005', - 25725.5, 30672.7, 160.856)
    set u=CreateUnit(p, 'n005', - 24790.7, 30635.6, 160.856)
    set u=CreateUnit(p, 'n005', - 24722.4, 30750.2, 160.856)
    set u=CreateUnit(p, 'n005', - 24608.9, 30758.2, 160.856)
    set u=CreateUnit(p, 'n005', - 24502.5, 30645.8, 160.856)
    set u=CreateUnit(p, 'n005', - 24682.8, 29125.2, 160.856)
    set u=CreateUnit(p, 'n005', - 26478.7, 29050.5, 160.856)
    set u=CreateUnit(p, 'n005', - 26591.5, 29074.4, 160.856)
    set u=CreateUnit(p, 'n005', - 26992.7, 28355.8, 160.856)
    set u=CreateUnit(p, 'n005', - 27105.8, 28329.5, 160.856)
    set u=CreateUnit(p, 'n005', - 27101.2, 28201.6, 160.856)
    set u=CreateUnit(p, 'n005', - 28557.4, 27636.9, 160.856)
    set u=CreateUnit(p, 'n005', - 28640.6, 27542.6, 160.856)
    set u=CreateUnit(p, 'n004', - 28481.8, 27374.8, 239.762)
    set u=CreateUnit(p, 'n004', - 28256.5, 26618.1, 239.762)
    set u=CreateUnit(p, 'n00H', - 15290.5, - 24318.3, 57.933)
    set u=CreateUnit(p, 'n00H', - 13569.2, - 24300.3, 284.368)
    set u=CreateUnit(p, 'n004', - 28133.4, 26593.6, 239.762)
    set u=CreateUnit(p, 'n004', - 29015.8, 26684.4, 239.762)
    set u=CreateUnit(p, 'n004', - 27008.5, 28277.4, 239.762)
    set u=CreateUnit(p, 'n004', - 25878.2, 30775.0, 239.762)
    set u=CreateUnit(p, 'n004', - 24760.2, 29247.5, 239.762)
    set u=CreateUnit(p, 'n004', - 24765.3, 28986.8, 239.762)
    set u=CreateUnit(p, 'n005', - 24786.6, 27189.5, 160.856)
    set u=CreateUnit(p, 'n005', - 24917.4, 27339.6, 160.856)
    set u=CreateUnit(p, 'n005', - 25084.8, 27291.2, 160.856)
    set u=CreateUnit(p, 'n005', - 25128.8, 27101.3, 160.856)
    set u=CreateUnit(p, 'n005', - 25011.9, 26978.6, 160.856)
    set u=CreateUnit(p, 'n004', - 25794.1, 26986.9, 239.762)
    set u=CreateUnit(p, 'n004', - 25862.3, 26847.2, 239.762)
    set u=CreateUnit(p, 'n005', - 25360.9, 26305.5, 160.856)
    set u=CreateUnit(p, 'n005', - 25371.8, 26122.0, 160.856)
    set u=CreateUnit(p, 'n005', - 25519.1, 26089.0, 160.856)
    set u=CreateUnit(p, 'n004', - 24514.3, 26377.1, 239.762)
    set u=CreateUnit(p, 'nkob', - 24600.4, 26256.3, 315.724)
    set u=CreateUnit(p, 'n005', - 26247.2, 25883.1, 160.856)
    set u=CreateUnit(p, 'n005', - 26202.3, 25794.6, 160.856)
    set u=CreateUnit(p, 'n008', - 10740.9, - 21174.1, 338.093)
    set u=CreateUnit(p, 'hmpr', - 24300.7, - 27984.8, 112.600)
    set u=CreateUnit(p, 'n001', - 20243.4, - 25407.6, 238.098)
    set u=CreateUnit(p, 'n000', - 22351.4, - 25362.3, 225.081)
    set u=CreateUnit(p, 'n000', - 21352.1, - 25418.9, 160.680)
    set u=CreateUnit(p, 'n000', - 21389.1, - 25488.0, 149.342)
    set u=CreateUnit(p, 'n000', - 21844.8, - 26892.5, 95.434)
    set u=CreateUnit(p, 'n000', - 21751.7, - 26821.8, 121.892)
    set u=CreateUnit(p, 'n000', - 21820.5, - 28202.0, 101.973)
    set u=CreateUnit(p, 'n000', - 21874.5, - 28249.5, 94.646)
    set u=CreateUnit(p, 'n000', - 20754.8, - 29167.9, 77.403)
    set u=CreateUnit(p, 'n000', - 20853.9, - 29248.9, 158.789)
    set u=CreateUnit(p, 'n000', - 20877.0, - 27504.3, 274.662)
    set u=CreateUnit(p, 'n000', - 20964.9, - 27511.3, 296.892)
    set u=CreateUnit(p, 'n000', - 21066.7, - 27538.7, 318.936)
    set u=CreateUnit(p, 'n000', - 19567.3, - 28069.3, 335.701)
    set u=CreateUnit(p, 'n000', - 19598.3, - 28126.9, 350.317)
    set u=CreateUnit(p, 'n000', - 19585.7, - 28192.5, 5.233)
    set u=CreateUnit(p, 'n000', - 20455.3, - 26622.8, 131.880)
    set u=CreateUnit(p, 'n000', - 20307.9, - 26540.8, 147.676)
    set u=CreateUnit(p, 'n000', - 19953.9, - 27322.7, 130.270)
    set u=CreateUnit(p, 'n000', - 20066.1, - 27355.9, 103.938)
    set u=CreateUnit(p, 'n000', - 20169.6, - 25463.4, 219.112)
    set u=CreateUnit(p, 'n000', - 19607.4, - 24537.4, 286.347)
    set u=CreateUnit(p, 'n000', - 19738.3, - 24639.0, 320.039)
    set u=CreateUnit(p, 'n000', - 19849.6, - 24711.2, 341.871)
    set u=CreateUnit(p, 'n000', - 18688.0, - 24999.4, 230.050)
    set u=CreateUnit(p, 'n000', - 18600.1, - 25047.2, 205.263)
    set u=CreateUnit(p, 'n000', - 17520.6, - 25629.9, 246.243)
    set u=CreateUnit(p, 'n000', - 18011.0, - 26660.9, 109.361)
    set u=CreateUnit(p, 'n000', - 18137.4, - 26746.9, 276.534)
    set u=CreateUnit(p, 'n000', - 19189.3, - 25958.8, 250.368)
    set u=CreateUnit(p, 'n000', - 19294.0, - 25950.4, 262.757)
    set u=CreateUnit(p, 'n000', - 19444.2, - 25939.3, 280.683)
    set u=CreateUnit(p, 'n000', - 19296.5, - 26991.0, 67.784)
    set u=CreateUnit(p, 'n000', - 19409.1, - 27044.9, 55.919)
    set u=CreateUnit(p, 'n000', - 19275.4, - 27068.5, 75.280)
    set u=CreateUnit(p, 'n001', - 18777.4, - 24974.4, 258.810)
    set u=CreateUnit(p, 'n001', - 17436.7, - 25672.4, 230.640)
    set u=CreateUnit(p, 'n001', - 19551.7, - 25901.0, 290.916)
    set u=CreateUnit(p, 'n001', - 18445.9, - 27667.6, 155.011)
    set u=CreateUnit(p, 'n001', - 18564.1, - 27802.3, 136.143)
    set u=CreateUnit(p, 'n001', - 18663.9, - 27916.3, 120.451)
    set u=CreateUnit(p, 'n001', - 17028.4, - 27248.9, 227.965)
    set u=CreateUnit(p, 'n001', - 17833.2, - 27591.0, 59.932)
    set u=CreateUnit(p, 'n001', - 16312.3, - 27789.8, 182.546)
    set u=CreateUnit(p, 'n001', - 16013.9, - 27014.1, 50.585)
    set u=CreateUnit(p, 'n001', - 15976.7, - 25722.8, 263.374)
    set u=CreateUnit(p, 'n001', - 15849.1, - 25759.8, 240.199)
    set u=CreateUnit(p, 'n002', - 15133.2, - 26323.4, 146.479)
    set u=CreateUnit(p, 'n002', - 15241.6, - 26457.3, 128.201)
    set u=CreateUnit(p, 'n002', - 16915.7, - 26545.3, 108.288)
    set u=CreateUnit(p, 'n002', - 15923.0, - 27099.4, 79.919)
    set u=CreateUnit(p, 'n002', - 15009.5, - 27538.5, 157.951)
    set u=CreateUnit(p, 'n002', - 15128.3, - 27624.7, 145.743)
    set u=CreateUnit(p, 'n002', - 15131.5, - 27741.3, 137.169)
    set u=CreateUnit(p, 'n002', - 16851.8, - 27277.0, 213.019)
    set u=CreateUnit(p, 'n001', - 17728.3, - 27590.5, 44.705)
    set u=CreateUnit(p, 'n002', - 17236.9, - 27943.2, 184.134)
    set u=CreateUnit(p, 'n002', - 15316.0, - 25490.3, 149.539)
    set u=CreateUnit(p, 'n002', - 13663.6, - 24876.0, 214.515)
    set u=CreateUnit(p, 'n002', - 13708.1, - 26252.3, 230.929)
    set u=CreateUnit(p, 'n001', - 14571.5, - 25350.8, 225.117)
    set u=CreateUnit(p, 'n002', - 13881.6, - 25357.5, 210.396)
    set u=CreateUnit(p, 'n002', - 13789.8, - 25705.2, 160.548)
    set u=CreateUnit(p, 'n002', - 13917.8, - 25736.7, 146.948)
    set u=CreateUnit(p, 'n00G', - 13379.4, - 24480.5, 41.200)
    set u=CreateUnit(p, 'n00G', - 12093.9, - 23416.7, 154.066)
    set u=CreateUnit(p, 'n00G', - 10613.3, - 25065.8, 23.786)
    set u=CreateUnit(p, 'n00G', - 10816.0, - 24686.4, 135.213)
    set u=CreateUnit(p, 'n00H', - 13060.2, - 26306.7, 51.733)
    set u=CreateUnit(p, 'n00H', - 13051.9, - 26522.4, 62.962)
    set u=CreateUnit(p, 'n00H', - 12914.4, - 26548.6, 74.142)
    set u=CreateUnit(p, 'n00H', - 11064.6, - 27100.3, 119.573)
    set u=CreateUnit(p, 'n00H', - 10749.2, - 27067.4, 143.332)
    set u=CreateUnit(p, 'n00G', - 10720.3, - 26202.7, 220.490)
    set u=CreateUnit(p, 'n00G', - 10850.6, - 26258.6, 227.095)
    set u=CreateUnit(p, 'n00G', - 9573.2, - 25412.7, 287.762)
    set u=CreateUnit(p, 'n00G', - 9713.0, - 25436.3, 290.316)
    set u=CreateUnit(p, 'n00G', - 8296.7, - 25895.5, 158.672)
    set u=CreateUnit(p, 'n00G', - 8638.1, - 24924.6, 129.877)
    set u=CreateUnit(p, 'n00G', - 8767.5, - 25044.5, 108.960)
    set u=CreateUnit(p, 'n00G', - 10252.4, - 24467.3, 64.740)
    set u=CreateUnit(p, 'n00G', - 10187.3, - 24597.3, 77.281)
    set u=CreateUnit(p, 'n00G', - 8877.0, - 23672.7, 293.135)
    set u=CreateUnit(p, 'n00H', - 8815.4, - 23850.7, 325.436)
    set u=CreateUnit(p, 'n00H', - 10344.5, - 23568.4, 354.610)
    set u=CreateUnit(p, 'n00H', - 11776.8, - 24202.9, 303.814)
    set u=CreateUnit(p, 'n00H', - 9451.1, - 25428.1, 249.023)
    set u=CreateUnit(p, 'n00H', - 8404.5, - 26043.3, 136.458)
    set u=CreateUnit(p, 'n00H', - 8476.8, - 26207.4, 118.749)
    set u=CreateUnit(p, 'n00H', - 9639.5, - 23574.4, 320.635)
    set u=CreateUnit(p, 'n00H', - 9288.9, - 24497.2, 131.122)
    set u=CreateUnit(p, 'n00H', - 9380.0, - 24511.5, 120.132)
    set u=CreateUnit(p, 'n00H', - 9313.2, - 24582.4, 122.649)
    set u=CreateUnit(p, 'n00H', - 10744.4, - 24782.5, 161.174)
    set u=CreateUnit(p, 'n00H', - 10692.2, - 24882.3, 228.226)
    set u=CreateUnit(p, 'n00G', - 12609.1, - 25288.8, 323.600)
    set u=CreateUnit(p, 'n00G', - 12715.7, - 25377.7, 339.046)
    set u=CreateUnit(p, 'n00G', - 12819.2, - 25500.4, 354.212)
    set u=CreateUnit(p, 'n00G', - 11788.0, - 25601.0, 350.791)
    set u=CreateUnit(p, 'n00G', - 11703.6, - 25506.3, 337.961)
    set u=CreateUnit(p, 'n00G', - 12095.8, - 26701.9, 88.331)
    set u=CreateUnit(p, 'n00H', - 12008.4, - 26752.0, 97.566)
    set u=CreateUnit(p, 'n00H', - 12211.7, - 26788.8, 77.447)
    set u=CreateUnit(p, 'n00E', - 11447.5, - 28821.1, 287.278)
    set u=CreateUnit(p, 'n00H', - 10246.0, - 27635.0, 208.153)
    set u=CreateUnit(p, 'n00H', - 10256.8, - 27723.7, 354.166)
    set u=CreateUnit(p, 'n00G', - 10268.2, - 27798.7, 215.437)
    set u=CreateUnit(p, 'n00G', - 12268.0, - 27753.2, 20.666)
    set u=CreateUnit(p, 'n00G', - 12329.2, - 27960.6, 240.806)
    set u=CreateUnit(p, 'n00H', - 11609.0, - 28820.3, 159.446)
    set u=CreateUnit(p, 'n00G', - 11321.1, - 28790.2, 20.857)
    set u=CreateUnit(p, 'n00D', - 7383.8, - 25415.2, 197.980)
    set u=CreateUnit(p, 'n00D', - 6394.9, - 24318.7, 275.194)
    set u=CreateUnit(p, 'n00D', - 6478.9, - 24360.1, 321.283)
    set u=CreateUnit(p, 'n00C', - 7587.2, - 26869.7, 83.488)
    set u=CreateUnit(p, 'n00D', - 7442.6, - 26898.4, 299.365)
    set u=CreateUnit(p, 'n00D', - 5631.0, - 25313.4, 248.452)
    set u=CreateUnit(p, 'n00D', - 5669.2, - 25428.6, 269.272)
    set u=CreateUnit(p, 'n00D', - 4993.9, - 26717.1, 208.340)
    set u=CreateUnit(p, 'n00C', - 5054.8, - 26811.7, 268.888)
    set u=CreateUnit(p, 'n00C', - 6243.1, - 27311.3, 126.742)
    set u=CreateUnit(p, 'n00C', - 6356.1, - 27425.5, 14.239)
    set u=CreateUnit(p, 'n00C', - 6364.1, - 27613.6, 78.104)
    set u=CreateUnit(p, 'n00C', - 4794.6, - 27793.2, 10.558)
    set u=CreateUnit(p, 'n00B', - 4620.9, - 24935.8, 345.596)
    set u=CreateUnit(p, 'n00D', - 4547.8, - 25014.1, 332.775)
    set u=CreateUnit(p, 'n00B', - 3244.7, - 24684.5, 29.389)
    set u=CreateUnit(p, 'n00B', - 3087.6, - 24706.4, 4.636)
    set u=CreateUnit(p, 'n00B', - 3627.7, - 25816.5, 275.688)
    set u=CreateUnit(p, 'n00B', - 3290.3, - 25859.8, 52.758)
    set u=CreateUnit(p, 'n007', - 3548.9, - 26034.9, 78.027)
    set u=CreateUnit(p, 'n003', - 3353.2, - 26032.5, 212.273)
    set u=CreateUnit(p, 'n00B', - 4439.7, - 23665.2, 176.413)
    set u=CreateUnit(p, 'n00B', - 4540.5, - 23716.3, 104.923)
    set u=CreateUnit(p, 'n00B', - 4658.7, - 23787.0, 13.338)
    set u=CreateUnit(p, 'n00B', - 3961.1, - 23008.7, 149.693)
    set u=CreateUnit(p, 'n003', - 3801.3, - 22925.8, 239.586)
    set u=CreateUnit(p, 'n00B', - 4771.8, - 21244.6, 109.867)
    set u=CreateUnit(p, 'n007', - 4797.0, - 21581.5, 83.389)
    set u=CreateUnit(p, 'n003', - 4175.0, - 21025.3, 154.297)
    set u=CreateUnit(p, 'n003', - 4130.2, - 21124.0, 18.952)
    set u=CreateUnit(p, 'n003', - 3229.4, - 21341.8, 195.310)
    set u=CreateUnit(p, 'n003', - 3322.3, - 21341.8, 77.159)
    set u=CreateUnit(p, 'n00B', - 2807.5, - 23486.9, 283.709)
    set u=CreateUnit(p, 'n00B', - 2845.0, - 23650.9, 271.019)
    set u=CreateUnit(p, 'n00C', - 2494.0, - 23637.8, 188.454)
    set u=CreateUnit(p, 'n007', - 2643.2, - 23791.9, 55.944)
    set u=CreateUnit(p, 'n003', - 1889.0, - 21926.0, 190.322)
    set u=CreateUnit(p, 'n003', - 1996.5, - 22257.8, 245.552)
    set u=CreateUnit(p, 'n00C', - 1897.5, - 22068.9, 192.904)
    set u=CreateUnit(p, 'n00B', - 2114.8, - 20005.4, 40.640)
    set u=CreateUnit(p, 'n00B', - 1884.7, - 20108.6, 214.559)
    set u=CreateUnit(p, 'n00B', - 2214.6, - 21297.9, 141.277)
    set u=CreateUnit(p, 'n00B', - 4282.4, - 19245.3, 5.416)
    set u=CreateUnit(p, 'n00B', - 4383.0, - 19323.6, 333.083)
    set u=CreateUnit(p, 'n00B', - 4165.6, - 19340.7, 199.716)
    set u=CreateUnit(p, 'n00B', - 4264.7, - 19470.6, 354.551)
    set u=CreateUnit(p, 'n003', - 4265.5, - 19353.5, 38.168)
    set u=CreateUnit(p, 'n003', - 5829.5, - 22878.6, 61.350)
    set u=CreateUnit(p, 'n00B', - 5702.0, - 22987.0, 149.111)
    set u=CreateUnit(p, 'n00B', - 5839.2, - 23068.4, 327.040)
    set u=CreateUnit(p, 'n00B', - 6695.9, - 22804.3, 24.533)
    set u=CreateUnit(p, 'n00B', - 6778.3, - 23016.1, 327.172)
    set u=CreateUnit(p, 'n00B', - 6687.8, - 23204.4, 317.141)
    set u=CreateUnit(p, 'n00B', - 8124.3, - 22206.2, 120.590)
    set u=CreateUnit(p, 'n00C', - 7935.6, - 22153.9, 12.569)
    set u=CreateUnit(p, 'n00C', - 7863.8, - 23321.2, 75.336)
    set u=CreateUnit(p, 'n00C', - 7736.4, - 23413.6, 270.239)
    set u=CreateUnit(p, 'n007', - 8010.5, - 23677.7, 101.374)
    set u=CreateUnit(p, 'n00B', - 5403.1, - 20536.0, 55.691)
    set u=CreateUnit(p, 'n00B', - 5570.2, - 20382.2, 249.430)
    set u=CreateUnit(p, 'n00B', - 5717.3, - 20284.6, 325.238)
    set u=CreateUnit(p, 'n003', - 6131.4, - 21306.1, 329.490)
    set u=CreateUnit(p, 'n003', - 6131.2, - 21651.6, 95.936)
    set u=CreateUnit(p, 'n008', - 10593.5, - 21300.3, 313.548)
    set u=CreateUnit(p, 'n008', - 8830.8, - 21284.2, 234.653)
    set u=CreateUnit(p, 'n006', - 8688.9, - 21361.1, 160.911)
    set u=CreateUnit(p, 'n006', - 9836.9, - 22561.1, 236.609)
    set u=CreateUnit(p, 'n008', - 12132.4, - 21696.5, 8.548)
    set u=CreateUnit(p, 'n008', - 13506.2, - 22679.6, 73.940)
    set u=CreateUnit(p, 'n008', - 13499.9, - 21082.2, 244.992)
    set u=CreateUnit(p, 'n006', - 13277.5, - 21018.9, 228.786)
    set u=CreateUnit(p, 'n006', - 12207.6, - 19852.4, 254.550)
    set u=CreateUnit(p, 'n006', - 12108.2, - 19918.4, 152.945)
    set u=CreateUnit(p, 'n006', - 11058.1, - 18750.7, 201.715)
    set u=CreateUnit(p, 'n006', - 10934.0, - 18916.7, 309.890)
    set u=CreateUnit(p, 'n008', - 11151.4, - 18991.8, 306.978)
    set u=CreateUnit(p, 'n008', - 14682.5, - 20564.7, 334.874)
    set u=CreateUnit(p, 'n008', - 15923.3, - 21798.2, 304.583)
    set u=CreateUnit(p, 'n008', - 15798.1, - 21901.1, 76.291)
    set u=CreateUnit(p, 'n008', - 15033.9, - 23187.1, 197.452)
    set u=CreateUnit(p, 'n006', - 14998.0, - 23317.8, 60.196)
    set u=CreateUnit(p, 'n006', - 16118.0, - 23031.1, 118.689)
    set u=CreateUnit(p, 'n006', - 14123.6, - 23884.9, 69.633)
    set u=CreateUnit(p, 'n006', - 11005.7, - 22657.1, 300.397)
    set u=CreateUnit(p, 'n006', - 10917.4, - 22693.5, 73.775)
    set u=CreateUnit(p, 'n005', - 26928.7, 25363.7, 160.856)
    set u=CreateUnit(p, 'n005', - 27143.3, 25331.1, 160.856)
    set u=CreateUnit(p, 'n004', - 27019.1, 25336.2, 239.762)
    set u=CreateUnit(p, 'n004', - 25958.4, 29888.3, 239.762)
    set u=CreateUnit(p, 'n004', - 24490.2, 29908.0, 239.762)
    set u=CreateUnit(p, 'n004', - 23452.7, 25747.4, 239.762)
    set u=CreateUnit(p, 'n009', - 23220.3, 24607.5, 352.441)
    set u=CreateUnit(p, 'n004', - 23299.5, 24454.8, 239.762)
    set u=CreateUnit(p, 'n005', - 22696.9, 24893.0, 160.856)
    set u=CreateUnit(p, 'n005', - 22605.9, 24978.5, 160.856)
    set u=CreateUnit(p, 'n005', - 24466.5, 25039.0, 160.856)
    set u=CreateUnit(p, 'n005', - 24612.3, 24844.0, 160.856)
    set u=CreateUnit(p, 'n004', - 24603.9, 25044.5, 239.762)
    set u=CreateUnit(p, 'n005', - 23862.5, 25036.7, 160.856)
    set u=CreateUnit(p, 'n005', - 23721.6, 25131.7, 160.856)
    set u=CreateUnit(p, 'n004', - 23287.1, 25774.7, 239.762)
    set u=CreateUnit(p, 'n00J', - 10520.6, - 11841.8, 319.390)
    set u=CreateUnit(p, 'n00K', - 10567.0, - 12425.4, 20.084)
    set u=CreateUnit(p, 'n00L', - 9408.0, - 11032.1, 163.471)
    set u=CreateUnit(p, 'n00L', - 9230.2, - 10908.6, 64.591)
    set u=CreateUnit(p, 'n00L', - 9205.5, - 11128.8, 256.308)
    set u=CreateUnit(p, 'n00L', - 9907.5, - 13125.9, 341.575)
    set u=CreateUnit(p, 'n00M', - 9896.4, - 13025.1, 63.767)
    set u=CreateUnit(p, 'n00N', - 9774.0, - 13149.9, 191.629)
    set u=CreateUnit(p, 'n00N', - 8814.0, - 13217.7, 178.654)
    set u=CreateUnit(p, 'n00N', - 8635.0, - 13266.4, 224.161)
    set u=CreateUnit(p, 'n00N', - 7786.4, - 12767.1, 304.660)
    set u=CreateUnit(p, 'n00L', - 7684.0, - 12842.5, 106.054)
    set u=CreateUnit(p, 'n00L', - 7790.0, - 11214.5, 113.580)
    set u=CreateUnit(p, 'n00L', - 7679.2, - 11356.5, 160.757)
    set u=CreateUnit(p, 'n00L', - 7508.1, - 11394.9, 131.686)
    set u=CreateUnit(p, 'n00L', - 7311.1, - 11350.6, 197.914)
    set u=CreateUnit(p, 'n00M', - 7669.5, - 11125.9, 151.704)
    set u=CreateUnit(p, 'n00M', - 7434.2, - 11131.3, 148.847)
    set u=CreateUnit(p, 'n00M', - 6313.5, - 12434.3, 307.473)
    set u=CreateUnit(p, 'n00N', - 6032.8, - 12513.8, 149.847)
    set u=CreateUnit(p, 'n00N', - 7422.8, - 13301.5, 280.479)
    set u=CreateUnit(p, 'n00N', - 7295.8, - 13308.8, 179.192)
    set u=CreateUnit(p, 'n00N', - 7337.9, - 13377.0, 208.208)
    set u=CreateUnit(p, 'n00L', - 5007.7, - 13980.6, 117.129)
    set u=CreateUnit(p, 'n00L', - 4886.4, - 13947.9, 106.230)
    set u=CreateUnit(p, 'n00M', - 6825.6, - 14794.7, 270.481)
    set u=CreateUnit(p, 'n00N', - 6885.8, - 14650.4, 112.284)
    set u=CreateUnit(p, 'n00N', - 6780.4, - 14904.6, 129.401)
    set u=CreateUnit(p, 'n00N', - 6985.7, - 14882.0, 162.284)
    set u=CreateUnit(p, 'n00N', - 5798.4, - 15608.2, 111.668)
    set u=CreateUnit(p, 'n00N', - 5729.7, - 15743.5, 336.609)
    set u=CreateUnit(p, 'n00N', - 8970.4, - 14025.3, 215.086)
    set u=CreateUnit(p, 'n00N', - 8164.0, - 14660.1, 60.899)
    set u=CreateUnit(p, 'n00M', - 10825.6, - 13861.8, 347.640)
    set u=CreateUnit(p, 'n00M', - 10826.2, - 13944.6, 354.045)
    set u=CreateUnit(p, 'n00M', - 10735.9, - 13914.1, 358.671)
    set u=CreateUnit(p, 'n00L', - 11986.4, - 14006.7, 294.992)
    set u=CreateUnit(p, 'n00N', - 11879.2, - 14051.7, 346.080)
    set u=CreateUnit(p, 'n00M', - 11992.5, - 14176.1, 351.321)
    set u=CreateUnit(p, 'n00N', - 12025.3, - 12288.3, 124.358)
    set u=CreateUnit(p, 'n00N', - 12035.3, - 12474.0, 43.617)
    set u=CreateUnit(p, 'n00N', - 11931.7, - 12384.2, 316.757)
    set u=CreateUnit(p, 'n00M', - 12817.4, - 11565.8, 14.085)
    set u=CreateUnit(p, 'n00L', - 12741.7, - 11664.7, 191.476)
    set u=CreateUnit(p, 'n00L', - 13402.4, - 10499.3, 186.971)
    set u=CreateUnit(p, 'n00L', - 13492.5, - 10573.1, 193.794)
    set u=CreateUnit(p, 'n00N', - 12134.6, - 15182.9, 186.740)
    set u=CreateUnit(p, 'n00N', - 11998.1, - 15370.1, 300.474)
    set u=CreateUnit(p, 'n00M', - 12292.3, - 15333.4, 12.953)
    set u=CreateUnit(p, 'n00N', - 13757.3, - 14495.3, 353.342)
    set u=CreateUnit(p, 'n00N', - 13721.4, - 14673.7, 306.066)
    set u=CreateUnit(p, 'n00N', - 13605.9, - 14636.9, 173.897)
    set u=CreateUnit(p, 'n00N', - 13601.9, - 14481.5, 9.712)
    set u=CreateUnit(p, 'n00N', - 9825.8, - 15967.4, 176.775)
    set u=CreateUnit(p, 'n00N', - 9715.0, - 15997.5, 321.338)
    set u=CreateUnit(p, 'n00N', - 8120.2, - 16385.3, 234.148)
    set u=CreateUnit(p, 'n00N', - 8096.5, - 16202.3, 279.204)
    set u=CreateUnit(p, 'n00N', - 8026.9, - 16340.7, 258.362)
    set u=CreateUnit(p, 'n00N', - 9752.0, - 13552.3, 220.338)
    set u=CreateUnit(p, 'n00N', - 9654.9, - 13555.8, 271.151)
endfunction

//===========================================================================
function CreateNeutralPassiveBuildings takes nothing returns nothing
    local player p= Player(PLAYER_NEUTRAL_PASSIVE)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set gg_unit_ncp3_0027=CreateUnit(p, 'ncp3', - 25920.0, - 27456.0, 270.000)
endfunction

//===========================================================================
function CreateNeutralPassive takes nothing returns nothing
    local player p= Player(PLAYER_NEUTRAL_PASSIVE)
    local unit u
    local integer unitID
    local trigger t
    local real life

    set u=CreateUnit(p, 'h001', - 21109.8, - 27296.6, 81.928)
    set u=CreateUnit(p, 'h001', - 21139.8, - 27350.2, 298.607)
    set u=CreateUnit(p, 'h001', - 22086.1, - 28007.1, 188.498)
    set u=CreateUnit(p, 'h001', - 22060.6, - 28076.5, 149.474)
    set u=CreateUnit(p, 'h001', - 22108.2, - 28144.9, 103.187)
    set u=CreateUnit(p, 'h001', - 22483.0, - 25148.1, 253.330)
    set u=CreateUnit(p, 'h001', - 22536.0, - 25193.8, 97.023)
    set u=CreateUnit(p, 'h001', - 19485.1, - 28150.0, 236.180)
    set u=CreateUnit(p, 'h001', - 19371.5, - 28180.6, 233.115)
    set u=CreateUnit(p, 'h001', - 19363.6, - 28272.8, 228.281)
    set u=CreateUnit(p, 'h001', - 19430.4, - 28233.4, 335.390)
    set u=CreateUnit(p, 'h001', - 19420.8, - 28295.4, 36.289)
    set u=CreateUnit(p, 'h001', - 19396.0, - 25760.7, 0.560)
    set u=CreateUnit(p, 'h001', - 19464.6, - 25773.8, 194.640)
    set u=CreateUnit(p, 'h001', - 19470.5, - 25827.5, 155.901)
    set u=CreateUnit(p, 'h001', - 19373.1, - 25807.3, 143.662)
    set u=CreateUnit(p, 'h001', - 19295.9, - 25811.7, 349.035)
    set u=CreateUnit(p, 'h001', - 19237.5, - 25877.1, 257.919)
    set u=CreateUnit(p, 'h001', - 18666.0, - 24900.7, 23.731)
    set u=CreateUnit(p, 'h001', - 18597.6, - 24950.5, 189.322)
    set u=CreateUnit(p, 'h001', - 18496.0, - 24963.6, 33.081)
    set u=CreateUnit(p, 'h001', - 17505.5, - 25531.2, 184.224)
    set u=CreateUnit(p, 'h001', - 18118.4, - 26761.5, 190.597)
    set u=CreateUnit(p, 'h001', - 18222.3, - 26785.5, 162.284)
    set u=CreateUnit(p, 'h001', - 18187.0, - 26815.8, 217.195)
    set u=CreateUnit(p, 'h001', - 18080.5, - 26838.1, 156.153)
    set u=CreateUnit(p, 'h001', - 17974.4, - 26762.9, 242.432)
    set u=CreateUnit(p, 'h001', - 18087.7, - 26793.5, 11.921)
    set u=CreateUnit(p, 'h001', - 18177.7, - 26786.3, 47.210)
    set u=CreateUnit(p, 'h001', - 18127.7, - 26830.4, 278.072)
    set u=CreateUnit(p, 'h001', - 17974.5, - 26724.4, 163.899)
    set u=CreateUnit(p, 'h001', - 17995.5, - 26735.4, 54.878)
    set u=CreateUnit(p, 'h001', - 17823.8, - 27486.4, 68.809)
    set u=CreateUnit(p, 'h001', - 17818.4, - 27496.9, 88.311)
    set u=CreateUnit(p, 'h001', - 17808.5, - 27502.0, 109.021)
    set u=CreateUnit(p, 'h001', - 17788.2, - 27504.4, 143.200)
    set u=CreateUnit(p, 'h001', - 17773.2, - 27496.0, 251.023)
    set u=CreateUnit(p, 'h001', - 16905.0, - 26354.2, 189.718)
    set u=CreateUnit(p, 'h001', - 16977.7, - 26418.6, 118.744)
    set u=CreateUnit(p, 'h001', - 16990.3, - 26498.3, 300.419)
    set u=CreateUnit(p, 'h001', - 15943.6, - 25597.9, 244.058)
    set u=CreateUnit(p, 'h001', - 15840.3, - 25640.6, 307.231)
    set u=CreateUnit(p, 'h001', - 15866.9, - 25652.8, 163.119)
    set u=CreateUnit(p, 'h001', - 15078.3, - 26589.1, 24.511)
    set u=CreateUnit(p, 'h001', - 15039.7, - 26559.3, 318.097)
    set u=CreateUnit(p, 'h001', - 15079.0, - 26453.9, 22.600)
    set u=CreateUnit(p, 'h001', - 15084.3, - 26449.2, 200.693)
    set u=CreateUnit(p, 'h001', - 15020.1, - 26581.9, 194.167)
    set u=CreateUnit(p, 'h001', - 15137.0, - 26477.7, 134.529)
    set u=CreateUnit(p, 'h001', - 15136.7, - 26540.8, 130.804)
    set u=CreateUnit(p, 'h001', - 15080.2, - 26515.5, 31.169)
    set u=CreateUnit(p, 'h001', - 15991.3, - 27214.7, 253.199)
    set u=CreateUnit(p, 'h001', - 16042.9, - 27197.6, 149.968)
    set u=CreateUnit(p, 'h001', - 16074.7, - 27147.1, 263.790)
    set u=CreateUnit(p, 'h001', - 16074.6, - 27101.4, 286.301)
    set u=CreateUnit(p, 'h001', - 15939.7, - 27236.0, 331.072)
    set u=CreateUnit(p, 'h001', - 15928.4, - 27286.4, 246.596)
    set u=CreateUnit(p, 'h001', - 15927.3, - 27304.9, 6.295)
    set u=CreateUnit(p, 'h001', - 20757.7, - 27396.6, 324.711)
    set u=CreateUnit(p, 'h001', - 13420.1, - 23367.8, 192.278)
    set u=CreateUnit(p, 'h001', - 13900.5, - 25200.3, 162.482)
    set u=CreateUnit(p, 'h001', - 13337.9, - 23320.5, 53.099)
    set u=CreateUnit(p, 'h001', - 13340.3, - 23436.9, 49.550)
    set u=CreateUnit(p, 'h001', - 13434.5, - 23471.6, 12.437)
    set u=CreateUnit(p, 'h001', - 13525.8, - 23506.8, 39.640)
    set u=CreateUnit(p, 'h001', - 13285.9, - 23263.7, 106.527)
    set u=CreateUnit(p, 'h001', - 13585.5, - 23620.4, 246.519)
    set u=CreateUnit(p, 'h001', - 13914.7, - 25835.6, 134.351)
    set u=CreateUnit(p, 'h001', - 11576.3, - 23156.3, 187.597)
    set u=CreateUnit(p, 'h001', - 11641.8, - 23162.8, 259.011)
    set u=CreateUnit(p, 'h001', - 11723.3, - 23146.3, 159.515)
    set u=CreateUnit(p, 'h001', - 11803.0, - 23164.9, 41.749)
    set u=CreateUnit(p, 'h001', - 11923.5, - 23143.5, 178.566)
    set u=CreateUnit(p, 'h001', - 11985.8, - 23141.0, 202.264)
    set u=CreateUnit(p, 'h001', - 10772.4, - 24509.4, 243.333)
    set u=CreateUnit(p, 'h001', - 10839.0, - 24501.3, 63.206)
    set u=CreateUnit(p, 'h001', - 10805.1, - 24594.8, 119.524)
    set u=CreateUnit(p, 'h001', - 10745.9, - 24645.0, 22.874)
    set u=CreateUnit(p, 'h001', - 10679.0, - 24683.3, 268.602)
    set u=CreateUnit(p, 'h001', - 10624.9, - 24719.4, 48.951)
    set u=CreateUnit(p, 'h001', - 10723.8, - 24580.5, 165.954)
    set u=CreateUnit(p, 'h001', - 10675.0, - 24622.0, 79.499)
    set u=CreateUnit(p, 'h001', - 10613.3, - 24657.8, 46.651)
    set u=CreateUnit(p, 'h001', - 10544.4, - 24757.2, 54.919)
    set u=CreateUnit(p, 'h001', - 10526.2, - 24827.0, 153.857)
    set u=CreateUnit(p, 'h001', - 10658.2, - 24786.2, 107.318)
    set u=CreateUnit(p, 'h001', - 10589.9, - 24842.2, 120.227)
    set u=CreateUnit(p, 'h001', - 10539.3, - 24889.3, 320.679)
    set u=CreateUnit(p, 'h001', - 10469.4, - 24977.9, 241.322)
    set u=CreateUnit(p, 'h001', - 10477.4, - 25044.8, 105.219)
    set u=CreateUnit(p, 'h001', - 10478.6, - 25109.8, 243.113)
    set u=CreateUnit(p, 'h001', - 10497.4, - 25182.0, 116.019)
    set u=CreateUnit(p, 'h001', - 10495.6, - 25258.1, 84.531)
    set u=CreateUnit(p, 'h001', - 10528.0, - 25432.8, 85.169)
    set u=CreateUnit(p, 'h001', - 12069.3, - 24868.9, 75.863)
    set u=CreateUnit(p, 'h001', - 11966.9, - 24937.1, 92.123)
    set u=CreateUnit(p, 'h001', - 13154.0, - 26368.2, 48.592)
    set u=CreateUnit(p, 'h001', - 13153.7, - 26629.5, 60.173)
    set u=CreateUnit(p, 'h001', - 12962.2, - 26654.3, 72.929)
    set u=CreateUnit(p, 'h001', - 12876.9, - 26648.8, 78.794)
    set u=CreateUnit(p, 'h001', - 12804.0, - 26607.0, 83.782)
    set u=CreateUnit(p, 'h001', - 13089.6, - 26649.3, 64.589)
    set u=CreateUnit(p, 'h001', - 9605.9, - 26532.0, 106.395)
    set u=CreateUnit(p, 'h001', - 9716.7, - 25274.4, 71.216)
    set u=CreateUnit(p, 'h001', - 9627.6, - 25311.3, 246.508)
    set u=CreateUnit(p, 'h001', - 9559.5, - 25310.5, 254.231)
    set u=CreateUnit(p, 'h001', - 9623.5, - 25246.8, 254.001)
    set u=CreateUnit(p, 'h001', - 9785.3, - 25311.1, 187.586)
    set u=CreateUnit(p, 'h001', - 9716.7, - 25352.5, 99.199)
    set u=CreateUnit(p, 'h001', - 8427.7, - 24540.7, 120.798)
    set u=CreateUnit(p, 'h001', - 8541.4, - 24487.0, 103.857)
    set u=CreateUnit(p, 'h001', - 8518.4, - 24586.2, 14.931)
    set u=CreateUnit(p, 'h001', - 8474.9, - 24679.0, 248.430)
    set u=CreateUnit(p, 'h001', - 8423.5, - 24766.5, 159.483)
    set u=CreateUnit(p, 'h001', - 8427.0, - 24647.4, 325.480)
    set u=CreateUnit(p, 'h001', - 8557.3, - 24411.3, 315.636)
    set u=CreateUnit(p, 'h001', - 9829.3, - 23447.2, 230.061)
    set u=CreateUnit(p, 'h001', - 9874.5, - 23394.7, 69.908)
    set u=CreateUnit(p, 'h001', - 9717.7, - 23447.3, 341.169)
    set u=CreateUnit(p, 'h001', - 9792.4, - 23420.4, 78.906)
    set u=CreateUnit(p, 'h001', - 9645.3, - 23428.5, 357.880)
    set u=CreateUnit(p, 'h001', - 9588.0, - 24384.3, 152.275)
    set u=CreateUnit(p, 'h001', - 9698.1, - 24408.3, 135.630)
    set u=CreateUnit(p, 'h001', - 9750.4, - 24295.2, 346.750)
    set u=CreateUnit(p, 'h001', - 9679.7, - 24250.7, 5.581)
    set u=CreateUnit(p, 'h001', - 9614.0, - 24256.3, 354.671)
    set u=CreateUnit(p, 'h001', - 9670.2, - 24321.7, 214.976)
    set u=CreateUnit(p, 'h001', - 9832.6, - 24270.8, 59.405)
    set u=CreateUnit(p, 'h001', - 9717.4, - 24470.4, 254.297)
    set u=CreateUnit(p, 'h001', - 9613.1, - 24477.1, 358.956)
    set u=CreateUnit(p, 'h001', - 9551.1, - 24464.5, 48.682)
    set u=CreateUnit(p, 'h001', - 9522.9, - 24521.6, 133.763)
    set u=CreateUnit(p, 'h001', - 8376.1, - 26241.9, 125.205)
    set u=CreateUnit(p, 'h001', - 8288.6, - 26139.7, 137.383)
    set u=CreateUnit(p, 'h001', - 8237.0, - 26084.4, 144.356)
    set u=CreateUnit(p, 'h001', - 8257.0, - 26020.7, 148.374)
    set u=CreateUnit(p, 'h001', - 8406.2, - 26312.7, 119.693)
    set u=CreateUnit(p, 'h001', - 8330.7, - 26196.0, 131.000)
    set u=CreateUnit(p, 'h001', - 8318.2, - 26085.5, 139.410)
    set gg_unit_H006_0377=CreateUnit(p, 'H006', 30300.6, 30942.2, 273.164)
    call SetUnitState(gg_unit_H006_0377, UNIT_STATE_MANA, 20)
    set gg_unit_h00P_0470=CreateUnit(p, 'h00P', - 25919.2, - 27461.6, 47.850)
    set gg_unit_H003_0496=CreateUnit(p, 'H003', 29617.9, 30477.9, 341.990)
    call SetUnitState(gg_unit_H003_0496, UNIT_STATE_MANA, 20)
    set gg_unit_H005_0497=CreateUnit(p, 'H005', 30791.9, 30554.6, 234.390)
    call SetUnitState(gg_unit_H005_0497, UNIT_STATE_MANA, 60)
    set gg_unit_H010_0498=CreateUnit(p, 'H010', 30746.9, 29948.1, 156.414)
    set gg_unit_H013_0499=CreateUnit(p, 'H013', 30144.1, 29536.1, 65.040)
    set u=CreateUnit(p, 'H002', 29496.7, 29838.6, 187.839)
endfunction

//===========================================================================
function CreatePlayerBuildings takes nothing returns nothing
    call CreateBuildingsForPlayer10()
endfunction

//===========================================================================
function CreatePlayerUnits takes nothing returns nothing
    call CreateUnitsForPlayer0()
    call CreateUnitsForPlayer1()
    call CreateUnitsForPlayer2()
    call CreateUnitsForPlayer3()
    call CreateUnitsForPlayer4()
    call CreateUnitsForPlayer5()
    call CreateUnitsForPlayer6()
    call CreateUnitsForPlayer7()
    call CreateUnitsForPlayer8()
    call CreateUnitsForPlayer9()
    call CreateUnitsForPlayer10()
    call CreateUnitsForPlayer11()
endfunction

//===========================================================================
function CreateAllUnits takes nothing returns nothing
    call CreateNeutralPassiveBuildings()
    call CreateBuildingsForPlayer10() // INLINED!!
    call CreateNeutralHostile()
    call CreateNeutralPassive()
    call CreatePlayerUnits()
endfunction

//***************************************************************************
//*
//*  Regions
//*
//***************************************************************************

function CreateRegions takes nothing returns nothing
    local weathereffect we

    set gg_rct_a1_rain=Rect(- 29024.0, - 28992.0, - 4384.0, - 10240.0)
    set we=AddWeatherEffect(gg_rct_a1_rain, 'RAhr')
    call EnableWeatherEffect(we, true)
    set gg_rct_Choose_Wizard=Rect(30592.0, 29088.0, 31232.0, 29216.0)
    set gg_rct_Choose_Warrior=Rect(30560.0, 29088.0, 31232.0, 29216.0)
    set gg_rct_Choose_Archer=Rect(30592.0, 29056.0, 31232.0, 29248.0)
    set gg_rct_Create_Starting_Units=Rect(30176.0, 29216.0, 30208.0, 29248.0)
    set gg_rct_Red_Backpack_Area=Rect(28128.0, 21888.0, 28928.0, 22656.0)
    set gg_rct_Orange_Backpack_Area=Rect(28928.0, 20352.0, 29696.0, 21120.0)
    set gg_rct_Teal_Backpack_Area=Rect(28128.0, 21120.0, 28928.0, 21888.0)
    set gg_rct_Purple_Backpack_Area=Rect(28160.0, 20320.0, 28928.0, 21120.0)
    set gg_rct_Yellow_Backpack_Area=Rect(28928.0, 21856.0, 29696.0, 22656.0)
    set gg_rct_Green_Backpack_Area=Rect(29664.0, 21888.0, 30464.0, 22656.0)
    set gg_rct_Pink_Backpack_Area=Rect(29664.0, 20352.0, 30464.0, 21120.0)
    set gg_rct_Gray_Backpack_Area=Rect(30464.0, 21888.0, 31232.0, 22656.0)
    set gg_rct_Light_Blue_Backpack_Area=Rect(30432.0, 21120.0, 31232.0, 21888.0)
    set gg_rct_Dark_Green_Backpack_Area=Rect(30464.0, 20384.0, 31232.0, 21120.0)
    set gg_rct_Backpack_Area_All=Rect(28896.0, 21120.0, 30464.0, 21888.0)
    set gg_rct_DoE_Enter_Start=Rect(- 8096.0, - 23008.0, - 7648.0, - 22624.0)
    set gg_rct_DoE_Exit_End=Rect(- 7328.0, - 22880.0, - 7200.0, - 22752.0)
    set gg_rct_DoE_Exit_Start=Rect(- 29088.0, 30400.0, - 28384.0, 31104.0)
    set gg_rct_DoE_Enter_End=Rect(- 28192.0, 30400.0, - 28000.0, 30592.0)
    set gg_rct_Archer_Region_Lock=Rect(30208.0, 30688.0, 30240.0, 30720.0)
    set gg_rct_Wizard_Region_Lock=Rect(30560.0, 30432.0, 30592.0, 30464.0)
    set gg_rct_Warrior_Region_Lock=Rect(29760.0, 30368.0, 29824.0, 30400.0)
    set gg_rct_Rogue_Warrior_Lock=Rect(30560.0, 29984.0, 30592.0, 30016.0)
    set gg_rct_Summoner_Region_Lock=Rect(30144.0, 29728.0, 30176.0, 29760.0)
    set gg_rct_Instance_Room=Rect(28480.0, 22976.0, 29056.0, 24128.0)
    set gg_rct_Kobold_Dungeon_Enter_Instance=Rect(- 24608.0, 23936.0, - 24032.0, 24288.0)
    set gg_rct_Tree_Area=Rect(26752.0, 29824.0, 28800.0, 30848.0)
    set gg_rct_Menu_Area=Rect(28160.0, 29856.0, 28800.0, 30208.0)
    set gg_rct_TalentTitleRect=Rect(28288.0, 30752.0, 28768.0, 30816.0)
    set gg_rct_TalentDescRect=Rect(28192.0, 30240.0, 28800.0, 30688.0)
    set gg_rct_replaceRegion=Rect(26528.0, 29728.0, 28928.0, 31008.0)
    set gg_rct_Gotum_Fountain=Rect(- 24832.0, - 27200.0, - 23776.0, - 26464.0)
    set gg_rct_inventory=Rect(29088.0, 26368.0, 30400.0, 26880.0)
    set gg_rct_equipment=Rect(29120.0, 26880.0, 29632.0, 27392.0)
    set gg_rct_operator_console=Rect(30464.0, 26368.0, 31104.0, 26624.0)
    set gg_rct_equipment_console=Rect(29920.0, 26912.0, 30368.0, 27392.0)
    set gg_rct_Region_040=Rect(30624.0, 26656.0, 31072.0, 26720.0)
    set gg_rct_Region_041=Rect(30592.0, 27296.0, 31072.0, 27360.0)
    set gg_rct_Region_042=Rect(30496.0, 26816.0, 31072.0, 27232.0)
    set gg_rct_Region_043=Rect(- 24704.0, - 26784.0, - 24672.0, - 26752.0)
    set gg_rct_KFrenzyEntrance=Rect(- 25824.0, 23616.0, - 25504.0, 24096.0)
    set gg_rct_KFWipeA=Rect(- 29024.0, 20800.0, - 25440.0, 24384.0)
    set we=AddWeatherEffect(gg_rct_KFWipeA, 'MEds')
    call EnableWeatherEffect(we, true)
    set gg_rct_KFWipeB=Rect(- 25504.0, 20736.0, - 23264.0, 22432.0)
    set we=AddWeatherEffect(gg_rct_KFWipeB, 'MEds')
    call EnableWeatherEffect(we, true)
    set gg_rct_ExitGotum=Rect(- 22784.0, - 25824.0, - 22304.0, - 25344.0)
    set gg_rct_ReturnGotum=Rect(- 23040.0, - 26176.0, - 22784.0, - 25888.0)
endfunction

//***************************************************************************
//*
//*  Custom Script Code
//*
//***************************************************************************
//TESH.scrollpos=537
//TESH.alwaysfold=0


//***************************************************************************
//*
//*  Triggers
//*
//***************************************************************************

//===========================================================================
// Trigger: GameStart Copy
//
// 
//===========================================================================
//TESH.scrollpos=14
//TESH.alwaysfold=0
// Trigger: GlobalExpRate
//===========================================================================
function Trig_GlobalExpRate_Actions takes nothing returns nothing
    set bj_forLoopAIndex=1
    set bj_forLoopAIndexEnd=15
    loop
        exitwhen bj_forLoopAIndex > bj_forLoopAIndexEnd
        call SetPlayerHandicapXPBJ(ConvertedPlayer(GetForLoopIndexA()), 70.00)
        set bj_forLoopAIndex=bj_forLoopAIndex + 1
    endloop
endfunction

//===========================================================================
function InitTrig_GlobalExpRate takes nothing returns nothing
    set gg_trg_GlobalExpRate=CreateTrigger()
    call TriggerAddAction(gg_trg_GlobalExpRate, function Trig_GlobalExpRate_Actions)
endfunction

//===========================================================================
// Trigger: Untitled Trigger 008
//===========================================================================
function Trig_Untitled_Trigger_008_Actions takes nothing returns nothing
endfunction

//===========================================================================
function InitTrig_Untitled_Trigger_008 takes nothing returns nothing
    set gg_trg_Untitled_Trigger_008=CreateTrigger()
    call TriggerAddAction(gg_trg_Untitled_Trigger_008, function Trig_Untitled_Trigger_008_Actions)
endfunction

//===========================================================================
// Trigger: Inity
//===========================================================================
//TESH.scrollpos=14
//TESH.alwaysfold=0
function Trig_Inity_Func004001001001 takes nothing returns boolean
    return ( GetPlayerSlotState(GetFilterPlayer()) == PLAYER_SLOT_STATE_PLAYING )
endfunction

function Trig_Inity_Func004001001002 takes nothing returns boolean
    return ( GetPlayerController(GetFilterPlayer()) == MAP_CONTROL_USER )
endfunction

function Trig_Inity_Func004001001 takes nothing returns boolean
    return GetBooleanAnd((GetPlayerSlotState(GetFilterPlayer()) == PLAYER_SLOT_STATE_PLAYING), (GetPlayerController(GetFilterPlayer()) == MAP_CONTROL_USER)) // INLINED!!
endfunction

function Trig_Inity_Func004A takes nothing returns nothing
 //   call CreateNUnitsAtLoc( 1, 'hfoo', GetEnumPlayer(), GetRectCenter(gg_rct_Create_Starting_Units), bj_UNIT_FACING )
endfunction

//===========================================================================
function InitTrig_Inity takes nothing returns nothing
    call CreateFogModifierRectBJ(true, Player(0), FOG_OF_WAR_VISIBLE, GetPlayableMapRect())
    call SetForceAllianceStateBJ(bj_FORCE_PLAYER[10], GetPlayersAllies(Player(0)), bj_ALLIANCE_ALLIED_VISION)
    call SetForceAllianceStateBJ(bj_FORCE_PLAYER[10], bj_FORCE_PLAYER[0], bj_ALLIANCE_ALLIED_VISION)
    call SetForceAllianceStateBJ(GetPlayersByMapControl(MAP_CONTROL_USER), bj_FORCE_PLAYER[10], bj_ALLIANCE_ALLIED_VISION)
    call ForForce(GetPlayersMatching(Condition(function Trig_Inity_Func004001001)), function Trig_Inity_Func004A)
    set udg_BackPackArea[1]=gg_rct_Red_Backpack_Area
    set udg_BackPackArea[2]=gg_rct_Teal_Backpack_Area
    set udg_BackPackArea[3]=gg_rct_Purple_Backpack_Area
    set udg_BackPackArea[4]=gg_rct_Yellow_Backpack_Area
    set udg_BackPackArea[5]=gg_rct_Orange_Backpack_Area
    set udg_BackPackArea[6]=gg_rct_Pink_Backpack_Area
    set udg_BackPackArea[7]=gg_rct_Green_Backpack_Area
    set udg_BackPackArea[8]=gg_rct_Gray_Backpack_Area
    set udg_BackPackArea[9]=gg_rct_Light_Blue_Backpack_Area
    set udg_BackPackArea[10]=gg_rct_Dark_Green_Backpack_Area
    set udg_Backpack[1]=gg_unit_h009_0227
    set udg_Backpack[2]=gg_unit_h009_0232
    set udg_Backpack[3]=gg_unit_h009_0228
    set udg_Backpack[4]=gg_unit_h009_0229
    set udg_Backpack[5]=gg_unit_h009_0230
    set udg_Backpack[6]=gg_unit_h009_0226
    set udg_Backpack[7]=gg_unit_h009_0225
    set udg_Backpack[8]=gg_unit_h009_0231
    set udg_Backpack[9]=gg_unit_h009_0233
    set udg_Backpack[10]=gg_unit_h009_0224
endfunction

//===========================================================================
// Trigger: Thread
//===========================================================================
//TESH.scrollpos=42
//TESH.alwaysfold=0
// Trigger: Revive
//===========================================================================
function Trig_Revive_Conditions takes nothing returns boolean
    if ( not ( GetTriggerUnit() == udg_PlayerUnit[GetConvertedPlayerId(GetOwningPlayer(GetTriggerUnit()))] ) ) then
        return false
    endif
    return true
endfunction

function Trig_Revive_Actions takes nothing returns nothing
    call print(GetPlayerNameColored(GetTriggerPlayer()) + "'s " + GetUnitName(GetTriggerUnit()) + " has died and will be revived at Golum in 30 seconds")
    call TriggerSleepAction(10.00)
    set udg_TempLoc=GetUnitLoc(gg_unit_ncp3_0027)
    call ReviveHeroLoc(GetTriggerUnit(), udg_TempLoc, false)
    call RemoveLocation(udg_TempLoc)
    call DisplayTimedTextToForce(GetForceOfPlayer(GetTriggerPlayer()), 30, "TRIGSTR_1235")
endfunction

//===========================================================================
function InitTrig_Revive takes nothing returns nothing
    set gg_trg_Revive=CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(gg_trg_Revive, EVENT_PLAYER_UNIT_DEATH)
    call TriggerAddCondition(gg_trg_Revive, Condition(function Trig_Revive_Conditions))
    call TriggerAddAction(gg_trg_Revive, function Trig_Revive_Actions)
endfunction

//===========================================================================
// Trigger: Ascii
//===========================================================================
//TESH.scrollpos=21
//TESH.alwaysfold=0
// Trigger: Alloc
//===========================================================================
//TESH.scrollpos=7
//TESH.alwaysfold=0
// Trigger: Beta Test Buffs
//===========================================================================
function Trig_Beta_Test_Buffs_Conditions takes nothing returns boolean
    if ( not ( IsUnitType(GetTriggerUnit(), UNIT_TYPE_HERO) == true ) ) then
        return false
    endif
    return true
endfunction

function Trig_Beta_Test_Buffs_Actions takes nothing returns nothing
    call IssueTargetOrderBJ(gg_unit_h011_0520, "bloodlust", GetTriggerUnit())
    call TriggerSleepAction(0.25)
    call IssueTargetOrderBJ(gg_unit_h011_0520, "innerfire", GetTriggerUnit())
endfunction

//===========================================================================
function InitTrig_Beta_Test_Buffs takes nothing returns nothing
    set gg_trg_Beta_Test_Buffs=CreateTrigger()
    call TriggerRegisterUnitInRangeSimple(gg_trg_Beta_Test_Buffs, 500.00, gg_unit_h011_0520)
    call TriggerAddCondition(gg_trg_Beta_Test_Buffs, Condition(function Trig_Beta_Test_Buffs_Conditions))
    call TriggerAddAction(gg_trg_Beta_Test_Buffs, function Trig_Beta_Test_Buffs_Actions)
endfunction

//===========================================================================
// Trigger: Untitled Trigger 006
//===========================================================================
function Trig_Untitled_Trigger_006_Actions takes nothing returns nothing
    call SetUnitLifePercentBJ(GetTriggerUnit(), 100)
    call SetUnitManaPercentBJ(GetTriggerUnit(), 100)
endfunction

//===========================================================================
function InitTrig_Untitled_Trigger_006 takes nothing returns nothing
    set gg_trg_Untitled_Trigger_006=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_Untitled_Trigger_006, gg_rct_Gotum_Fountain)
    call TriggerAddAction(gg_trg_Untitled_Trigger_006, function Trig_Untitled_Trigger_006_Actions)
endfunction

//===========================================================================
// Trigger: lvl
//===========================================================================
function Trig_lvl_Actions takes nothing returns nothing
    call SetHeroLevelBJ(udg_PlayerUnit[GetConvertedPlayerId(GetTriggerPlayer())], S2I(SubStringBJ(GetEventPlayerChatString(), 5, StringLength(GetEventPlayerChatString()))), false)
endfunction

//===========================================================================
function InitTrig_lvl takes nothing returns nothing
    set gg_trg_lvl=CreateTrigger()
    call TriggerRegisterPlayerChatEvent(gg_trg_lvl, Player(0), "-lvl", false)
    call TriggerAddAction(gg_trg_lvl, function Trig_lvl_Actions)
endfunction

//===========================================================================
// Trigger: init
//===========================================================================
function Trig_init_Func042A takes nothing returns nothing
    call TriggerRegisterPlayerKeyEventBJ(gg_trg_right_arrow, GetEnumPlayer(), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_RIGHT)
    call TriggerRegisterPlayerKeyEventBJ(gg_trg_left_arrow, GetEnumPlayer(), bj_KEYEVENTTYPE_DEPRESS, bj_KEYEVENTKEY_LEFT)
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_esc, GetEnumPlayer())
    call TriggerRegisterPlayerChatEvent(gg_trg_repick, GetEnumPlayer(), "-repick", true)
    call SelectUnitForPlayerSingle(udg_Select_Hero[udg_Select_Current[udg_Temp_Integer]], GetEnumPlayer())
    call SetCameraFieldForPlayer(GetEnumPlayer(), CAMERA_FIELD_TARGET_DISTANCE, 360.00, 0)
    call SetCameraFieldForPlayer(GetEnumPlayer(), CAMERA_FIELD_ANGLE_OF_ATTACK, 360.00, 0)
    call SetCameraFieldForPlayer(GetEnumPlayer(), CAMERA_FIELD_ZOFFSET, 100.00, 0)
    call ForceAddPlayerSimple(GetEnumPlayer(), udg_Select_PlayerGroup)
    call PanCameraToTimedLocForPlayer(GetEnumPlayer(), udg_Select_HeroCam[udg_Select_Current[udg_Temp_Integer]], 0)
    call SetCameraTargetControllerNoZForPlayer(GetEnumPlayer(), udg_Select_HeroCenterDummy[udg_Select_Current[udg_Temp_Integer]], 0, 0, false)
    call ClearTextMessagesBJ(GetForceOfPlayer(GetEnumPlayer()))
    set udg_Temp_Integer=GetConvertedPlayerId(GetEnumPlayer())
    call DisplayTimedTextToForce(GetForceOfPlayer(GetEnumPlayer()), 180000.00, ( "|cffffcc00Name|r : " + GetUnitName(udg_Select_Hero[udg_Select_Current[udg_Temp_Integer]]) ))
    call DisplayTimedTextToForce(GetForceOfPlayer(GetEnumPlayer()), 180000.00, ( "|cffffcc00Role|r : " + udg_Select_HeroRole[udg_Select_Current[udg_Temp_Integer]] ))
    call DisplayTimedTextToForce(GetForceOfPlayer(GetEnumPlayer()), 180000.00, ( "|cffffcc00Abilities|r : " + udg_Select_HeroAbilties[udg_Select_Current[udg_Temp_Integer]] ))
    call DisplayTimedTextToForce(GetForceOfPlayer(GetEnumPlayer()), 180000.00, ( "|cffffcc00Description|r : " + udg_Select_HeroDescription[udg_Select_Current[udg_Temp_Integer]] ))
    call DisplayTimedTextToForce(GetForceOfPlayer(GetEnumPlayer()), 180000.00, ( "|cffffcc00Evolution|r : " + udg_Select_Evolutions[udg_Select_Current[udg_Temp_Integer]] ))
    call DisplayTimedTextToForce(GetForceOfPlayer(GetEnumPlayer()), 180000.00, ( "|cffffcc00Hint|r : " + udg_Select_Hint ))
endfunction

function Trig_init_Actions takes nothing returns nothing
    set udg_Select_HeroCenterDummy[0]=gg_unit_h00Y_0505
    set udg_Select_HeroCenterDummy[1]=gg_unit_h00Y_0504
    set udg_Select_HeroCenterDummy[2]=gg_unit_h00Y_0506
    set udg_Select_HeroCenterDummy[3]=gg_unit_h00Y_0515
    set udg_Select_HeroCenterDummy[4]=gg_unit_h00Y_0526
    set udg_Select_RegionLock[0]=gg_rct_Archer_Region_Lock
    set udg_Select_RegionLock[1]=gg_rct_Wizard_Region_Lock
    set udg_Select_RegionLock[2]=gg_rct_Warrior_Region_Lock
    set udg_Select_RegionLock[3]=gg_rct_Rogue_Warrior_Lock
    set udg_Select_RegionLock[4]=gg_rct_Summoner_Region_Lock
    set udg_Select_Hero[0]=gg_unit_H006_0377
    set udg_Select_Hero[1]=gg_unit_H005_0497
    set udg_Select_Hero[2]=gg_unit_H003_0496
    set udg_Select_Hero[3]=gg_unit_H010_0498
    set udg_Select_Hero[4]=gg_unit_H013_0499
    set udg_Select_HeroName[0]="Archer"
    set udg_Select_HeroName[1]="Wizard"
    set udg_Select_HeroName[2]="Warrior"
    set udg_Select_HeroName[3]="Rogue"
    set udg_Select_HeroName[4]="Summoner"
    set udg_Select_HeroRole[0]="Ranged Physical DPS"
    set udg_Select_HeroRole[1]="Ranged Magical DPS"
    set udg_Select_HeroRole[2]="Tank / Melee Physical DPS"
    set udg_Select_HeroRole[3]="Melee Physical DPS"
    set udg_Select_HeroRole[4]="All-Around"
    set udg_Select_HeroAbilties[0]="Flaming Arrow, Entangling Roots, Multishot, Eye of the Hunt, Elune's Arrow"
    set udg_Select_HeroAbilties[1]="Magical Bolt, Electricity, Frost Nova, Artificial Shield, Meteor"
    set udg_Select_HeroAbilties[2]="Fierce Blow, Frenzy, Defensive Stance, Battle Cry, Fury of Athens"
    set udg_Select_HeroAbilties[3]="Swift Blows, Wind Walk, Chidori, Tactics, Shuriken"
    set udg_Select_HeroAbilties[4]="Corrupted Sprite, Rejuvenated Blood, Bloodsucker, Champion of Death, Bloodbath"
    set udg_Select_HeroDescription[0]="Able to deal physical damage from a distance while also specializing in support"
    set udg_Select_HeroDescription[1]="Able to deal maximized magical damage from a distance"
    set udg_Select_HeroDescription[2]="Able to deal physical damage from melee distance while being used for tanking"
    set udg_Select_HeroDescription[3]="Able to get into and out of combat fast at melee range"
    set udg_Select_HeroDescription[4]="Able to specialize in any field to suit his or his team's needs the most."
    set udg_Select_Evolutions[0]="Master Archer, Magic Shot, Ranger, Warden, Axe Thrower"
    set udg_Select_Evolutions[1]="Master Wizard, White Mage, Warlock, Spellbreaker, Magic Shot"
    set udg_Select_Evolutions[2]="Master Fighter, Axe Thrower, Spellbreaker, Paladin, Beast Master"
    set udg_Select_Evolutions[3]="Master Rogue, Assassin, Monk, Warden, Bomb Rogue"
    set udg_Select_Evolutions[4]="Master Summoner, Spirit, Beast Master, Ranger, Warlock"
    set udg_Select_Hint="ESC = Choose, ESC+Load = Load, Arrow Keys = Next"
    call ForForce(GetPlayersAll(), function Trig_init_Func042A)
endfunction

//===========================================================================
function InitTrig_init takes nothing returns nothing
    set gg_trg_init=CreateTrigger()
    call TriggerAddAction(gg_trg_init, function Trig_init_Actions)
endfunction

//===========================================================================
// Trigger: right arrow
//===========================================================================
function Trig_right_arrow_Conditions takes nothing returns boolean
    if ( not ( IsPlayerInForce(GetTriggerPlayer(), udg_Select_PlayerGroup) == true ) ) then
        return false
    endif
    return true
endfunction

function Trig_right_arrow_Func002C takes nothing returns boolean
    if ( not ( udg_Select_Current[udg_Temp_Integer] == 4 ) ) then
        return false
    endif
    return true
endfunction

function Trig_right_arrow_Actions takes nothing returns nothing
    set udg_Temp_Integer=GetConvertedPlayerId(GetTriggerPlayer())
    if ( Trig_right_arrow_Func002C() ) then
        set udg_Select_Current[udg_Temp_Integer]=0
    else
        set udg_Select_Current[udg_Temp_Integer]=( udg_Select_Current[udg_Temp_Integer] + 1 )
    endif
    call PanCameraToTimedLocForPlayer(GetTriggerPlayer(), udg_Select_HeroCam[udg_Select_Current[udg_Temp_Integer]], 0)
    call SetCameraTargetControllerNoZForPlayer(GetTriggerPlayer(), udg_Select_HeroCenterDummy[udg_Select_Current[udg_Temp_Integer]], 0, 0, false)
    call SetCameraFieldForPlayer(GetTriggerPlayer(), CAMERA_FIELD_ROTATION, ( GetUnitFacing(udg_Select_Hero[udg_Select_Current[udg_Temp_Integer]]) + 180.00 ), 0)
    call ClearTextMessagesBJ(GetForceOfPlayer(GetTriggerPlayer()))
    call SelectUnitForPlayerSingle(udg_Select_Hero[udg_Select_Current[udg_Temp_Integer]], GetEnumPlayer())
    call DisplayTimedTextToForce(GetForceOfPlayer(GetTriggerPlayer()), 180000.00, ( "|cffffcc00Name|r : " + GetUnitName(udg_Select_Hero[udg_Select_Current[udg_Temp_Integer]]) ))
    call DisplayTimedTextToForce(GetForceOfPlayer(GetTriggerPlayer()), 180000.00, ( "|cffffcc00Role|r : " + udg_Select_HeroRole[udg_Select_Current[udg_Temp_Integer]] ))
    call DisplayTimedTextToForce(GetForceOfPlayer(GetTriggerPlayer()), 180000.00, ( "|cffffcc00Abilities|r : " + udg_Select_HeroAbilties[udg_Select_Current[udg_Temp_Integer]] ))
    call DisplayTimedTextToForce(GetForceOfPlayer(GetTriggerPlayer()), 180000.00, ( "|cffffcc00Description|r : " + udg_Select_HeroDescription[udg_Select_Current[udg_Temp_Integer]] ))
    call DisplayTimedTextToForce(GetForceOfPlayer(GetTriggerPlayer()), 180000.00, ( "|cffffcc00Evolution|r : " + udg_Select_Evolutions[udg_Select_Current[udg_Temp_Integer]] ))
    call DisplayTimedTextToForce(GetForceOfPlayer(GetTriggerPlayer()), 180000.00, ( "|cffffcc00Hint|r : " + udg_Select_Hint ))
endfunction

//===========================================================================
function InitTrig_right_arrow takes nothing returns nothing
    set gg_trg_right_arrow=CreateTrigger()
    call TriggerAddCondition(gg_trg_right_arrow, Condition(function Trig_right_arrow_Conditions))
    call TriggerAddAction(gg_trg_right_arrow, function Trig_right_arrow_Actions)
endfunction

//===========================================================================
// Trigger: left arrow
//===========================================================================
function Trig_left_arrow_Conditions takes nothing returns boolean
    if ( not ( IsPlayerInForce(GetTriggerPlayer(), udg_Select_PlayerGroup) == true ) ) then
        return false
    endif
    return true
endfunction

function Trig_left_arrow_Func002C takes nothing returns boolean
    if ( not ( udg_Select_Current[udg_Temp_Integer] == 0 ) ) then
        return false
    endif
    return true
endfunction

function Trig_left_arrow_Actions takes nothing returns nothing
    set udg_Temp_Integer=GetConvertedPlayerId(GetTriggerPlayer())
    if ( Trig_left_arrow_Func002C() ) then
        set udg_Select_Current[udg_Temp_Integer]=4
    else
        set udg_Select_Current[udg_Temp_Integer]=( udg_Select_Current[udg_Temp_Integer] - 1 )
    endif
    call PanCameraToTimedLocForPlayer(GetTriggerPlayer(), udg_Select_HeroCam[udg_Select_Current[udg_Temp_Integer]], 0)
    call SetCameraTargetControllerNoZForPlayer(GetTriggerPlayer(), udg_Select_HeroCenterDummy[udg_Select_Current[udg_Temp_Integer]], 0, 0, false)
    call SetCameraFieldForPlayer(GetTriggerPlayer(), CAMERA_FIELD_ROTATION, ( GetUnitFacing(udg_Select_Hero[udg_Select_Current[udg_Temp_Integer]]) + 180.00 ), 0)
    call ClearTextMessagesBJ(GetForceOfPlayer(GetTriggerPlayer()))
    call SelectUnitForPlayerSingle(udg_Select_Hero[udg_Select_Current[udg_Temp_Integer]], GetEnumPlayer())
    call DisplayTimedTextToForce(GetForceOfPlayer(GetTriggerPlayer()), 180000.00, ( "|cffffcc00Name|r : " + GetUnitName(udg_Select_Hero[udg_Select_Current[udg_Temp_Integer]]) ))
    call DisplayTimedTextToForce(GetForceOfPlayer(GetTriggerPlayer()), 180000.00, ( "|cffffcc00Role|r : " + udg_Select_HeroRole[udg_Select_Current[udg_Temp_Integer]] ))
    call DisplayTimedTextToForce(GetForceOfPlayer(GetTriggerPlayer()), 180000.00, ( "|cffffcc00Abilities|r : " + udg_Select_HeroAbilties[udg_Select_Current[udg_Temp_Integer]] ))
    call DisplayTimedTextToForce(GetForceOfPlayer(GetTriggerPlayer()), 180000.00, ( "|cffffcc00Description|r : " + udg_Select_HeroDescription[udg_Select_Current[udg_Temp_Integer]] ))
    call DisplayTimedTextToForce(GetForceOfPlayer(GetTriggerPlayer()), 180000.00, ( "|cffffcc00Evolution|r : " + udg_Select_Evolutions[udg_Select_Current[udg_Temp_Integer]] ))
    call DisplayTimedTextToForce(GetForceOfPlayer(GetTriggerPlayer()), 180000.00, ( "|cffffcc00Hint|r : " + udg_Select_Hint ))
endfunction

//===========================================================================
function InitTrig_left_arrow takes nothing returns nothing
    set gg_trg_left_arrow=CreateTrigger()
    call TriggerAddCondition(gg_trg_left_arrow, Condition(function Trig_left_arrow_Conditions))
    call TriggerAddAction(gg_trg_left_arrow, function Trig_left_arrow_Actions)
endfunction

//===========================================================================
// Trigger: periodic
//===========================================================================
function Trig_periodic_Func001A takes nothing returns nothing
    call SetCameraFieldForPlayer(GetEnumPlayer(), CAMERA_FIELD_TARGET_DISTANCE, 360.00, 0)
    call SetCameraFieldForPlayer(GetEnumPlayer(), CAMERA_FIELD_ANGLE_OF_ATTACK, 360.00, 0)
    call SetCameraFieldForPlayer(GetEnumPlayer(), CAMERA_FIELD_ZOFFSET, 100.00, 0)
endfunction

function Trig_periodic_Actions takes nothing returns nothing
    call ForForce(udg_Select_PlayerGroup, function Trig_periodic_Func001A)
endfunction

//===========================================================================
function InitTrig_periodic takes nothing returns nothing
    set gg_trg_periodic=CreateTrigger()
    call TriggerRegisterTimerEventPeriodic(gg_trg_periodic, 0.10)
    call TriggerAddAction(gg_trg_periodic, function Trig_periodic_Actions)
endfunction

//===========================================================================
// Trigger: repick
//===========================================================================
function Trig_repick_Func009Func001C takes nothing returns boolean
    if ( not ( IsUnitType(GetEnumUnit(), UNIT_TYPE_HERO) == false ) ) then
        return false
    endif
    if ( not ( GetUnitTypeId(GetEnumUnit()) != 'h009' ) ) then
        return false
    endif
    if ( not ( GetUnitTypeId(GetEnumUnit()) != 'h00Y' ) ) then
        return false
    endif
    if ( not ( GetUnitTypeId(GetEnumUnit()) != 'h004' ) ) then
        return false
    endif
    return true
endfunction

function Trig_repick_Func009A takes nothing returns nothing
    if ( Trig_repick_Func009Func001C() ) then
        call KillUnit(GetEnumUnit())
    else
    endif
endfunction

function Trig_repick_Actions takes nothing returns nothing
    call ForceUICancelBJ(GetTriggerPlayer())
    call TriggerSleepAction(1.00)
    call s__QuestAPI_onRepick(GetTriggerPlayer())
    call s__Party_onRepick(GetTriggerPlayer())
    call s__CustomInventory_destroyEverything(udg_PlayerUnit[GetPlayerId(GetTriggerPlayer()) + 1])
    call SetPlayerStateBJ(GetTriggerPlayer(), PLAYER_STATE_RESOURCE_GOLD, 0)
    call SetPlayerStateBJ(GetTriggerPlayer(), PLAYER_STATE_RESOURCE_LUMBER, 0)
    set bj_wantDestroyGroup=true
    call ForGroupBJ(GetUnitsInRectOfPlayer(GetPlayableMapRect(), GetTriggerPlayer()), function Trig_repick_Func009A)
    set bj_forLoopAIndex=1
    set bj_forLoopAIndexEnd=6
    loop
        exitwhen bj_forLoopAIndex > bj_forLoopAIndexEnd
        call RemoveItem(UnitItemInSlotBJ(udg_Backpack[GetConvertedPlayerId(GetTriggerPlayer())], GetForLoopIndexA()))
        set bj_forLoopAIndex=bj_forLoopAIndex + 1
    endloop
    call RemoveUnit(udg_PlayerUnit[GetConvertedPlayerId(GetTriggerPlayer())])
    set udg_PlayerUnit[GetPlayerId(GetTriggerPlayer()) + 1]=null
    call SetCameraFieldForPlayer(GetTriggerPlayer(), CAMERA_FIELD_TARGET_DISTANCE, 360.00, 0)
    call SetCameraFieldForPlayer(GetTriggerPlayer(), CAMERA_FIELD_ANGLE_OF_ATTACK, 360.00, 0)
    call SetCameraFieldForPlayer(GetTriggerPlayer(), CAMERA_FIELD_ZOFFSET, 100.00, 0)
    call ForceAddPlayerSimple(GetTriggerPlayer(), udg_Select_PlayerGroup)
    set udg_Temp_Integer=GetConvertedPlayerId(GetTriggerPlayer())
    call TriggerExecute(gg_trg_right_arrow)
endfunction

//===========================================================================
function InitTrig_repick takes nothing returns nothing
    set gg_trg_repick=CreateTrigger()
    call TriggerAddAction(gg_trg_repick, function Trig_repick_Actions)
endfunction

//===========================================================================
// Trigger: esc
//===========================================================================
//TESH.scrollpos=15
//TESH.alwaysfold=0
// Trigger: RootLibrary
//
// integer typeOfTraitx, real aminx, real amaxx, real aweightx, real bminx, real bmaxx, real bweightx, /*
//         */                      real cminx, real cmaxx, real cweightx, real dminx, real dmaxx, real dweightx, integer traitWeight
//===========================================================================
//TESH.scrollpos=92
//TESH.alwaysfold=0
// Trigger: TraitConstants
//===========================================================================
//TESH.scrollpos=51
//TESH.alwaysfold=0
// Trigger: showinventory
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: mainitemcreation
//
// 
// Damage : 535,000
// Chaos Damage : 50,000
// Armor Reduction : 1000
// Strength : 100,000
// Ability : 10% chance on kill to cast Redeem
// 0Ability : Light of the Avenger
// Hyper Damage : Damage = damage * 2^24 + 2^28, damage = damage/2^24 - 2^28 
// Hyper Life : life = life * 2^24 + 2^28, life = life/2^24 - 2^28,
// Hyper Attack : 5 attacks per hit, attack speed 1/4
// Hyper Armor = actualArmor = armor * 2048 + 8192
//===========================================================================
//TESH.scrollpos=416
//TESH.alwaysfold=0
// Trigger: InventoryCoderInterface
//
// 
//             constant integer SLOT_BELT = 1
//             constant integer SLOT_HELM = 2
//             constant integer SLOT_GLOVE = 3
//             constant integer SLOT_WING = 4
//             constant integer SLOT_MAINHAND = 5
//             constant integer SLOT_OFFHAND = 6
//             constant integer SLOT_RINGLEFT = 7
//             constant integer SLOT_RINGRIGHT = 8
//             constant integer SLOT_BOOTS = 9
//             constant integer SLOT_NECKLACE = 10
//             constant integer SLOT_PANTS = 11
//             constant integer SLOT_SHOULDERS = 12
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: TraitHandler
//
// Randomized Traits>
//       Trait Value > Trait Min/Max > Random Trait Generator > Random Item Generator
// Finished Traits
//       Trait Value(s) > Item
//===========================================================================
//TESH.scrollpos=1
//TESH.alwaysfold=0
    //===========================================================================
// Trigger: Recipe
//===========================================================================
//TESH.scrollpos=69
//TESH.alwaysfold=0
// Trigger: Statboard
//===========================================================================
//TESH.scrollpos=154
//TESH.alwaysfold=0
//===========================================================================
// Trigger: NoLeaveGotum
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0

//===========================================================================
// Trigger: QuestListener
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: AdvancedQuest
//===========================================================================
//TESH.scrollpos=156
//TESH.alwaysfold=0
// Trigger: GotumStarterQuests
//===========================================================================
//TESH.scrollpos=5
//TESH.alwaysfold=0
// Trigger: Quest
//
// response 1 = add gold
// 2 = add woodn
// 3 = spawn units
// 4 = add item
// 5 = add to trigger
// 6 = condition
// 7 = get trigger
// 8 = get victim
//  gg_unit_h00L_0367 "|cffffcc00Quest Description|r : I would like you walk around town and talk to the villagers\n\n|cffffcc00Goal|r \n" + "     - Talk to the Ship Captain" 
// "     - Talk to the Blacksmith \n     - Talk to the Bounty Agent\n     - Talk to the Alchemist\n\n|cffffcc00Reward|r" + " : 150 Gold, 500 EXP, Quest 'Alchemy'\n\n|cffffcc00Hint|r : The Ship Captain is located in the" + " topleft of the village, the Blacksmith is located in the mid-top of the village, the Bounty Agent is located at the entrance of the forest, and the Alchemist is located in the bottomright of the village.\n\n|cffffcc00Talk to me again to accept this quest|r"
//     call RemoveUnit( gg_unit_h00D_0307 ) - "|cffffcc00Ship Captain|r : Good day. When you are ready to leave Elohim, I am the person you will talk to."
//     call RemoveUnit( gg_unit_h00C_0139 ) - "|cffffcc00Blacksmith|r : Hello. My job in this town is to sell building manuscripts and recipes."
//     call RemoveUnit( gg_unit_h00B_0223 ) - "|cffffcc00Bounty Agent|r Hello. My job is to sell bounties to adventurers. If you are going on a quest you should grab bounties to maximize your time."
//     call RemoveUnit( gg_unit_h00H_0310 ) - "|cffffcc00Alchemist|r : Hello, I am the Alchemist. My job in town is to sell potions and other chemical creation formulas."
//===========================================================================
//TESH.scrollpos=662
//TESH.alwaysfold=0
// Trigger: Party
//===========================================================================
//TESH.scrollpos=200
//TESH.alwaysfold=0
// Trigger: HeroImage
//
// 
//                     set copy = CreateUnit(enumPlayer, unitTypeId, WORLD_BOUNDS_MAX_X, WORLD_BOUNDS_MAX_Y, 0)
//                     
//                     call SaveInteger(HASHTABLE, GetHandleId(copy), 1, this)
//                     
//                     set n = n + 1
//                     set this.copies[n] = copy
//===========================================================================
//TESH.scrollpos=182
//TESH.alwaysfold=0
// Trigger: StatHandler
//
// 
//                 //! runtextmacro RESISTANCE_MACRO("0")
//             elseif t.typeOfTrait == TRAIT_TYPE_LIGHTNING_RESISTANCE then
//                 //! runtextmacro RESISTANCE_MACRO("1")
//             elseif t.typeOfTrait == TRAIT_TYPE_COLD_RESISTANCE then
//                 //! runtextmacro RESISTANCE_MACRO("2")
//             elseif t.typeOfTrait == TRAIT_TYPE_POISON_RESISTANCE then
//                 //! runtextmacro RESISTANCE_MACRO("3")
//             elseif t.typeOfTrait == TRAIT_TYPE_DARKNESS_RESISTANCE then
//                 //! runtextmacro RESISTANCE_MACRO("4")
//             elseif t.typeOfTrait == TRAIT_TYPE_HOLY_RESISTANCE then
//                 //! runtextmacro RESISTANCE_MACRO("5")
//             elseif t.typeOfTrait == TRAIT_TYPE_PHYSICAL_RESISTANCE then
//                 //! runtextmacro RESISTANCE_MACRO("6")
//             elseif t.typeOfTrait == TRAIT_TYPE_ALL_RESISTANCE then
//                 //! runtextmacro RESISTANCE_MACRO("7")
//===========================================================================
//TESH.scrollpos=185
//TESH.alwaysfold=0
//==========//===========================================================================
// Trigger: BigInt
//===========================================================================
//TESH.scrollpos=154
//TESH.alwaysfold=0
// Trigger: Scrambler
//===========================================================================
//TESH.scrollpos=3
//TESH.alwaysfold=0
// Trigger: Base
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: GetLearnedAbilities
//===========================================================================
//TESH.scrollpos=3
//TESH.alwaysfold=0
// Trigger: AddRepeatedString
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: Remove String
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: NumberStack
//===========================================================================
//TESH.scrollpos=67
//TESH.alwaysfold=0
//Requires
//  BigInt          hiveworkshop.com/forums/jass-functions-413/system-bigint-188973/
//  Base            hiveworkshop.com/forums/submissions-414/snippet-base-188814/
//  Ascii           wc3c.net/showthread.php?t=110153
//  Table           hiveworkshop.com/forums/jass-functions-413/snippet-new-table-188084/

//Insecure Save


//Insecure Load
//===========================================================================
// Trigger: Knuth Checksum
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: Buffer
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: EncryptNumber
//===========================================================================
//TESH.scrollpos=30
//TESH.alwaysfold=0
//Requires
//  Scrambler       hiveworkshop.com/forums/submissions-414/snippet-salt-189766/
//  NumberStack     hiveworkshop.com/forums/1993458-post521.html
// Trigger: ApplyChecksum
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//Requires
//  KnuthChecksum   hiveworkshop.com/forums/1846246-post343.html
//  NumberStack     hiveworkshop.com/forums/1993458-post521.html
// Trigger: InitSave
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: Simple SaveLoad
//===========================================================================
//TESH.scrollpos=208
//TESH.alwaysfold=0
    
    
    
    
    
    
    
        //Versions
        
    function s__Demo_saveMain takes integer stack,player p returns nothing
        local integer playa= GetPlayerId(p)
        local unit heroUnit= udg_PlayerUnit[playa + 1]
        
        call s__NumberStack_push(stack,GetPlayerState(p, PLAYER_STATE_RESOURCE_LUMBER) , 1000000)
        call s__NumberStack_push(stack,GetPlayerState(p, PLAYER_STATE_RESOURCE_GOLD) , 1000000)
        call s__NumberStack_push(stack,GetHeroLevel(heroUnit) , 4096)
        call s__NumberStack_push(stack,sc__Heroes__get_id((GetUnitTypeId(heroUnit))) , sc__Heroes__get_count())
        
        set heroUnit=null
        set p=null
    endfunction
    
    function s__Demo_loadMain takes integer stack,player p returns nothing
        local integer triggerPlayer= GetPlayerId(p)
        local unit heroUnit
        local integer next= (s__BigInt_divide(((stack)),(sc__Heroes__get_count()) + 1)) // INLINED!!
        
        set udg_PlayerUnit[triggerPlayer + 1]=CreateUnit(p, sc__Heroes__get_raw((next)), 0, 0, 0)
        set heroUnit=udg_PlayerUnit[triggerPlayer + 1]
        set next=(s__BigInt_divide(((stack)),(4096) + 1)) // INLINED!!
        if next != 1 then
            call SetHeroLevel(heroUnit, next, false)
        endif
        
        call SetPlayerState(p, PLAYER_STATE_RESOURCE_GOLD, (s__BigInt_divide(((stack)),(1000000) + 1))) // INLINED!!
        call SetPlayerState(p, PLAYER_STATE_RESOURCE_LUMBER, (s__BigInt_divide(((stack)),(1000000) + 1))) // INLINED!!
        
        call SetUnitX(heroUnit, GetUnitX(gg_unit_ncp3_0027))
        call SetUnitY(heroUnit, GetUnitY(gg_unit_ncp3_0027))
        
        call RemoveLocation(udg_TempLoc)
        if GetLocalPlayer() == GetTriggerPlayer() then
            call ResetToGameCamera(0)
            call PanCameraToTimed(GetUnitX(gg_unit_ncp3_0027), GetUnitY(gg_unit_ncp3_0027), 0)
            call ClearTextMessages()
        endif
        call ForceRemovePlayer(udg_Select_PlayerGroup, GetTriggerPlayer())
        
        call UnitAddItemToSlotById(heroUnit, 'I00I', 5)
        set heroUnit=null
        set p=null
        
    endfunction
    
    function s__Demo_saveInventory takes integer stack,unit pval,integer vers returns nothing
        local integer equipment= s__CustomInventory_getEquipment(pval)
        local integer inventory= s__CustomInventory_getInventory(pval)
        local integer it
        local integer t
        
        local integer i= 0
        local integer i2= 0
        local integer status= 0
        local integer count= 0
        local integer heroCatalog= sc__ItemRoots_get(pval , vers)
        local integer max
        call print("323?:" + I2S(heroCatalog))
        set max=(CatalogCount((heroCatalog))) // INLINED!!
        call print("323!")
        loop
            set it=(LoadInteger(Table___ht, (inventory), (i))) // INLINED!!
            exitwhen it == 0
            call print("Saving an inventory item! : " + GetItemName(s__Item_link[it]) + " : " + I2S(GetItemTypeId(s__Item_link[it])))
            call s__NumberStack_push(stack,(CatalogId((heroCatalog) , (GetItemTypeId(s__Item_link[it])))) , max) // INLINED!!
            set count=count + 1
            set i=i + 1
        endloop
        set i=0
        loop
            set it=(LoadInteger(Table___ht, (equipment), (i))) // INLINED!!
            exitwhen it == 0
            call print("Saving an equipment item! : " + GetItemName(s__Item_link[it]) + " : " + I2S(GetItemTypeId(s__Item_link[it])))
            call s__NumberStack_push(stack,(CatalogId((heroCatalog) , (GetItemTypeId(s__Item_link[it])))) , max) // INLINED!!
            set count=count + 1
            set i=i + 1
        endloop
        call print("Final count:" + I2S(count) + " max " + I2S(max))
        call s__NumberStack_push(stack,count , 1024)
        call s__Table_destroy(equipment)
        call s__Table_destroy(inventory)
        call CatalogDestroy((heroCatalog)) // INLINED!!
    endfunction
    
    function s__Demo_LoadInventory takes player p,integer stack,integer vers returns nothing
        local integer status= 0
        local integer next
        local unit u= udg_PlayerUnit[GetPlayerId(p) + 1]
        local integer heroCatalog= sc__ItemRoots_get(u , vers)
        local integer count= (s__BigInt_divide(((stack)),(1024) + 1)) // INLINED!!
        local integer i= 0
        local integer max= (CatalogCount((heroCatalog))) // INLINED!!
        call print("Count:" + I2S(count) + "max" + I2S(max))
        loop
            exitwhen i == count
            set next=(s__BigInt_divide(((stack)),(max) + 1)) // INLINED!!
            call print("Loading an item! : " + I2S((CatalogRaw((heroCatalog) , (next))))) // INLINED!!
            call s__CustomInventory_generateNewItem(CreateItem((CatalogRaw((heroCatalog) , (next))), 0, 0) , u) // INLINED!!
            set i=i + 1
        endloop
        call CatalogDestroy((heroCatalog)) // INLINED!!
    endfunction
    
    function s__Demo_save takes nothing returns boolean
        local integer stack
        local string encrypted
        local integer triggerPlayer= GetPlayerId(GetTriggerPlayer())
        local unit heroed= udg_PlayerUnit[GetPlayerId(GetTriggerPlayer()) + 1]
        if GetHandleId(udg_PlayerUnit[GetPlayerId(GetTriggerPlayer()) + 1]) == 0 then
            call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 60, "You have no hero to save!")
            return false
        endif
        
        
        set stack=s__NumberStack_create(s__Demo_encryptionKey)
        
        
        
        call s__BigInt_add((stack ),( 1)) // INLINED!!
        
        
        
        //call stack.push(10, 64)      //Stack Values: 10
        //call stack.push(20, 31)      //Stack Values: 20, 10
        call s__Demo_saveInventory(stack , udg_PlayerUnit[GetPlayerId(GetTriggerPlayer()) + 1] , s__Demo_v03G)
        call s__Demo_saveMain(stack , GetTriggerPlayer())
        call s__NumberStack_push(stack,s__Demo_v03G , s__Demo_versionMax)
        
        
        
        
        call ApplyChecksum(stack , s__Demo_security)
        
        
        call EncryptNumber(stack , s__Demo_ENCRYPTION_STRENGTH , GetPlayerId(GetTriggerPlayer()))
        
        set encrypted=s__NumberStack__get_string(stack)
        
        
        call SaveCodeToHD("0.3F" , GetPlayerId(GetTriggerPlayer()) , GetUnitName(heroed) + ", Level " + I2S(GetHeroLevel(heroed)) , encrypted)
        call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, 60, "Check Your Warcraft 3 Directory In The Folder " + ("Fables of Elohim RPG") + " for your save/load code") // INLINED!!
        
        
       // set encrypted = AddRepeatedString(encrypted, "-", 4, 0)
        
        
       // set encrypted = ColorCodeString(encrypted, "40e0d0",  "ff69b4",    "00AA00",  "ffff00",                   0)
        
        
        call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 60, "Code: " + encrypted)
        
        
        call s__BigInt_destroy(((stack))) // INLINED!!
        
        return false
    endfunction
    
    function s__Demo_load takes nothing returns boolean
        local string saveCode
        
        local integer value1
        local integer value2
        local integer curVersion
        
        local integer stack
        
        if GetHandleId(udg_PlayerUnit[GetPlayerId(GetTriggerPlayer()) + 1]) != 0 then
            call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 60, "You cannot load when you have a hero selected")
            return false
        endif
        
        
        set saveCode=GetEventPlayerChatString()
        
        
        set saveCode=RemoveString(saveCode , GetEventPlayerChatStringMatched() , 1 , 0)
        
        
        //set saveCode = RemoveString(saveCode," ",0,0)
        
        
        //set saveCode = RemoveString(saveCode,"-",0,0)
        
        
        if ( 0 == StringLength(saveCode) ) then
            call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 60, "Invalid Code : Bad Length")
            return false
        endif
        
        
        set stack=DecryptNumber(saveCode , s__Demo_encryptionKey , s__Demo_ENCRYPTION_STRENGTH , GetPlayerId(GetTriggerPlayer()))
        
        
        if ( 0 == stack ) then
            call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 60, "Invalid Code : No Information")
            return false
        endif
        
        
        if ( not ValidateChecksum(stack , s__Demo_security) ) then
            call s__BigInt_destroy(((stack))) // INLINED!!
            call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 60, "Invalid Code : Bad Checksum")
            return false
        endif
        
        
        
        
        
        set curVersion=(s__BigInt_divide(((stack)),(s__Demo_versionMax) + 1)) // INLINED!!
        call s__Demo_loadMain(stack , GetTriggerPlayer())
        call s__Demo_LoadInventory(GetTriggerPlayer() , stack , curVersion)
        
        if ( not ValidateCRC(stack , 1) ) then
            call s__BigInt_destroy(((stack))) // INLINED!!
            call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 60, "Invalid Code : Bad CRC Checksum. Report to mapmaker")
            return false
        endif
        
        call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 60, "Loaded: " + I2S(value1) + "," + I2S(value2))
        
        
        call s__BigInt_destroy(((stack))) // INLINED!!
        
        return false
    endfunction
    function s__Demo_onInit takes nothing returns nothing
        
        set s__Demo_encryptionKey=s__Base__staticgetindex(s__Demo_CIPHER)
        
        
        set s__Demo_security=s__BigInt_convertString(s__Demo_SECURITY , s__Base__staticgetindex("0123456789"))
        call s__BigInt__set_base(s__Demo_security,0)
        
        
        call InitSave(s__Demo_SAVE_COMMAND , s__Demo_LOAD_COMMAND , Condition(function s__Demo_save) , Condition(function s__Demo_load) , true)
    endfunction
// Trigger: ItemRootsCatalog
//
// get takes integer ver, integer groupId, integer mmethod addGroup takes integer ver, integer groupId, integer groupId2 returns nothinginLevel, integer maxLevel
// method addGroup takes integer ver, integer groupId, integer groupId2 returns nothing
//===========================================================================
//TESH.scrollpos=28
//TESH.alwaysfold=0

        
        //Versions
        //Group Id
        
        
        function s__ItemRoots_test takes nothing returns nothing
            local integer cg= s__LevelGroupVersionCatalog_create()
            //call cg.addGroup(1,2,1)
           // call cg.add(15,1,1,0)
            //call cg.add(20,1,2,0)
            
        //          i   v  g  L
        call s__LevelGroupVersionCatalog_add(cg,15 , 1 , 1 , 1)
        call s__LevelGroupVersionCatalog_add(cg,20 , 1 , 2 , 1)
        
        //               v  P  S
        call s__LevelGroupVersionCatalog_addGroup(cg,1 , 2 , 1)
        
            if (CatalogCount(((s__LevelGroupVersionCatalog__VersionFilter_get(s__LevelGroupVersionCatalog_versionFilter[(cg)],(1 ) , ( 2 ) , ( 1 ) , ( 10)))))) == 1 then // INLINED!!
                call print("fail")
            else
                call print("success")
            endif
        endfunction
        function s__ItemRoots_get takes unit u,integer vers returns integer
            local integer id= GetUnitTypeId(u)
            local integer c
            call s__ItemRoots_test()
            call print("check vers " + I2S(vers))
            if id == s__ItemRoots_amazon then
                call print("amazon")
                set c=(s__LevelGroupVersionCatalog__VersionFilter_get(s__LevelGroupVersionCatalog_versionFilter[(s__ItemRoots_catalog)],(vers ) , ( s__ItemRoots_gAm ) , ( 0 ) , ( GetHeroLevel(u)))) // INLINED!!
                call print("32")
                return c
            elseif id == s__ItemRoots_zealot then
                return (s__LevelGroupVersionCatalog__VersionFilter_get(s__LevelGroupVersionCatalog_versionFilter[(s__ItemRoots_catalog)],(vers ) , ( s__ItemRoots_gZ ) , ( 0 ) , ( GetHeroLevel(u)))) // INLINED!!
            elseif id == s__ItemRoots_witch then
                return (s__LevelGroupVersionCatalog__VersionFilter_get(s__LevelGroupVersionCatalog_versionFilter[(s__ItemRoots_catalog)],(vers ) , ( s__ItemRoots_gW ) , ( 0 ) , ( GetHeroLevel(u)))) // INLINED!!
            elseif id == s__ItemRoots_anarchist then
                return (s__LevelGroupVersionCatalog__VersionFilter_get(s__LevelGroupVersionCatalog_versionFilter[(s__ItemRoots_catalog)],(vers ) , ( s__ItemRoots_gAn ) , ( 0 ) , ( GetHeroLevel(u)))) // INLINED!!
            elseif id == s__ItemRoots_runemaster then
                return (s__LevelGroupVersionCatalog__VersionFilter_get(s__LevelGroupVersionCatalog_versionFilter[(s__ItemRoots_catalog)],(vers ) , ( s__ItemRoots_gR ) , ( 0 ) , ( GetHeroLevel(u)))) // INLINED!!
            else
                call print("illegal ID : " + GetUnitName(u))
                return 1 / 0
            endif
        endfunction
        function s__ItemRoots_onInit takes nothing returns nothing
            set s__ItemRoots_catalog=s__LevelGroupVersionCatalog_create()
            
            //All
              //Rings
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I00S' , s__ItemRoots_v03G , s__ItemRoots_gA , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I016' , s__ItemRoots_v03G , s__ItemRoots_gA , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I01E' , s__ItemRoots_v03G , s__ItemRoots_gA , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I00W' , s__ItemRoots_v03G , s__ItemRoots_gA , 1)
              //Armors
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I004' , s__ItemRoots_v03G , s__ItemRoots_gA , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I00X' , s__ItemRoots_v03G , s__ItemRoots_gA , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I01F' , s__ItemRoots_v03G , s__ItemRoots_gA , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I015' , s__ItemRoots_v03G , s__ItemRoots_gA , 1)
              //Helms
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I00J' , s__ItemRoots_v03G , s__ItemRoots_gA , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I013' , s__ItemRoots_v03G , s__ItemRoots_gA , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I01C' , s__ItemRoots_v03G , s__ItemRoots_gA , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I01L' , s__ItemRoots_v03G , s__ItemRoots_gA , 1)
              //Boots
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I00K' , s__ItemRoots_v03G , s__ItemRoots_gA , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I010' , s__ItemRoots_v03G , s__ItemRoots_gA , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I019' , s__ItemRoots_v03G , s__ItemRoots_gA , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I01I' , s__ItemRoots_v03G , s__ItemRoots_gA , 1)
              //Gloves
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I00H' , s__ItemRoots_v03G , s__ItemRoots_gA , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I011' , s__ItemRoots_v03G , s__ItemRoots_gA , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I018' , s__ItemRoots_v03G , s__ItemRoots_gA , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I01K' , s__ItemRoots_v03G , s__ItemRoots_gA , 1)
              //Amulets
              
              
            //Zealot and Anarchist
              //Swords
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I002' , s__ItemRoots_v03G , s__ItemRoots_gZA , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I00Y' , s__ItemRoots_v03G , s__ItemRoots_gZA , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I017' , s__ItemRoots_v03G , s__ItemRoots_gZA , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I01G' , s__ItemRoots_v03G , s__ItemRoots_gZA , 1)
            //Witch and Runemaster
              //Staves
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I00O' , s__ItemRoots_v03G , s__ItemRoots_gWR , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I00V' , s__ItemRoots_v03G , s__ItemRoots_gWR , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I01D' , s__ItemRoots_v03G , s__ItemRoots_gWR , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I014' , s__ItemRoots_v03G , s__ItemRoots_gWR , 1)
            //Amazon
              //Bows
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I00G' , s__ItemRoots_v03G , s__ItemRoots_gAm , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I012' , s__ItemRoots_v03G , s__ItemRoots_gAm , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I01A' , s__ItemRoots_v03G , s__ItemRoots_gAm , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I01J' , s__ItemRoots_v03G , s__ItemRoots_gAm , 1)
              //Quivers
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I00F' , s__ItemRoots_v03G , s__ItemRoots_gAm , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I00Z' , s__ItemRoots_v03G , s__ItemRoots_gAm , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I018' , s__ItemRoots_v03G , s__ItemRoots_gAm , 1)
                call s__LevelGroupVersionCatalog_add(s__ItemRoots_catalog,'I01H' , s__ItemRoots_v03G , s__ItemRoots_gAm , 1)
                            
            call s__LevelGroupVersionCatalog_addGroup(s__ItemRoots_catalog,s__ItemRoots_v03G , s__ItemRoots_gAm , s__ItemRoots_gA)
            call s__LevelGroupVersionCatalog_addGroup(s__ItemRoots_catalog,s__ItemRoots_v03G , s__ItemRoots_gZ , s__ItemRoots_gA)
            call s__LevelGroupVersionCatalog_addGroup(s__ItemRoots_catalog,s__ItemRoots_v03G , s__ItemRoots_gR , s__ItemRoots_gA)
            call s__LevelGroupVersionCatalog_addGroup(s__ItemRoots_catalog,s__ItemRoots_v03G , s__ItemRoots_gAn , s__ItemRoots_gA)
            call s__LevelGroupVersionCatalog_addGroup(s__ItemRoots_catalog,s__ItemRoots_v03G , s__ItemRoots_gW , s__ItemRoots_gA)

            
            call s__LevelGroupVersionCatalog_addGroup(s__ItemRoots_catalog,s__ItemRoots_v03G , s__ItemRoots_gZ , s__ItemRoots_gZA)
            call s__LevelGroupVersionCatalog_addGroup(s__ItemRoots_catalog,s__ItemRoots_v03G , s__ItemRoots_gAn , s__ItemRoots_gZA)
            call s__LevelGroupVersionCatalog_addGroup(s__ItemRoots_catalog,s__ItemRoots_v03G , s__ItemRoots_gW , s__ItemRoots_gWR)
            call s__LevelGroupVersionCatalog_addGroup(s__ItemRoots_catalog,s__ItemRoots_v03G , s__ItemRoots_gR , s__ItemRoots_gWR)
                
        endfunction
        
        //Saving
            //Heroes['id00'].id
            //Heroes[GetUnitTypeId(hero)].id
            //call stack.push(Heroes[GetUnitTypeId(hero)].id,Heroes.count)
        
        //Loading
            //CreateUnit(Heroes[unitIdFromCode].raw,0,1)
            //call CreateUnit(Heroes[stack.pop(Heroes.count)].raw,0,0)
// Trigger: ItemRootsCatalog Copy
//===========================================================================
//TESH.scrollpos=3
//TESH.alwaysfold=0

//Implemented from module Catalog:
        function s__Heroes__get_raw takes integer this returns integer
            return CatalogRaw(s__Heroes_catalog , this)
        endfunction
        function s__Heroes__get_count takes nothing returns integer
            return CatalogCount(s__Heroes_catalog)
        endfunction
        function s__Heroes__get_id takes integer this returns integer
            return CatalogId(s__Heroes_catalog , this)
        endfunction
        function s__Heroes_add takes integer v returns nothing
            call CatalogAdd(s__Heroes_catalog , v)
        endfunction
        function s__Heroes_addCatalog takes integer catalog returns nothing
            call CatalogAddCatalog(s__Heroes_catalog , catalog)
        endfunction
        function s__Heroes_Catalog___onInit takes nothing returns nothing
            set s__Heroes_catalog=CatalogCreate()
        endfunction
        
        function s__Heroes_onInit takes nothing returns nothing
            call CatalogAdd(s__Heroes_catalog , ('H006')) // INLINED!!
            call CatalogAdd(s__Heroes_catalog , ('H010')) // INLINED!!
            call CatalogAdd(s__Heroes_catalog , ('H002')) // INLINED!!
            call CatalogAdd(s__Heroes_catalog , ('H014')) // INLINED!!
            call CatalogAdd(s__Heroes_catalog , ('H00G')) // INLINED!!
            call CatalogAdd(s__Heroes_catalog , ('H008')) // INLINED!!
            call CatalogAdd(s__Heroes_catalog , ('H005')) // INLINED!!
            call CatalogAdd(s__Heroes_catalog , ('H013')) // INLINED!!
            call CatalogAdd(s__Heroes_catalog , ('H003')) // INLINED!!
            call CatalogAdd(s__Heroes_catalog , ('H00Z')) // INLINED!!
        endfunction
        
        //Saving
            //Heroes['id00'].id
            //Heroes[GetUnitTypeId(hero)].id
            //call stack.push(Heroes[GetUnitTypeId(hero)].id,Heroes.count)
        
        //Loading
            //CreateUnit(Heroes[unitIdFromCode].raw,0,0)
            //call CreateUnit(Heroes[stack.pop(Heroes.count)].raw,0,0)
// Trigger: SaveCodeToHD
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: GroupVersionFilter
//===========================================================================
//TESH.scrollpos=44
//TESH.alwaysfold=0

// Trigger: LevelGroupSlotVersionFilter
//===========================================================================
//TESH.scrollpos=385
//TESH.alwaysfold=0

// redeclaration of library TempCatalog skipped

// Trigger: LevelGroupVersionFilter
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0

// redeclaration of library TempCatalog skipped
// redeclaration of library LevelTree skipped
// redeclaration of library LevelFilter skipped

// Trigger: VersionFilter
//===========================================================================
//TESH.scrollpos=9
//TESH.alwaysfold=0

// Trigger: wordwrapstring
//===========================================================================
//TESH.scrollpos=152
//TESH.alwaysfold=0
// Trigger: Untitled Trigger 005
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: stringsize
//===========================================================================
//TESH.scrollpos=162
//TESH.alwaysfold=0

//===========================================================================
// Trigger: ButtonDemo
//
// static method create takes integer x, integer y, integer heroIndex, integer buttonId, integer disabledButtonId, integer maxLevel, integer initPointReq, integer pointReq, string descName, string descDescription returns thistype
//===========================================================================
//TESH.scrollpos=20
//TESH.alwaysfold=0
// Trigger: VJassTalentTree
//
// native EnumDestructablesInRect takes rect r, boolexpr filter, code actionFunc returns nothing
//     //addButton takes int heroIndex, integer buttonId ,int x, int y //DataIndex1//
//     //addMaxLevel takes int heroIndex, int level, int x, int y //DataIndex2//
//     //addInitPointReq takes int heroIndex, int number, int x, int y //DataIndex3//
//     //addPointReq takes int heroIndex, int number, int x, int y //DataIndex4//
//     //addMultiButton takes int heroIndex, string iconFileName, int x, int y //DataIndex5//
//     //addMultiName takes int heroIndex, string name, int x, int y  //DataIndex6//
//     //addMultiDescription takes int heroIndex, string description, int x, int y //DataIndex7//
//     //       "Multi" refers to "Multiboard"//
//     //addLink takes int heroIndex, int x, int y, int linkx, int linky, int level //DataIndex8 for link, DataIndex9 for level//
//     //        x,y requires linkx,linky
//     //addStartReq takes int heroIndex, int x, int y, int level returns nothing
//     //addLevelReq takes int heroIndex, int x, int y, int increment returns nothing
//     //GetHeroIndex takes integer heroID returns integer//
//     //   Takes the ID of the hero and returns the hero index//
//     //AllocHeroIndex takes integer heroID returns integer (the heroIndex that it was assigned)//
//===========================================================================
//TESH.scrollpos=497
//TESH.alwaysfold=0

// Trigger: Borders
//===========================================================================
//TESH.scrollpos=111
//TESH.alwaysfold=0
        //0 = ne
        //1 = hum
        //2 = orc
        //3 = und
        //4 = simp
function s__DescList_create takes integer l__index returns integer
            local integer this= s__DescList__allocate()
            if l__index == 0 then
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_D]='B01I'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_DL]='B01J'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_DR]='B01K'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_L]='B01L'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_R]='B01M'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_U]='B01N'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_UL]='B01O'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_R]='B01Q'
            elseif l__index == 1 then
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_D]='B01Q'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_DL]='B01R'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_DR]='B01S'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_L]='B01T'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_R]='B01U'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_U]='B01V'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_UL]='B01W'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_R]='B01X'
            elseif l__index == 2 then
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_D]='B014'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_DL]='B015'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_DR]='B016'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_L]='B017'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_R]='B018'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_U]='B013'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_UL]='B012'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_R]='B011'
            elseif l__index == 3 then
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_D]='B019'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_DL]='B01A'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_DR]='B01B'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_L]='B01C'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_R]='B01D'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_U]='B01E'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_UL]='B01F'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_R]='B01G'
            elseif l__index == 4 then
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_D]='B000'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_DL]='B004'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_DR]='B005'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_L]='B002'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_R]='B003'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_U]='B001'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_UL]='B006'
                set s___DescList_bdrs[s__DescList_bdrs[this]+s__DescList_R]='B007'
            endif
            return this
        endfunction
    function s__Borders_destEnum takes nothing returns boolean
        local integer forLoop= 0
        local destructable d= GetFilterDestructable()
        local integer i
        local integer i2
        call print("enum")
        loop
            call print(I2S(s___DescList_bdrs[s__DescList_bdrs[s__Borders_desc[s__Borders_current]]+forLoop]))
            if GetDestructableTypeId(d) == s___DescList_bdrs[s__DescList_bdrs[s__Borders_desc[s__Borders_current]]+forLoop] then
                set i=GetDestructableTypeId(d)
                set i2=s___DescList_bdrs[s__DescList_bdrs[s__Borders_desc[s__Borders_replace]]+forLoop]
                if GetLocalPlayer() != s__Borders_p then
                    set i2=i
                endif
                call print("making")
                call CreateDestructable(i2, GetDestructableX(d), GetDestructableY(d), 0, 1, 0)
                call RemoveDestructable(d)
                exitwhen true
            endif
            set forLoop=forLoop + 1
            exitwhen forLoop == 8
        endloop
        return false
    endfunction
function s__Borders_replaceDestructables takes integer l__index,integer replace,player p,rect enumRegion returns boolean
        set s__Borders_current=l__index
        set s__Borders_replace=replace
        set s__Borders_p=p
        call EnumDestructablesInRect(enumRegion, Filter(function s__Borders_destEnum), null)
        return false
    endfunction
    function s__Borders_replaceDestructablesChat takes nothing returns boolean
        set s__Borders_replace=S2I(SubString(GetEventPlayerChatString(), 6, 6))
        set s__Borders_p=GetTriggerPlayer()
        call print("enuming")
      //  if SubString(GetEventPlayerChatString(), 0, 4) != "-menu" then
    //        call print("false")
    //        return false
    //    else
            if s__Borders_replace > 4 then
                set s__Borders_replace=4
            endif
            call EnumDestructablesInRect(gg_rct_replaceRegion, Filter(function s__Borders_destEnum), null)
            return false
      //  endif
       // return false
    endfunction
    function s__Borders_onInit takes nothing returns nothing
        local integer forLoop= 0
        local trigger t= CreateTrigger()
        loop
            set s__Borders_desc[forLoop]=s__DescList_create(forLoop)
            set forLoop=forLoop + 1
            exitwhen forLoop == 5
        endloop
        set forLoop=0
        call TriggerAddCondition(t, Filter(function s__Borders_replaceDestructablesChat))
        loop
            call TriggerRegisterPlayerChatEvent(t, Player(forLoop), "-menu", false)
            set forLoop=forLoop + 1
            exitwhen forLoop == 12
        endloop
    endfunction
// Trigger: Button
//
// umDestructablesInRect takes rect r, boolexpr filter, code actionFunc returns nothing
//     //addButton takes int heroIndex, integer buttonId ,int x, int y //DataIndex1//
//     //addMaxLevel takes int heroIndex, int level, int x, int y //DataIndex2//
//     //addInitPointReq takes int heroIndex, int number, int x, int y //DataIndex3//
//     //addPointReq takes int heroIndex, int number, int x, int y //DataIndex4//
//     //addMultiButton takes int heroIndex, string iconFileName, int x, int y //DataIndex5//
//     //addMultiName takes int heroIndex, string name, int x, int y  //DataIndex6//
//     //addMultiDescription takes int heroIndex, string description, int x, int y //DataIndex7//
//     //       "Multi" refers to "Multiboard"//
//     //addLink takes int heroIndex, int x, int y, int linkx, int linky, int level //DataIndex8 for link, DataIndex9 for level//
//     //        x,y requires linkx,linky
//     //GetHeroIndex takes integer heroID returns integer//
//     //   Takes the ID of the hero and returns the hero index//
//     //AllocHeroIndex takes integer heroID returns integer (the heroIndex that it was asstatic method addLink takes integer heroIndex, integer x, integer y, integer linkx, integer linky, integer level, integer lightningIndex, boolean autoallocate returns nothingsigned)//
// static method addLink takes integer heroIndex, integer x, integer y, integer linkx, integer linky, integer level, integer lightningIndex, boolean autoallocate returns nothing
//===========================================================================
//TESH.scrollpos=38
//TESH.alwaysfold=0
        function s__Button_create takes integer x,integer y,integer heroIndex,integer buttonId,integer disabledButtonId,integer maxLevel,integer initPointReq,integer pointReq,string descName,string descDescription returns integer
            local integer this= s__Button__allocate()
            set s__Button_x[this]=x
            set s__Button_y[this]=y
            set s__Button_heroIndex[this]=heroIndex
            set s__Button_buttonId[this]=buttonId
            set s__Button_disabledButtonId[this]=disabledButtonId
            set s__Button_maxLevel[this]=maxLevel
            set s__Button_initPointReq[this]=initPointReq
            set s__Button_pointReq[this]=pointReq
            set s__Button_descName[this]=descName
            set s__Button_descDescription[this]=descDescription
            set s__Button_currentLink[this]=- 1
            set s__Button_is[this]=false
            return this
        endfunction
        function s__Button_addData takes integer this,integer data returns nothing
            set s__Button_data[this]=data
        endfunction
        function s__Button_isMenu takes integer this,boolean is returns nothing
            set s__Button_is[this]=is
        endfunction
        function s__Button_createLink takes integer this,integer x,integer y,integer level returns nothing
            set s__Button_currentLink[this]=s__Button_currentLink[this] + 1
            set s___Button_linkx[s__Button_linkx[this]+s__Button_currentLink[this]]=x
            set s___Button_linky[s__Button_linky[this]+s__Button_currentLink[this]]=y
            set s___Button_linkLevel[s__Button_linkLevel[this]+s__Button_currentLink[this]]=level
        endfunction
        function s__Button_push takes integer this returns nothing
            local integer i= s__Button_currentLink[this]
            call s__VJassTalentTree_addButton(s__Button_heroIndex[this] , s__Button_buttonId[this] , s__Button_x[this] , s__Button_y[this])
            call s__VJassTalentTree_addMaxLevel(s__Button_heroIndex[this] , s__Button_maxLevel[this] , s__Button_x[this] , s__Button_y[this])
            call s__VJassTalentTree_addInitPointReq(s__Button_heroIndex[this] , s__Button_initPointReq[this] , s__Button_x[this] , s__Button_y[this])
            call s__VJassTalentTree_addPointReq(s__Button_heroIndex[this] , s__Button_pointReq[this] , s__Button_x[this] , s__Button_y[this])
            call s__VJassTalentTree_addDisabledButton(s__Button_heroIndex[this] , s__Button_disabledButtonId[this] , s__Button_x[this] , s__Button_y[this])
            call s__VJassTalentTree_addMultiName(s__Button_heroIndex[this] , s__Button_descName[this] , s__Button_x[this] , s__Button_y[this])
            call s__VJassTalentTree_addMultiDescription(s__Button_heroIndex[this] , s__Button_descDescription[this] , s__Button_x[this] , s__Button_y[this])
            call s__VJassTalentTree_attachData(s__Button_heroIndex[this] , s__Button_x[this] , s__Button_y[this] , s__Button_data[this])
            call s__VJassTalentTree_setAsMenu(s__Button_heroIndex[this] , s__Button_is[this] , s__Button_x[this] , s__Button_y[this])
            if i > - 1 then
                loop
                    call s__VJassTalentTree_addLink(s__Button_heroIndex[this] , s__Button_x[this] , s__Button_y[this] , s___Button_linkx[s__Button_linkx[this]+i] , s___Button_linky[s__Button_linky[this]+i] , s___Button_linkLevel[s__Button_linkLevel[this]+i] , 0 , true)
                    set i=i - 1
                    exitwhen i == - 1
                endloop
            endif
        endfunction
        function s__Button_reCreate takes integer this,integer x,integer y,integer heroIndex,integer buttonId,integer disabledButtonId,integer maxLevel,integer initPointReq,integer pointReq,string descName,string descDescription returns nothing
            set s__Button_x[this]=x
            set s__Button_y[this]=y
            set s__Button_heroIndex[this]=heroIndex
            set s__Button_buttonId[this]=buttonId
            set s__Button_disabledButtonId[this]=disabledButtonId
            set s__Button_maxLevel[this]=maxLevel
            set s__Button_initPointReq[this]=initPointReq
            set s__Button_pointReq[this]=pointReq
            set s__Button_descName[this]=descName
            set s__Button_descDescription[this]=descDescription
            set s__Button_data[this]=- 1
            set s__Button_is[this]=false
            if s__Button_currentLink[this] > - 1 then
                loop
                    set s___Button_linkx[s__Button_linkx[this]+s__Button_currentLink[this]]=- 1
                    set s___Button_linky[s__Button_linky[this]+s__Button_currentLink[this]]=- 1
                    set s___Button_linkLevel[s__Button_linkLevel[this]+s__Button_currentLink[this]]=- 1
                    set s__Button_currentLink[this]=s__Button_currentLink[this] - 1
                    exitwhen s__Button_currentLink[this] == - 1
                endloop
            endif
        endfunction
// Trigger: Interact
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
    function s__vJassTTInteract_onShowUI takes nothing returns nothing
    endfunction
    function s__vJassTTInteract_onHideUI takes nothing returns nothing
    endfunction
    function s__vJassTTInteract_onClick takes nothing returns nothing
        if s__vJassTTInteract_attachedData < 200 and s__vJassTTInteract_attachedData != - 1 then
            call s__VJassTalentTree_showUI(s__vJassTTInteract_interactingPlayer , s__vJassTTInteract_attachedData)
        endif
        call print(I2S(s__vJassTTInteract_attachedData))
    endfunction
    function s__vJassTTInteract_onHover takes nothing returns nothing
    endfunction
    function s__vJassTTInteract_externalRequirement takes nothing returns boolean
        call print("External")
        return true
    endfunction
    function s__vJassTTInteract_onInit takes nothing returns nothing
    endfunction
//Implemented from module VJassTT:

            function s__vJassTTInteract_VJassTT___onShowUIEvent takes nothing returns boolean
                    set s__vJassTTInteract_buttonId=VJTT_buttonId
                    set s__vJassTTInteract_attachedData=VJTT_attachedData
                    set s__vJassTTInteract_interactingPlayer=VJTT_interactingPlayer
                    set s__vJassTTInteract_heroIndex=VJTT_heroIndex
                call ExecuteFunc("s__vJassTTInteract_onShowUI")
                return false
            endfunction


            function s__vJassTTInteract_VJassTT___onHideUIEvent takes nothing returns boolean
                set s__vJassTTInteract_interactingPlayer=VJTT_interactingPlayer
                set s__vJassTTInteract_heroIndex=VJTT_heroIndex
                call ExecuteFunc("s__vJassTTInteract_onHideUI")
                return false
            endfunction


            function s__vJassTTInteract_VJassTT___onHoverEvent takes nothing returns boolean
                set s__vJassTTInteract_buttonId=VJTT_buttonId
                set s__vJassTTInteract_attachedData=VJTT_attachedData
                set s__vJassTTInteract_interactingPlayer=VJTT_interactingPlayer
                set s__vJassTTInteract_heroIndex=VJTT_heroIndex
                call ExecuteFunc("s__vJassTTInteract_onHover")
                return false
            endfunction


            function s__vJassTTInteract_VJassTT___onClickEvent takes nothing returns boolean
                set s__vJassTTInteract_buttonId=VJTT_buttonId
                set s__vJassTTInteract_attachedData=VJTT_attachedData
                set s__vJassTTInteract_interactingPlayer=VJTT_interactingPlayer
                set s__vJassTTInteract_rejected=VJTT_rejected
                set s__vJassTTInteract_heroIndex=VJTT_heroIndex
                call ExecuteFunc("s__vJassTTInteract_onClick")
                return false
            endfunction


            function s__vJassTTInteract_VJassTT___onExternalRequirement takes nothing returns boolean
                set s__vJassTTInteract_buttonId=VJTT_buttonId
                set s__vJassTTInteract_attachedData=VJTT_attachedData
                set s__vJassTTInteract_interactingPlayer=VJTT_interactingPlayer
                set s__vJassTTInteract_rejected=VJTT_rejected
                set s__vJassTTInteract_heroIndex=VJTT_heroIndex
                return s__vJassTTInteract_externalRequirement()
            endfunction

        function s__vJassTTInteract_VJassTT___onInit takes nothing returns nothing

                call TriggerAddCondition(VJTT_onShowModule, Filter(function s__vJassTTInteract_VJassTT___onShowUIEvent))


                call TriggerAddCondition(VJTT_externalRequirementModule, Filter(function s__vJassTTInteract_VJassTT___onExternalRequirement))


                call TriggerAddCondition(VJTT_onHideModule, Filter(function s__vJassTTInteract_VJassTT___onHideUIEvent))


                call TriggerAddCondition(VJTT_onHoverModule, Filter(function s__vJassTTInteract_VJassTT___onHoverEvent))


                call TriggerAddCondition(VJTT_onClickModule, Filter(function s__vJassTTInteract_VJassTT___onClickEvent))

        endfunction
// Trigger: Call Bag
//===========================================================================
function Trig_Call_Bag_Func004C takes nothing returns boolean
    if ( not ( GetTriggerPlayer() == Player(0) ) ) then
        return false
    endif
    return true
endfunction

function Trig_Call_Bag_Func005C takes nothing returns boolean
    if ( not ( GetTriggerPlayer() == Player(1) ) ) then
        return false
    endif
    return true
endfunction

function Trig_Call_Bag_Func006C takes nothing returns boolean
    if ( not ( GetTriggerPlayer() == Player(2) ) ) then
        return false
    endif
    return true
endfunction

function Trig_Call_Bag_Func007C takes nothing returns boolean
    if ( not ( GetTriggerPlayer() == Player(3) ) ) then
        return false
    endif
    return true
endfunction

function Trig_Call_Bag_Func008C takes nothing returns boolean
    if ( not ( GetTriggerPlayer() == Player(4) ) ) then
        return false
    endif
    return true
endfunction

function Trig_Call_Bag_Func009C takes nothing returns boolean
    if ( not ( GetTriggerPlayer() == Player(5) ) ) then
        return false
    endif
    return true
endfunction

function Trig_Call_Bag_Func010C takes nothing returns boolean
    if ( not ( GetTriggerPlayer() == Player(6) ) ) then
        return false
    endif
    return true
endfunction

function Trig_Call_Bag_Func011C takes nothing returns boolean
    if ( not ( GetTriggerPlayer() == Player(7) ) ) then
        return false
    endif
    return true
endfunction

function Trig_Call_Bag_Func012C takes nothing returns boolean
    if ( not ( GetTriggerPlayer() == Player(8) ) ) then
        return false
    endif
    return true
endfunction

function Trig_Call_Bag_Func013C takes nothing returns boolean
    if ( not ( GetTriggerPlayer() == Player(9) ) ) then
        return false
    endif
    return true
endfunction

function Trig_Call_Bag_Actions takes nothing returns nothing
    set udg_TempLoc=GetUnitLoc(udg_PlayerUnit[GetConvertedPlayerId(GetTriggerPlayer())])
    call SetUnitPositionLoc(udg_Backpack[GetConvertedPlayerId(GetTriggerPlayer())], udg_TempLoc)
    call RemoveLocation(udg_TempLoc)
    if ( Trig_Call_Bag_Func004C() ) then
        call PauseTimerBJ(true, udg_BTimerRed)
        call StartTimerBJ(udg_BTimerRed, false, 10.00)
    else
    endif
    if ( Trig_Call_Bag_Func005C() ) then
        call PauseTimerBJ(true, udg_BTimerBlue)
        call StartTimerBJ(udg_BTimerBlue, false, 10.00)
    else
    endif
    if ( Trig_Call_Bag_Func006C() ) then
        call PauseTimerBJ(true, udg_BTimerTeal)
        call StartTimerBJ(udg_BTimerTeal, false, 10.00)
    else
    endif
    if ( Trig_Call_Bag_Func007C() ) then
        call PauseTimerBJ(true, udg_BTimerPurple)
        call StartTimerBJ(udg_BTimerPurple, false, 10.00)
    else
    endif
    if ( Trig_Call_Bag_Func008C() ) then
        call PauseTimerBJ(true, udg_BTimerYellow)
        call StartTimerBJ(udg_BTimerYellow, false, 10.00)
    else
    endif
    if ( Trig_Call_Bag_Func009C() ) then
        call PauseTimerBJ(true, udg_BTimerOrange)
        call StartTimerBJ(udg_BTimerOrange, false, 10.00)
    else
    endif
    if ( Trig_Call_Bag_Func010C() ) then
        call PauseTimerBJ(true, udg_BTimerGreen)
        call StartTimerBJ(udg_BTimerGreen, false, 10.00)
    else
    endif
    if ( Trig_Call_Bag_Func011C() ) then
        call PauseTimerBJ(true, udg_BTimerPink)
        call StartTimerBJ(udg_BTimerPink, false, 10.00)
    else
    endif
    if ( Trig_Call_Bag_Func012C() ) then
        call PauseTimerBJ(true, udg_BTimerGray)
        call StartTimerBJ(udg_BTimerGray, false, 10.00)
    else
    endif
    if ( Trig_Call_Bag_Func013C() ) then
        call PauseTimerBJ(true, udg_BTimerLB)
        call StartTimerBJ(udg_BTimerLB, false, 10.00)
    else
    endif
endfunction

//===========================================================================
function InitTrig_Call_Bag takes nothing returns nothing
    set gg_trg_Call_Bag=CreateTrigger()
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_Call_Bag, Player(0))
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_Call_Bag, Player(1))
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_Call_Bag, Player(2))
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_Call_Bag, Player(3))
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_Call_Bag, Player(4))
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_Call_Bag, Player(5))
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_Call_Bag, Player(6))
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_Call_Bag, Player(7))
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_Call_Bag, Player(8))
    call TriggerRegisterPlayerEventEndCinematic(gg_trg_Call_Bag, Player(9))
    call TriggerAddAction(gg_trg_Call_Bag, function Trig_Call_Bag_Actions)
endfunction

//===========================================================================
// Trigger: BRP1
//===========================================================================
function Trig_BRP1_Actions takes nothing returns nothing
    set udg_TempLoc=GetRectCenter(udg_BackPackArea[1])
    call SetUnitPositionLoc(udg_Backpack[1], udg_TempLoc)
    call RemoveLocation(udg_TempLoc)
endfunction

//===========================================================================
function InitTrig_BRP1 takes nothing returns nothing
    set gg_trg_BRP1=CreateTrigger()
    call TriggerRegisterTimerExpireEventBJ(gg_trg_BRP1, udg_BTimerRed)
    call TriggerAddAction(gg_trg_BRP1, function Trig_BRP1_Actions)
endfunction

//===========================================================================
// Trigger: BRP2
//===========================================================================
function Trig_BRP2_Actions takes nothing returns nothing
    set udg_TempLoc=GetRectCenter(udg_BackPackArea[2])
    call SetUnitPositionLoc(udg_Backpack[2], udg_TempLoc)
    call RemoveLocation(udg_TempLoc)
endfunction

//===========================================================================
function InitTrig_BRP2 takes nothing returns nothing
    set gg_trg_BRP2=CreateTrigger()
    call TriggerRegisterTimerExpireEventBJ(gg_trg_BRP2, udg_BTimerBlue)
    call TriggerAddAction(gg_trg_BRP2, function Trig_BRP2_Actions)
endfunction

//===========================================================================
// Trigger: BRP3
//===========================================================================
function Trig_BRP3_Actions takes nothing returns nothing
    set udg_TempLoc=GetRectCenter(udg_BackPackArea[3])
    call SetUnitPositionLoc(udg_Backpack[3], udg_TempLoc)
    call RemoveLocation(udg_TempLoc)
endfunction

//===========================================================================
function InitTrig_BRP3 takes nothing returns nothing
    set gg_trg_BRP3=CreateTrigger()
    call TriggerRegisterTimerExpireEventBJ(gg_trg_BRP3, udg_BTimerTeal)
    call TriggerAddAction(gg_trg_BRP3, function Trig_BRP3_Actions)
endfunction

//===========================================================================
// Trigger: BRP4
//===========================================================================
function Trig_BRP4_Actions takes nothing returns nothing
    set udg_TempLoc=GetRectCenter(udg_BackPackArea[4])
    call SetUnitPositionLoc(udg_Backpack[4], udg_TempLoc)
    call RemoveLocation(udg_TempLoc)
endfunction

//===========================================================================
function InitTrig_BRP4 takes nothing returns nothing
    set gg_trg_BRP4=CreateTrigger()
    call TriggerRegisterTimerExpireEventBJ(gg_trg_BRP4, udg_BTimerPurple)
    call TriggerAddAction(gg_trg_BRP4, function Trig_BRP4_Actions)
endfunction

//===========================================================================
// Trigger: BRP5
//===========================================================================
function Trig_BRP5_Actions takes nothing returns nothing
    set udg_TempLoc=GetRectCenter(udg_BackPackArea[5])
    call SetUnitPositionLoc(udg_Backpack[5], udg_TempLoc)
    call RemoveLocation(udg_TempLoc)
endfunction

//===========================================================================
function InitTrig_BRP5 takes nothing returns nothing
    set gg_trg_BRP5=CreateTrigger()
    call TriggerRegisterTimerExpireEventBJ(gg_trg_BRP5, udg_BTimerYellow)
    call TriggerAddAction(gg_trg_BRP5, function Trig_BRP5_Actions)
endfunction

//===========================================================================
// Trigger: BRP6
//===========================================================================
function Trig_BRP6_Actions takes nothing returns nothing
    set udg_TempLoc=GetRectCenter(udg_BackPackArea[6])
    call SetUnitPositionLoc(udg_Backpack[6], udg_TempLoc)
    call RemoveLocation(udg_TempLoc)
endfunction

//===========================================================================
function InitTrig_BRP6 takes nothing returns nothing
    set gg_trg_BRP6=CreateTrigger()
    call TriggerRegisterTimerExpireEventBJ(gg_trg_BRP6, udg_BTimerOrange)
    call TriggerAddAction(gg_trg_BRP6, function Trig_BRP6_Actions)
endfunction

//===========================================================================
// Trigger: BRP7
//===========================================================================
function Trig_BRP7_Actions takes nothing returns nothing
    set udg_TempLoc=GetRectCenter(udg_BackPackArea[7])
    call SetUnitPositionLoc(udg_Backpack[7], udg_TempLoc)
    call RemoveLocation(udg_TempLoc)
endfunction

//===========================================================================
function InitTrig_BRP7 takes nothing returns nothing
    set gg_trg_BRP7=CreateTrigger()
    call TriggerRegisterTimerExpireEventBJ(gg_trg_BRP7, udg_BTimerGreen)
    call TriggerAddAction(gg_trg_BRP7, function Trig_BRP7_Actions)
endfunction

//===========================================================================
// Trigger: BRP8
//===========================================================================
function Trig_BRP8_Actions takes nothing returns nothing
    set udg_TempLoc=GetRectCenter(udg_BackPackArea[8])
    call SetUnitPositionLoc(udg_Backpack[8], udg_TempLoc)
    call RemoveLocation(udg_TempLoc)
endfunction

//===========================================================================
function InitTrig_BRP8 takes nothing returns nothing
    set gg_trg_BRP8=CreateTrigger()
    call TriggerRegisterTimerExpireEventBJ(gg_trg_BRP8, udg_BTimerPink)
    call TriggerAddAction(gg_trg_BRP8, function Trig_BRP8_Actions)
endfunction

//===========================================================================
// Trigger: BRP9
//===========================================================================
function Trig_BRP9_Actions takes nothing returns nothing
    set udg_TempLoc=GetRectCenter(udg_BackPackArea[9])
    call SetUnitPositionLoc(udg_Backpack[9], udg_TempLoc)
    call RemoveLocation(udg_TempLoc)
endfunction

//===========================================================================
function InitTrig_BRP9 takes nothing returns nothing
    set gg_trg_BRP9=CreateTrigger()
    call TriggerRegisterTimerExpireEventBJ(gg_trg_BRP9, udg_BTimerGray)
    call TriggerAddAction(gg_trg_BRP9, function Trig_BRP9_Actions)
endfunction

//===========================================================================
// Trigger: BRP10
//===========================================================================
function Trig_BRP10_Actions takes nothing returns nothing
    set udg_TempLoc=GetRectCenter(udg_BackPackArea[10])
    call SetUnitPositionLoc(udg_Backpack[10], udg_TempLoc)
    call RemoveLocation(udg_TempLoc)
endfunction

//===========================================================================
function InitTrig_BRP10 takes nothing returns nothing
    set gg_trg_BRP10=CreateTrigger()
    call TriggerRegisterTimerExpireEventBJ(gg_trg_BRP10, udg_BTimerLB)
    call TriggerAddAction(gg_trg_BRP10, function Trig_BRP10_Actions)
endfunction

//===========================================================================
// Trigger: Commands
//===========================================================================
function Trig_Commands_Func001C takes nothing returns boolean
    if ( not ( SubStringBJ(GetEventPlayerChatString(), 1, 6) == "-clear" ) ) then
        return false
    endif
    return true
endfunction

function Trig_Commands_Func002Func013Func001C takes nothing returns boolean
    if ( not ( RectContainsItem(GetEnumItem(), gg_rct_Backpack_Area_All) == false ) ) then
        return false
    endif
    return true
endfunction

function Trig_Commands_Func002Func013A takes nothing returns nothing
    if ( Trig_Commands_Func002Func013Func001C() ) then
        call RemoveItem(GetEnumItem())
    else
    endif
endfunction

function Trig_Commands_Func002C takes nothing returns boolean
    if ( not ( SubStringBJ(GetEventPlayerChatString(), 1, 6) == "-item wipe" ) ) then
        return false
    endif
    return true
endfunction

function Trig_Commands_Func003C takes nothing returns boolean
    if ( not ( SubStringBJ(GetEventPlayerChatString(), 1, 5) == "-zoom" ) ) then
        return false
    endif
    return true
endfunction

function Trig_Commands_Func004C takes nothing returns boolean
    if ( not ( SubStringBJ(GetEventPlayerChatString(), 1, 5) == "-kill" ) ) then
        return false
    endif
    return true
endfunction

function Trig_Commands_Func005Func002Func001C takes nothing returns boolean
    if ( not ( IsUnitType(GetEnumUnit(), UNIT_TYPE_HERO) == false ) ) then
        return false
    endif
    if ( not ( GetUnitTypeId(GetEnumUnit()) != 'h009' ) ) then
        return false
    endif
    if ( not ( GetUnitTypeId(GetEnumUnit()) != 'h00Y' ) ) then
        return false
    endif
    if ( not ( GetUnitTypeId(GetEnumUnit()) != 'h004' ) ) then
        return false
    endif
    if ( not ( GetUnitTypeId(GetEnumUnit()) != 'h007' ) ) then
        return false
    endif
    return true
endfunction

function Trig_Commands_Func005Func002A takes nothing returns nothing
    if ( Trig_Commands_Func005Func002Func001C() ) then
        call KillUnit(GetEnumUnit())
    else
    endif
endfunction

function Trig_Commands_Func005C takes nothing returns boolean
    if ( not ( SubStringBJ(GetEventPlayerChatString(), 1, 12) == "-summon kill" ) ) then
        return false
    endif
    return true
endfunction

function Trig_Commands_Func006Func002Func001C takes nothing returns boolean
    if ( not ( IsUnitType(GetEnumUnit(), UNIT_TYPE_HERO) == false ) ) then
        return false
    endif
    if ( not ( GetUnitTypeId(GetEnumUnit()) != 'h009' ) ) then
        return false
    endif
    if ( not ( GetUnitTypeId(GetEnumUnit()) != 'h00Y' ) ) then
        return false
    endif
    if ( not ( GetUnitTypeId(GetEnumUnit()) != 'h004' ) ) then
        return false
    endif
    if ( not ( GetUnitTypeId(GetEnumUnit()) != 'h007' ) ) then
        return false
    endif
    return true
endfunction

function Trig_Commands_Func006Func002A takes nothing returns nothing
    if ( Trig_Commands_Func006Func002Func001C() ) then
        set udg_TempLoc=GetUnitLoc(udg_PlayerUnit[GetConvertedPlayerId(GetOwningPlayer(GetEnumUnit()))])
        call SetUnitPositionLoc(GetEnumUnit(), udg_TempLoc)
        call RemoveLocation(udg_TempLoc)
    else
    endif
endfunction

function Trig_Commands_Func006C takes nothing returns boolean
    if ( not ( SubStringBJ(GetEventPlayerChatString(), 1, 14) == "-summon recall" ) ) then
        return false
    endif
    return true
endfunction

function Trig_Commands_Func007Func001C takes nothing returns boolean
    if ( not ( GetEventPlayerChatString() == "-info" ) ) then
        return false
    endif
    return true
endfunction

function Trig_Commands_Func007C takes nothing returns boolean
    if ( not ( SubStringBJ(GetEventPlayerChatString(), 1, 5) == "-info" ) ) then
        return false
    endif
    return true
endfunction

function Trig_Commands_Actions takes nothing returns nothing
    if ( Trig_Commands_Func001C() ) then
        call ClearTextMessagesBJ(GetForceOfPlayer(GetTriggerPlayer()))
    else
    endif
    if ( Trig_Commands_Func002C() ) then
        call DisplayTimedTextToForce(GetPlayersAll(), 15.00, "TRIGSTR_1205")
        call TriggerSleepAction(10.00)
        call DisplayTimedTextToForce(GetPlayersAll(), 5.00, "TRIGSTR_1206")
        call TriggerSleepAction(1.00)
        call DisplayTimedTextToForce(GetPlayersAll(), 4.00, "TRIGSTR_1207")
        call TriggerSleepAction(1.00)
        call DisplayTimedTextToForce(GetPlayersAll(), 3.00, "TRIGSTR_1208")
        call TriggerSleepAction(1.00)
        call DisplayTimedTextToForce(GetPlayersAll(), 2.00, "TRIGSTR_1209")
        call TriggerSleepAction(1.00)
        call DisplayTimedTextToForce(GetPlayersAll(), 1.00, "TRIGSTR_1210")
        call TriggerSleepAction(1.00)
        call EnumItemsInRectBJ(GetPlayableMapRect(), function Trig_Commands_Func002Func013A)
    else
    endif
    if ( Trig_Commands_Func003C() ) then
        call SetCameraFieldForPlayer(GetTriggerPlayer(), CAMERA_FIELD_TARGET_DISTANCE, ( S2R(SubStringBJ(GetEventPlayerChatString(), 7, 9)) * 10.00 ), 0)
    else
    endif
    if ( Trig_Commands_Func004C() ) then
        call KillUnit(udg_PlayerUnit[GetConvertedPlayerId(GetTriggerPlayer())])
    else
    endif
    if ( Trig_Commands_Func005C() ) then
        set bj_wantDestroyGroup=true
        call ForGroupBJ(GetUnitsInRectOfPlayer(GetPlayableMapRect(), GetTriggerPlayer()), function Trig_Commands_Func005Func002A)
    else
    endif
    if ( Trig_Commands_Func006C() ) then
        set bj_wantDestroyGroup=true
        call ForGroupBJ(GetUnitsInRectOfPlayer(GetPlayableMapRect(), GetTriggerPlayer()), function Trig_Commands_Func006Func002A)
    else
    endif
    if ( Trig_Commands_Func007C() ) then
        if ( Trig_Commands_Func007Func001C() ) then
            set udg_TempUnit=GroupPickRandomUnit(GetUnitsSelectedAll(GetTriggerPlayer()))
        else
        endif
    else
    endif
endfunction

//===========================================================================
function InitTrig_Commands takes nothing returns nothing
    set gg_trg_Commands=CreateTrigger()
    call TriggerRegisterPlayerChatEvent(gg_trg_Commands, Player(0), "-", false)
    call TriggerRegisterPlayerChatEvent(gg_trg_Commands, Player(1), "-", false)
    call TriggerRegisterPlayerChatEvent(gg_trg_Commands, Player(2), "-", false)
    call TriggerRegisterPlayerChatEvent(gg_trg_Commands, Player(3), "-", false)
    call TriggerRegisterPlayerChatEvent(gg_trg_Commands, Player(4), "-", false)
    call TriggerRegisterPlayerChatEvent(gg_trg_Commands, Player(5), "-", false)
    call TriggerRegisterPlayerChatEvent(gg_trg_Commands, Player(6), "-", false)
    call TriggerRegisterPlayerChatEvent(gg_trg_Commands, Player(7), "-", false)
    call TriggerRegisterPlayerChatEvent(gg_trg_Commands, Player(8), "-", false)
    call TriggerRegisterPlayerChatEvent(gg_trg_Commands, Player(10), "-", false)
    call TriggerRegisterPlayerChatEvent(gg_trg_Commands, Player(9), "-", false)
    call TriggerRegisterPlayerChatEvent(gg_trg_Commands, Player(11), "-", false)
    call TriggerAddAction(gg_trg_Commands, function Trig_Commands_Actions)
endfunction

//===========================================================================
// Trigger: ChargedBolt
//
// 
// *       static method create takes real originX, real originY, real originZ...
// *                               ...real targetX, real targetY, real targetZ returns Missile
//===========================================================================
//TESH.scrollpos=7
//TESH.alwaysfold=0
// Trigger: DoE Enter
//===========================================================================
function Trig_DoE_Enter_Conditions takes nothing returns boolean
    if ( not ( GetOwningPlayer(GetTriggerUnit()) != Player(PLAYER_NEUTRAL_AGGRESSIVE) ) ) then
        return false
    endif
    if ( not ( GetOwningPlayer(GetTriggerUnit()) != Player(11) ) ) then
        return false
    endif
    if ( not ( GetOwningPlayer(GetTriggerUnit()) != Player(10) ) ) then
        return false
    endif
    return true
endfunction

function Trig_DoE_Enter_Actions takes nothing returns nothing
    set udg_TempLoc=GetRectCenter(gg_rct_DoE_Enter_End)
    call SetUnitPositionLoc(GetTriggerUnit(), udg_TempLoc)
    call PanCameraToTimedLocForPlayer(GetOwningPlayer(GetTriggerUnit()), udg_TempLoc, 0)
    call RemoveLocation(udg_TempLoc)
endfunction

//===========================================================================
function InitTrig_DoE_Enter takes nothing returns nothing
    set gg_trg_DoE_Enter=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_DoE_Enter, gg_rct_DoE_Enter_Start)
    call TriggerAddCondition(gg_trg_DoE_Enter, Condition(function Trig_DoE_Enter_Conditions))
    call TriggerAddAction(gg_trg_DoE_Enter, function Trig_DoE_Enter_Actions)
endfunction

//===========================================================================
// Trigger: DoE Exit
//===========================================================================
function Trig_DoE_Exit_Conditions takes nothing returns boolean
    if ( not ( GetOwningPlayer(GetTriggerUnit()) != Player(PLAYER_NEUTRAL_AGGRESSIVE) ) ) then
        return false
    endif
    if ( not ( GetOwningPlayer(GetTriggerUnit()) != Player(11) ) ) then
        return false
    endif
    if ( not ( GetOwningPlayer(GetTriggerUnit()) != Player(10) ) ) then
        return false
    endif
    return true
endfunction

function Trig_DoE_Exit_Actions takes nothing returns nothing
    set udg_TempLoc=GetRectCenter(gg_rct_DoE_Exit_End)
    call SetUnitPositionLoc(GetTriggerUnit(), udg_TempLoc)
    call PanCameraToTimedLocForPlayer(GetOwningPlayer(GetTriggerUnit()), udg_TempLoc, 0)
    call RemoveLocation(udg_TempLoc)
endfunction

//===========================================================================
function InitTrig_DoE_Exit takes nothing returns nothing
    set gg_trg_DoE_Exit=CreateTrigger()
    call TriggerRegisterEnterRectSimple(gg_trg_DoE_Exit, gg_rct_DoE_Exit_Start)
    call TriggerAddCondition(gg_trg_DoE_Exit, Condition(function Trig_DoE_Exit_Conditions))
    call TriggerAddAction(gg_trg_DoE_Exit, function Trig_DoE_Exit_Actions)
endfunction

//===========================================================================
// Trigger: WizardForceSpells
//===========================================================================
//TESH.scrollpos=9
//TESH.alwaysfold=0
// Trigger: T32Interface
//===========================================================================
//TESH.scrollpos=35
//TESH.alwaysfold=0
// Trigger: FunctionAfterTime
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: StructAttach
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: FighterFirstSpells
//===========================================================================
//TESH.scrollpos=248
//TESH.alwaysfold=0
// Trigger: Untitled Trigger 001
//===========================================================================
function Trig_Untitled_Trigger_001_Actions takes nothing returns nothing
    call IssueImmediateOrderBJ(null, "stop")
endfunction

//===========================================================================
function InitTrig_Untitled_Trigger_001 takes nothing returns nothing
    set gg_trg_Untitled_Trigger_001=CreateTrigger()
    call TriggerAddAction(gg_trg_Untitled_Trigger_001, function Trig_Untitled_Trigger_001_Actions)
endfunction

//===========================================================================
// Trigger: WitchFirstSpells
//===========================================================================
//TESH.scrollpos=28
//TESH.alwaysfold=0
// Trigger: WizardFireSpells
//
// 
// *       static method create takes real originX, real originY, real originZ...
// *                               ...real angle, real distance, real targetZ returns Missile
// *           -   The angle is in radians.
// *           -   Missiles have the following values to be set by you.
// *               -   real speed
// *               -   real turn
// *               -   real open / curve
// *               -   real height / arc
// *               -   real acceleration
// *               -   real collision
// *               -   unit target
// *               -   unit source
// *               -   string model
// *               -   integer data
//===========================================================================
//TESH.scrollpos=279
//TESH.alwaysfold=0
// Trigger: DamageModification
//===========================================================================
//TESH.scrollpos=41
//TESH.alwaysfold=0
    function s__Test_affixCheck takes unit u returns boolean
        return ( GetUnitAbilityLevel(u, 'B006') > 0 or GetUnitAbilityLevel(u, 'B007') > 0 or GetUnitAbilityLevel(u, 'B004') > 0 )
    endfunction
    
    function s__Test_onDamage takes nothing returns nothing
            
        local integer sourcePlayerID= GetPlayerId(GetOwningPlayer((UnitIndexer___e[((s__DDS_DDS___sourceId_p))]))) // INLINED!!
        local boolean crit= false
        
        local boolean reduceSpellResistance= (s__DDS_DDS_Archetype___archetype_p) == s__DDS_Archetype___DamageEventArchtype_SPELL // INLINED!!
        local boolean reducePhysicalResistance= (s__DDS_DDS_Archetype___archetype_p) == s__DDS_Archetype___DamageEventArchtype_PHYSICAL // INLINED!!
        local real critPowMod= 1
        local real dBetween
        local real x
        local real y
        
        if (s__DDS_DDS_Archetype___archetype_p) == s__DDS_Archetype___DamageEventArchtype_AGGRO then // INLINED!!
            set s__DDS_DDS___damage_p=((1)*1.0) // INLINED!!
            call print("dealing 1 dmg")
            return
        endif
        
        //WAS IT A HEAL?
        if (s__DDS_DDS_Archetype___archetype_p) == s__DDS_Archetype___DamageEventArchtype_HEAL then // INLINED!!
            if GetRandomInt(1, 100) < getCritRate(udg_PlayerUnit[sourcePlayerID + 1]) then
                set s__DDS_DDS___damage_p=(((s__DDS_DDS___damage_p) * getCritPow(udg_PlayerUnit[sourcePlayerID + 1]))*1.0) // INLINED!!
            endif
            return
        //ENDHEAL
        
        //CRIT MANAGER
        elseif (s__DDS_DDS_Archetype___archetype_p) != s__DDS_Archetype___DamageEventArchtype_DOT and GetPlayerId(GetOwningPlayer((UnitIndexer___e[((s__DDS_DDS___sourceId_p))]))) < 10 then // INLINED!!
            if GetRandomInt(1, 100) < getCritRate(udg_PlayerUnit[sourcePlayerID + 1]) then
                set crit=true
            endif
            
        elseif (s__DDS_DDS_Archetype___archetype_p) == s__DDS_Archetype___DamageEventArchtype_DOT and GetPlayerId(GetOwningPlayer((UnitIndexer___e[((s__DDS_DDS___sourceId_p))]))) < 10 then // INLINED!!
            if GetRandomInt(1, 1000) < getCritRate(udg_PlayerUnit[sourcePlayerID + 1]) then
                set crit=true
                set critPowMod=10
            endif
        endif
        //END CRITM
        
        //CARRION SWARM DUMMIES
        
        if GetUnitTypeId((UnitIndexer___e[((s__DDS_DDS___sourceId_p))])) == WW_DUMMY then // INLINED!!
            set x=( GetUnitX((UnitIndexer___e[((s__DDS_DDS___sourceId_p))])) - GetUnitX((UnitIndexer___e[((s__DDS_DDS___targetId_p))])) ) // INLINED!!
            set y=( GetUnitY((UnitIndexer___e[((s__DDS_DDS___sourceId_p))])) - GetUnitY((UnitIndexer___e[((s__DDS_DDS___targetId_p))])) ) // INLINED!!
            if ( x * x + y * y ) > ( 200 * 200 ) then
                if GetUnitAbilityLevel((UnitIndexer___e[((s__DDS_DDS___sourceId_p))]), WW_WAVE_ABIL) > 0 then // INLINED!!
                    set s__DDS_DDS___damage_p=((s__FFS_WhirlingWrath_onHit((UnitIndexer___e[((s__DDS_DDS___sourceId_p))]) , (UnitIndexer___e[((s__DDS_DDS___targetId_p))])))*1.0) // INLINED!!
                elseif GetUnitAbilityLevel((UnitIndexer___e[((s__DDS_DDS___sourceId_p))]), FB_WAVE) > 0 then // INLINED!!
                    set s__DDS_DDS___damage_p=((s__Firebomb_onViableHit((UnitIndexer___e[((s__DDS_DDS___sourceId_p))]) , (UnitIndexer___e[((s__DDS_DDS___targetId_p))])))*1.0) // INLINED!!
                    if (s__DDS_DDS___damage_p) == 0 then // INLINED!!
                        return
                    endif
                endif
            else
                set s__DDS_DDS___damage_p=((0)*1.0) // INLINED!!
                return
            endif
            
            set reduceSpellResistance=true
            set reducePhysicalResistance=false
        
        //END CARRION DUMMIES
        
        //AFFIX CHECKS
        elseif s__Test_affixCheck((UnitIndexer___e[((s__DDS_DDS___targetId_p))])) then // INLINED!!
        
            if GetUnitAbilityLevel((UnitIndexer___e[((s__DDS_DDS___sourceId_p))]), 'A00P') > 0 then // INLINED!!
                set s__DDS_DDS___damage_p=((s__FFS_MightySlash_onHit((UnitIndexer___e[((s__DDS_DDS___sourceId_p))]) , (UnitIndexer___e[((s__DDS_DDS___targetId_p))]) , (s__DDS_DDS___damage_p)))*1.0) // INLINED!!
            
            elseif GetUnitAbilityLevel((UnitIndexer___e[((s__DDS_DDS___sourceId_p))]), 'A00O') > 0 then // INLINED!!
                set s__DDS_DDS___damage_p=(((s__DDS_DDS___damage_p) + ( s__DDS_damageOriginal * ( 0.05 + ( 0.05 * GetUnitAbilityLevel((UnitIndexer___e[((s__DDS_DDS___sourceId_p))]), 'A00P') ) ) ) + ( 0.25 * GetHeroAgi((UnitIndexer___e[((s__DDS_DDS___sourceId_p))]), true) ))*1.0) // INLINED!!
            
            elseif (s__DDS_DDS_Archetype___archetype_p) == s__DDS_Archetype___DamageEventArchtype_SPELL and GetUnitAbilityLevel((UnitIndexer___e[((s__DDS_DDS___sourceId_p))]), 'A00D') != 0 then // INLINED!!
                set s__DDS_DDS___damage_p=((( (s__DDS_DDS___damage_p) + ( I2R(GetHeroInt((UnitIndexer___e[((s__DDS_DDS___sourceId_p))]), true)) * 1.00 ) ))*1.0) // INLINED!!
                
            endif
            
            
            call UnitRemoveAbility((UnitIndexer___e[((s__DDS_DDS___targetId_p))]), 'B001') // INLINED!!
            call UnitRemoveAbility((UnitIndexer___e[((s__DDS_DDS___targetId_p))]), 'B004') // INLINED!!
            call UnitRemoveAbility((UnitIndexer___e[((s__DDS_DDS___targetId_p))]), 'B006') // INLINED!!
            call UnitRemoveAbility((UnitIndexer___e[((s__DDS_DDS___targetId_p))]), 'B007') // INLINED!!
            
        endif
        // APPLY CRIT DAMAGE
        if crit then
            set s__DDS_DDS___damage_p=(((s__DDS_DDS___damage_p) * getCritPow(udg_PlayerUnit[sourcePlayerID + 1]) * critPowMod)*1.0) // INLINED!!
        endif
        if reduceSpellResistance then
            set s__DDS_DDS___damage_p=(((s__DDS_DDS___damage_p) * ( ( 100 - s__StatHandler_getUnitResistance((UnitIndexer___e[((s__DDS_DDS___targetId_p))]) , TRAIT_TYPE_SPELL_RESISTANCE) ) / 100 ))*1.0) // INLINED!!
        endif
        if reducePhysicalResistance then
            set s__DDS_DDS___damage_p=(((s__DDS_DDS___damage_p) * ( ( 100 - s__StatHandler_getUnitResistance((UnitIndexer___e[((s__DDS_DDS___targetId_p))]) , TRAIT_TYPE_PHYSICAL_RESISTANCE) ) / 100 ))*1.0) // INLINED!!
        endif
        
        //DAMAGE REDUCING ABILITIES
        if GetUnitAbilityLevel((UnitIndexer___e[((s__DDS_DDS___targetId_p))]), BC_ID) > 0 then // INLINED!!
            if s__FFS_BurstCounter_isUnitInBC((UnitIndexer___e[((s__DDS_DDS___targetId_p))]) , (s__DDS_DDS___damage_p) , crit) then // INLINED!!
                set s__DDS_DDS___damage_p=((0)*1.0) // INLINED!!
                if crit then
                    call CreateTextTagUnitBJ(( "Crit Absorbed!" ), (UnitIndexer___e[((s__DDS_DDS___targetId_p))]), 50.00, 13.00, GetRandomInt(1, 255), GetRandomInt(1, 255), GetRandomInt(1, 255), 0) // INLINED!!
                    call SetTextTagVelocityBJ(GetLastCreatedTextTag(), 75.00, 90.00)
                    call SetTextTagPermanentBJ(GetLastCreatedTextTag(), false)
                    call SetTextTagLifespanBJ(GetLastCreatedTextTag(), 3.50)
                    call SetTextTagFadepointBJ(GetLastCreatedTextTag(), 1.40)
                endif
                set crit=false
            endif
        endif
        //END DAMAGE REDUCING ABILITIES
        
        if crit then
            call CreateTextTagUnitBJ(( I2S(R2I((s__DDS_DDS___damage_p))) + "!" ), (UnitIndexer___e[((s__DDS_DDS___targetId_p))]), 50.00, 13.00, GetRandomInt(1, 255), GetRandomInt(1, 255), GetRandomInt(1, 255), 0) // INLINED!!
            call SetTextTagVelocityBJ(GetLastCreatedTextTag(), 75.00, 90.00)
            call SetTextTagPermanentBJ(GetLastCreatedTextTag(), false)
            call SetTextTagLifespanBJ(GetLastCreatedTextTag(), 3.50)
            call SetTextTagFadepointBJ(GetLastCreatedTextTag(), 1.40)
        endif
        
    endfunction
    
    function s__Test_filter takes nothing returns boolean
        return true
    endfunction

//Implemented from module DDS:
        


            

                function s__Test_DDS___DAMAGE_EVENT_INTERFACE___init takes code c returns nothing

                        call s__PriorityEvent_register(s__DDS_ANY,Condition(c) , s__DDS_DamageEvent___DamageEventPriority_PRIORITY)



                    return
                endfunction

                function s__Test_DDS___DAMAGE_EVENT_INTERFACE___onInit takes nothing returns nothing
                    call s__Test_DDS___DAMAGE_EVENT_INTERFACE___init(function s__Test_onDamage)
                endfunction

            
            

//===========================================================================
// Trigger: Untitled Trigger 002
//
// 
// *
// *       constant integer BONUS_ARMOR
// *       constant integer BONUS_DAMAGE
// *       constant integer BONUS_AGILITY
// *       constant integer BONUS_STRENGTH
// *       constant integer BONUS_INTELLIGENCE
// *       constant integer BONUS_LIFE
// *       constant integer BONUS_LIFE_REGEN
// *       constant integer BONUS_MANA
// *       constant integer BONUS_MANA_REGEN
// *       constant integer BONUS_ATTACK_SPEED
// *       constant integer BONUS_SIGHT
// *       function GetUnitBonus takes unit whichUnit, integer whichBonus returns integer
// *       function SetUnitBonus takes unit whichUnit, integer whichBonus, integer value returns nothing
// *       function AddUnitBonus takes unit whichUnit, integer whichBonus, integer value returns nothing
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_Untitled_Trigger_002_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A03W' ) ) then
        return false
    endif
    return true
endfunction

function Trig_Untitled_Trigger_002_Actions takes nothing returns nothing
    local unit u
    local group g
    set udg_TempLoc=GetSpellTargetLoc()
    set g=CreateNUnitsAtLoc(1 + B2I(GetUnitAbilityLevel(GetTriggerUnit(), 'A03W') >= 5) + B2I(GetUnitAbilityLevel(GetTriggerUnit(), 'A03W') >= 10), 'o001', GetTriggerPlayer(), udg_TempLoc, bj_UNIT_FACING)
    loop
        set u=FirstOfGroup(g)
        call UnitApplyTimedLife(u, 'BTLF', 180)
        call SetUnitBonus(u , BONUS_DAMAGE , R2I(I2R(GetHeroInt(GetTriggerUnit(), true)) * ( 1 + ( 0.1 * I2R(GetUnitAbilityLevel(GetTriggerUnit(), 'A03W')) ) )))
        call SetUnitBonus(u , BONUS_LIFE , R2I(I2R(GetHeroStr(GetTriggerUnit(), true)) * ( 3 + ( 0.3 * I2R(GetUnitAbilityLevel(GetTriggerUnit(), 'A03W')) ) )))
        call SetUnitBonus(u , BONUS_ARMOR , R2I(I2R(GetHeroAgi(GetTriggerUnit(), true)) * ( 0.05 + ( 0.0125 * I2R(GetUnitAbilityLevel(GetTriggerUnit(), 'A03W')) ) )))
        call SetUnitBonus(u , BONUS_ATTACK_SPEED , 10 + ( 2 * R2I(GetUnitAbilityLevel(GetTriggerUnit(), 'A03W')) ))
        call GroupRemoveUnit(g, u)
    endloop
    call AddSpecialEffectLocBJ(udg_TempLoc, "Abilities\\Spells\\Orc\\FeralSpirit\\feralspirittarget.mdl")
    call DestroyEffectBJ(GetLastCreatedEffectBJ())
    call RemoveLocation(udg_TempLoc)
    call DestroyGroup(g)
    set u=null
endfunction

//===========================================================================
function InitTrig_Untitled_Trigger_002 takes nothing returns nothing
    set gg_trg_Untitled_Trigger_002=CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(gg_trg_Untitled_Trigger_002, EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(gg_trg_Untitled_Trigger_002, Condition(function Trig_Untitled_Trigger_002_Conditions))
    call TriggerAddAction(gg_trg_Untitled_Trigger_002, function Trig_Untitled_Trigger_002_Actions)
endfunction

//===========================================================================
// Trigger: No Autocast Fierce Blow
//===========================================================================
//TESH.scrollpos=-1
//TESH.alwaysfold=0
// scope NoAutocast begins
    
    
    function NoAutocast__onExpire takes nothing returns nothing
        local timer t= GetExpiredTimer()
        local unit u= LoadUnitHandle(NoAutocast__hash, GetHandleId(t), 0)
        call IssueImmediateOrderById(u, 852245)
        set u=null
        call FlushChildHashtable(NoAutocast__hash, GetHandleId(t))
        call DestroyTimer(t)
        set t=null
    endfunction

    function NoAutocast__handler takes nothing returns boolean
        local timer t
        
        if GetIssuedOrderId() == 852244 and GetUnitTypeId(GetTriggerUnit()) == 'H003' then
            set t=CreateTimer()
            call SaveUnitHandle(NoAutocast__hash, GetHandleId(t), 0, GetTriggerUnit())
            call TimerStart(t, 0., false, function NoAutocast__onExpire)
        endif
        set t=null
        return false
    endfunction

    function NoAutocast__init takes nothing returns nothing
        local trigger t= CreateTrigger()
        call TriggerRegisterAnyUnitEventBJ(t, EVENT_PLAYER_UNIT_ISSUED_ORDER)
        call TriggerAddCondition(t, Condition(function NoAutocast__handler))
        set t=null
    endfunction

// scope NoAutocast ends
//===========================================================================
// Trigger: Frost Nova
//===========================================================================
function Trig_Frost_Nova_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A014' ) ) then
        return false
    endif
    return true
endfunction

function Trig_Frost_Nova_Func003001003 takes nothing returns boolean
    return ( 0 == 0 )
endfunction

function Trig_Frost_Nova_Func003Func001C takes nothing returns boolean
    if ( not ( GetConvertedPlayerId(GetOwningPlayer(GetEnumUnit())) >= 11 ) ) then
        return false
    endif
    return true
endfunction

function Trig_Frost_Nova_Func003A takes nothing returns nothing
    if ( Trig_Frost_Nova_Func003Func001C() ) then
        call UnitDamageTargetBJ(GetTriggerUnit(), GetEnumUnit(), ( I2R(GetHeroStatBJ(bj_HEROSTAT_INT, GetTriggerUnit(), true)) * 4.00 ), ATTACK_TYPE_NORMAL, DAMAGE_TYPE_ENHANCED)
        call AddSpecialEffectTargetUnitBJ("origin", GetEnumUnit(), "Abilities\\Spells\\Undead\\FrostNova\\FrostNovaTarget.mdl")
        call DestroyEffectBJ(GetLastCreatedEffectBJ())
    else
    endif
endfunction

function Trig_Frost_Nova_Actions takes nothing returns nothing
    call AddSpecialEffectTargetUnitBJ("origin", GetTriggerUnit(), "war3mapImported\\FrostNova.MDX")
    call DestroyEffectBJ(GetLastCreatedEffectBJ())
    call ForGroupBJ(GetUnitsInRangeOfLocMatching(400.00, GetUnitLoc(GetTriggerUnit()), Condition(function Trig_Frost_Nova_Func003001003)), function Trig_Frost_Nova_Func003A)
endfunction

//===========================================================================
function InitTrig_Frost_Nova takes nothing returns nothing
    set gg_trg_Frost_Nova=CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(gg_trg_Frost_Nova, EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(gg_trg_Frost_Nova, Condition(function Trig_Frost_Nova_Conditions))
    call TriggerAddAction(gg_trg_Frost_Nova, function Trig_Frost_Nova_Actions)
endfunction

//===========================================================================
// Trigger: Electricity Main
//
// U2U
//  *          From attached to a unit to attached to a unit
//  *          static method U2U takes lightning l, unit s, unit t, real time, real z1, real z2, real startAlpha, real endAlpha returns nothing
//  *
//  *          The lightning, source unit, target unit, duration, source z, target z
//  *
//===========================================================================
//TESH.scrollpos=24
//TESH.alwaysfold=0

function Trig_Electricity_Main_Actions takes nothing returns nothing
    local integer i= 0
    local integer i2= 0
    local integer i3= 0
    local real i4= 0
    local unit s= GetSpellAbilityUnit()
    local unit t= GetSpellTargetUnit()
    local unit udum
    local location l
    local location l2
    local group g
    if GetSpellAbilityId() == 'A046' then
        call UnitDamageTarget(s, t, I2R(GetHeroInt(s, true)) * ( 1.50 ) + ( 25 * GetUnitAbilityLevel(s, 'A00N') ), false, false, null, null, null)
        set l=GetUnitLoc(t)
       // call TimedL.U2U(AddLightning("CLPB", true, GetUnitX(s), GetUnitY(s), GetUnitX(t), GetUnitY(t)), s, t, 0.5, 50, 50, 255, 255)
        call s__TimedL_U2U(AddLightning("CLSB", true, GetUnitX(s), GetUnitY(s), GetUnitX(t), GetUnitY(t)) , s , t , 0.5 , 50 , 50 , 255 , 255)
        set udg_TempUnit=t
        set g=CreateGroup()
        call GroupEnumUnitsInRangeOfLoc(g, l, 400, Condition(function filterOnlyEnemy))
        set i2=CountUnitsInGroup(g)
        set i3=i2
            
        loop
                
                set udum=GetClosestUnitInGroup(GetLocationX(l) , GetLocationY(l) , g)
                if isViableTarget(s , udum) then
                    set l2=GetUnitLoc(udum)
                    set l=GetUnitLoc(t)
                    
                    set i4=DistanceBetweenPoints(l2, l)
                    call UnitDamageTarget(s, udum, ( ( I2R(GetHeroInt(s, true)) * 0.75 ) + ( 25 * GetUnitAbilityLevel(s, 'A00N') ) ) * ( 1 - ( i4 / 800 ) ), false, false, null, null, null)
                    call s__TimedL_U2U(AddLightning("AFOD", true, GetUnitX(t), GetUnitY(t), GetUnitX(udum), GetUnitY(udum)) , udum , t , 0.5 , 50 , 50 , 255 , 255)
                endif
                call GroupRemoveUnit(g, udum)
                set i2=i2 - 1
                exitwhen i2 == 0 or i3 - i2 >= 1.5 + ( GetUnitAbilityLevel(s, 'A00N') * 0.5 )
                    
        endloop
        set s=null
        set t=null
        call RemoveLocation(l)
        call RemoveLocation(l2)
        set udum=null
        call DestroyGroup(g)
    endif
endfunction

//===========================================================================
function InitTrig_Electricity_Main takes nothing returns nothing
    set gg_trg_Electricity_Main=CreateTrigger()
    call TriggerAddAction(gg_trg_Electricity_Main, function Trig_Electricity_Main_Actions)
    call TriggerRegisterAnyUnitEventBJ(gg_trg_Electricity_Main, EVENT_PLAYER_UNIT_SPELL_EFFECT)
endfunction

//===========================================================================
// Trigger: Chat
//===========================================================================
function Trig_Chat_Actions takes nothing returns nothing
endfunction

//===========================================================================
function InitTrig_Chat takes nothing returns nothing
    set gg_trg_Chat=CreateTrigger()
    call TriggerAddAction(gg_trg_Chat, function Trig_Chat_Actions)
endfunction

//===========================================================================
// Trigger: Waypoint
//===========================================================================
//TESH.scrollpos=-1
//TESH.alwaysfold=0

//===========================================================================
// Trigger: ItemStacker
//===========================================================================
//TESH.scrollpos=2
//TESH.alwaysfold=0
// Trigger: CritHandler
//
// 3.7358*(()^0.1756)
//===========================================================================
//TESH.scrollpos=60
//TESH.alwaysfold=0
// Trigger: Dungeon
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0

//===========================================================================
// Trigger: Custom Drop System
//===========================================================================
//TESH.scrollpos=77
//TESH.alwaysfold=0
// Trigger: UnitRespawn
//
// 
// *
// *   struct UnitIndexer extends array
// *
// *        -    Controls the unit indexer system.
// *
// *       static constant Event UnitIndexer.INDEX
// *       static constant Event UnitIndexer.DEINDEX
// *           -   Don't register functions and triggers directly to the events. Register them via
// *           -   RegisterUnitIndexEvent and TriggerRegisterUnitIndexEvent.
// *
// *       static boolean enabled
// ************************************************************************************
// *
// *    Functions
// *
// *       function RegisterUnitIndexEvent takes boolexpr codeToRegister, Event unitIndexEvent returns nothing
// *       function TriggerRegisterUnitIndexEvent takes trigger triggerToRegister, Event unitIndexEvent returns nothing
// *
// *       function GetUnitById takes integer index returns unit
// *           -   Returns unit given a unit index
// *       function GetUnitId takes unit u returns integer
// *           -   Returns unit index given a unit
// *
// *       function IsUnitIndexed takes unit u returns boolean
// *       function IsUnitDeindexing takes unit u returns boolean
// *
// *           -   Enables and disables unit indexing. Useful for filtering out dummy units.
//===========================================================================
//TESH.scrollpos=4
//TESH.alwaysfold=0
    function s__UnitRespawn_index takes integer this returns nothing
        local unit u= (UnitIndexer___e[(this)]) // INLINED!!
        call SaveReal(s__UnitRespawn_creepTable, this, 1, GetUnitX(u))
        call SaveReal(s__UnitRespawn_creepTable, this, 2, GetUnitY(u))
        call SaveReal(s__UnitRespawn_creepTable, this, 3, GetUnitFacing(u))
        set u=null
    endfunction
    
    function s__UnitRespawn_deindex takes integer this returns nothing
        call FlushChildHashtable(s__UnitRespawn_creepTable, this)
    endfunction
    
    function s__UnitRespawn_onDeathFilter takes nothing returns boolean
        return LoadReal(s__UnitRespawn_creepTable, (GetUnitUserData((GetFilterUnit()))), 1) >= 0 // INLINED!!
    endfunction
    
    function s__UnitRespawn_onDeath takes nothing returns nothing
        local unit u= GetDyingUnit()
        local integer id= GetUnitTypeId(u)
        local integer lv= GetHeroLevel(u)
        local integer cv= (GetUnitUserData((u))) // INLINED!!
        local real x= LoadReal(s__UnitRespawn_creepTable, cv, 1)
        local real y= LoadReal(s__UnitRespawn_creepTable, cv, 2)
        local real ang= LoadReal(s__UnitRespawn_creepTable, cv, 3)
        //if RectContainsUnit(gg_rct_Kobold_Dungeon_I, u) == true or RectContainsUnit(gg_rct_Kobold_Dungeon_II, u) == true then
        //    return
        //endif
        call TriggerSleepAction(15.00)
        call RemoveUnit(u)
        set u=CreateUnit(GetTriggerPlayer(), id, x, y, ang)
        if lv > 1 then
            call SetHeroLevel(u, lv, false)
        endif
        set u=null
    endfunction

    function s__UnitRespawn_onInit takes nothing returns nothing
        local trigger t3= CreateTrigger()
        call TriggerRegisterPlayerUnitEventSimple(t3, Player(PLAYER_NEUTRAL_AGGRESSIVE), EVENT_PLAYER_UNIT_DEATH)
        call TriggerAddAction(t3, function s__UnitRespawn_onDeath)
        call TriggerAddCondition(t3, Condition(function s__UnitRespawn_onDeathFilter))
        set t3=null
    endfunction
    
//Implemented from module UnitIndexStruct:
        function s__UnitRespawn__staticgetindex takes unit u returns integer
            return GetUnitUserData(u)
        endfunction
        function s__UnitRespawn__get_unit takes integer this returns unit
            return UnitIndexer___e[this]
        endfunction
        



























            function s__UnitRespawn_UnitIndexStruct___onIndexEvent takes nothing returns boolean









                        set s__UnitRespawn_allocated[(UnitIndexer___o)]=true

                    call s__UnitRespawn_index((UnitIndexer___o))

                return false
            endfunction


            function s__UnitRespawn_UnitIndexStruct___onDeindexEvent takes nothing returns boolean













                        set s__UnitRespawn_allocated[(UnitIndexer___o)]=false

                    call FlushChildHashtable(s__UnitRespawn_creepTable, ((UnitIndexer___o))) // INLINED!!

                return false
            endfunction



                function s__UnitRespawn_UnitIndexStruct___onInit takes nothing returns nothing
                    call RegisterUnitIndexEvent(Condition(function s__UnitRespawn_UnitIndexStruct___onIndexEvent) , s__UnitIndexer_INDEX)
                    call RegisterUnitIndexEvent(Condition(function s__UnitRespawn_UnitIndexStruct___onDeindexEvent) , s__UnitIndexer_DEINDEX)
                endfunction











//===========================================================================
// Trigger: Bounty System
//
// 
//     call AdjustPlayerStateBJ( 1000, Player(0), PLAYER_STATE_RESOURCE_GOLD )
//     call AddHeroXPSwapped( 1000, GetTriggerUnit(), false )
//===========================================================================
//TESH.scrollpos=92
//TESH.alwaysfold=0
//===========================================================================
// Trigger: KeepTime
//===========================================================================
function Trig_KeepTime_Actions takes nothing returns nothing
    set udg_CurrentGameTime=( udg_CurrentGameTime + 0.25 )
endfunction

//===========================================================================
function InitTrig_KeepTime takes nothing returns nothing
    set gg_trg_KeepTime=CreateTrigger()
    call TriggerRegisterTimerEventPeriodic(gg_trg_KeepTime, 0.25)
    call TriggerAddAction(gg_trg_KeepTime, function Trig_KeepTime_Actions)
endfunction

//===========================================================================
// Trigger: Add Bounty
//
// AddBounty takes integer unit1, integer unit2, integer unit3, integer unit4, integer unit5, integer unit6, integer count, integer playerFor, integer gold, integer exp
//===========================================================================
function Trig_Add_Bounty_Func001C takes nothing returns boolean
    if ( not ( GetItemTypeId(GetManipulatedItem()) == 'I005' ) ) then
        return false
    endif
    return true
endfunction

function Trig_Add_Bounty_Func002C takes nothing returns boolean
    if ( not ( GetItemTypeId(GetManipulatedItem()) == 'I01R' ) ) then
        return false
    endif
    return true
endfunction

function Trig_Add_Bounty_Func003C takes nothing returns boolean
    if ( not ( GetItemTypeId(GetManipulatedItem()) == 'I01S' ) ) then
        return false
    endif
    return true
endfunction

function Trig_Add_Bounty_Actions takes nothing returns nothing
    if ( Trig_Add_Bounty_Func001C() ) then
        call AddBounty('n000' , 'n001' , 'n002' , 'n00H' , 'n00G' , 0 , 10 , GetPlayerId(GetTriggerPlayer()) , 150 , 70 , "|cffFFcc00Baby Spiders|r")
        return
    else
    endif
    if ( Trig_Add_Bounty_Func002C() ) then
        call AddBounty('n00B' , 'n00C' , 'n00D' , 'n003' , 0 , 0 , 15 , GetPlayerId(GetTriggerPlayer()) , 500 , 150 , "|cffFFcc00Weak Bandits|r")
        return
    else
    endif
    if ( Trig_Add_Bounty_Func003C() ) then
        call AddBounty('n005' , 'n004' , 'n009' , 0 , 0 , 0 , 15 , GetPlayerId(GetTriggerPlayer()) , 700 , 250 , "|cffFFcc00Weak Kobolds|r")
        return
    else
    endif
endfunction

//===========================================================================
function InitTrig_Add_Bounty takes nothing returns nothing
    set gg_trg_Add_Bounty=CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(gg_trg_Add_Bounty, EVENT_PLAYER_UNIT_USE_ITEM)
    call TriggerAddAction(gg_trg_Add_Bounty, function Trig_Add_Bounty_Actions)
endfunction

//===========================================================================
// Trigger: PlayerLeaveGame
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Leave takes nothing returns nothing
    call print(GetPlayerName(GetTriggerPlayer()) + " Has left the game.")
endfunction

//===========================================================================
function InitTrig_PlayerLeaveGame takes nothing returns nothing
    local trigger t= CreateTrigger()
    local integer i= 0
    loop
        exitwhen i == 12
        call TriggerRegisterPlayerEvent(t, Player(i), EVENT_PLAYER_LEAVE)
        set i=i + 1
    endloop
    call TriggerAddAction(t, function Leave)
endfunction

//===========================================================================
// Trigger: GUI SpellEvent
//===========================================================================
function Trig_GUI_SpellEvent_Actions takes nothing returns nothing
        call SaveTriggerHandle(udg_SpellEventHash, udg_SpellEventAbility, 0, udg_SpellEventTrigger)
    endfunction
     
    // -
    // This function only executes one trigger.
    // -
     
    function OnSpell takes nothing returns boolean
        local trigger t= LoadTriggerHandle(udg_SpellEventHash, GetSpellAbilityId(), 0)
        if TriggerEvaluate(t) then
            call TriggerExecute(t)
        endif
        set t=null
        return false
    endfunction
     
    // -
    // This is the Initialization function of the entire system.
    // -
     
    function InitSpellEvent takes nothing returns nothing
        local trigger t= CreateTrigger()
    call InitHashtableBJ()
    set udg_SpellEventHash=GetLastCreatedHashtableBJ()
    // -
    // The only purpose of this is to automatically create the variables.
    // -
    set udg_SpellEventTrigger=GetTriggeringTrigger()
    set udg_SpellEventAbility='AIpl'
        call TriggerRegisterAnyUnitEventBJ(t, EVENT_PLAYER_UNIT_SPELL_EFFECT)
        call TriggerAddCondition(t, Condition(function OnSpell))
        set t=null
endfunction

//===========================================================================
function InitTrig_GUI_SpellEvent takes nothing returns nothing
    set gg_trg_GUI_SpellEvent=CreateTrigger()
    call TriggerAddAction(gg_trg_GUI_SpellEvent, function Trig_GUI_SpellEvent_Actions)
endfunction

//===========================================================================
// Trigger: GUI SpellEvent Init
//===========================================================================
function Trig_GUI_SpellEvent_Init_Actions takes nothing returns nothing
    call ExecuteFunc("InitSpellEvent")
    set udg_SpellEventAbility='A03M'
    set udg_SpellEventTrigger=gg_trg_Electricity_Main
    call TriggerExecute(udg_SpellEventTrigger)
endfunction

//===========================================================================
function InitTrig_GUI_SpellEvent_Init takes nothing returns nothing
    set gg_trg_GUI_SpellEvent_Init=CreateTrigger()
    call TriggerAddAction(gg_trg_GUI_SpellEvent_Init, function Trig_GUI_SpellEvent_Init_Actions)
endfunction

//===========================================================================
// Trigger: Trigger Refresh
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0


// Trigger: DDS
//===========================================================================
//TESH.scrollpos=7
//TESH.alwaysfold=0
// Trigger: Damage Event DDS Plugin
//===========================================================================
//TESH.scrollpos=161
//TESH.alwaysfold=0
// Trigger: Damage Event Modification DDS Plugin
//===========================================================================
//TESH.scrollpos=34
//TESH.alwaysfold=0
// Trigger: Damage Event Archetype DDS Plugin
//===========================================================================
//TESH.scrollpos=102
//TESH.alwaysfold=0
// Trigger: LifeSaver
//===========================================================================
//TESH.scrollpos=7
//TESH.alwaysfold=0
// Trigger: Type
//===========================================================================
//TESH.scrollpos=24
//TESH.alwaysfold=0
// Trigger: ShadowTrail
//===========================================================================
//TESH.scrollpos=14
//TESH.alwaysfold=0



//===========================================================================
// Trigger: AddShadowTrailTest2
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_AddShadowTrailTest2_Conditions takes nothing returns boolean
    if ( not ( GetSpellAbilityId() == 'A002' ) ) then
        return false
    endif
    return true
endfunction

function Trig_AddShadowTrailTest2_Actions takes nothing returns nothing
    local integer st
    // ----------------------------------------
    set udg_u=GetTriggerUnit()
    // ----------------------------------------
    set st=s__ShadowTrail_add(udg_u , TRAIL_TYPE_MOTION , 12)
    call s__ShadowTrail_setupMovingTrail(st,5 , 16 , 0.7)
    call s__ShadowTrail_setColor(st,150 , 150 , 150 , 200)
    call s__ShadowTrail_setAnimationIndex(st,2)
    call s__ShadowTrail_setFadeRate(st,10 , true)
    call s__ShadowTrail_setEffect(st,"Abilities\\Weapons\\ZigguratMissile\\ZigguratMissile.mdl" , "chest" , false)
    // ----------------------------------------
endfunction

//===========================================================================
function InitTrig_AddShadowTrailTest2 takes nothing returns nothing
    set gg_trg_AddShadowTrailTest2=CreateTrigger()
    call TriggerRegisterAnyUnitEventBJ(gg_trg_AddShadowTrailTest2, EVENT_PLAYER_UNIT_SPELL_EFFECT)
    call TriggerAddCondition(gg_trg_AddShadowTrailTest2, Condition(function Trig_AddShadowTrailTest2_Conditions))
    call TriggerAddAction(gg_trg_AddShadowTrailTest2, function Trig_AddShadowTrailTest2_Actions)
endfunction

//===========================================================================
// Trigger: GetUnitCollision
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0

//===========================================================================
// Trigger: AdvLoc
//===========================================================================
//TESH.scrollpos=77
//TESH.alwaysfold=0
// Trigger: AVL Tree
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: BinaryHeap
//===========================================================================
//TESH.scrollpos=14
//TESH.alwaysfold=0
// Trigger: Bonus
//===========================================================================
//TESH.scrollpos=-1
//TESH.alwaysfold=0

// Trigger: BoundSentinel
//===========================================================================
//TESH.scrollpos=39
//TESH.alwaysfold=0

//===========================================================================
// Trigger: Catalog
//===========================================================================
//TESH.scrollpos=455
//TESH.alwaysfold=0
// Trigger: Color Code String
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: CompressInt
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: CTL
//===========================================================================
//TESH.scrollpos=240
//TESH.alwaysfold=0
// Trigger: DiracLinkedList
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: GetClosestUnit
//===========================================================================
//TESH.scrollpos=-1
//TESH.alwaysfold=0

// Trigger: GetItemOwner
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: GetNameColored
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: GetRequiredXP
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: Group Utils
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: IsTerrainWalkable
//===========================================================================
//TESH.scrollpos=70
//TESH.alwaysfold=0
// Trigger: Loc
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: Missile
//===========================================================================
//TESH.scrollpos=148
//TESH.alwaysfold=0
    //===========================================================================
// Trigger: MissleRecycler
//===========================================================================
//TESH.scrollpos=81
//TESH.alwaysfold=0
// Trigger: PriorityEevent
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: RegisterPlayerUnitEvent
//===========================================================================
//TESH.scrollpos=25
//TESH.alwaysfold=0

// Trigger: SimError
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Table
//===========================================================================
//TESH.scrollpos=7
//TESH.alwaysfold=0
// Trigger: Track
//
// Default melee game initialization for all players
//===========================================================================
//TESH.scrollpos=54
//TESH.alwaysfold=0
// Trigger: TimedLightning
//===========================================================================
//TESH.scrollpos=14
//TESH.alwaysfold=0

// Trigger: T32
//===========================================================================
//TESH.scrollpos=160
//TESH.alwaysfold=0
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~ Timer32 ~~ By Jesus4Lyf ~~ Version 1.06 ~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//  What is Timer32?
//         - Timer32 implements a fully optimised timer loop for a struct.
//         - Instances can be added to the loop, which will call .periodic every
//           PERIOD until .stopPeriodic() is called.
//
//    =Pros=
//         - Efficient.
//         - Simple.
//
//    =Cons=
//         - Only allows one period.
//         - The called method must be named ".periodic".
//
//    Methods:
//         - struct.startPeriodic()
//         - struct.stopPeriodic()
//
//         - private method periodic takes nothing returns nothing
//
//           This must be defined in structs that implement Periodic Module.
//           It will be executed by the module every PERIOD until .stopPeriodic() is called.
//           Put "implement T32x" BELOW this method.
//
//    Modules:
//         - T32x
//           Has no safety on .stopPeriodic or .startPeriodic (except debug messages
//           to warn).
//
//         - T32xs
//           Has safety on .stopPeriodic and .startPeriodic so if they are called
//           multiple times, or while otherwise are already stopped/started respectively,
//           no error will occur, the call will be ignored.
//
//         - T32
//           The original, old version of the T32 module. This remains for backwards
//           compatability, and is deprecated. The periodic method must return a boolean,
//           false to continue running or true to stop.
//
//  Details:
//         - Uses one timer.
//
//         - Do not, within a .periodic method, follow a .stopPeriodic call with a
//           .startPeriodic call.
//
//  How to import:
//         - Create a trigger named T32.
//         - Convert it to custom text and replace the whole trigger text with this.
//
//  Thanks:
//         - Infinitegde for finding a bug in the debug message that actually altered
//           system operation (when in debug mode).
//
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Trigger: TimerUtils
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
//===========================================================================
// Trigger: Timed AS
//===========================================================================
//TESH.scrollpos=104
//TESH.alwaysfold=0
//***********************************************************************************
//*
//*       ____ __   ____        _______________________________________
//*      /_  _| _\ / __/        |      T I M E D   A B I L I T Y      |
//*        | || _ \\__ \        |               A N D                 |
//*        |_||_|\_\___/        |        S T A C K   S Y S T E M      |
//*         By Spinnaker        '_____________________________________'
//*                                                         v3.0.0.1
//*
//*    What is TAS?
//*    ____________
//*
//*       There are lots situations when you want your spells/abilities to add some
//*       kind of timed buff/debuff which can be increased with new applications.
//*       Timed ability/stack system allows you to time any ability you want,
//*       and makes ability-stacking an easy job. 
//*
//*       System consists of one trigger. Script - depending on option chosen -
//*       divides abilities into two groups:
//*
//*       1) Without refreshing - runs abilities that don't refresh with
//*          new applications, but each stack has it's own private duration.
//*
//*       2) With refreshing - runs abilities that do refresh with every
//*          new application.
//*     
//*
//*    Reason - why?
//*    _____________
//*
//*       I decided to create this system due to lack of such and the high
//*       frequency of adding timed stuff in various triggers.
//*       Great example where such stacking abilities exist is obviously DotA.
//*
//*
//*    How to implement?
//*    _________________
//*
//*       1) Be sure "Automatically create unknown variables while pasting
//*          trigger data" is enabled in the World Editor general preferences.
//*
//*       2) Copy and paste trigger 'TAS Veriable Creator' into your map for
//*          automatical variable creation
//*
//*       3) Copy trigger "Timed AS" and paste it into your map.
//*          System requires no Object Editor stuff.
//*
//*       System is implemented. To run it properly see the next part.  
//*
//*
//*    What needs to be done?
//*    ______________________
//*
//*       Set TASability to ability you want to be timed. 
//*       Now, choose unit that a timed ability will be added to.
//*       Next step is setting duration of the ability in field TASduration.
//*
//*       Select the refresh option. Choosing 'True' will let your ability
//*       refresh even if maximum value of stacks has been reached, while 'False'
//*       converts abilities to private stacks which don't interfere with each other.
//*
//*       Enter maximum amount of applications in TASmaxstack.
//*       Abilities with maximum value won't be increased, but can refreash.
//*      
//*     Leave the rest for the system, enjoy!
//*     _____________________________________
//*
//*
//***********************************************************************************


//***************************************************************************
//*
//*  Global Variables
//*
//***************************************************************************


    //* udg_TAShash                           Hashtable for refreshable abilities issues
    //* udg_TASindex                          Counts all running instances
    //* udg_TAStimer                          Global timer for periodic issues
    //* udg_TASdur[]                          Stores duration of each instance
    //* udg_TASend[]                          Checks if given instance should be removed
    //* udg_TASids[]                          Contains all the ability data
    //* udg_TASref[]                          Checks if ability manipulated is refreshable or not
    //* udg_TASunits[]                        For unit storage
    
  //* User friendly parameters
  
    //* udg_TASability                        Gets new ability
    //* udg_TASunit                           Gets new unit
    //* udg_TASduration                       Gets duration for new ability
    //* udg_TASrefresh                        Sets instance type
    //* udg_TASmaxstack                       Maximum amount of stacks for given ability

    
//***************************************************************************
//* Constant interval function
//***************************************************************************

    constant function TASinterval takes nothing returns real
        return 0.031250000
    endfunction

//***************************************************************************
//*
//*  System itself
//*
//***************************************************************************


function TASallocate takes integer id returns nothing
    set udg_TASindex=udg_TASindex + 1
    set udg_TASids[udg_TASindex]=id
    set udg_TASunits[udg_TASindex]=udg_TASunit
    set udg_TASdur[udg_TASindex]=udg_TASduration
    set udg_TASref[udg_TASindex]=udg_TASrefresh
    set udg_TASend[udg_TASindex]=false
endfunction

function TASdeallocate takes integer i returns nothing
    set udg_TASunits[i]=udg_TASunits[udg_TASindex]
    set udg_TASids[i]=udg_TASids[udg_TASindex]
    set udg_TASdur[i]=udg_TASdur[udg_TASindex]
    set udg_TASref[i]=udg_TASref[udg_TASindex]
    set udg_TASend[i]=udg_TASend[udg_TASindex]
    set udg_TASindex=udg_TASindex - 1
endfunction

function TASunitcheck takes unit u returns boolean
    return IsUnitType(u, UNIT_TYPE_DEAD) or GetUnitTypeId(u) == 0
endfunction

function TAScallback takes nothing returns nothing
    local integer i= 1
    local integer h
    local integer n
    local boolean b
    local player p
    loop
        exitwhen i > udg_TASindex
        if udg_TASref[i] then
            set h=GetHandleId(udg_TASunits[i])
            set udg_TASdur[i]=LoadReal(udg_TAShash, h, udg_TASids[i])
        endif
        set udg_TASdur[i]=udg_TASdur[i] - (0.031250000) // INLINED!!
        set b=udg_TASref[i] or GetUnitAbilityLevel(udg_TASunits[i], udg_TASids[i]) < 2
        if ( udg_TASdur[i] <= 0. and b ) or TASunitcheck(udg_TASunits[i]) then
            set udg_TASend[i]=true
            call UnitRemoveAbility(udg_TASunits[i], udg_TASids[i])
        elseif udg_TASdur[i] <= 0. and not b then
            set udg_TASend[i]=true
            set p=GetOwningPlayer(udg_TASunits[i])
            call SetPlayerAbilityAvailable(p, udg_TASids[i], false)
            call DecUnitAbilityLevel(udg_TASunits[i], udg_TASids[i])
            call SetPlayerAbilityAvailable(p, udg_TASids[i], true)
        elseif udg_TASref[i] then
            call SaveReal(udg_TAShash, h, udg_TASids[i], udg_TASdur[i])
        endif
        if udg_TASend[i] then
            if udg_TASref[i] then
                set n=LoadInteger(udg_TAShash, h, 0) - 1
                if 0 == n then
                    call FlushChildHashtable(udg_TAShash, h)
                else
                    call SaveInteger(udg_TAShash, h, 0, n)
                endif
            endif
            call TASdeallocate(i)
            set i=i - i
            if 0 == udg_TASindex then
                call PauseTimer(udg_TAStimer)
            endif
        endif
        set i=i + 1
    endloop
    set p=null
endfunction  

function TASexecute takes nothing returns nothing
    local integer id= udg_TASability
    local integer n= GetUnitAbilityLevel(udg_TASunit, id)
    local player p
    if 0 == udg_TASindex then
        call TimerStart(udg_TAStimer, (0.031250000), true, function TAScallback) // INLINED!!
    endif
    if UnitAddAbility(udg_TASunit, id) then
        call TASallocate(id)
    elseif n < udg_TASmaxstack then
        set p=GetOwningPlayer(udg_TASunit)
        call SetPlayerAbilityAvailable(p, id, false)
        call IncUnitAbilityLevel(udg_TASunit, id)
        call SetPlayerAbilityAvailable(p, id, true)
        if not udg_TASrefresh then
            call TASallocate(id)
        endif
        set p=null
    endif
    if udg_TASrefresh then
        set n=GetHandleId(udg_TASunit)
        if LoadReal(udg_TAShash, n, id) == 0. then
            call SaveInteger(udg_TAShash, n, 0, LoadInteger(udg_TAShash, n, 0) + 1)
        endif
        call SaveReal(udg_TAShash, n, id, udg_TASduration)
    endif
endfunction

//***************************************************************************    
function InitTrig_Timed_AS takes nothing returns nothing
    set gg_trg_Timed_AS=CreateTrigger()
    set udg_TAStimer=CreateTimer()
    set udg_TAShash=InitHashtable()
    call TriggerAddAction(gg_trg_Timed_AS, function TASexecute)
endfunction//===========================================================================
// Trigger: UnitEvent
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
// Trigger: Unit Indexer Copy
//===========================================================================
//TESH.scrollpos=71
//TESH.alwaysfold=0
// Trigger: xebasic
//===========================================================================
//TESH.scrollpos=19
//TESH.alwaysfold=0


//===========================================================================
// Trigger: Untitled Trigger 003
//===========================================================================
//TESH.scrollpos=0
//TESH.alwaysfold=0
function InitCustomTriggers takes nothing returns nothing
    //Function not found: call InitTrig_GameStart_Copy()
    call InitTrig_GlobalExpRate()
    call InitTrig_Untitled_Trigger_008()
    call InitTrig_Inity()
    //Function not found: call InitTrig_Thread()
    call InitTrig_Revive()
    //Function not found: call InitTrig_Ascii()
    //Function not found: call InitTrig_Alloc()
    call InitTrig_Beta_Test_Buffs()
    call InitTrig_Untitled_Trigger_006()
    call InitTrig_lvl()
    call InitTrig_init()
    call InitTrig_right_arrow()
    call InitTrig_left_arrow()
    call InitTrig_periodic()
    call InitTrig_repick()
    call InitTrig_esc()
    //Function not found: call InitTrig_RootLibrary()
    //Function not found: call InitTrig_TraitConstants()
    //Function not found: call InitTrig_showinventory()
    //Function not found: call InitTrig_mainitemcreation()
    //Function not found: call InitTrig_InventoryCoderInterface()
    //Function not found: call InitTrig_TraitHandler()
    //Function not found: call InitTrig_Recipe()
    //Function not found: call InitTrig_Statboard()
    //Function not found: call InitTrig_NoLeaveGotum()
    //Function not found: call InitTrig_QuestListener()
    //Function not found: call InitTrig_AdvancedQuest()
    //Function not found: call InitTrig_GotumStarterQuests()
    //Function not found: call InitTrig_Quest()
    //Function not found: call InitTrig_Party()
    //Function not found: call InitTrig_HeroImage()
    //Function not found: call InitTrig_StatHandler()
    //Function not found: call InitTrig_BigInt()
    //Function not found: call InitTrig_Scrambler()
    //Function not found: call InitTrig_Base()
    //Function not found: call InitTrig_GetLearnedAbilities()
    //Function not found: call InitTrig_AddRepeatedString()
    //Function not found: call InitTrig_Remove_String()
    //Function not found: call InitTrig_NumberStack()
    //Function not found: call InitTrig_Knuth_Checksum()
    //Function not found: call InitTrig_Buffer()
    //Function not found: call InitTrig_EncryptNumber()
    //Function not found: call InitTrig_ApplyChecksum()
    //Function not found: call InitTrig_InitSave()
    //Function not found: call InitTrig_Simple_SaveLoad()
    //Function not found: call InitTrig_ItemRootsCatalog()
    //Function not found: call InitTrig_ItemRootsCatalog_Copy()
    //Function not found: call InitTrig_SaveCodeToHD()
    //Function not found: call InitTrig_GroupVersionFilter()
    //Function not found: call InitTrig_LevelGroupSlotVersionFilter()
    //Function not found: call InitTrig_LevelGroupVersionFilter()
    //Function not found: call InitTrig_VersionFilter()
    //Function not found: call InitTrig_wordwrapstring()
    //Function not found: call InitTrig_Untitled_Trigger_005()
    //Function not found: call InitTrig_stringsize()
    //Function not found: call InitTrig_ButtonDemo()
    //Function not found: call InitTrig_VJassTalentTree()
    //Function not found: call InitTrig_Borders()
    //Function not found: call InitTrig_Button()
    //Function not found: call InitTrig_Interact()
    call InitTrig_Call_Bag()
    call InitTrig_BRP1()
    call InitTrig_BRP2()
    call InitTrig_BRP3()
    call InitTrig_BRP4()
    call InitTrig_BRP5()
    call InitTrig_BRP6()
    call InitTrig_BRP7()
    call InitTrig_BRP8()
    call InitTrig_BRP9()
    call InitTrig_BRP10()
    call InitTrig_Commands()
    //Function not found: call InitTrig_ChargedBolt()
    call InitTrig_DoE_Enter()
    call InitTrig_DoE_Exit()
    //Function not found: call InitTrig_WizardForceSpells()
    //Function not found: call InitTrig_T32Interface()
    //Function not found: call InitTrig_FunctionAfterTime()
    //Function not found: call InitTrig_StructAttach()
    //Function not found: call InitTrig_FighterFirstSpells()
    call InitTrig_Untitled_Trigger_001()
    //Function not found: call InitTrig_WitchFirstSpells()
    //Function not found: call InitTrig_WizardFireSpells()
    //Function not found: call InitTrig_DamageModification()
    call InitTrig_Untitled_Trigger_002()
    //Function not found: call InitTrig_No_Autocast_Fierce_Blow()
    call InitTrig_Frost_Nova()
    call InitTrig_Electricity_Main()
    call InitTrig_Chat()
    //Function not found: call InitTrig_Waypoint()
    //Function not found: call InitTrig_ItemStacker()
    //Function not found: call InitTrig_CritHandler()
    //Function not found: call InitTrig_Dungeon()
    //Function not found: call InitTrig_Custom_Drop_System()
    //Function not found: call InitTrig_UnitRespawn()
    //Function not found: call InitTrig_Bounty_System()
    call InitTrig_KeepTime()
    call InitTrig_Add_Bounty()
    call InitTrig_PlayerLeaveGame()
    call InitTrig_GUI_SpellEvent()
    call InitTrig_GUI_SpellEvent_Init()
    //Function not found: call InitTrig_Trigger_Refresh()
    //Function not found: call InitTrig_DDS()
    //Function not found: call InitTrig_Damage_Event_DDS_Plugin()
    //Function not found: call InitTrig_Damage_Event_Modification_DDS_Plugin()
    //Function not found: call InitTrig_Damage_Event_Archetype_DDS_Plugin()
    //Function not found: call InitTrig_LifeSaver()
    //Function not found: call InitTrig_Type()
    //Function not found: call InitTrig_ShadowTrail()
    call InitTrig_AddShadowTrailTest2()
    //Function not found: call InitTrig_GetUnitCollision()
    //Function not found: call InitTrig_AdvLoc()
    //Function not found: call InitTrig_AVL_Tree()
    //Function not found: call InitTrig_BinaryHeap()
    //Function not found: call InitTrig_Bonus()
    //Function not found: call InitTrig_BoundSentinel()
    //Function not found: call InitTrig_Catalog()
    //Function not found: call InitTrig_Color_Code_String()
    //Function not found: call InitTrig_CompressInt()
    //Function not found: call InitTrig_CTL()
    //Function not found: call InitTrig_DiracLinkedList()
    //Function not found: call InitTrig_GetClosestUnit()
    //Function not found: call InitTrig_GetItemOwner()
    //Function not found: call InitTrig_GetNameColored()
    //Function not found: call InitTrig_GetRequiredXP()
    //Function not found: call InitTrig_Group_Utils()
    //Function not found: call InitTrig_IsTerrainWalkable()
    //Function not found: call InitTrig_Loc()
    //Function not found: call InitTrig_Missile()
    //Function not found: call InitTrig_MissleRecycler()
    //Function not found: call InitTrig_PriorityEevent()
    //Function not found: call InitTrig_RegisterPlayerUnitEvent()
    //Function not found: call InitTrig_SimError()
    //Function not found: call InitTrig_Table()
    //Function not found: call InitTrig_Track()
    //Function not found: call InitTrig_TimedLightning()
    //Function not found: call InitTrig_T32()
    //Function not found: call InitTrig_TimerUtils()
    call InitTrig_Timed_AS()
    //Function not found: call InitTrig_UnitEvent()
    //Function not found: call InitTrig_Unit_Indexer_Copy()
    //Function not found: call InitTrig_xebasic()
    //Function not found: call InitTrig_Untitled_Trigger_003()
endfunction

//===========================================================================
function RunInitializationTriggers takes nothing returns nothing
    call ConditionalTriggerExecute(gg_trg_GlobalExpRate)
    call ConditionalTriggerExecute(gg_trg_Inity)
    call ConditionalTriggerExecute(gg_trg_init)
    call ConditionalTriggerExecute(gg_trg_GUI_SpellEvent_Init)
    call ConditionalTriggerExecute(gg_trg_Track)
endfunction

//***************************************************************************
//*
//*  Players
//*
//***************************************************************************

function InitCustomPlayerSlots takes nothing returns nothing

    // Player 0
    call SetPlayerStartLocation(Player(0), 0)
    call ForcePlayerStartLocation(Player(0), 0)
    call SetPlayerColor(Player(0), ConvertPlayerColor(0))
    call SetPlayerRacePreference(Player(0), RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(0), false)
    call SetPlayerController(Player(0), MAP_CONTROL_USER)

    // Player 1
    call SetPlayerStartLocation(Player(1), 1)
    call ForcePlayerStartLocation(Player(1), 1)
    call SetPlayerColor(Player(1), ConvertPlayerColor(1))
    call SetPlayerRacePreference(Player(1), RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(1), false)
    call SetPlayerController(Player(1), MAP_CONTROL_USER)

    // Player 2
    call SetPlayerStartLocation(Player(2), 2)
    call ForcePlayerStartLocation(Player(2), 2)
    call SetPlayerColor(Player(2), ConvertPlayerColor(2))
    call SetPlayerRacePreference(Player(2), RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(2), false)
    call SetPlayerController(Player(2), MAP_CONTROL_USER)

    // Player 3
    call SetPlayerStartLocation(Player(3), 3)
    call ForcePlayerStartLocation(Player(3), 3)
    call SetPlayerColor(Player(3), ConvertPlayerColor(3))
    call SetPlayerRacePreference(Player(3), RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(3), false)
    call SetPlayerController(Player(3), MAP_CONTROL_USER)

    // Player 4
    call SetPlayerStartLocation(Player(4), 4)
    call ForcePlayerStartLocation(Player(4), 4)
    call SetPlayerColor(Player(4), ConvertPlayerColor(4))
    call SetPlayerRacePreference(Player(4), RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(4), false)
    call SetPlayerController(Player(4), MAP_CONTROL_USER)

    // Player 5
    call SetPlayerStartLocation(Player(5), 5)
    call ForcePlayerStartLocation(Player(5), 5)
    call SetPlayerColor(Player(5), ConvertPlayerColor(5))
    call SetPlayerRacePreference(Player(5), RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(5), false)
    call SetPlayerController(Player(5), MAP_CONTROL_USER)

    // Player 6
    call SetPlayerStartLocation(Player(6), 6)
    call ForcePlayerStartLocation(Player(6), 6)
    call SetPlayerColor(Player(6), ConvertPlayerColor(6))
    call SetPlayerRacePreference(Player(6), RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(6), false)
    call SetPlayerController(Player(6), MAP_CONTROL_USER)

    // Player 7
    call SetPlayerStartLocation(Player(7), 7)
    call ForcePlayerStartLocation(Player(7), 7)
    call SetPlayerColor(Player(7), ConvertPlayerColor(7))
    call SetPlayerRacePreference(Player(7), RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(7), false)
    call SetPlayerController(Player(7), MAP_CONTROL_USER)

    // Player 8
    call SetPlayerStartLocation(Player(8), 8)
    call ForcePlayerStartLocation(Player(8), 8)
    call SetPlayerColor(Player(8), ConvertPlayerColor(8))
    call SetPlayerRacePreference(Player(8), RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(8), false)
    call SetPlayerController(Player(8), MAP_CONTROL_USER)

    // Player 9
    call SetPlayerStartLocation(Player(9), 9)
    call ForcePlayerStartLocation(Player(9), 9)
    call SetPlayerColor(Player(9), ConvertPlayerColor(9))
    call SetPlayerRacePreference(Player(9), RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(9), false)
    call SetPlayerController(Player(9), MAP_CONTROL_USER)

    // Player 10
    call SetPlayerStartLocation(Player(10), 10)
    call SetPlayerColor(Player(10), ConvertPlayerColor(10))
    call SetPlayerRacePreference(Player(10), RACE_PREF_HUMAN)
    call SetPlayerRaceSelectable(Player(10), false)
    call SetPlayerController(Player(10), MAP_CONTROL_COMPUTER)

    // Player 11
    call SetPlayerStartLocation(Player(11), 11)
    call SetPlayerColor(Player(11), ConvertPlayerColor(11))
    call SetPlayerRacePreference(Player(11), RACE_PREF_UNDEAD)
    call SetPlayerRaceSelectable(Player(11), false)
    call SetPlayerController(Player(11), MAP_CONTROL_COMPUTER)

endfunction

function InitCustomTeams takes nothing returns nothing
    // Force: TRIGSTR_1923
    call SetPlayerTeam(Player(0), 0)
    call SetPlayerState(Player(0), PLAYER_STATE_ALLIED_VICTORY, 1)
    call SetPlayerTeam(Player(1), 0)
    call SetPlayerState(Player(1), PLAYER_STATE_ALLIED_VICTORY, 1)
    call SetPlayerTeam(Player(2), 0)
    call SetPlayerState(Player(2), PLAYER_STATE_ALLIED_VICTORY, 1)
    call SetPlayerTeam(Player(3), 0)
    call SetPlayerState(Player(3), PLAYER_STATE_ALLIED_VICTORY, 1)
    call SetPlayerTeam(Player(4), 0)
    call SetPlayerState(Player(4), PLAYER_STATE_ALLIED_VICTORY, 1)
    call SetPlayerTeam(Player(5), 0)
    call SetPlayerState(Player(5), PLAYER_STATE_ALLIED_VICTORY, 1)
    call SetPlayerTeam(Player(6), 0)
    call SetPlayerState(Player(6), PLAYER_STATE_ALLIED_VICTORY, 1)
    call SetPlayerTeam(Player(7), 0)
    call SetPlayerState(Player(7), PLAYER_STATE_ALLIED_VICTORY, 1)
    call SetPlayerTeam(Player(8), 0)
    call SetPlayerState(Player(8), PLAYER_STATE_ALLIED_VICTORY, 1)
    call SetPlayerTeam(Player(9), 0)
    call SetPlayerState(Player(9), PLAYER_STATE_ALLIED_VICTORY, 1)

    //   Allied
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(3), true)
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(4), true)
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(5), true)
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(6), true)
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(7), true)
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(8), true)
    call SetPlayerAllianceStateAllyBJ(Player(0), Player(9), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(3), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(4), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(5), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(6), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(7), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(8), true)
    call SetPlayerAllianceStateAllyBJ(Player(1), Player(9), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(3), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(4), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(5), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(6), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(7), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(8), true)
    call SetPlayerAllianceStateAllyBJ(Player(2), Player(9), true)
    call SetPlayerAllianceStateAllyBJ(Player(3), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(3), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(3), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(3), Player(4), true)
    call SetPlayerAllianceStateAllyBJ(Player(3), Player(5), true)
    call SetPlayerAllianceStateAllyBJ(Player(3), Player(6), true)
    call SetPlayerAllianceStateAllyBJ(Player(3), Player(7), true)
    call SetPlayerAllianceStateAllyBJ(Player(3), Player(8), true)
    call SetPlayerAllianceStateAllyBJ(Player(3), Player(9), true)
    call SetPlayerAllianceStateAllyBJ(Player(4), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(4), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(4), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(4), Player(3), true)
    call SetPlayerAllianceStateAllyBJ(Player(4), Player(5), true)
    call SetPlayerAllianceStateAllyBJ(Player(4), Player(6), true)
    call SetPlayerAllianceStateAllyBJ(Player(4), Player(7), true)
    call SetPlayerAllianceStateAllyBJ(Player(4), Player(8), true)
    call SetPlayerAllianceStateAllyBJ(Player(4), Player(9), true)
    call SetPlayerAllianceStateAllyBJ(Player(5), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(5), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(5), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(5), Player(3), true)
    call SetPlayerAllianceStateAllyBJ(Player(5), Player(4), true)
    call SetPlayerAllianceStateAllyBJ(Player(5), Player(6), true)
    call SetPlayerAllianceStateAllyBJ(Player(5), Player(7), true)
    call SetPlayerAllianceStateAllyBJ(Player(5), Player(8), true)
    call SetPlayerAllianceStateAllyBJ(Player(5), Player(9), true)
    call SetPlayerAllianceStateAllyBJ(Player(6), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(6), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(6), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(6), Player(3), true)
    call SetPlayerAllianceStateAllyBJ(Player(6), Player(4), true)
    call SetPlayerAllianceStateAllyBJ(Player(6), Player(5), true)
    call SetPlayerAllianceStateAllyBJ(Player(6), Player(7), true)
    call SetPlayerAllianceStateAllyBJ(Player(6), Player(8), true)
    call SetPlayerAllianceStateAllyBJ(Player(6), Player(9), true)
    call SetPlayerAllianceStateAllyBJ(Player(7), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(7), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(7), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(7), Player(3), true)
    call SetPlayerAllianceStateAllyBJ(Player(7), Player(4), true)
    call SetPlayerAllianceStateAllyBJ(Player(7), Player(5), true)
    call SetPlayerAllianceStateAllyBJ(Player(7), Player(6), true)
    call SetPlayerAllianceStateAllyBJ(Player(7), Player(8), true)
    call SetPlayerAllianceStateAllyBJ(Player(7), Player(9), true)
    call SetPlayerAllianceStateAllyBJ(Player(8), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(8), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(8), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(8), Player(3), true)
    call SetPlayerAllianceStateAllyBJ(Player(8), Player(4), true)
    call SetPlayerAllianceStateAllyBJ(Player(8), Player(5), true)
    call SetPlayerAllianceStateAllyBJ(Player(8), Player(6), true)
    call SetPlayerAllianceStateAllyBJ(Player(8), Player(7), true)
    call SetPlayerAllianceStateAllyBJ(Player(8), Player(9), true)
    call SetPlayerAllianceStateAllyBJ(Player(9), Player(0), true)
    call SetPlayerAllianceStateAllyBJ(Player(9), Player(1), true)
    call SetPlayerAllianceStateAllyBJ(Player(9), Player(2), true)
    call SetPlayerAllianceStateAllyBJ(Player(9), Player(3), true)
    call SetPlayerAllianceStateAllyBJ(Player(9), Player(4), true)
    call SetPlayerAllianceStateAllyBJ(Player(9), Player(5), true)
    call SetPlayerAllianceStateAllyBJ(Player(9), Player(6), true)
    call SetPlayerAllianceStateAllyBJ(Player(9), Player(7), true)
    call SetPlayerAllianceStateAllyBJ(Player(9), Player(8), true)

    //   Shared Vision
    call SetPlayerAllianceStateVisionBJ(Player(0), Player(1), true)
    call SetPlayerAllianceStateVisionBJ(Player(0), Player(2), true)
    call SetPlayerAllianceStateVisionBJ(Player(0), Player(3), true)
    call SetPlayerAllianceStateVisionBJ(Player(0), Player(4), true)
    call SetPlayerAllianceStateVisionBJ(Player(0), Player(5), true)
    call SetPlayerAllianceStateVisionBJ(Player(0), Player(6), true)
    call SetPlayerAllianceStateVisionBJ(Player(0), Player(7), true)
    call SetPlayerAllianceStateVisionBJ(Player(0), Player(8), true)
    call SetPlayerAllianceStateVisionBJ(Player(0), Player(9), true)
    call SetPlayerAllianceStateVisionBJ(Player(1), Player(0), true)
    call SetPlayerAllianceStateVisionBJ(Player(1), Player(2), true)
    call SetPlayerAllianceStateVisionBJ(Player(1), Player(3), true)
    call SetPlayerAllianceStateVisionBJ(Player(1), Player(4), true)
    call SetPlayerAllianceStateVisionBJ(Player(1), Player(5), true)
    call SetPlayerAllianceStateVisionBJ(Player(1), Player(6), true)
    call SetPlayerAllianceStateVisionBJ(Player(1), Player(7), true)
    call SetPlayerAllianceStateVisionBJ(Player(1), Player(8), true)
    call SetPlayerAllianceStateVisionBJ(Player(1), Player(9), true)
    call SetPlayerAllianceStateVisionBJ(Player(2), Player(0), true)
    call SetPlayerAllianceStateVisionBJ(Player(2), Player(1), true)
    call SetPlayerAllianceStateVisionBJ(Player(2), Player(3), true)
    call SetPlayerAllianceStateVisionBJ(Player(2), Player(4), true)
    call SetPlayerAllianceStateVisionBJ(Player(2), Player(5), true)
    call SetPlayerAllianceStateVisionBJ(Player(2), Player(6), true)
    call SetPlayerAllianceStateVisionBJ(Player(2), Player(7), true)
    call SetPlayerAllianceStateVisionBJ(Player(2), Player(8), true)
    call SetPlayerAllianceStateVisionBJ(Player(2), Player(9), true)
    call SetPlayerAllianceStateVisionBJ(Player(3), Player(0), true)
    call SetPlayerAllianceStateVisionBJ(Player(3), Player(1), true)
    call SetPlayerAllianceStateVisionBJ(Player(3), Player(2), true)
    call SetPlayerAllianceStateVisionBJ(Player(3), Player(4), true)
    call SetPlayerAllianceStateVisionBJ(Player(3), Player(5), true)
    call SetPlayerAllianceStateVisionBJ(Player(3), Player(6), true)
    call SetPlayerAllianceStateVisionBJ(Player(3), Player(7), true)
    call SetPlayerAllianceStateVisionBJ(Player(3), Player(8), true)
    call SetPlayerAllianceStateVisionBJ(Player(3), Player(9), true)
    call SetPlayerAllianceStateVisionBJ(Player(4), Player(0), true)
    call SetPlayerAllianceStateVisionBJ(Player(4), Player(1), true)
    call SetPlayerAllianceStateVisionBJ(Player(4), Player(2), true)
    call SetPlayerAllianceStateVisionBJ(Player(4), Player(3), true)
    call SetPlayerAllianceStateVisionBJ(Player(4), Player(5), true)
    call SetPlayerAllianceStateVisionBJ(Player(4), Player(6), true)
    call SetPlayerAllianceStateVisionBJ(Player(4), Player(7), true)
    call SetPlayerAllianceStateVisionBJ(Player(4), Player(8), true)
    call SetPlayerAllianceStateVisionBJ(Player(4), Player(9), true)
    call SetPlayerAllianceStateVisionBJ(Player(5), Player(0), true)
    call SetPlayerAllianceStateVisionBJ(Player(5), Player(1), true)
    call SetPlayerAllianceStateVisionBJ(Player(5), Player(2), true)
    call SetPlayerAllianceStateVisionBJ(Player(5), Player(3), true)
    call SetPlayerAllianceStateVisionBJ(Player(5), Player(4), true)
    call SetPlayerAllianceStateVisionBJ(Player(5), Player(6), true)
    call SetPlayerAllianceStateVisionBJ(Player(5), Player(7), true)
    call SetPlayerAllianceStateVisionBJ(Player(5), Player(8), true)
    call SetPlayerAllianceStateVisionBJ(Player(5), Player(9), true)
    call SetPlayerAllianceStateVisionBJ(Player(6), Player(0), true)
    call SetPlayerAllianceStateVisionBJ(Player(6), Player(1), true)
    call SetPlayerAllianceStateVisionBJ(Player(6), Player(2), true)
    call SetPlayerAllianceStateVisionBJ(Player(6), Player(3), true)
    call SetPlayerAllianceStateVisionBJ(Player(6), Player(4), true)
    call SetPlayerAllianceStateVisionBJ(Player(6), Player(5), true)
    call SetPlayerAllianceStateVisionBJ(Player(6), Player(7), true)
    call SetPlayerAllianceStateVisionBJ(Player(6), Player(8), true)
    call SetPlayerAllianceStateVisionBJ(Player(6), Player(9), true)
    call SetPlayerAllianceStateVisionBJ(Player(7), Player(0), true)
    call SetPlayerAllianceStateVisionBJ(Player(7), Player(1), true)
    call SetPlayerAllianceStateVisionBJ(Player(7), Player(2), true)
    call SetPlayerAllianceStateVisionBJ(Player(7), Player(3), true)
    call SetPlayerAllianceStateVisionBJ(Player(7), Player(4), true)
    call SetPlayerAllianceStateVisionBJ(Player(7), Player(5), true)
    call SetPlayerAllianceStateVisionBJ(Player(7), Player(6), true)
    call SetPlayerAllianceStateVisionBJ(Player(7), Player(8), true)
    call SetPlayerAllianceStateVisionBJ(Player(7), Player(9), true)
    call SetPlayerAllianceStateVisionBJ(Player(8), Player(0), true)
    call SetPlayerAllianceStateVisionBJ(Player(8), Player(1), true)
    call SetPlayerAllianceStateVisionBJ(Player(8), Player(2), true)
    call SetPlayerAllianceStateVisionBJ(Player(8), Player(3), true)
    call SetPlayerAllianceStateVisionBJ(Player(8), Player(4), true)
    call SetPlayerAllianceStateVisionBJ(Player(8), Player(5), true)
    call SetPlayerAllianceStateVisionBJ(Player(8), Player(6), true)
    call SetPlayerAllianceStateVisionBJ(Player(8), Player(7), true)
    call SetPlayerAllianceStateVisionBJ(Player(8), Player(9), true)
    call SetPlayerAllianceStateVisionBJ(Player(9), Player(0), true)
    call SetPlayerAllianceStateVisionBJ(Player(9), Player(1), true)
    call SetPlayerAllianceStateVisionBJ(Player(9), Player(2), true)
    call SetPlayerAllianceStateVisionBJ(Player(9), Player(3), true)
    call SetPlayerAllianceStateVisionBJ(Player(9), Player(4), true)
    call SetPlayerAllianceStateVisionBJ(Player(9), Player(5), true)
    call SetPlayerAllianceStateVisionBJ(Player(9), Player(6), true)
    call SetPlayerAllianceStateVisionBJ(Player(9), Player(7), true)
    call SetPlayerAllianceStateVisionBJ(Player(9), Player(8), true)

    // Force: TRIGSTR_199
    call SetPlayerTeam(Player(10), 1)
    call SetPlayerState(Player(10), PLAYER_STATE_ALLIED_VICTORY, 1)

    // Force: TRIGSTR_020
    call SetPlayerTeam(Player(11), 2)
    call SetPlayerState(Player(11), PLAYER_STATE_ALLIED_VICTORY, 1)

endfunction

function InitAllyPriorities takes nothing returns nothing

    call SetStartLocPrioCount(10, 9)
    call SetStartLocPrio(10, 0, 0, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(10, 1, 2, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(10, 2, 3, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(10, 3, 4, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(10, 4, 5, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(10, 5, 6, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(10, 6, 7, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(10, 7, 8, MAP_LOC_PRIO_HIGH)
    call SetStartLocPrio(10, 8, 9, MAP_LOC_PRIO_HIGH)
endfunction

//***************************************************************************
//*
//*  Main Initialization
//*
//***************************************************************************

//===========================================================================
function main takes nothing returns nothing
    call SetCameraBounds(- 29440.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), - 29696.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 31232.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), 31232.0 - GetCameraMargin(CAMERA_MARGIN_TOP), - 29440.0 + GetCameraMargin(CAMERA_MARGIN_LEFT), 31232.0 - GetCameraMargin(CAMERA_MARGIN_TOP), 31232.0 - GetCameraMargin(CAMERA_MARGIN_RIGHT), - 29696.0 + GetCameraMargin(CAMERA_MARGIN_BOTTOM))
    call SetDayNightModels("Environment\\DNC\\DNCAshenvale\\DNCAshenvaleTerrain\\DNCAshenvaleTerrain.mdl", "Environment\\DNC\\DNCAshenvale\\DNCAshenvaleUnit\\DNCAshenvaleUnit.mdl")
    call NewSoundEnvironment("psychotic")
    call SetAmbientDaySound("AshenvaleDay")
    call SetAmbientNightSound("AshenvaleNight")
    call SetMapMusic("Music", true, 0)
    call CreateRegions()
    call CreateAllDestructables()
    call CreateAllUnits()
    call InitBlizzard()

call ExecuteFunc("jasshelper__initstructs5190200")
call ExecuteFunc("AdvancedQuest__init")
call ExecuteFunc("BaseFunction__onInit")
call ExecuteFunc("BoundSentinel___init")
call ExecuteFunc("BountySystem___init")
call ExecuteFunc("CustomDrop___init")
call ExecuteFunc("Dungeon___init")
call ExecuteFunc("GetPlayerColored___init")
call ExecuteFunc("HeroImage__onInit")
call ExecuteFunc("ItemStacker___itemOnInit")
call ExecuteFunc("SimError___init")
call ExecuteFunc("T32___OnInit")
call ExecuteFunc("TTDemo__init")
call ExecuteFunc("TerrainPathability___Init")
call ExecuteFunc("TimerUtils___init")
call ExecuteFunc("Waypoint__Init")
call ExecuteFunc("crit___Init")
call ExecuteFunc("dsf___onInit")
call ExecuteFunc("test__init")
call ExecuteFunc("FighterFirstSpells__onInit")
call ExecuteFunc("StatBoard__onInit")
call ExecuteFunc("MissileRecycler___Init")
call ExecuteFunc("Quest__init")
call ExecuteFunc("StatHandler__onInit")
call ExecuteFunc("noleavegotum__init")
call ExecuteFunc("ShowInventory__onInittT")
call ExecuteFunc("WitchFirstSpells__onInit")
call ExecuteFunc("WizardFireSpells__onInit")
call ExecuteFunc("WizardForceSpells__onInit")
call NoAutocast__init()

    call InitGlobals()
    call InitCustomTriggers()
    call RunInitializationTriggers()

endfunction

//***************************************************************************
//*
//*  Map Configuration
//*
//***************************************************************************

function config takes nothing returns nothing
    call SetMapName("TRIGSTR_001")
    call SetMapDescription("TRIGSTR_003")
    call SetPlayers(12)
    call SetTeams(12)
    call SetGamePlacement(MAP_PLACEMENT_TEAMS_TOGETHER)

    call DefineStartLocation(0, - 2048.0, 12800.0)
    call DefineStartLocation(1, - 6080.0, 20608.0)
    call DefineStartLocation(2, - 22080.0, - 24384.0)
    call DefineStartLocation(3, 8832.0, 1920.0)
    call DefineStartLocation(4, - 1600.0, - 7808.0)
    call DefineStartLocation(5, 5312.0, - 12992.0)
    call DefineStartLocation(6, 11520.0, - 14528.0)
    call DefineStartLocation(7, 3136.0, - 11136.0)
    call DefineStartLocation(8, 6016.0, 25280.0)
    call DefineStartLocation(9, 3328.0, - 22016.0)
    call DefineStartLocation(10, 18880.0, 13120.0)
    call DefineStartLocation(11, 5824.0, 23040.0)

    // Player setup
    call InitCustomPlayerSlots()
    call InitCustomTeams()
    call InitAllyPriorities()
endfunction




//Struct method generated initializers/callers:

//Functions for BigArrays:
function sa__Quest_refreshDescription takes nothing returns boolean
local integer this=f__arg_this
            local integer i= 0
            local string progresses= " "
            local string s
            loop
                if (LoadStr(Table___ht, (((s__Quest_progressHashes[this]))), (i))) != null then // INLINED!!
                    if (LoadBoolean(Table___ht, (((sc__TableArray__getindex(s__Quest_progress[this],2)))), (StringHash((LoadStr(Table___ht, (((s__Quest_progressHashes[this]))), (i))))))) then // INLINED!!
                        set s=AdvancedQuest__finishedcolor + AdvancedQuest__perProgressPrefix + (LoadStr(Table___ht, (((s__Quest_progressHashes[this]))), (i))) + AdvancedQuest__perProgressSuffix + I2S((LoadInteger(Table___ht, (sc__TableArray__getindex(s__Quest_progress[this],0)), (StringHash((LoadStr(Table___ht, (((s__Quest_progressHashes[this]))), (i)))))))) + AdvancedQuest__intseperator + I2S((LoadInteger(Table___ht, (sc__TableArray__getindex(s__Quest_progress[this],1)), (StringHash((LoadStr(Table___ht, (((s__Quest_progressHashes[this]))), (i)))))))) + " (Finished) |r" // INLINED!!
                    else
                        set s=AdvancedQuest__perProgressPrefix + (LoadStr(Table___ht, (((s__Quest_progressHashes[this]))), (i))) + AdvancedQuest__perProgressSuffix + I2S((LoadInteger(Table___ht, (sc__TableArray__getindex(s__Quest_progress[this],0)), (StringHash((LoadStr(Table___ht, (((s__Quest_progressHashes[this]))), (i)))))))) + AdvancedQuest__intseperator + I2S((LoadInteger(Table___ht, (sc__TableArray__getindex(s__Quest_progress[this],1)), (StringHash((LoadStr(Table___ht, (((s__Quest_progressHashes[this]))), (i)))))))) // INLINED!!
                    endif
                    set progresses=progresses + AdvancedQuest__newline + s
                else
                    exitwhen true
                endif
                set i=i + 1
            endloop
            if progresses == " " then
                set progresses="None"
            endif
            call QuestSetDescription(s__Quest_q[this], AdvancedQuest__titleString + s__Quest_title[this] + AdvancedQuest__newline2x + AdvancedQuest__descriptionPrefix + s__Quest_description[this] + AdvancedQuest__newline2x + AdvancedQuest__progressPrefix + progresses + AdvancedQuest__newline2x + AdvancedQuest__rewardPrefix + s__Quest_reward[this])
set f__result_integer= this
   return true
endfunction
function sa__Button_create takes nothing returns boolean
local integer x=f__arg_integer1
local integer y=f__arg_integer2
local integer heroIndex=f__arg_integer3
local integer buttonId=f__arg_integer4
local integer disabledButtonId=f__arg_integer5
local integer maxLevel=f__arg_integer6
local integer initPointReq=f__arg_integer7
local integer pointReq=f__arg_integer8
local string descName=f__arg_string1
local string descDescription=f__arg_string2
            local integer this= s__Button__allocate()
            set s__Button_x[this]=x
            set s__Button_y[this]=y
            set s__Button_heroIndex[this]=heroIndex
            set s__Button_buttonId[this]=buttonId
            set s__Button_disabledButtonId[this]=disabledButtonId
            set s__Button_maxLevel[this]=maxLevel
            set s__Button_initPointReq[this]=initPointReq
            set s__Button_pointReq[this]=pointReq
            set s__Button_descName[this]=descName
            set s__Button_descDescription[this]=descDescription
            set s__Button_currentLink[this]=- 1
            set s__Button_is[this]=false
set f__result_integer= this
   return true
endfunction
function sa__Button_addData takes nothing returns boolean
local integer this=f__arg_this
local integer data=f__arg_integer1
            set s__Button_data[this]=data
   return true
endfunction
function sa__Button_isMenu takes nothing returns boolean
local integer this=f__arg_this
local boolean is=f__arg_boolean1
            set s__Button_is[this]=is
   return true
endfunction
function sa__Button_createLink takes nothing returns boolean
local integer this=f__arg_this
local integer x=f__arg_integer1
local integer y=f__arg_integer2
local integer level=f__arg_integer3
            set s__Button_currentLink[this]=s__Button_currentLink[this] + 1
            set s___Button_linkx[s__Button_linkx[this]+s__Button_currentLink[this]]=x
            set s___Button_linky[s__Button_linky[this]+s__Button_currentLink[this]]=y
            set s___Button_linkLevel[s__Button_linkLevel[this]+s__Button_currentLink[this]]=level
   return true
endfunction
function sa__Button_push takes nothing returns boolean
local integer this=f__arg_this
            local integer i= s__Button_currentLink[this]
            call s__VJassTalentTree_addButton(s__Button_heroIndex[this] , s__Button_buttonId[this] , s__Button_x[this] , s__Button_y[this])
            call s__VJassTalentTree_addMaxLevel(s__Button_heroIndex[this] , s__Button_maxLevel[this] , s__Button_x[this] , s__Button_y[this])
            call s__VJassTalentTree_addInitPointReq(s__Button_heroIndex[this] , s__Button_initPointReq[this] , s__Button_x[this] , s__Button_y[this])
            call s__VJassTalentTree_addPointReq(s__Button_heroIndex[this] , s__Button_pointReq[this] , s__Button_x[this] , s__Button_y[this])
            call s__VJassTalentTree_addDisabledButton(s__Button_heroIndex[this] , s__Button_disabledButtonId[this] , s__Button_x[this] , s__Button_y[this])
            call s__VJassTalentTree_addMultiName(s__Button_heroIndex[this] , s__Button_descName[this] , s__Button_x[this] , s__Button_y[this])
            call s__VJassTalentTree_addMultiDescription(s__Button_heroIndex[this] , s__Button_descDescription[this] , s__Button_x[this] , s__Button_y[this])
            call s__VJassTalentTree_attachData(s__Button_heroIndex[this] , s__Button_x[this] , s__Button_y[this] , s__Button_data[this])
            call s__VJassTalentTree_setAsMenu(s__Button_heroIndex[this] , s__Button_is[this] , s__Button_x[this] , s__Button_y[this])
            if i > - 1 then
                loop
                    call s__VJassTalentTree_addLink(s__Button_heroIndex[this] , s__Button_x[this] , s__Button_y[this] , s___Button_linkx[s__Button_linkx[this]+i] , s___Button_linky[s__Button_linky[this]+i] , s___Button_linkLevel[s__Button_linkLevel[this]+i] , 0 , true)
                    set i=i - 1
                    exitwhen i == - 1
                endloop
            endif
   return true
endfunction
function sa__Button_reCreate takes nothing returns boolean
local integer this=f__arg_this
local integer x=f__arg_integer1
local integer y=f__arg_integer2
local integer heroIndex=f__arg_integer3
local integer buttonId=f__arg_integer4
local integer disabledButtonId=f__arg_integer5
local integer maxLevel=f__arg_integer6
local integer initPointReq=f__arg_integer7
local integer pointReq=f__arg_integer8
local string descName=f__arg_string1
local string descDescription=f__arg_string2
            set s__Button_x[this]=x
            set s__Button_y[this]=y
            set s__Button_heroIndex[this]=heroIndex
            set s__Button_buttonId[this]=buttonId
            set s__Button_disabledButtonId[this]=disabledButtonId
            set s__Button_maxLevel[this]=maxLevel
            set s__Button_initPointReq[this]=initPointReq
            set s__Button_pointReq[this]=pointReq
            set s__Button_descName[this]=descName
            set s__Button_descDescription[this]=descDescription
            set s__Button_data[this]=- 1
            set s__Button_is[this]=false
            if s__Button_currentLink[this] > - 1 then
                loop
                    set s___Button_linkx[s__Button_linkx[this]+s__Button_currentLink[this]]=- 1
                    set s___Button_linky[s__Button_linky[this]+s__Button_currentLink[this]]=- 1
                    set s___Button_linkLevel[s__Button_linkLevel[this]+s__Button_currentLink[this]]=- 1
                    set s__Button_currentLink[this]=s__Button_currentLink[this] - 1
                    exitwhen s__Button_currentLink[this] == - 1
                endloop
            endif
   return true
endfunction
function sa__Heroes__get_raw takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= CatalogRaw(s__Heroes_catalog , this)
   return true
endfunction
function sa__Heroes__get_count takes nothing returns boolean

set f__result_integer= CatalogCount(s__Heroes_catalog)
   return true
endfunction
function sa__Heroes__get_id takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= CatalogId(s__Heroes_catalog , this)
   return true
endfunction
function sa__ItemRoots_get takes nothing returns boolean
    set f__result_integer=s__ItemRoots_get(f__arg_unit1,f__arg_integer1)
   return true
endfunction
function sa__PhoenixBarrage_launch takes nothing returns boolean
local integer this=f__arg_integer1
            call Missile___StartPeriodic(si__PhoenixBarrage)
            call s__Missile_insertNode(Missile___NODE[si__PhoenixBarrage],this)
   return true
endfunction
function sa__FlameConjuration_T32Interface___expire takes nothing returns boolean

            local integer i= 0
            local integer array recycle
            local integer recycleCount= 0
            local integer temp
            local boolean running= false
            loop
                exitwhen s__FlameConjuration_T32Interface___list[i] == 0
                if not s__FlameConjuration_onLoop(s__FlameConjuration_T32Interface___list[i]) then
                   set recycle[recycleCount]=s__FlameConjuration_T32Interface___list[i]
                   set recycleCount=recycleCount + 1
                   call s__FlameConjuration_onExpire(s__FlameConjuration_T32Interface___list[i])
                else
                    set running=true
                endif
                set i=i + 1
            endloop
            if recycleCount != 0 then
                set i=0
                loop
                    exitwhen recycle[i] == 0
                    set temp=recycle[i]
                    set s__FlameConjuration_recyclePosition[s__FlameConjuration_T32Interface___list[s__FlameConjuration_T32Interface___count]]=s__FlameConjuration_recyclePosition[temp]
                    set s__FlameConjuration_T32Interface___list[s__FlameConjuration_recyclePosition[temp]]=s__FlameConjuration_T32Interface___list[s__FlameConjuration_T32Interface___count]
                    set s__FlameConjuration_T32Interface___list[s__FlameConjuration_T32Interface___count]=0
                    set s__FlameConjuration_T32Interface___count=s__FlameConjuration_T32Interface___count - 1
                    set i=i + 1
                endloop
            endif
            if not running then
                call CTL___SR32((s__FlameConjuration_T32Interface___timers)) // INLINED!!
            endif
   return true
endfunction
function sa__Pressure_T32Interface___expire takes nothing returns boolean

            local integer i= 0
            local integer array recycle
            local integer recycleCount= 0
            local integer temp
            local boolean running= false
            loop
                exitwhen s__Pressure_T32Interface___list[i] == 0
                if not s__Pressure_onLoop(s__Pressure_T32Interface___list[i]) then
                   set recycle[recycleCount]=s__Pressure_T32Interface___list[i]
                   set recycleCount=recycleCount + 1
                   call s__Pressure_onExpire(s__Pressure_T32Interface___list[i])
                else
                    set running=true
                endif
                set i=i + 1
            endloop
            if recycleCount != 0 then
                set i=0
                loop
                    exitwhen recycle[i] == 0
                    set temp=recycle[i]
                    set s__Pressure_recyclePosition[s__Pressure_T32Interface___list[s__Pressure_T32Interface___count]]=s__Pressure_recyclePosition[temp]
                    set s__Pressure_T32Interface___list[s__Pressure_recyclePosition[temp]]=s__Pressure_T32Interface___list[s__Pressure_T32Interface___count]
                    set s__Pressure_T32Interface___list[s__Pressure_T32Interface___count]=0
                    set s__Pressure_T32Interface___count=s__Pressure_T32Interface___count - 1
                    set i=i + 1
                endloop
            endif
            if not running then
                call CTL___SR32((s__Pressure_T32Interface___timers)) // INLINED!!
            endif
   return true
endfunction
function sa__FlameWave_T32Interface___expire takes nothing returns boolean

            local integer i= 0
            local integer array recycle
            local integer recycleCount= 0
            local integer temp
            local boolean running= false
            loop
                exitwhen s__FlameWave_T32Interface___list[i] == 0
                if not s__FlameWave_onLoop(s__FlameWave_T32Interface___list[i]) then
                   set recycle[recycleCount]=s__FlameWave_T32Interface___list[i]
                   set recycleCount=recycleCount + 1
                   call s__FlameWave_onExpire(s__FlameWave_T32Interface___list[i])
                else
                    set running=true
                endif
                set i=i + 1
            endloop
            if recycleCount != 0 then
                set i=0
                loop
                    exitwhen recycle[i] == 0
                    set temp=recycle[i]
                    set s__FlameWave_recyclePosition[s__FlameWave_T32Interface___list[s__FlameWave_T32Interface___count]]=s__FlameWave_recyclePosition[temp]
                    set s__FlameWave_T32Interface___list[s__FlameWave_recyclePosition[temp]]=s__FlameWave_T32Interface___list[s__FlameWave_T32Interface___count]
                    set s__FlameWave_T32Interface___list[s__FlameWave_T32Interface___count]=0
                    set s__FlameWave_T32Interface___count=s__FlameWave_T32Interface___count - 1
                    set i=i + 1
                endloop
            endif
            if not running then
                call CTL___SR32((s__FlameWave_T32Interface___timers)) // INLINED!!
            endif
   return true
endfunction
function sa__BurningSoul_T32Interface___expire takes nothing returns boolean

            local integer i= 0
            local integer array recycle
            local integer recycleCount= 0
            local integer temp
            local boolean running= false
            loop
                exitwhen s__BurningSoul_T32Interface___list[i] == 0
                if not sc__BurningSoul_onLoop(s__BurningSoul_T32Interface___list[i]) then
                   set recycle[recycleCount]=s__BurningSoul_T32Interface___list[i]
                   set recycleCount=recycleCount + 1
                   call sc__BurningSoul_onExpire(s__BurningSoul_T32Interface___list[i])
                else
                    set running=true
                endif
                set i=i + 1
            endloop
            if recycleCount != 0 then
                set i=0
                loop
                    exitwhen recycle[i] == 0
                    set temp=recycle[i]
                    set s__BurningSoul_recyclePosition[s__BurningSoul_T32Interface___list[s__BurningSoul_T32Interface___count]]=s__BurningSoul_recyclePosition[temp]
                    set s__BurningSoul_T32Interface___list[s__BurningSoul_recyclePosition[temp]]=s__BurningSoul_T32Interface___list[s__BurningSoul_T32Interface___count]
                    set s__BurningSoul_T32Interface___list[s__BurningSoul_T32Interface___count]=0
                    set s__BurningSoul_T32Interface___count=s__BurningSoul_T32Interface___count - 1
                    set i=i + 1
                endloop
            endif
            if not running then
                call CTL___SR32((s__BurningSoul_T32Interface___timers)) // INLINED!!
            endif
   return true
endfunction
function sa__BurningSoul_onLoop takes nothing returns boolean
local integer this=f__arg_this
            set s__BurningSoul_ticksRemaining[this]=s__BurningSoul_ticksRemaining[this] - 1
            if s__BurningSoul_ticksRemaining[this] <= 0 then
set f__result_boolean= false
return true
            endif
            call dotDamage(s__BurningSoul_caster[this] , s__BurningSoul_target[this] , s__BurningSoul_damagePer32[this])
set f__result_boolean= true
   return true
endfunction
function sa__BurningSoul_onExpire takes nothing returns boolean
local integer this=f__arg_this
            call SaveInteger(Table___ht, (s__BurningSoul_perHeroInstances), (GetHandleId(s__BurningSoul_target[this])), ( 0)) // INLINED!!
            call UnitRemoveAbility(s__BurningSoul_target[this], WizardFireSpells__BS_FX)
            set s__BurningSoul_caster[this]=null
            set s__BurningSoul_target[this]=null
            call s__BurningSoul_deallocate(this)
   return true
endfunction
function sa__BurningSoul_create takes nothing returns boolean
    set f__result_integer=s__BurningSoul_create(f__arg_unit1,f__arg_unit2)
   return true
endfunction
function sa__WitchFirstSpells__BathMain_expire takes nothing returns boolean

            local integer i= 0
            local integer array recycle
            local integer recycleCount= 0
            local integer temp
            local boolean running= false
            loop
                exitwhen s__WitchFirstSpells__BathMain_list[i] == 0
                if not sc__WitchFirstSpells__BathMain_onLoop(s__WitchFirstSpells__BathMain_list[i]) then
                   set recycle[recycleCount]=s__WitchFirstSpells__BathMain_list[i]
                   set recycleCount=recycleCount + 1
                else
                    set running=true
                endif
                set i=i + 1
            endloop
            if recycleCount != 0 then
                set i=0
                loop
                    exitwhen recycle[i] == 0
                    set temp=recycle[i]
                    set s__WitchFirstSpells__BathMain_recyclePosition[s__WitchFirstSpells__BathMain_list[s__WitchFirstSpells__BathMain_count]]=s__WitchFirstSpells__BathMain_recyclePosition[temp]
                    set s__WitchFirstSpells__BathMain_list[s__WitchFirstSpells__BathMain_recyclePosition[temp]]=s__WitchFirstSpells__BathMain_list[s__WitchFirstSpells__BathMain_count]
                    set s__WitchFirstSpells__BathMain_list[s__WitchFirstSpells__BathMain_count]=0
                    call s__WitchFirstSpells__BathMain_deallocate(temp)
                    set s__WitchFirstSpells__BathMain_count=s__WitchFirstSpells__BathMain_count - 1
                    set i=i + 1
                endloop
            endif
            if not running then
                call CTL___SR32((s__WitchFirstSpells__BathMain_timers)) // INLINED!!
            endif
   return true
endfunction
function sa__WitchFirstSpells__BathMain_onLoop takes nothing returns boolean
local integer this=f__arg_this
            local real angle
            local real distance
            local integer i= 0
            local group toHit= CreateGroup()
            local unit hit
            local integer check
            if (TimerGetElapsed(gameTimer)) - s__WitchFirstSpells__BathMain_timeOnStart[this] >= WitchFirstSpells__BA_DURATION then // INLINED!!
set f__result_boolean= false
return true
            endif
            call GroupEnumUnitsInRange(toHit, s__WitchFirstSpells__BathMain_castx[this], s__WitchFirstSpells__BathMain_casty[this], WitchFirstSpells__BA_RADIUS, getTargetFilter(GetOwningPlayer(s__WitchFirstSpells__BathMain_caster[this])))
            loop
                set hit=FirstOfGroup(toHit)
                exitwhen hit == null
                call pureDamage(s__WitchFirstSpells__BathMain_caster[this] , hit , s__WitchFirstSpells__BathMain_damagePer32[this])
                call GroupRemoveUnit(toHit, hit)
            endloop
            loop
                exitwhen i == WitchFirstSpells__BA_BLOOD_PER_32
                set angle=(GetRandomReal(- bj_PI, bj_PI)) // INLINED!!
                set distance=GetRandomReal(0, WitchFirstSpells__BA_RADIUS)
                set check=GetRandomInt(1, 5)
                if check == 1 then
                    call DestroyEffect(AddSpecialEffect(WitchFirstSpells__BA_EFFECT2, s__WitchFirstSpells__BathMain_castx[this] + Cos(angle) * distance, s__WitchFirstSpells__BathMain_casty[this] + Sin(angle) * distance))
                elseif check == 2 then
                    call DestroyEffect(AddSpecialEffect(WitchFirstSpells__BA_EFFECT2, s__WitchFirstSpells__BathMain_castx[this] + Cos(angle) * distance, s__WitchFirstSpells__BathMain_casty[this] + Sin(angle) * distance))
                elseif check == 3 then
                    call DestroyEffect(AddSpecialEffect(WitchFirstSpells__BA_EFFECT3, s__WitchFirstSpells__BathMain_castx[this] + Cos(angle) * distance, s__WitchFirstSpells__BathMain_casty[this] + Sin(angle) * distance))
                elseif check == 4 then
                    call DestroyEffect(AddSpecialEffect(WitchFirstSpells__BA_EFFECT4, s__WitchFirstSpells__BathMain_castx[this] + Cos(angle) * distance, s__WitchFirstSpells__BathMain_casty[this] + Sin(angle) * distance))
                elseif check == 5 then
                    call DestroyEffect(AddSpecialEffect(WitchFirstSpells__BA_EFFECT5, s__WitchFirstSpells__BathMain_castx[this] + Cos(angle) * distance, s__WitchFirstSpells__BathMain_casty[this] + Sin(angle) * distance))
                endif
                set i=i + 1
            endloop
            call DestroyGroup(toHit)
            set toHit=null
            set hit=null
set f__result_boolean= true
   return true
endfunction
function sa__WitchFirstSpells__ChampTimer_T32Interface___expire takes nothing returns boolean

            local integer i= 0
            local integer array recycle
            local integer recycleCount= 0
            local integer temp
            local boolean running= false
            loop
                exitwhen s__WitchFirstSpells__ChampTimer_T32Interface___list[i] == 0
                if not sc__WitchFirstSpells__ChampTimer_onLoop(s__WitchFirstSpells__ChampTimer_T32Interface___list[i]) then
                   set recycle[recycleCount]=s__WitchFirstSpells__ChampTimer_T32Interface___list[i]
                   set recycleCount=recycleCount + 1
                   call sc__WitchFirstSpells__ChampTimer_onExpire(s__WitchFirstSpells__ChampTimer_T32Interface___list[i])
                else
                    set running=true
                endif
                set i=i + 1
            endloop
            if recycleCount != 0 then
                set i=0
                loop
                    exitwhen recycle[i] == 0
                    set temp=recycle[i]
                    set s__WitchFirstSpells__ChampTimer_recyclePosition[s__WitchFirstSpells__ChampTimer_T32Interface___list[s__WitchFirstSpells__ChampTimer_T32Interface___count]]=s__WitchFirstSpells__ChampTimer_recyclePosition[temp]
                    set s__WitchFirstSpells__ChampTimer_T32Interface___list[s__WitchFirstSpells__ChampTimer_recyclePosition[temp]]=s__WitchFirstSpells__ChampTimer_T32Interface___list[s__WitchFirstSpells__ChampTimer_T32Interface___count]
                    set s__WitchFirstSpells__ChampTimer_T32Interface___list[s__WitchFirstSpells__ChampTimer_T32Interface___count]=0
                    set s__WitchFirstSpells__ChampTimer_T32Interface___count=s__WitchFirstSpells__ChampTimer_T32Interface___count - 1
                    set i=i + 1
                endloop
            endif
            if not running then
                call CTL___SR32((s__WitchFirstSpells__ChampTimer_T32Interface___timers)) // INLINED!!
            endif
   return true
endfunction
function sa__WitchFirstSpells__ChampTimer_onLoop takes nothing returns boolean
local integer this=f__arg_this
            local group g
            local unit u
            if s__WitchFirstSpells__ChampTimer_startTime[this] < (TimerGetElapsed(gameTimer)) - s__WitchFirstSpells__ChampTimer_duration then // INLINED!!
set f__result_boolean= false
return true
            endif
            if GetUnitCurrentOrder(s__WitchFirstSpells__ChampTimer_toHide[this]) != OrderId("attack") then
                set g=CreateGroup()
                set filterHost=s__WitchFirstSpells__ChampTimer_toHide[this]
                call GroupEnumUnitsInRange(g, GetUnitX(s__WitchFirstSpells__ChampTimer_toHide[this]), GetUnitY(s__WitchFirstSpells__ChampTimer_toHide[this]), 350, getTargetFilter(GetOwningPlayer(s__WitchFirstSpells__ChampTimer_toShow[this])))
                set u=FirstOfGroup(g)
                if u != null then
                    call IssueTargetOrderById(s__WitchFirstSpells__ChampTimer_toHide[this], 851983, u)
                endif
                set u=null
                call DestroyGroup(g)
                set g=null
            endif
set f__result_boolean= true
   return true
endfunction
function sa__WitchFirstSpells__ChampTimer_onExpire takes nothing returns boolean
local integer this=f__arg_this
            call RemoveUnit(s__WitchFirstSpells__ChampTimer_toHide[this])
            set s__WitchFirstSpells__ChampTimer_toHide[this]=null
            set s__WitchFirstSpells__ChampTimer_toShow[this]=null
            call s__WitchFirstSpells__ChampTimer_deallocate(this)
   return true
endfunction
function sa__VJassTalentTree_hideUI takes nothing returns boolean
local player p=f__arg_player1
            local integer heroIndex= fuuulibrary__currentHeroIndex[GetPlayerId(p)]
            local integer forLoop= ( fuuulibrary__WIDTH * 8 ) + 1
            local integer linkLoop= 0
            local integer start
            local integer end
            local integer i
            call SetCameraBoundsToRect(bj_mapInitialPlayableArea)
            set fuuulibrary__currentHeroIndex[GetPlayerId(p)]=- 1
            loop
                set forLoop=forLoop - 1
                exitwhen forLoop == - 1
                if (LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (((1 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))))) >= 5 then // INLINED!!
                    set i=0
                    if i <= 5 or GetLocalPlayer() == p then
                        set i=fuuulibrary__invisible
                    endif
                    if fuuulibrary__buttons[forLoop] != null and fuuulibrary__X[forLoop] != 0 then
                        call RemoveDestructable(fuuulibrary__buttons[forLoop])
                        set fuuulibrary__buttons[forLoop]=CreateDestructable(i, fuuulibrary__X[forLoop], fuuulibrary__Y[forLoop], 0, 1, 0)
                        call ShowDestructable(fuuulibrary__buttons[forLoop], true)
                        loop
                            if (LoadLightningHandle(Table___ht, (((fuuulibrary__staticTree))), (forLoop + 10000 * linkLoop))) != null then // INLINED!!
                                call DestroyLightning((LoadLightningHandle(Table___ht, (((fuuulibrary__staticTree))), (forLoop + 10000 * linkLoop)))) // INLINED!!
                            else
                                exitwhen true
                            endif
                            set linkLoop=linkLoop + 1
                        endloop
                    else
                        call BJDebugMsg("TALENT TREE ERROR : INVALID INDEX")
                    endif
                    set linkLoop=0
                endif
            endloop
            set VJTT_heroIndex=heroIndex
            set VJTT_interactingPlayer=p
            call TriggerEvaluate(VJTT_onHideModule)
   return true
endfunction
function sa__VJassTalentTree_showUI takes nothing returns boolean
local player p=f__arg_player1
local integer heroIndex=f__arg_integer1
            local integer forLoop= fuuulibrary__WIDTH * 15
            local integer linkLoop= 0
            local integer i
            local integer i2
            local integer i3
            local integer i4= 0
            if fuuulibrary__currentHeroIndex[GetPlayerId(p)] != - 1 then
                call s__VJassTalentTree_hideUI(p) //if its shown when it already shown, it just refreshes it.
            endif
            set fuuulibrary__currentHeroIndex[GetPlayerId(p)]=heroIndex
            call s__VJassTalentTree_cameraPan(p)
            loop
                set forLoop=forLoop - 1
                exitwhen forLoop == - 1
                if (LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (((1 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))))) >= 5 then // INLINED!!
                    loop
                        if (LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (((8 ) + ( ( heroIndex) * ( fuuulibrary__NUM_OF_DATA + 1 ) ))))) > 0 then // INLINED!!
                            call s__VJassTalentTree_lightningCreate(p , forLoop , (LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (( 8 + linkLoop * 2 ) + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )))) - 1) // INLINED!!
                            set i2=(LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (( 8 + linkLoop * 2 ) + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )))) - 1 // INLINED!!
                            set i2=(LoadInteger(Table___ht, (((fuuulibrary__tree) + (i2))), (( 22 + GetPlayerId(p) ) + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )))) // INLINED!!
                            set i3=(LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (( 9 + linkLoop * 2 ) + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )))) // INLINED!!
                            if i2 < i3 then
                                set i4=i4 + 1
                            endif
                        else
                            exitwhen true
                        endif
                        set linkLoop=linkLoop + 1
                    endloop
                    if i4 < linkLoop then
                        set i=(LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (1 + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )))) // INLINED!!
                    else
                        set i=(LoadInteger(Table___ht, (((fuuulibrary__tree) + (forLoop))), (5 + ( heroIndex * ( fuuulibrary__NUM_OF_DATA + 1 ) )))) // INLINED!!
                    endif
                    set i4=0
                    set linkLoop=0
                    if GetLocalPlayer() != p then
                        set i=GetDestructableTypeId(fuuulibrary__buttons[forLoop])
                    endif
                    if i < 5 then
                        set i=fuuulibrary__invisible
                    endif
                    call RemoveDestructable(fuuulibrary__buttons[forLoop])
                    set fuuulibrary__buttons[forLoop]=CreateDestructable(i, fuuulibrary__X[forLoop], fuuulibrary__Y[forLoop], 0, 1, 0)
                    call BJDebugMsg("i : " + I2S(i) + ", forLoop : " + I2S(forLoop) + ", X[] : " + R2S(fuuulibrary__X[forLoop]) + ", Y[] : " + R2S(fuuulibrary__Y[forLoop]) + "\n         NAME: " + GetDestructableName(fuuulibrary__buttons[forLoop]) + ", BO1O : " + I2S('B010'))
                    call ShowDestructable(fuuulibrary__buttons[forLoop], true)
                endif
            endloop
            set VJTT_heroIndex=heroIndex
            set VJTT_interactingPlayer=p
            call TriggerEvaluate(VJTT_onShowModule)
   return true
endfunction
function sa__StatHandler_addUnitBonus takes nothing returns boolean
    call s__StatHandler_addUnitBonus(f__arg_unit1,f__arg_integer1)
   return true
endfunction
function sa__StatHandler_r_compile takes nothing returns boolean
    call s__StatHandler_r_compile(f__arg_unit1,f__arg_integer1)
   return true
endfunction
function sa__StatHandler_removeUnitBonus takes nothing returns boolean
    call s__StatHandler_removeUnitBonus(f__arg_unit1,f__arg_integer1)
   return true
endfunction
function sa__StatHandler_getUnitBonus takes nothing returns boolean
    set f__result_real=s__StatHandler_getUnitBonus(f__arg_unit1,f__arg_integer1)
   return true
endfunction
function sa__StatHandler_getUnitResistance takes nothing returns boolean
    set f__result_real=s__StatHandler_getUnitResistance(f__arg_unit1,f__arg_integer1)
   return true
endfunction
function sa__Listener_interactCondition takes nothing returns boolean

set f__result_boolean= RAbsBJ(GetUnitX(GetTriggerUnit()) - GetWidgetX(GetOrderTarget())) < 250 and RAbsBJ(GetUnitY(GetTriggerUnit()) - GetWidgetY(GetOrderTarget())) < 250
   return true
endfunction
function sa__CustomInventory_setOnRecipe takes nothing returns boolean
    set s__CustomInventory_onRecipe=(f__arg_trigger1) // INLINED!!
   return true
endfunction
function sa__CustomInventory_linkItemTraitData takes nothing returns boolean
    call s__CustomInventory_linkItemTraitData(f__arg_integer1,f__arg_integer2,f__arg_string1,f__arg_string2,f__arg_item1)
   return true
endfunction
function sa__CustomInventory_getItemTraitData takes nothing returns boolean
    set f__result_integer=(LoadInteger(Table___ht, (ItemInventory__itemLinks), (GetHandleId((f__arg_item1))))) // INLINED!!
   return true
endfunction
function sa__CustomInventory_doesUnitHaveItemInEq takes nothing returns boolean
    set f__result_integer=s__CustomInventory_doesUnitHaveItemInEq(f__arg_integer1,f__arg_unit1)
   return true
endfunction
function sa__CustomInventory_gather takes nothing returns boolean
    set f__result_integer=s__CustomInventory_gather(f__arg_unit1)
   return true
endfunction
function sa__CustomInventory_wipeSelected takes nothing returns boolean
local player p=f__arg_player1
            local integer tempid
            if GetLocalPlayer() == p then
                set tempid=ItemInventory__EMPTY_BAG_SLOT
            else
                set tempid=GetDestructableTypeId(ItemInventory__currentlySelectedIcon)
            endif
            call RemoveDestructable(ItemInventory__currentlySelectedIcon)
            set ItemInventory__currentlySelectedIcon=CreateDestructable(tempid, ItemInventory__crntX, ItemInventory__crntY, 0, 1, 0)
            call SaveInteger(Table___ht, (s__T2InvB_t[(ItemInventory__currentlySelectedItem)]), (((GetHandleId((udg_PlayerUnit[GetPlayerId(((p))) + 1]))))), ( ( 0))) // INLINED!!
            if ItemInventory__crntTT == null then
                set ItemInventory__crntTT=CreateTextTag()
                call SetTextTagPos(ItemInventory__crntTT, GetRectMinX(ItemInventory__selectedRect), GetRectMinY(ItemInventory__selectedRect), 0)
                call SetTextTagVisibility(ItemInventory__crntTT, true)
            endif
            if GetLocalPlayer() == p then
                call SetTextTagTextBJ(ItemInventory__crntTT, "", 10)
            endif
            call sc__CustomInventory_wipeHovered(p)
   return true
endfunction
function sa__CustomInventory_wipeHovered takes nothing returns boolean
local player p=f__arg_player1
            local integer tempid
                if GetLocalPlayer() == p then
                    set tempid=ItemInventory__EMPTY_BAG_SLOT
                else
                    set tempid=GetDestructableTypeId(ItemInventory__lastHoveredIcon)
                endif
                call RemoveDestructable(ItemInventory__lastHoveredIcon)
                set ItemInventory__lastHoveredIcon=CreateDestructable(tempid, ItemInventory__lstX, ItemInventory__lstY, 0, 1, 0)
                call SaveInteger(Table___ht, (s__T2InvB_t[(ItemInventory__lastHoveredItem)]), (((GetHandleId((udg_PlayerUnit[GetPlayerId(((p))) + 1]))))), ( ( 0))) // INLINED!!
                if ItemInventory__lstTTtitle == null then
                    set ItemInventory__lstTTtitle=CreateTextTag()
                    set ItemInventory__lstTTdesc=CreateTextTag()
                    call SetTextTagPos(ItemInventory__lstTTtitle, GetRectMinX(ItemInventory__hoverTitleRect), GetRectMinY(ItemInventory__hoverTitleRect), 0)
                    call SetTextTagVisibility(ItemInventory__lstTTtitle, true)
                    call SetTextTagPos(ItemInventory__lstTTdesc, GetRectMinX(ItemInventory__hoverDescRect), GetRectMinY(ItemInventory__hoverDescRect), 0)
                    call SetTextTagVisibility(ItemInventory__lstTTdesc, true)
                endif
                if GetLocalPlayer() == p then
                    call SetTextTagTextBJ(ItemInventory__lstTTtitle, "", 10)
                    call SetTextTagTextBJ(ItemInventory__lstTTdesc, "", 10)
                endif
   return true
endfunction
function sa__CustomInventory_moveFromRecipe takes nothing returns boolean
    call s__CustomInventory_moveFromRecipe(f__arg_integer1,f__arg_unit1)
   return true
endfunction
function sa__CustomInventory_removeEqWithoutAdd takes nothing returns boolean
local integer b=f__arg_integer1
local player click=f__arg_player1
            local integer i3= 0
            local integer i= (GetHandleId((udg_PlayerUnit[GetPlayerId(((click))) + 1]))) // INLINED!!
            local integer tempid
            local integer trait
            set trait=(LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i)))) // INLINED!!
            if (LoadInteger(Table___ht, (s__Item_traits[((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i)))))]), ((0)))) != 0 then // INLINED!!
                loop
                    call s__ICI_removeTraitFromUnit((LoadInteger(Table___ht, (s__Item_traits[((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i)))))]), ((i3)))) , (udg_PlayerUnit[GetPlayerId((click)) + 1])) // INLINED!!
                    set i3=i3 + 1
                    exitwhen (LoadInteger(Table___ht, (s__Item_traits[((LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[b])]), ((i)))))]), ((i3)))) == 0 // INLINED!!
                endloop
            endif
            call s__InventoryButton_removeItem(b,(udg_PlayerUnit[GetPlayerId((click)) + 1])) // INLINED!!
            set tempid=s__ICI_getSlotEmptyBackground(R2I(( ( ( s__InventoryButton_x[b] - ItemInventory__eqminx ) / ItemInventory__eqxbetween ) + ItemInventory__eqwidth * ( RAbsBJ(( s__InventoryButton_y[b] - ItemInventory__eqmaxy )) / ItemInventory__eqybetween ) )))
            if GetLocalPlayer() != click then
                set tempid=GetDestructableTypeId(s__InventoryButton_current[b])
            endif
            call RemoveDestructable(s__InventoryButton_current[b])
            set s__InventoryButton_current[b]=CreateDestructable(tempid, s__InventoryButton_x[b], s__InventoryButton_y[b], 0, 1, 0)
            if s__Item_setv[trait] != 0 then
                call s__Set_checkForSetData(s__Item_setv[trait],(udg_PlayerUnit[GetPlayerId((click)) + 1])) // INLINED!!
            endif
   return true
endfunction
function sa__CustomInventory_generateNewItem takes nothing returns boolean
    call s__CustomInventory_generateNewItem(f__arg_item1,f__arg_unit1)
   return true
endfunction
function sa__CustomInventory_initsiesss takes nothing returns boolean

            local item i
            local integer fullItemGenerator
            local integer r
            local integer s
            local integer i3= 0
            local trigger tr= CreateTrigger()
            set s__CustomInventory_t=s__Table_create()
            call TriggerAddCondition(tr, Filter(function s__CustomInventory_ITEM_GENERATION___onPickup))
            call TriggerRegisterAnyUnitEventBJ(tr, EVENT_PLAYER_UNIT_USE_ITEM)
            set tr=null
            set s=s__Set_create("Troll Wizard's Armaments" , "|cffffcc00Description|r : The many pieces of the Troll Wizard's wardrobe which were constantlyrun with energy while the Troll Wizard was in combat.\n\n|cffffcc00Pieces|r\n|cffffcc00    -|r Troll Wizard's Brilliant Essence\n|cffffcc00    -|r Troll Wizard's Luminescent Gloves\n|cffffcc00    -|r Troll Wizard's Silk Robez\n|cffffcc00    -|r Troll Wizard's Shining Ring\n|cffffcc00    -|r Troll Wizard's Shimmering Amulet\n|cffffcc00    -|r Troll Wizard's Long Staff\n|cffffcc00    -|r Troll Wizard's Floating Orb\n\n|cffffcc00Bonuses|r\n|cffffcc00    (3) Intelligence|r : 15\n|cffffcc00    (5) Spell Critical Rate|r : 5%\n|cffffcc00    (7) |r10% chance to renanimate as: Troll Wizard\n|cffffcc00    (7) Spell Critical Damage|r : 50%\n|cffffcc00    (7) Intelligence|r : 20")
            call s__Set_addTrait(s,TRAIT_TYPE_INTELLIGENCE , 15 , 3)
            call s__Set_addTrait(s,TRAIT_TYPE_SPELL_CRIT_RATE , 5 , 5)
            call s__Set_addTrait(s,TRAIT_TYPE_SPELL_CRIT_POW , 50 , 7)
            call s__Set_addTrait(s,TRAIT_TYPE_PHYSICAL_RESISTANCE , 40 , 7)
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll Wizard's Brillant Essence|r" , "|cffffcc00Description|r : The Troll Wizard would collect the souls of its victim and embottle them in order to gain their strength.|n|cff008000|nPart of the Troll Wizard's Armaments set|r" , 'B02W' , SLOT_WING),'I00M'),TRAIT_TYPE_ALL_STATS , 5 , 0 , 0 , 0),TRAIT_TYPE_MOVEMENT_SPEED , 30 , 0 , 0 , 0),s)
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll Wizard's Luminescent Gloves|r" , "|cffffcc00Description|r : Every hand needs a glove.|n|cff008000|nPart of the Troll Wizard's Armaments set|r" , 'B02X' , SLOT_GLOVE),'I02D'),TRAIT_TYPE_ATTACK_SPEED , 10 , 0 , 0 , 0),TRAIT_TYPE_INTELLIGENCE , 5 , 0 , 0 , 0),s)
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll Wizard's Silk Robes|r" , "|cffffcc00Description|r : The Troll's robes leached the energy that was coming from his staff and enchanted themselves.|n|cff008000|nPart of the Troll Wizard's Armaments set|r" , 'B02N' , SLOT_ARMOR),'I026'),TRAIT_TYPE_ARMOR , 4 , 0 , 0 , 0),TRAIT_TYPE_INTELLIGENCE , 9 , 0 , 0 , 0),s)
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll Wizard's Shining Ring|r" , "|cffffcc00Description|r : Rather than the Troll King's ring, this ring embodies the mind and spirit.|n|cff008000|nPart of the Troll Wizard's Armaments set|r" , 'B02L' , SLOT_RINGRIGHT),'I01V'),TRAIT_TYPE_INTELLIGENCE , 9 , 0 , 0 , 0),TRAIT_TYPE_STRENGTH , 4 , 0 , 0 , 0),TRAIT_TYPE_AGILITY , 4 , 0 , 0 , 0),s)
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll Wizard's Long Staff|r" , "|cffffcc00Description|r : This staff is glowing with energy through so much use from the Troll Wizard.|n|cff008000|nPart of the Troll Wizard's Armaments set|r" , 'B02M' , SLOT_MAINHAND),'I01W'),TRAIT_TYPE_DAMAGE , 20 , 0 , 0 , 0),TRAIT_TYPE_INTELLIGENCE , 10 , 0 , 0 , 0),s)
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll Wizard's Floating Orb|r" , "|cffffcc00Description|r : Acted as a battery for the Troll Wizard's magic.|n|cff008000|nPart of the Troll Wizard's Armaments set|r" , 'B02B' , SLOT_OFFHANDONLY),'I01X'),TRAIT_TYPE_DAMAGE , 10 , 0 , 0 , 0),TRAIT_TYPE_INTELLIGENCE , 10 , 0 , 0 , 0),s)
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll Wizard's Shimmering Amulet|r" , "|cffffcc00Description|r : The coup-de-gras of the Troll Wizard's armaments, this amulet was used as the eye of energy, making the Wizard's magic able to focus itself.|n|cff008000|nPart of the Troll Wizard's Armaments set|r" , 'B02T' , SLOT_NECKLACE),'I01Y'),TRAIT_TYPE_INTELLIGENCE , 15 , 0 , 0 , 0),TRAIT_TYPE_STRENGTH , 5 , 0 , 0 , 0),TRAIT_TYPE_AGILITY , 5 , 0 , 0 , 0),s)
            set s=s__Set_create("Troll King's Garments" , "|cffffcc00Description|r : The many parts of the Troll King that made him once so great.\n\n|cffffcc00Pieces\n    - |r Troll King's Belt\n|cffffcc00    - |rTroll King's Crown\n|cffffcc00    - |rTroll King's Chest Protector\n|cffffcc00    - |rTroll King's Majestic Ring\n|cffffcc00    - |rTroll King's Emerald Amulet\n|cffffcc00    - |rTroll King's Bronze Sword\n|cffffcc00    - |rTroll King's Broken Dagger\n\n|cffffcc00Bonuses|r\n|cffffcc00    (3)|r |cffffcc00Strength/Agility\r : 10\n|cffffcc00    (5)|cffffcc00Attack Speed|r : 15%\n|cffffcc00    (7)|r 15% of slain enemies reanimate as: Troll Warrior\n        |cffffcc00Armor|r : 5\n        |cffffcc00All Stats|r : 15")
            call s__Set_addTrait(s,TRAIT_TYPE_STRENGTH , 10 , 3)
            call s__Set_addTrait(s,TRAIT_TYPE_AGILITY , 10 , 3)
            call s__Set_addTrait(s,TRAIT_TYPE_ATTACK_SPEED , 15 , 5)
            call s__Set_addTrait(s,TRAIT_TYPE_ALL_STATS , 10 , 7)
            call s__Set_addTrait(s,TRAIT_TYPE_ARMOR , 5 , 7)
            call s__Set_addTrait(s,TRAIT_TYPE_ALL_RESISTANCE , 20 , 7)
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll King's Belt|r" , "|cffffcc00Description|r : Held the legendary stomach of the Troll King|n|n|cff008000Part of the Troll King's Equipment set|r" , 'B02W' , SLOT_BELT),'I020'),TRAIT_TYPE_ARMOR , 2 , 0 , 0 , 0),TRAIT_TYPE_STRENGTH , 5 , 0 , 0 , 0),s)
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll King's Crown|r" , "|cffffcc00Description|r : Once protected the head of the Troll King. Once.|n|n|cff008000Part of the Troll King's Equipment set|r" , 'B02U' , SLOT_HELM),'I00D'),TRAIT_TYPE_ARMOR , 2 , 0 , 0 , 0),TRAIT_TYPE_ALL_STATS , 3 , 0 , 0 , 0),s)
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll King's Chest Protector|r" , "|cffffcc00Description|r : Protected the stomach of the Troll King.|n|n|cff008000Part of the Troll King's Equipment set|r" , 'B02F' , SLOT_ARMOR),'I00E'),TRAIT_TYPE_ARMOR , 5 , 0 , 0 , 0),TRAIT_TYPE_STRENGTH , 7 , 0 , 0 , 0),TRAIT_TYPE_AGILITY , 4 , 0 , 0 , 0),s)
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll King's Majestic Ring|r" , "|cffffcc00Description|r : One of many on the Troll King's fingers which he stole from the women of plundered villages.|n|n|cff008000Part of the Troll King's Equipment set|r" , 'B02C' , SLOT_RINGRIGHT),'I025'),TRAIT_TYPE_INTELLIGENCE , 5 , 0 , 0 , 0),TRAIT_TYPE_STRENGTH , 8 , 0 , 0 , 0),TRAIT_TYPE_AGILITY , 8 , 0 , 0 , 0),s)
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll King's Emerald Amulet|r" , "|cffffcc00Description|r : The Troll King's favorite, which was taken from a widow who tried to steal from the Troll King.|n|n|cff008000Part of the Troll King's Equipment set|r" , 'B02T' , SLOT_NECKLACE),'I01Z'),TRAIT_TYPE_ALL_STATS , 6 , 0 , 0 , 0),s)
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll King's Bronze Sword|r" , "|cffffcc00Description|r : One of the discarded swords of the Troll King.|n|n|cff008000Part of the Troll King's Equipment set|r" , 'B02I' , SLOT_MAINHAND),'I021'),TRAIT_TYPE_DAMAGE , 20 , 0 , 0 , 0),TRAIT_TYPE_STRENGTH , 5 , 0 , 0 , 0),s)
            set fullItemGenerator=s__FullItemGenerator_addSet(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_register(s__FullItemGenerator_create("|cff008000Troll King's Broken Dagger|r" , "|cffffcc00Description|r : Kept in a holster of the Troll King in case his sword broke.|n|n|cff008000Part of the Troll King's Equipment set|r" , 'B02V' , SLOT_OFFHAND),'I024'),TRAIT_TYPE_DAMAGE , 10 , 0 , 0 , 0),TRAIT_TYPE_STRENGTH , 5 , 0 , 0 , 0),TRAIT_TYPE_AGILITY , 5 , 0 , 0 , 0),TRAIT_TYPE_ATTACK_SPEED , 10 , 0 , 0 , 0),s)
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_create("Weak Iron Scrap" , "|cffffcc00Description|r : Used in various blacksmithing recipes" , 'B02O' , TYPE_MATERIAL),'I00U')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_create("Iron Scrap" , "|cffffcc00Description|r : Used in various blacksmithing recipes" , 'B02O' , TYPE_MATERIAL),'I01M')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_create("Hand-sharpened Iron Scrap" , "|cffffcc00Description|r : Used in various blacksmithing recipes" , 'B02O' , TYPE_MATERIAL),'I01N')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Flimsy Sword" , "|cffffcc00Item Type |r- 1-H Weapon|n|cffffcc00Class Requirement|r : Warrior" , 'B02I' , SLOT_OFFHAND),TRAIT_TYPE_DAMAGE , 2 , 0 , 0 , 0),'I002')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Flimsy Sword +" , "|cffffcc00Item Type |r- 1-H Weapon|n|cffffcc00Class Requirement|r : Warrior" , 'B02I' , SLOT_OFFHAND),TRAIT_TYPE_DAMAGE , 3 , 0 , 0 , 0),'I00Y')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Flimsy Sword ++" , "|cffffcc00Item Type |r- 1-H Weapon|n|cffffcc00Class Requirement|r : Warrior" , 'B02I' , SLOT_OFFHAND),TRAIT_TYPE_DAMAGE , 5 , 0 , 0 , 0),'I017')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Flimsy Sword +++" , "|cffffcc00Item Type |r- 1-H Weapon|n|cffffcc00Class Requirement|r : Warrior" , 'B02I' , SLOT_OFFHAND),TRAIT_TYPE_DAMAGE , 7 , 0 , 0 , 0),'I01G')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Flimsy Branch" , "|cffffcc00Item Type|r : 2-Handed Weapon|n|cffffcc00Class Requirement|r : Wizard, Witch" , 'B02P' , SLOT_MAINHAND),TRAIT_TYPE_DAMAGE , 2 , 0 , 0 , 0),TRAIT_TYPE_INTELLIGENCE , 2 , 0 , 0 , 0),'I00O')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Flimsy Branch +" , "|cffffcc00Item Type|r : 2-Handed Weapon|n|cffffcc00Class Requirement|r : Wizard, Witch" , 'B02P' , SLOT_MAINHAND),TRAIT_TYPE_DAMAGE , 3 , 0 , 0 , 0),TRAIT_TYPE_INTELLIGENCE , 3 , 0 , 0 , 0),'I00V')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Flimsy Branch ++" , "|cffffcc00Item Type|r : 2-Handed Weapon|n|cffffcc00Class Requirement|r : Wizard, Witch" , 'B02P' , SLOT_MAINHAND),TRAIT_TYPE_DAMAGE , 3 , 0 , 0 , 0),TRAIT_TYPE_INTELLIGENCE , 3 , 0 , 0 , 0),'I01D')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Flimsy Branch +++" , "|cffffcc00Item Type|r : 2-Handed Weapon|n|cffffcc00Class Requirement|r : Wizard, Witch" , 'B02P' , SLOT_MAINHAND),TRAIT_TYPE_DAMAGE , 4 , 0 , 0 , 0),TRAIT_TYPE_INTELLIGENCE , 4 , 0 , 0 , 0),'I014')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Cracked Ring" , "|cffffcc00Item Type|r : Ring" , 'B02E' , SLOT_RINGRIGHT),TRAIT_TYPE_ALL_STATS , 2 , 0 , 0 , 0),TRAIT_TYPE_PHYSICAL_RESISTANCE , 20 , 0 , 0 , 0),'I00S')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Cracked Ring +" , "|cffffcc00Item Type|r : Ring" , 'B02E' , SLOT_RINGRIGHT),TRAIT_TYPE_ALL_STATS , 3 , 0 , 0 , 0),'I016')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Cracked Ring ++" , "|cffffcc00Item Type|r : Ring" , 'B02E' , SLOT_RINGRIGHT),TRAIT_TYPE_ALL_STATS , 4 , 0 , 0 , 0),'I01E')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Cracked Ring +++" , "|cffffcc00Item Type|r : Ring" , 'B02E' , SLOT_RINGRIGHT),TRAIT_TYPE_ALL_STATS , 6 , 0 , 0 , 0),'I00W')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Flimsy Armor" , "|cffffcc00Item Type |r: Armor" , 'B02F' , SLOT_ARMOR),TRAIT_TYPE_ARMOR , 1 , 0 , 0 , 0),'I004')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Flimsy Armor +" , "|cffffcc00Item Type |r: Armor" , 'B02F' , SLOT_ARMOR),TRAIT_TYPE_ARMOR , 1 , 0 , 0 , 0),'I00X')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Flimsy Armor ++" , "|cffffcc00Item Type |r: Armor" , 'B02F' , SLOT_ARMOR),TRAIT_TYPE_ARMOR , 2 , 0 , 0 , 0),'I01F')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Flimsy Armor +++" , "|cffffcc00Item Type |r: Armor" , 'B02F' , SLOT_ARMOR),TRAIT_TYPE_ARMOR , 3 , 0 , 0 , 0),'I015')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Leather Quiver" , "|cffffcc00Item Type |r: Offhand|n|cffffcc00Class Requirement|r : Archer" , 'B02Q' , SLOT_OFFHANDONLY),TRAIT_TYPE_ATTACK_SPEED , 2 , 0 , 0 , 0),'I00F')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Leather Quiver +" , "|cffffcc00Item Type |r: Offhand|n|cffffcc00Class Requirement|r : Archer" , 'B02Q' , SLOT_OFFHANDONLY),TRAIT_TYPE_ATTACK_SPEED , 3 , 0 , 0 , 0),'I00Z')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Leather Quiver ++" , "|cffffcc00Item Type |r: Offhand|n|cffffcc00Class Requirement|r : Archer" , 'B02Q' , SLOT_OFFHANDONLY),TRAIT_TYPE_ATTACK_SPEED , 5 , 0 , 0 , 0),'I018')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Leather Quiver +++" , "|cffffcc00Item Type |r: Offhand|n|cffffcc00Class Requirement|r : Archer" , 'B02Q' , SLOT_OFFHANDONLY),TRAIT_TYPE_ATTACK_SPEED , 7 , 0 , 0 , 0),'I01H')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Rough Slippers" , "|cffffcc00Item Type |r: Boots" , 'B02G' , SLOT_BOOTS),TRAIT_TYPE_MOVEMENT_SPEED , 5 , 0 , 0 , 0),'I00K')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Rough Slippers +" , "|cffffcc00Item Type |r: Boots" , 'B02G' , SLOT_BOOTS),TRAIT_TYPE_MOVEMENT_SPEED , 7 , 0 , 0 , 0),'I010')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Rough Slippers ++" , "|cffffcc00Item Type |r: Boots" , 'B02G' , SLOT_BOOTS),TRAIT_TYPE_MOVEMENT_SPEED , 12 , 0 , 0 , 0),TRAIT_TYPE_ARMOR , 1 , 0 , 0 , 0),'I019')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Rough Slippers +++" , "|cffffcc00Item Type |r: Boots" , 'B02G' , SLOT_BOOTS),TRAIT_TYPE_MOVEMENT_SPEED , 15 , 0 , 0 , 0),TRAIT_TYPE_ARMOR , 2 , 0 , 0 , 0),'I01I')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Twig Bow" , "|cffffcc00Item Type |r: 1-H Mainhand|n|cffffcc00Class Requirement|r : Archer" , 'B02R' , SLOT_MAINHAND),TRAIT_TYPE_DAMAGE , 3 , 0 , 0 , 0),TRAIT_TYPE_ATTACK_SPEED , - 15 , - 0 , 0 , 0),'I00G')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Twig Bow +" , "|cffffcc00Item Type |r: 1-H Mainhand|n|cffffcc00Class Requirement|r : Archer" , 'B02R' , SLOT_MAINHAND),TRAIT_TYPE_DAMAGE , 5 , 0 , 0 , 0),TRAIT_TYPE_ATTACK_SPEED , - 15 , 0 , 0 , 0),'I012')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Twig Bow ++" , "|cffffcc00Item Type |r: 1-H Mainhand|n|cffffcc00Class Requirement|r : Archer" , 'B02R' , SLOT_MAINHAND),TRAIT_TYPE_DAMAGE , 7 , 0 , 0 , 0),TRAIT_TYPE_ATTACK_SPEED , - 15 , 0 , 0 , 0),'I01A')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Twig Bow +++" , "|cffffcc00Item Type |r: 1-H Mainhand|n|cffffcc00Class Requirement|r : Archer" , 'B02R' , SLOT_MAINHAND),TRAIT_TYPE_DAMAGE , 11 , 0 , 0 , 0),TRAIT_TYPE_ATTACK_SPEED , - 15 , 0 , 0 , 0),'I01J')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Weak Gloves" , "|cffffcc00Item Type |r: Gloves" , 'B02H' , SLOT_GLOVE),TRAIT_TYPE_ATTACK_SPEED , 1 , 0 , 0 , 0),'I00H')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Weak Gloves +" , "|cffffcc00Item Type |r: Gloves" , 'B02H' , SLOT_GLOVE),TRAIT_TYPE_ATTACK_SPEED , 1 , 0 , 0 , 0),'I011')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Weak Gloves ++" , "|cffffcc00Item Type |r: Gloves" , 'B02H' , SLOT_GLOVE),TRAIT_TYPE_ATTACK_SPEED , 2 , 0 , 0 , 0),'I01B')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Weak Gloves +++" , "|cffffcc00Item Type |r: Gloves" , 'B02H' , SLOT_GLOVE),TRAIT_TYPE_ATTACK_SPEED , 3 , 0 , 0 , 0),'I01K')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Weak Mask" , "|cffffcc00Item Type |r: Helmet" , 'B02S' , SLOT_HELM),TRAIT_TYPE_ARMOR , 1 , 0 , 0 , 0),'I00J')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Weak Mask +" , "|cffffcc00Item Type |r: Helmet" , 'B02S' , SLOT_HELM),TRAIT_TYPE_ARMOR , 1 , 0 , 0 , 0),'I013')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Weak Mask ++" , "|cffffcc00Item Type |r: Helmet" , 'B02S' , SLOT_HELM),TRAIT_TYPE_ARMOR , 2 , 0 , 0 , 0),TRAIT_TYPE_ALL_STATS , 1 , 0 , 0 , 0),'I01C')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("Weak Mask +++" , "|cffffcc00Item Type |r: Helmet" , 'B02S' , SLOT_HELM),TRAIT_TYPE_ARMOR , 3 , 0 , 0 , 0),TRAIT_TYPE_ALL_STATS , 2 , 0 , 0 , 0),'I01L')
            set fullItemGenerator=s__FullItemGenerator_register(s__FullItemGenerator_addReq(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_addTrait(s__FullItemGenerator_create("|cffff4500Sun Fragment of Helios|r" , "Contains the blazing heat by which Helios created the Sun." , 'B01H' , 8),TRAIT_TYPE_ALL_STATS , 13371337 , 0 , 0 , 0),TRAIT_TYPE_MANA_REGEN , 13371337 , 0 , 0 , 0),TRAIT_TYPE_LIFE_REGEN , 13371337 , 0 , 0 , 0),TRAIT_TYPE_ATTACK_SPEED , 13371337 , 0 , 0 , 0),TRAIT_TYPE_MOVEMENT_SPEED , 13371337 , 0 , 0 , 0),TRAIT_TYPE_ARMOR , 13371337 , 0 , 0 , 0),TRAIT_TYPE_STATIC_ARMOR , 13371337 , 0 , 0 , 0),TRAIT_TYPE_SPIKE_ARMOR , 13371337 , 0 , 0 , 0),TRAIT_TYPE_LIFE_LEECH , 13371337 , 0 , 0 , 0),TRAIT_TYPE_ARMOR_REDUCTION , 13371337 , 0 , 0 , 0),TRAIT_TYPE_FIRE_DAMAGE , 13371337 , 14443346 , 0 , 0),TRAIT_TYPE_LIGHTNING_DAMAGE , 13371337 , 14443346 , 0 , 0),TRAIT_TYPE_STATIC_DAMAGE , 13371337 , 14443346 , 0 , 0),TRAIT_TYPE_COLD_DAMAGE , 13371337 , 14443346 , 0 , 0),TRAIT_TYPE_POISON_DAMAGE , 13371337 , 14443346 , 0 , 0),TRAIT_TYPE_CRIT_RATE , 13371337 , 0 , 0 , 0),TRAIT_TYPE_CRIT_POW , 13371337 , 0 , 0 , 0),TRAIT_TYPE_SPELL_CRIT_RATE , 13371337 , 0 , 0 , 0),TRAIT_TYPE_SPELL_CRIT_POW , 13371337 , 0 , 0 , 0),TRAIT_TYPE_ALL_RESISTANCE , 13371337 , 0 , 0 , 0),TRAIT_TYPE_DAMAGE , 131313 , 0 , 0 , 0),TRAIT_REQ_LEVEL , 2),'I000')
            set fullItemGenerator=s__FullItemGenerator_create("[Recipe] Gotum Gear +" , "|cffffcc00Description|r : Upgrades any piece of gear from the weapon salesman in Gotum.|n|n|cffffcc00Recipe|r : Recipe + Any piece of gear + Weak Iron Scrap + Corresponding Material|n|n|cffffcc00Hint|r : 'Corresponding Material' is sold at the Materials Salesman" , 'B02A' , TYPE_RECIPE)
            call s__Recipe2_addResult(s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(s__FullItemGenerator_register(fullItemGenerator,'I006')),0 , 'I00O'),1 , 'I00U'),'I00V'),'I006')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I00S'),1 , 'I00U'),'I016')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I004'),1 , 'I00U'),'I00X')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I002'),1 , 'I00U'),'I00Y')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I00F'),1 , 'I00U'),'I00Z')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I00K'),1 , 'I00U'),'I010')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I00G'),1 , 'I00U'),'I012')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I00H'),1 , 'I00U'),'I011')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I00J'),1 , 'I00U'),'I013')
            set fullItemGenerator=s__FullItemGenerator_create("[Recipe] Gotum Gear ++" , "|cffffcc00Description|r : Upgrades any piece of gear from the weapon salesman in Gotum.|n|n|cffffcc00Recipe|r : Recipe + Any single-plus piece of gear + Iron Scrap + Corresponding Material|n|n|cffffcc00Hint|r : 'Corresponding Material' is sold at the Materials Salesman" , 'B02A' , TYPE_RECIPE)
            call s__FullItemGenerator_register(fullItemGenerator,'I007')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I00V'),1 , 'I01M'),'I01D')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I016'),1 , 'I01M'),'I01E')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I00X'),1 , 'I01M'),'I01F')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I00Y'),1 , 'I01M'),'I017')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I00Z'),1 , 'I01M'),'I018')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I010'),1 , 'I01M'),'I019')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I012'),1 , 'I01M'),'I01A')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I011'),1 , 'I01M'),'I01B')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I013'),1 , 'I01M'),'I01C')
            set fullItemGenerator=s__FullItemGenerator_create("[Recipe] Gotum Gear +++" , "|cffffcc00Description|r : Upgrades any piece of gear from the weapon salesman in Gotum.|n|n|cffffcc00Recipe|r : Recipe + Any double-plus piece of gear + Hand-sharpened Iron Scrap + Corresponding Material|n|n|cffffcc00Hint|r : 'Corresponding Material' is sold at the Materials Salesman" , 'B02A' , TYPE_RECIPE)
            call s__FullItemGenerator_register(fullItemGenerator,'I00C')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I01D'),1 , 'I01N'),'I014')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I01E'),1 , 'I01N'),'I00W')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I01F'),1 , 'I01N'),'I015')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I017'),1 , 'I01N'),'I01G')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I018'),1 , 'I01N'),'I01H')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I019'),1 , 'I01N'),'I01I')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I01A'),1 , 'I01N'),'I01J')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I01B'),1 , 'I01N'),'I01K')
            call s__Recipe2_addResult(s__Recipe2_addPiece(s__Recipe2_addPiece(s__FullItemGenerator_addNewRecipe(fullItemGenerator),0 , 'I01C'),1 , 'I01N'),'I01L')
   return true
endfunction
function sa__CustomInventory_register takes nothing returns boolean
local integer i=f__arg_integer1
local integer itemId=f__arg_integer2
            call s__CustomInventory_PRIVATEOUTCAST_add(i , itemId)
   return true
endfunction
function sa__Recipe2_create takes nothing returns boolean

            local integer this= s__Recipe2__allocate()
            set s__Recipe2_pieces[this]=s__TableArray__staticgetindex(10)
            set s__Recipe2_results[this]=s__Table_create()
            set s__Recipe2_piecesCount[this]=s__Table_create()
            set s__Recipe2_resultsCount[this]=0
set f__result_integer= this
   return true
endfunction
function sa__Recipe2_check takes nothing returns boolean
    set f__result_boolean=s__Recipe2_check(f__arg_this,f__arg_unit1,f__arg_integer1,f__arg_integer2)
   return true
endfunction
function sa__RecipeGroup_add takes nothing returns boolean
local integer this=f__arg_this
local integer rec=f__arg_integer1
            call SaveInteger(Table___ht, (s__RecipeGroup_recipes[this]), (s__RecipeGroup_recIndex[this]), ( rec)) // INLINED!!
            set s__RecipeGroup_recIndex[this]=s__RecipeGroup_recIndex[this] + 1
   return true
endfunction
function sa__Set_addItem takes nothing returns boolean
local integer this=f__arg_this
local integer itemId=f__arg_integer1
            call SaveInteger(Table___ht, (s__Set_itemIds[this]), (s__Set_currentItem[this]), ( itemId)) // INLINED!!
            set s__Set_currentItem[this]=s__Set_currentItem[this] + 1
   return true
endfunction
function sa__InventoryButton_removeItem takes nothing returns boolean
    call s__InventoryButton_removeItem(f__arg_this,f__arg_unit1)
   return true
endfunction
function sa__InventoryButton_noTooltip takes nothing returns boolean
local integer this=f__arg_this
            set s__InventoryButton_title[this]=""
            set s__InventoryButton_description[this]=""
            set s__InventoryButton_showOnTooltip[this]=false
   return true
endfunction
function sa__InventoryButton_desc takes nothing returns boolean
    set f__result_string=(s__Item_genDesc[(LoadInteger(Table___ht, (s__ItemInventory__link2table_t[(s__InventoryButton_link[(f__arg_this)])]), ((GetHandleId((f__arg_unit1))))))]) // INLINED!!
   return true
endfunction
function sa__T2InvB_create takes nothing returns boolean

            local integer this= s__T2InvB__allocate()
            set s__T2InvB_t[this]=s__Table_create()
set f__result_integer= this
   return true
endfunction
function sa__Item_addSet takes nothing returns boolean
local integer this=f__arg_this
local integer s=f__arg_integer1
            set s__Item_setv[this]=s
   return true
endfunction
function sa__Item_addRecipe takes nothing returns boolean
local integer this=f__arg_this
local integer s=f__arg_integer1
            call sc__RecipeGroup_add(s__Item_possibleRecipe[this],s)
   return true
endfunction
function sa__Item_addTrait takes nothing returns boolean
local integer this=f__arg_this
local integer trait=f__arg_integer1
            call SaveInteger(Table___ht, (s__Item_traits[this]), (s__Item_current[this]), ( (trait))) // INLINED!!
            set s__Item_current[this]=s__Item_current[this] + 1
            set s__Item_genDesc[this]=s__Item_generateDescription(this)
   return true
endfunction
function sa__Item_addReq takes nothing returns boolean
local integer this=f__arg_this
local integer t=f__arg_integer1
            call SaveInteger(Table___ht, (s__Item_reqs[this]), (s__Item_reqCount[this]), ( t)) // INLINED!!
            set s__Item_reqCount[this]=s__Item_reqCount[this] + 1
            set s__Item_genDesc[this]=s__Item_generateDescription(this)
   return true
endfunction
function sa__Item_getTrait takes nothing returns boolean
local integer this=f__arg_this
local integer at=f__arg_integer1
set f__result_integer= ((LoadInteger(Table___ht, (s__Item_traits[this]), (at)))) // INLINED!!
   return true
endfunction
function sa__Item_getReq takes nothing returns boolean
local integer this=f__arg_this
local integer at=f__arg_integer1
set f__result_integer= (LoadInteger(Table___ht, (s__Item_reqs[this]), (at))) // INLINED!!
   return true
endfunction
function sa__ICI_getTraitDescription takes nothing returns boolean
local string color=f__arg_string1
local integer t=f__arg_integer1
            if s__Trait_typeOfTrait[t] == TRAIT_TYPE_DAMAGE then
set f__result_string= color + "Damage|r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_ARMOR then
set f__result_string= color + "Armor |r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_STATIC_ARMOR then
set f__result_string= color + "Static Armor|r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_FIRE_DAMAGE then
set f__result_string= color + "Fire Damage |r: " + I2S(R2I(s__Trait_a[t])) + " - " + I2S(R2I(s__Trait_b[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_LIGHTNING_DAMAGE then
set f__result_string= color + "Electric Damage |r: 1 - " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_STRENGTH then
set f__result_string= color + "Strength|r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_AGILITY then
set f__result_string= color + "Agility |r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_INTELLIGENCE then
set f__result_string= color + "Inteligence |r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_MANA then
set f__result_string= color + "Mana|r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_MANA_REGEN then
set f__result_string= color + "Mana Regen |r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_SPIKE_ARMOR then
set f__result_string= color + "Spike Armor |r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_STATIC_DAMAGE then
set f__result_string= color + "Chaos Damage |r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_LIFE then
set f__result_string= color + "Life |r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_LIFE_REGEN then
set f__result_string= color + "Life Regen |r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_ATTACK_SPEED then
set f__result_string= color + "Attack Speed|r: " + I2S(R2I(s__Trait_a[t])) + "%"
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_ALL_STATS then
set f__result_string= color + "All Stats|r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_LIFE_LEECH then
set f__result_string= color + "Life Leech|r: " + I2S(R2I(s__Trait_a[t])) + "%"
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_ARMOR_REDUCTION then
set f__result_string= color + "On-hit Armor Reduction|r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_SPELL_CRIT_RATE then
set f__result_string= color + "Spell Critical Strike Rate|r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_CRIT_POW then
set f__result_string= color + "Critical Strike Power|r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_CRIT_RATE then
set f__result_string= color + "Critical Strike Rate|r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_SPELL_CRIT_POW then
set f__result_string= color + "Spell Critical Strike Power|r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_MOVEMENT_SPEED then
set f__result_string= color + "Movement Speed|r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_FIRE_RESISTANCE then
set f__result_string= color + "Fire Resistance|r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_COLD_RESISTANCE then
set f__result_string= color + "Cold Resistance|r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_LIGHTNING_RESISTANCE then
set f__result_string= color + "Lightning Resistance|r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_POISON_RESISTANCE then
set f__result_string= color + "Poison Resistance|r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_DARKNESS_RESISTANCE then
set f__result_string= color + "Darkness Resistance|r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_HOLY_RESISTANCE then
set f__result_string= color + "Holy Resistance|r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_PHYSICAL_RESISTANCE then
set f__result_string= color + "Physical Resistance|r: " + I2S(R2I(s__Trait_a[t]))
return true
            elseif s__Trait_typeOfTrait[t] == TRAIT_TYPE_ALL_RESISTANCE then
set f__result_string= color + "All Resistance|r: " + I2S(R2I(s__Trait_a[t]))
return true
            endif
set f__result_string= ""
   return true
endfunction
function sa__ICI_displaySetData takes nothing returns boolean
local integer it=f__arg_integer1
local integer os=f__arg_integer2
local player p=f__arg_player1
            local integer tempid
            local string title
            local string desc
            if s__Item_setv[it] == 0 then
                set title="No Set Data"
                set desc=title
            else
                set title="Set Description : " + s__Set_title[s__Item_setv[it]]
                set desc=s__Set_desc[s__Item_setv[it]]
            endif
            if GetLocalPlayer() == p then
                set tempid='B00I'
            else
                set tempid=GetDestructableTypeId(ItemInventory__lastHoveredIcon)
            endif
            call RemoveDestructable(ItemInventory__lastHoveredIcon)
            set ItemInventory__lastHoveredIcon=CreateDestructable(tempid, ItemInventory__lstX, ItemInventory__lstY, 0, 1, 0)
            if ItemInventory__lstTTtitle == null then
                set ItemInventory__lstTTtitle=CreateTextTag()
                set ItemInventory__lstTTdesc=CreateTextTag()
                call SetTextTagPos(ItemInventory__lstTTtitle, GetRectMinX(ItemInventory__hoverTitleRect), GetRectMinY(ItemInventory__hoverTitleRect), 0)
                call SetTextTagVisibility(ItemInventory__lstTTtitle, true)
                call SetTextTagPos(ItemInventory__lstTTdesc, GetRectMinX(ItemInventory__hoverDescRect), GetRectMinY(ItemInventory__hoverDescRect), 0)
                call SetTextTagVisibility(ItemInventory__lstTTdesc, true)
            endif
            if GetLocalPlayer() == p then
                call SetTextTagTextBJ(ItemInventory__lstTTtitle, title, 10)
                call SetTextTagTextBJ(ItemInventory__lstTTdesc, desc, 10)
            endif
   return true
endfunction
function sa__QuestInstance_create takes nothing returns boolean
local integer root=f__arg_integer1
            local integer this= s__QuestInstance__allocate()
            set s__QuestInstance_root[this]=root
            set s__QuestInstance_stage[this]=- 1
            set s__QuestInstance_onDestIndex[this]=0
            set s__QuestInstance_onDestroy[this]=s__Table_create()
            set s__QuestInstance_progress[this]=s__Table_create()
            set Quest__listOfQuestsIndex=Quest__listOfQuestsIndex + 1
            set Quest__listOfQuests[Quest__listOfQuestsIndex]=this
            set s__QuestInstance_thisIndex[this]=Quest__listOfQuestsIndex
            set s__QuestInstance_currentProgress[this]=s__Table_create()
set f__result_integer= this
   return true
endfunction
function sa__QuestInstance_containsPlayer takes nothing returns boolean
local integer this=f__arg_this
local player p=f__arg_player1
set f__result_boolean= s__Party_doesContainPlayer(s__QuestInstance_party[this],p)
   return true
endfunction
function sa__QuestInstance_getStage takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= s__QuestInstance_stage[this]
   return true
endfunction
function sa__QuestInstance_start takes nothing returns boolean
local integer this=f__arg_this
local integer p=f__arg_integer1
            if s__QuestInstance_stage[this] != - 1 then
                call TimedTextAll(Quest__MESSAGE_DURATION , "FAIL")
            endif
            set s__QuestInstance_party[this]=p
            call s__Party_startQuest(s__QuestInstance_party[this],this)
            call sc__QuestInstance_nextStage(this)
set f__result_integer= this
   return true
endfunction
function sa__QuestInstance_nextStage takes nothing returns boolean
local integer this=f__arg_this
            local integer forLoop= 0
            local integer i= 0
            local integer numIteration= - 1
            local widget w
            local integer t= ((Quest__questTable) + (s__QuestInstance_root[this])) // INLINED!!
            call FlushChildHashtable(Table___ht, (s__QuestInstance_progress[this])) // INLINED!!
            call FlushChildHashtable(Table___ht, (s__QuestInstance_currentProgress[this])) // INLINED!!
            set s__QuestInstance_onDestIndex[this]=0
            call FlushChildHashtable(Table___ht, (s__QuestInstance_onDestroy[this])) // INLINED!!
            set s__QuestInstance_stage[this]=s__QuestInstance_stage[this] + 1
            if (LoadInteger(Table___ht, (t), (s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT))) == Quest__GLOBAL_FINISH then // INLINED!!
                call TimedTextBoolean(Quest__MESSAGE_DURATION , s__Party_doesContainPlayer(s__QuestInstance_party[this],GetLocalPlayer()) , (LoadStr(Table___ht, (((t))), (1 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT ))))) // INLINED!!
                call sc__QuestInstance_finish(this)
return true
            elseif (LoadStr(Table___ht, (((t))), (( Quest__STAGE_INDICE_INDENT - 2 ) + ( Quest__STAGE_INDICE_INDENT * ( s__QuestInstance_stage[this] - 1 ) )))) != null then // INLINED!!
                call TimedTextBoolean(Quest__MESSAGE_DURATION , s__Party_doesContainPlayer(s__QuestInstance_party[this],GetLocalPlayer()) , (LoadStr(Table___ht, (((t))), (( Quest__STAGE_INDICE_INDENT - 2 ) + ( ( s__QuestInstance_stage[this] - 1 ) * Quest__STAGE_INDICE_INDENT ))))) // INLINED!!
            endif
            loop
                set i=(LoadInteger(Table___ht, (t), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) // INLINED!!
                if i < 0 then
                    set i=- i
                    if i == - Quest__STAGE_FINISH then
                        call SaveInteger(Table___ht, (s__QuestInstance_progress[this]), (numIteration), ( Quest__STAGE_FINISH)) // INLINED!!
return true
                    elseif i == 1 then
                        set numIteration=numIteration + 7
                        set forLoop=forLoop + 6
                        set w=I2W((LoadInteger(Table___ht, (t), (forLoop - 5 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT ))))) // INLINED!!
                        call SaveInteger(Table___ht, (s__QuestInstance_progress[this]), (numIteration - 6), ( - 1)) // INLINED!!
                        call SaveInteger(Table___ht, (s__QuestInstance_progress[this]), (numIteration - 5), ( (LoadInteger(Table___ht, (t), (forLoop - 5 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))))) // INLINED!!
                        call SaveStr(Table___ht, (((s__QuestInstance_progress[this]))), (numIteration - 4), ( (LoadStr(Table___ht, (((t))), (forLoop - 4 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))))) // INLINED!!
                        call SaveBoolean(Table___ht, (((s__QuestInstance_progress[this]))), (numIteration - 3), ( false)) // INLINED!!
                        call SaveUnitHandle(Table___ht, (((s__QuestInstance_progress[this]))), (numIteration - 2), ( CreateUnit(Player(10), Quest__EXCLAMATION_POINT_ID, GetWidgetX(w), GetWidgetY(w), 0))) // INLINED!!
                        call ShowUnit((LoadUnitHandle(Table___ht, (((s__QuestInstance_progress[this]))), (numIteration - 2))), s__Party_doesContainPlayer(s__QuestInstance_party[this],GetLocalPlayer())) // INLINED!!
                        call UnitAddAbility((LoadUnitHandle(Table___ht, (((s__QuestInstance_progress[this]))), (numIteration - 2))), 'Amrf') // INLINED!!
                        call SetUnitFlyHeight((LoadUnitHandle(Table___ht, (((s__QuestInstance_progress[this]))), (numIteration - 2))), (LoadReal(Table___ht, (((t))), (forLoop - 2 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))), 100000) // INLINED!!
                        call UnitRemoveAbility((LoadUnitHandle(Table___ht, (((s__QuestInstance_progress[this]))), (numIteration - 2))), 'Amrf') // INLINED!!
                        call s__Party_addPing(s__QuestInstance_party[this],(LoadReal(Table___ht, (((t))), (forLoop - 1 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) , (LoadReal(Table___ht, (((t))), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT ))))) // INLINED!!
                        set w=null
                    elseif i == 2 or i == 3 then
                        set numIteration=numIteration + 7
                        set forLoop=forLoop + 6
                        if i == 2 then
                            call SaveInteger(Table___ht, (s__QuestInstance_progress[this]), (numIteration - 6), ( - 2)) // INLINED!!
                        else
                            call SaveInteger(Table___ht, (s__QuestInstance_progress[this]), (numIteration - 6), ( - 3)) // INLINED!!
                        endif
                        call SaveInteger(Table___ht, (s__QuestInstance_progress[this]), (numIteration - 5), ( (LoadInteger(Table___ht, (t), (forLoop - 5 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))))) // INLINED!!
                        call SaveInteger(Table___ht, (s__QuestInstance_progress[this]), (numIteration - 4), ( (LoadInteger(Table___ht, (t), (forLoop - 4 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))))) // INLINED!!
                        call SaveStr(Table___ht, (((s__QuestInstance_progress[this]))), (numIteration - 3), ( (LoadStr(Table___ht, (((t))), (forLoop - 3 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))))) // INLINED!!
                        call SaveStr(Table___ht, (((s__QuestInstance_progress[this]))), (numIteration - 2), ( (LoadStr(Table___ht, (((t))), (forLoop - 2 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))))) // INLINED!!
                    elseif i == 4 then
                        set numIteration=numIteration + 5
                        set forLoop=forLoop + 4
                        call SaveInteger(Table___ht, (s__QuestInstance_progress[this]), (numIteration - 4), ( - 4)) // INLINED!!
                        call SaveTriggerHandle(Table___ht, (((s__QuestInstance_progress[this]))), (numIteration - 3), ( (LoadTriggerHandle(Table___ht, (((t))), (forLoop - 3 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))))) // INLINED!!
                        call SaveBoolean(Table___ht, (((s__QuestInstance_progress[this]))), (numIteration - 2), ( false)) // INLINED!!
                    elseif i == 121 then
                        set forLoop=forLoop + 1
                        call runTriggerForForce((s__Party_playerPool[(s__QuestInstance_party[this])]) , (LoadTriggerHandle(Table___ht, (((t))), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT ))))) // INLINED!!
                    elseif i == 122 then
                        call print("On Destroy")
                        set forLoop=forLoop + 1
                        call SaveTriggerHandle(Table___ht, (((s__QuestInstance_onDestroy[this]))), (s__QuestInstance_onDestIndex[this]), ( (LoadTriggerHandle(Table___ht, (((t))), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))))) // INLINED!!
                        set s__QuestInstance_onDestIndex[this]=s__QuestInstance_onDestIndex[this] + 1
                    endif
                endif
                set forLoop=forLoop + 1
                exitwhen (LoadInteger(Table___ht, (t), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) == 0 // INLINED!!
            endloop
            call SaveInteger(Table___ht, (s__QuestInstance_progress[this]), (numIteration + 1), ( Quest__STAGE_FINISH)) // INLINED!!
   return true
endfunction
function sa__QuestInstance_notifyClosure takes nothing returns boolean
local integer this=f__arg_this
            call s__QuestInstance_destroy(this)
   return true
endfunction
function sa__QuestInstance_finish takes nothing returns boolean
local integer this=f__arg_this
            local integer forLoop= 0
            local integer i= 0
            local player playerNoob
            local integer t= ((Quest__questTable) + (s__QuestInstance_root[this])) // INLINED!!
            set s__QuestInstance_stage[this]=s__QuestInstance_stage[this] + 1
            loop
                if (LoadInteger(Table___ht, (t), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) == - 1 then // INLINED!!
                    loop
                        set playerNoob=Player(i)
                        set i=i + 1
                        exitwhen i > 11
                    endloop
                    set forLoop=forLoop + 2
                elseif (LoadInteger(Table___ht, (t), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) == - 2 then // INLINED!!
                    set i=0
                    loop
                        set playerNoob=Player(i)
                        if s__Party_doesContainPlayer(s__QuestInstance_party[this],playerNoob) then
                            set Quest_QUESTSYSTEM_ITEMTYPE=(LoadInteger(Table___ht, (t), (forLoop + 1 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) // INLINED!!
                            set Quest_QUESTSYSTEM_ITEMAMOUNT=(LoadInteger(Table___ht, (t), (forLoop + 2 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) // INLINED!!
                            set Quest_QUESTSYSTEM_TRIGGERUNIT=udg_PlayerUnit[i + 1]
                            set Quest_QUESTSYSTEM_TRIGGERPLAYERUNIT=udg_PlayerUnit[i + 1]
                            set Quest_QUESTSYSTEM_RESPONSETYPE=4
                            call TriggerEvaluate(Quest_QUESTSYSTEM_MAINTRIGGER)
                        endif
                        set i=i + 1
                        exitwhen i > 11
                    endloop
                    set forLoop=forLoop + 2
                elseif (LoadInteger(Table___ht, (t), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) == - 3 then // INLINED!!
                    set i=0
                    loop
                        set playerNoob=Player(i)
                        if s__Party_doesContainPlayer(s__QuestInstance_party[this],playerNoob) then
                            set Quest_QUESTSYSTEM_GOLDTOADD=(LoadInteger(Table___ht, (t), (forLoop + 1 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) // INLINED!!
                            set Quest_QUESTSYSTEM_TRIGGERUNIT=s__QuestInstance_lastTrigger[this]
                            set Quest_QUESTSYSTEM_PLAYER=playerNoob
                            set Quest_QUESTSYSTEM_TRIGGERPLAYERUNIT=s___QuestInstance_lastTriggerUnit[s__QuestInstance_lastTriggerUnit[this]+GetPlayerId(playerNoob)]
                            set Quest_QUESTSYSTEM_RESPONSETYPE=1
                            call TriggerEvaluate(Quest_QUESTSYSTEM_MAINTRIGGER)
                        endif
                        set i=i + 1
                        exitwhen i > 11
                    endloop
                    set forLoop=forLoop + 1
                elseif (LoadInteger(Table___ht, (t), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) == - 4 then // INLINED!!
                    set i=0
                    loop
                        set playerNoob=Player(i)
                        if s__Party_doesContainPlayer(s__QuestInstance_party[this],playerNoob) then
                            set Quest_QUESTSYSTEM_LUMBTOADD=(LoadInteger(Table___ht, (t), (forLoop + 1 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) // INLINED!!
                            set Quest_QUESTSYSTEM_TRIGGERUNIT=s__QuestInstance_lastTrigger[this]
                            set Quest_QUESTSYSTEM_TRIGGERPLAYERUNIT=s___QuestInstance_lastTriggerUnit[s__QuestInstance_lastTriggerUnit[this]+GetPlayerId(playerNoob)]
                            set Quest_QUESTSYSTEM_PLAYER=playerNoob
                            set Quest_QUESTSYSTEM_RESPONSETYPE=2
                            call TriggerEvaluate(Quest_QUESTSYSTEM_MAINTRIGGER)
                        endif
                        set i=i + 1
                        exitwhen i > 11
                    endloop
                    set forLoop=forLoop + 1
                elseif (LoadInteger(Table___ht, (t), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) == - 5 then // INLINED!!
                    set i=0
                    loop
                        set playerNoob=Player(i)
                        if s__Party_doesContainPlayer(s__QuestInstance_party[this],playerNoob) then
                            set Quest_QUESTSYSTEM_EXPTOADD=(LoadInteger(Table___ht, (t), (forLoop + 1 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) // INLINED!!
                            set Quest_QUESTSYSTEM_TRIGGERUNIT=udg_PlayerUnit[i + 1]
                            set Quest_QUESTSYSTEM_TRIGGERPLAYERUNIT=udg_PlayerUnit[i + 1]
                            set Quest_QUESTSYSTEM_PLAYER=playerNoob
                            set Quest_QUESTSYSTEM_RESPONSETYPE=6
                            call TriggerEvaluate(Quest_QUESTSYSTEM_MAINTRIGGER)
                        endif
                        set i=i + 1
                        exitwhen i > 11
                    endloop
                    set forLoop=forLoop + 1
                elseif (LoadInteger(Table___ht, (t), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) == - 6 then // INLINED!!
                    call s__QuestAPI_start(((LoadInteger(Table___ht, (t), (forLoop + 1 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT ))))),s__QuestInstance_party[this]) // INLINED!!
                    set forLoop=forLoop + 1
                elseif (LoadInteger(Table___ht, (t), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) == - 7 then // INLINED!!
                    call s__QuestInteractListener_enableParty((s__QuestAPI_starter[(((LoadInteger(Table___ht, (t), (forLoop + 1 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT ))))))]),s__QuestInstance_party[this]) // INLINED!!
                    set forLoop=forLoop + 1
                elseif (LoadInteger(Table___ht, (t), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) == - 121 then // INLINED!!
                    call print("Trigger Run")
                    call runTriggerForForce((s__Party_playerPool[(s__QuestInstance_party[this])]) , (LoadTriggerHandle(Table___ht, (((t))), (forLoop + 1 + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT ))))) // INLINED!!
                    set forLoop=forLoop + 1
                else
                    call print("Error?")
                endif
                set forLoop=forLoop + 1
                exitwhen (LoadInteger(Table___ht, (t), (forLoop + ( s__QuestInstance_stage[this] * Quest__STAGE_INDICE_INDENT )))) == 0 // INLINED!!
            endloop
            call s__QuestInstance_endQuest(this)
   return true
endfunction
function sa__QuestInstance_triggerFulfill takes nothing returns boolean
    set f__result_boolean=s__QuestInstance_triggerFulfill(f__arg_this,f__arg_trigger1)
   return true
endfunction
function sa__QuestInteractListener_create takes nothing returns boolean
    set f__result_integer=s__QuestInteractListener_create(f__arg_integer1,f__arg_widget1,f__arg_string1,f__arg_string2,f__arg_string3,f__arg_boolean1)
   return true
endfunction
function sa__QuestInteractListener_setLevel takes nothing returns boolean
local integer this=f__arg_this
local integer reqLevel=f__arg_integer1
local boolean enableWhenReady=f__arg_boolean1
            local integer i= 0
            set s__QuestInteractListener_levelPinged[this]=s__Table_create()
            set s__QuestInteractListener_usesLevel[this]=true
            set s__QuestInteractListener_level[this]=reqLevel
            set s__QuestInteractListener_levelPosition[this]=Quest__interactLevelTablePos
            set Quest__interactLevelTablePos=Quest__interactLevelTablePos + 1
            set Quest__interactLevelTable[s__QuestInteractListener_levelPosition[this]]=this
            if enableWhenReady then
                set s__QuestInteractListener_defaultEnabled[this]=true
                loop
                    exitwhen i == 10
                    call SaveInteger(Table___ht, (s__QuestInteractListener_b[this]), (i), ( 1)) // INLINED!!
                    set i=i + 1
                endloop
            endif
   return true
endfunction
function sa__QuestInteractListener_enable takes nothing returns boolean
local integer this=f__arg_this
local player p=f__arg_player1
            call SaveInteger(Table___ht, (s__QuestInteractListener_b[this]), (GetPlayerId(p)), ( 1)) // INLINED!!
            call PingMinimap(GetWidgetX(s__QuestInteractListener_interact[this]), GetWidgetY(s__QuestInteractListener_interact[this]), 5)
            call ShowUnit(s__QuestInteractListener_exc[this], (LoadInteger(Table___ht, (s__QuestInteractListener_b[this]), (GetPlayerId(GetLocalPlayer())))) != 99) // INLINED!!
            call TimedTextBoolean(15 , (LoadInteger(Table___ht, (s__QuestInteractListener_b[this]), (GetPlayerId(GetLocalPlayer())))) != 99 , Quest__beforeQuestNameAccepted + s__QuestInteractListener_questName[this] + Quest__afterQuestNameAccepted) // INLINED!!
set f__result_integer= this
   return true
endfunction
function sa__QuestInteractListener_reset takes nothing returns boolean
local integer this=f__arg_this
local player p=f__arg_player1
            if s__QuestInteractListener_defaultEnabled[this] then
                call print("defeaultEnabled")
                call SaveInteger(Table___ht, (s__QuestInteractListener_b[this]), (GetPlayerId(p)), ( 1)) // INLINED!!
            else
                call print("nonenabled")
                call SaveInteger(Table___ht, (s__QuestInteractListener_b[this]), (GetPlayerId(p)), ( 0)) // INLINED!!
            endif
            call SaveBoolean(Table___ht, (((s__QuestInteractListener_levelPinged[this]))), (GetPlayerId(p)), ( false)) // INLINED!!
            call ShowUnit(s__QuestInteractListener_exc[this], not s__QuestInteractListener_usesLevel[this] and (LoadInteger(Table___ht, (s__QuestInteractListener_b[this]), (GetPlayerId(GetLocalPlayer())))) != 99 and (LoadInteger(Table___ht, (s__QuestInteractListener_b[this]), (GetPlayerId(GetLocalPlayer())))) != 0) // INLINED!!
   return true
endfunction
function sa__QuestAPI_triggerRun takes nothing returns boolean
    call s__QuestAPI_triggerRun(f__arg_this,f__arg_trigger1)
   return true
endfunction
function sa__GameStart__Init_run takes nothing returns boolean

            local integer thread= s__Thread_create()
            call s__Thread_sync(thread)
            call s__Thread_wait(thread)
            call s__Thread_destroy(thread)
            set GameStart__gameStarted=true
   return true
endfunction
function sa__UnitIndexer__set_enabled takes nothing returns boolean
local boolean l__UnitIndexer___b=f__arg_boolean1
            if ( l__UnitIndexer___b ) then
                call DisableTrigger(UnitIndexer___q)
                call DisableTrigger(UnitIndexer___l)
            else
                call EnableTrigger(UnitIndexer___q)
                call EnableTrigger(UnitIndexer___l)
            endif
   return true
endfunction
function sa__StatBoard__ConstantLoop_T32Interface___expire takes nothing returns boolean

            local integer i= 0
            local integer array recycle
            local integer recycleCount= 0
            local integer temp
            local boolean running= false
            loop
                exitwhen s__StatBoard__ConstantLoop_T32Interface___list[i] == 0
                if not sc__StatBoard__ConstantLoop_onLoop(s__StatBoard__ConstantLoop_T32Interface___list[i]) then
                   set recycle[recycleCount]=s__StatBoard__ConstantLoop_T32Interface___list[i]
                   set recycleCount=recycleCount + 1
                   call sc__StatBoard__ConstantLoop_onExpire(s__StatBoard__ConstantLoop_T32Interface___list[i])
                else
                    set running=true
                endif
                set i=i + 1
            endloop
            if recycleCount != 0 then
                set i=0
                loop
                    exitwhen recycle[i] == 0
                    set temp=recycle[i]
                    set s__StatBoard__ConstantLoop_recyclePosition[s__StatBoard__ConstantLoop_T32Interface___list[s__StatBoard__ConstantLoop_T32Interface___count]]=s__StatBoard__ConstantLoop_recyclePosition[temp]
                    set s__StatBoard__ConstantLoop_T32Interface___list[s__StatBoard__ConstantLoop_recyclePosition[temp]]=s__StatBoard__ConstantLoop_T32Interface___list[s__StatBoard__ConstantLoop_T32Interface___count]
                    set s__StatBoard__ConstantLoop_T32Interface___list[s__StatBoard__ConstantLoop_T32Interface___count]=0
                    set s__StatBoard__ConstantLoop_T32Interface___count=s__StatBoard__ConstantLoop_T32Interface___count - 1
                    set i=i + 1
                endloop
            endif
            if not running then
                call CTL___SR32((s__StatBoard__ConstantLoop_T32Interface___timers)) // INLINED!!
            endif
   return true
endfunction
function sa__StatBoard__ConstantLoop_onLoop takes nothing returns boolean
local integer this=f__arg_this
            set s__StatBoard__ConstantLoop_i[this]=s__StatBoard__ConstantLoop_i[this] + 1
            if s__StatBoard__ConstantLoop_i[this] == 5 then
                set s__StatBoard__ConstantLoop_i[this]=0
                set s__StatBoard__ConstantLoop_c[this]=s__StatBoard__ConstantLoop_c[this] + 1
                if s__StatBoard__ConstantLoop_c[this] > 9 then
                    set s__StatBoard__ConstantLoop_c[this]=0
                endif
                if s__StatBoard__ConstantLoop_c[this] == 0 and DoesUnitExist(udg_PlayerUnit[s__StatBoard__ConstantLoop_c[this] + 1]) then
                    call s__MainBoard_update(StatBoard__p[s__StatBoard__ConstantLoop_c[this]],udg_PlayerUnit[s__StatBoard__ConstantLoop_c[this] + 1])
                endif
            endif
set f__result_boolean= true
   return true
endfunction
function sa__StatBoard__ConstantLoop_onExpire takes nothing returns boolean
local integer this=f__arg_this
   return true
endfunction
function sa__ShadowTrail_remove takes nothing returns boolean
local integer this=f__arg_this
            set s__ShadowTrail_dur[this]=0
            set s__ShadowTrail_perm[this]=false
   return true
endfunction
function sa__ShadowTrail_setEffect takes nothing returns boolean
local integer this=f__arg_this
local string model=f__arg_string1
local string attachPoint=f__arg_string2
local boolean attachToShadows=f__arg_boolean1
            local integer i= 1
            set s__ShadowTrail_eff[this]=model
            set s__ShadowTrail_att[this]=attachPoint
            set s__ShadowTrail_bo2[this]=attachToShadows
            if attachToShadows then
                loop
                    exitwhen (LoadUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i))) == null // INLINED!!
                    if (LoadEffectHandle(Table___ht, (((s__ShadowTrail_tb[this]))), (i))) != null then // INLINED!!
                        call DestroyEffect((LoadEffectHandle(Table___ht, (((s__ShadowTrail_tb[this]))), (i)))) // INLINED!!
                    endif
                    call SaveEffectHandle(Table___ht, (((s__ShadowTrail_tb[this]))), (i), ( AddSpecialEffectTarget(model, (LoadUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i))), attachPoint))) // INLINED!!
                    set i=i + 1
                endloop
            endif
            if (LoadEffectHandle(Table___ht, (((s__ShadowTrail_tb[this]))), (i))) != null then // INLINED!!
                call DestroyEffect((LoadEffectHandle(Table___ht, (((s__ShadowTrail_tb[this]))), (i)))) // INLINED!!
            endif
            call SaveEffectHandle(Table___ht, (((s__ShadowTrail_tb[this]))), (0), ( AddSpecialEffectTarget(model, s__ShadowTrail_main[this], attachPoint))) // INLINED!!
   return true
endfunction
function sa__ShadowTrail_setColor takes nothing returns boolean
local integer this=f__arg_this
local integer red=f__arg_integer1
local integer grn=f__arg_integer2
local integer blu=f__arg_integer3
local integer alpha=f__arg_integer4
            local integer i= 1
            set s__ShadowTrail_r[this]=red
            set s__ShadowTrail_g[this]=grn
            set s__ShadowTrail_b[this]=blu
            set s__ShadowTrail_a[this]=alpha
            loop
                exitwhen (LoadUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i))) == null // INLINED!!
                if s__ShadowTrail_id[this] == TRAIL_TYPE_STATIC or not s__ShadowTrail_h[this] then
                    call SetUnitVertexColor((LoadUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i))), red, grn, blu, R2I(s__ShadowTrail_a[this] * Pow(s__ShadowTrail_af[this], i - 1))) // INLINED!!
                else
                    call SetUnitVertexColor((LoadUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i))), red, grn, blu, 0) // INLINED!!
                endif
                set i=i + 1
            endloop
   return true
endfunction
function sa__ShadowTrail_setAnimationIndex takes nothing returns boolean
local integer this=f__arg_this
local integer k=f__arg_integer1
            local integer i= 1
            set s__ShadowTrail_anim[this]=k
            loop
                exitwhen (LoadUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i))) == null // INLINED!!
                call SetUnitAnimationByIndex((LoadUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i))), k) // INLINED!!
                set i=i + 1
            endloop
   return true
endfunction
function sa__ShadowTrail_setFadeRate takes nothing returns boolean
local integer this=f__arg_this
local real rate=f__arg_real1
local boolean flatMode=f__arg_boolean1
            if flatMode then
                set s__ShadowTrail_fr[this]=R2I(rate)
            else
                set s__ShadowTrail_fp[this]=1 - rate
            endif
            set s__ShadowTrail_bo1[this]=flatMode
   return true
endfunction
function sa__ShadowTrail_setupMovingTrail takes nothing returns boolean
local integer this=f__arg_this
local integer count=f__arg_integer1
local real separation=f__arg_real1
local real alphaFactor=f__arg_real2
            local integer i
            local unit l__ShadowTrail___u
            local real x= GetUnitX(s__ShadowTrail_main[this])
            local real y= GetUnitY(s__ShadowTrail_main[this])
            local real f= GetUnitFacing(s__ShadowTrail_main[this])
            if s__ShadowTrail_id[this] == TRAIL_TYPE_MOTION then
                if count > 0 then
                    set s__ShadowTrail_d[this]=separation
                    set s__ShadowTrail_tc[this]=count
                    set s__ShadowTrail_h[this]=false
                    set s__ShadowTrail_af[this]=alphaFactor
                    set s__ShadowTrail_xm[this]=GetUnitX(s__ShadowTrail_main[this])
                    set s__ShadowTrail_ym[this]=GetUnitY(s__ShadowTrail_main[this])
                    set s__ShadowTrail_ta[this]=s__Table_create()
                    set i=1
                    loop
                        set l__ShadowTrail___u=ShadowTrail___CreateUnitWithoutShadow(Player(15) , s__ShadowTrail_uid[this] , f , ShadowTrail___SHADOWPATH)
                        call ShowUnit(l__ShadowTrail___u, false)
                        call SetUnitVertexColor(l__ShadowTrail___u, s__ShadowTrail_r[this], s__ShadowTrail_g[this], s__ShadowTrail_b[this], 0)
                        set ShadowTrail___dc=ShadowTrail___dc + 1
                        call SetUnitColor(l__ShadowTrail___u, s__ShadowTrail_pc[this])
                        call UnitAddAbility(l__ShadowTrail___u, 'Arav')
                        call UnitAddAbility(l__ShadowTrail___u, 'Aloc')
                        call SetUnitUseFood(l__ShadowTrail___u, false)
                        call SetUnitX(l__ShadowTrail___u, x)
                        call SetUnitY(l__ShadowTrail___u, y)
                        call PauseUnit(l__ShadowTrail___u, true)
                        call SaveUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (i), ( l__ShadowTrail___u)) // INLINED!!
                        exitwhen i == count
                        set i=i + 1
                    endloop
                    set s__ShadowTrail_h[this]=true
                    call SaveUnitHandle(Table___ht, (((s__ShadowTrail_ta[this]))), (0), ( s__ShadowTrail_main[this])) // INLINED!!
                    set l__ShadowTrail___u=null
                else
                endif
            endif
   return true
endfunction
function sa__ShadowTrail_add takes nothing returns boolean
    set f__result_integer=s__ShadowTrail_add(f__arg_unit1,f__arg_integer1,f__arg_real1)
   return true
endfunction
function sa__FFS_BurstCounter_T32Interface___expire takes nothing returns boolean

            local integer i= 0
            local integer array recycle
            local integer recycleCount= 0
            local integer temp
            local boolean running= false
            loop
                exitwhen s__FFS_BurstCounter_T32Interface___list[i] == 0
                if not sc__FFS_BurstCounter_onLoop(s__FFS_BurstCounter_T32Interface___list[i]) then
                   set recycle[recycleCount]=s__FFS_BurstCounter_T32Interface___list[i]
                   set recycleCount=recycleCount + 1
                   call sc__FFS_BurstCounter_onExpire(s__FFS_BurstCounter_T32Interface___list[i])
                else
                    set running=true
                endif
                set i=i + 1
            endloop
            if recycleCount != 0 then
                set i=0
                loop
                    exitwhen recycle[i] == 0
                    set temp=recycle[i]
                    set s__FFS_BurstCounter_recyclePosition[s__FFS_BurstCounter_T32Interface___list[s__FFS_BurstCounter_T32Interface___count]]=s__FFS_BurstCounter_recyclePosition[temp]
                    set s__FFS_BurstCounter_T32Interface___list[s__FFS_BurstCounter_recyclePosition[temp]]=s__FFS_BurstCounter_T32Interface___list[s__FFS_BurstCounter_T32Interface___count]
                    set s__FFS_BurstCounter_T32Interface___list[s__FFS_BurstCounter_T32Interface___count]=0
                    set s__FFS_BurstCounter_T32Interface___count=s__FFS_BurstCounter_T32Interface___count - 1
                    set i=i + 1
                endloop
            endif
            if not running then
                call CTL___SR32((s__FFS_BurstCounter_T32Interface___timers)) // INLINED!!
            endif
   return true
endfunction
function sa__FFS_BurstCounter_onLoop takes nothing returns boolean
local integer this=f__arg_this
            set s__FFS_BurstCounter_tickCount[this]=s__FFS_BurstCounter_tickCount[this] + 1
            if s__FFS_BurstCounter_tickCount[this] >= s__FFS_BurstCounter_tickCountTo[this] then
set f__result_boolean= false
return true
            endif
            if s__FFS_BurstCounter_tickCount[this] == s__FFS_BurstCounter_tickCountTo[this] - 20 then
                call DestroyEffect(AddSpecialEffect(FighterFirstSpells__BC_FX, GetUnitX(s__FFS_BurstCounter_caster[this]), GetUnitY(s__FFS_BurstCounter_caster[this])))
            endif
            call SetTextTagPos(s__FFS_BurstCounter_textTag[this], GetUnitX(s__FFS_BurstCounter_caster[this]), GetUnitY(s__FFS_BurstCounter_caster[this]), FighterFirstSpells__BC_HEIGHT)
set f__result_boolean= true
   return true
endfunction
function sa__FFS_BurstCounter_onExpire takes nothing returns boolean
local integer this=f__arg_this
            local group g= CreateGroup()
            local unit u
            local real lvl= GetUnitAbilityLevel(s__FFS_BurstCounter_caster[this], BC_ID)
            local real damage= s__FFS_BurstCounter_currentCapacity[this] * ( FighterFirstSpells__BC_PERCENT + ( FighterFirstSpells__BC_PERCENT_LVL * lvl ) )
            call GroupEnumUnitsInRange(g, GetUnitX(s__FFS_BurstCounter_caster[this]), GetUnitY(s__FFS_BurstCounter_caster[this]), FighterFirstSpells__BC_KABOOM_RADIUS, getTargetFilter(GetOwningPlayer(s__FFS_BurstCounter_caster[this])))
            loop
                set u=FirstOfGroup(g)
                exitwhen u == null
                call spellDamage(s__FFS_BurstCounter_caster[this] , u , damage)
                call GroupRemoveUnit(g, u)
            endloop
            call DestroyTextTag(s__FFS_BurstCounter_textTag[this])
            call SaveInteger(Table___ht, (s__FFS_BurstCounter_currentInstances), (GetUnitTypeId(s__FFS_BurstCounter_caster[this])), ( 0)) // INLINED!!
            set s__FFS_BurstCounter_caster[this]=null
            call s__FFS_BurstCounter_deallocate(this)
   return true
endfunction
function sa__FFS_Banish_T32Interface___expire takes nothing returns boolean

            local integer i= 0
            local integer array recycle
            local integer recycleCount= 0
            local integer temp
            local boolean running= false
            loop
                exitwhen s__FFS_Banish_T32Interface___list[i] == 0
                if not sc__FFS_Banish_onLoop(s__FFS_Banish_T32Interface___list[i]) then
                   set recycle[recycleCount]=s__FFS_Banish_T32Interface___list[i]
                   set recycleCount=recycleCount + 1
                   call sc__FFS_Banish_onExpire(s__FFS_Banish_T32Interface___list[i])
                else
                    set running=true
                endif
                set i=i + 1
            endloop
            if recycleCount != 0 then
                set i=0
                loop
                    exitwhen recycle[i] == 0
                    set temp=recycle[i]
                    set s__FFS_Banish_recyclePosition[s__FFS_Banish_T32Interface___list[s__FFS_Banish_T32Interface___count]]=s__FFS_Banish_recyclePosition[temp]
                    set s__FFS_Banish_T32Interface___list[s__FFS_Banish_recyclePosition[temp]]=s__FFS_Banish_T32Interface___list[s__FFS_Banish_T32Interface___count]
                    set s__FFS_Banish_T32Interface___list[s__FFS_Banish_T32Interface___count]=0
                    set s__FFS_Banish_T32Interface___count=s__FFS_Banish_T32Interface___count - 1
                    set i=i + 1
                endloop
            endif
            if not running then
                call CTL___SR32((s__FFS_Banish_T32Interface___timers)) // INLINED!!
            endif
   return true
endfunction
function sa__FFS_Banish_onLoop takes nothing returns boolean
local integer this=f__arg_this
            local unit u
            local group g= CreateGroup()
            local real x
            local real y
            local real angle
            local real xdiff
            local real ydiff
            if s__FFS_Banish_isCharging[this] then
                set s__FFS_Banish_tickCount[this]=s__FFS_Banish_tickCount[this] + 1
                call IssueImmediateOrder(s__FFS_Banish_caster[this], "stop")
                if s__FFS_Banish_tickCount[this] > 5 * 32 then
                    call sc__FFS_Banish_cancel(this)
                        call DestroyGroup(g)
                        set u=null
set f__result_boolean= false
return true
                else
                    set xdiff=GetUnitX(s__FFS_Banish_chargeTarget[this]) - GetUnitX(s__FFS_Banish_caster[this])
                    set ydiff=GetUnitY(s__FFS_Banish_chargeTarget[this]) - GetUnitY(s__FFS_Banish_caster[this])
                    if ( xdiff * xdiff ) + ( ydiff * ydiff ) > ( FighterFirstSpells__BN_RANGE * FighterFirstSpells__BN_RANGE ) then
                        call sc__FFS_Banish_cancel(this)
                        call DestroyGroup(g)
                        set u=null
set f__result_boolean= false
return true
                    endif
                    set angle=Atan2(GetUnitY(s__FFS_Banish_chargeTarget[this]) - GetUnitY(s__FFS_Banish_caster[this]), GetUnitX(s__FFS_Banish_chargeTarget[this]) - GetUnitX(s__FFS_Banish_caster[this]))
                    call SetUnitX(s__FFS_Banish_caster[this], GetUnitX(s__FFS_Banish_caster[this]) + ( FighterFirstSpells__BN_SPEED * Cos(angle) ))
                    call SetUnitY(s__FFS_Banish_caster[this], GetUnitY(s__FFS_Banish_caster[this]) + ( FighterFirstSpells__BN_SPEED * Sin(angle) ))
                    set xdiff=GetUnitX(s__FFS_Banish_chargeTarget[this]) - GetUnitX(s__FFS_Banish_caster[this])
                    set ydiff=GetUnitY(s__FFS_Banish_chargeTarget[this]) - GetUnitY(s__FFS_Banish_caster[this])
                    if ( xdiff * xdiff ) + ( ydiff * ydiff ) < ( FighterFirstSpells__BN_COLLIDE_DST ) then
                        set s__FFS_Banish_tickCount[this]=0
                        call sc__FFS_Banish_onCollide(this)
                    endif
                endif
            else
                set s__FFS_Banish_tickCount[this]=s__FFS_Banish_tickCount[this] + 1
                if s__FFS_Banish_tickCount[this] >= 17 then
                    call DestroyGroup(g)
                    set u=null
set f__result_boolean= false
return true
                endif
                call GroupAddGroup(s__FFS_Banish_units[this], g)
                loop
                    set u=FirstOfGroup(g)
                    exitwhen u == null
                    set x=GetUnitX(u) + (LoadReal(Table___ht, (((s__FFS_Banish_data[this]))), (GetUnitUserData(u)))) // INLINED!!
                    set y=GetUnitY(u) + (LoadReal(Table___ht, (((s__FFS_Banish_data[this]))), (GetUnitUserData(u) + 100000))) // INLINED!!
                    if IsTerrainWalkable(x , y) then
                        call SetUnitX(u, GetUnitX(u) + (LoadReal(Table___ht, (((s__FFS_Banish_data[this]))), (GetUnitUserData(u))))) // INLINED!!
                        call SetUnitY(u, GetUnitY(u) + (LoadReal(Table___ht, (((s__FFS_Banish_data[this]))), (GetUnitUserData(u) + 100000)))) // INLINED!!
                    endif
                    call GroupRemoveUnit(g, u)
                endloop
            endif
            call DestroyGroup(g)
            set u=null
set f__result_boolean= true
   return true
endfunction
function sa__FFS_Banish_onExpire takes nothing returns boolean
local integer this=f__arg_this
            local unit u
            call sc__ShadowTrail_remove(s__FFS_Banish_trail[this])
            call PauseUnit(s__FFS_Banish_caster[this], false)
            call SetUnitInvulnerable(s__FFS_Banish_caster[this], false)
            loop
                set u=FirstOfGroup(s__FFS_Banish_units[this])
                exitwhen u == null
                call PauseUnit(u, false)
                call pureDamage(s__FFS_Banish_caster[this] , u , 1)
                call GroupRemoveUnit(s__FFS_Banish_units[this], u)
            endloop
            call DestroyGroup(s__FFS_Banish_units[this])
            set s__FFS_Banish_caster[this]=null
            call FlushChildHashtable(Table___ht, (s__FFS_Banish_data[this])) // INLINED!!
            call s__Table_destroy(s__FFS_Banish_data[this])
            call s__FFS_Banish_deallocate(this)
            set u=null
   return true
endfunction
function sa__FFS_Banish_cancel takes nothing returns boolean
local integer this=f__arg_this
            call DestroyEffect(AddSpecialEffect(MS_FX, GetUnitX(s__FFS_Banish_caster[this]), GetUnitY(s__FFS_Banish_caster[this])))
            call sc__ShadowTrail_remove(s__FFS_Banish_trail[this])
            call PauseUnit(s__FFS_Banish_caster[this], false)
   return true
endfunction
function sa__FFS_Banish_onCollide takes nothing returns boolean
local integer this=f__arg_this
            local group g= CreateGroup()
            local unit u
            local real casterx= GetUnitX(s__FFS_Banish_caster[this])
            local real castery= GetUnitY(s__FFS_Banish_caster[this])
            local real angle
            local real damage= s__FFS_Banish_onHitDamage[this]
            call DestroyEffect(AddSpecialEffect(MS_FX, casterx, castery))
            call sc__ShadowTrail_remove(s__FFS_Banish_trail[this])
            call PauseUnit(s__FFS_Banish_caster[this], false)
            call SetUnitInvulnerable(s__FFS_Banish_caster[this], false)
            set s__FFS_Banish_isCharging[this]=false
            set s__FFS_Banish_tickCount[this]=0
            call GroupEnumUnitsInRange(g, GetUnitX(s__FFS_Banish_chargeTarget[this]), GetUnitY(s__FFS_Banish_chargeTarget[this]), 200, getTargetFilter(GetOwningPlayer(s__FFS_Banish_caster[this])))
            loop
                set u=FirstOfGroup(g)
                exitwhen u == null
                set angle=Atan2(GetUnitY(u) - castery, GetUnitX(u) - casterx)
                call SaveReal(Table___ht, (((s__FFS_Banish_data[this]))), (GetUnitUserData(u)), (( ( 1.0 / 16.0 ) * ( FighterFirstSpells__BN_KNOCKBACK_RANGE * Cos(angle) ))*1.0)) // INLINED!!
                call SaveReal(Table___ht, (((s__FFS_Banish_data[this]))), (GetUnitUserData(u) + 100000), (( ( 1.0 / 16.0 ) * ( FighterFirstSpells__BN_KNOCKBACK_RANGE * Sin(angle) ))*1.0)) // INLINED!!
                call GroupAddUnit(s__FFS_Banish_units[this], u)
                set s__FFS_Banish_dataIndex[this]=s__FFS_Banish_dataIndex[this] + 1
                call PauseUnit(u, true)
                call pureDamage(s__FFS_Banish_caster[this] , u , damage)
                call GroupRemoveUnit(g, u)
            endloop
   return true
endfunction
function sa__FFS_WhirlingWrath_T32Interface___expire takes nothing returns boolean

            local integer i= 0
            local integer array recycle
            local integer recycleCount= 0
            local integer temp
            local boolean running= false
            loop
                exitwhen s__FFS_WhirlingWrath_T32Interface___list[i] == 0
                if not sc__FFS_WhirlingWrath_onLoop(s__FFS_WhirlingWrath_T32Interface___list[i]) then
                   set recycle[recycleCount]=s__FFS_WhirlingWrath_T32Interface___list[i]
                   set recycleCount=recycleCount + 1
                   call sc__FFS_WhirlingWrath_onExpire(s__FFS_WhirlingWrath_T32Interface___list[i])
                else
                    set running=true
                endif
                set i=i + 1
            endloop
            if recycleCount != 0 then
                set i=0
                loop
                    exitwhen recycle[i] == 0
                    set temp=recycle[i]
                    set s__FFS_WhirlingWrath_recyclePosition[s__FFS_WhirlingWrath_T32Interface___list[s__FFS_WhirlingWrath_T32Interface___count]]=s__FFS_WhirlingWrath_recyclePosition[temp]
                    set s__FFS_WhirlingWrath_T32Interface___list[s__FFS_WhirlingWrath_recyclePosition[temp]]=s__FFS_WhirlingWrath_T32Interface___list[s__FFS_WhirlingWrath_T32Interface___count]
                    set s__FFS_WhirlingWrath_T32Interface___list[s__FFS_WhirlingWrath_T32Interface___count]=0
                    set s__FFS_WhirlingWrath_T32Interface___count=s__FFS_WhirlingWrath_T32Interface___count - 1
                    set i=i + 1
                endloop
            endif
            if not running then
                call CTL___SR32((s__FFS_WhirlingWrath_T32Interface___timers)) // INLINED!!
            endif
   return true
endfunction
function sa__FFS_WhirlingWrath_onLoop takes nothing returns boolean
local integer this=f__arg_this
            local real angle= (GetRandomReal(- bj_PI, bj_PI)) // INLINED!!
            set s__FFS_WhirlingWrath_tick[this]=s__FFS_WhirlingWrath_tick[this] + 1
            if s__FFS_WhirlingWrath_tick[this] == FighterFirstSpells__WW_TICK then
                set s__FFS_WhirlingWrath_tick[this]=0
            else
set f__result_boolean= true
return true
            endif
            if (TimerGetElapsed(gameTimer)) - s__FFS_WhirlingWrath_startTime[this] > FighterFirstSpells__WW_TIME then // INLINED!!
set f__result_boolean= false
return true
            endif
            call FireWave(s__FFS_WhirlingWrath_playerId[this] , WW_WAVE_ABIL , s__FFS_WhirlingWrath_x[this] , s__FFS_WhirlingWrath_y[this] , angle , this)
            call SetUnitFacingTimed(s__FFS_WhirlingWrath_caster[this], angle * bj_RADTODEG, 0)
            call SetUnitAnimation(s__FFS_WhirlingWrath_caster[this], "attack")
set f__result_boolean= true
   return true
endfunction
function sa__FFS_WhirlingWrath_onExpire takes nothing returns boolean
local integer this=f__arg_this
            local timer t= CreateTimer()
            call SaveInteger(Table___ht, (s__FFS_WhirlingWrath_attachedTimerData), (GetHandleId(t)), ( this)) // INLINED!!
            if s__FFS_WhirlingWrath_caster[this] == null then
            endif
            call PauseUnit(s__FFS_WhirlingWrath_caster[this], false)
            call TimerStart(t, 15, false, function s__FFS_WhirlingWrath_onFinalExpire)
   return true
endfunction
function sa__Catalog_create takes nothing returns boolean

set f__result_integer= CatalogCreate()
   return true
endfunction
function sa__Catalog_add takes nothing returns boolean
local integer this=f__arg_this
local integer v=f__arg_integer1
            call CatalogAdd(this , v)
   return true
endfunction
function sa__Catalog_addCatalog takes nothing returns boolean
local integer this=f__arg_this
local integer catalog=f__arg_integer1
            call CatalogAddCatalog(this , catalog)
   return true
endfunction
function sa__TableArray__staticgetindex takes nothing returns boolean
local integer array_size=f__arg_integer1
        local integer tb= (LoadInteger(Table___ht, ((Table___sizeK)), (array_size))) // INLINED!!
        local integer this= (LoadInteger(Table___ht, (tb), (0))) // INLINED!!
        if array_size <= 0 then
            call BJDebugMsg("TypeError: Invalid specified TableArray size: " + I2S(array_size))
set f__result_integer= 0
return true
        endif
            set this=Table___less - array_size
            set Table___less=this
        call SaveInteger(Table___ht, ((Table___sizeK)), (this), ( array_size)) //This remembers the array size // INLINED!!
set f__result_integer= this
   return true
endfunction
function sa__TableArray__getindex takes nothing returns boolean
local integer this=f__arg_this
local integer key=f__arg_integer1
set f__result_integer= this + key
   return true
endfunction
function sa__Table__get_real takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= this
   return true
endfunction
function sa__Table__get_boolean takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= this
   return true
endfunction
function sa__Table__get_string takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= this
   return true
endfunction
function sa__Table__get_widget takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= this
   return true
endfunction
function sa__Table__get_unit takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= this
   return true
endfunction
function sa__Table__get_fogstate takes nothing returns boolean
local integer this=f__arg_this
set f__result_integer= this
   return true
endfunction
function sa__Table__getindex takes nothing returns boolean
local integer this=f__arg_this
local integer key=f__arg_integer1
set f__result_integer= LoadInteger(Table___ht, this, key)
   return true
endfunction
function sa__Table__setindex takes nothing returns boolean
local integer this=f__arg_this
local integer key=f__arg_integer1
local integer tb=f__arg_integer2
        call SaveInteger(Table___ht, this, key, tb)
   return true
endfunction
function sa__Table_has takes nothing returns boolean
local integer this=f__arg_this
local integer key=f__arg_integer1
set f__result_boolean= HaveSavedInteger(Table___ht, this, key)
   return true
endfunction
function sa__Table_remove takes nothing returns boolean
local integer this=f__arg_this
local integer key=f__arg_integer1
        call RemoveSavedInteger(Table___ht, this, key)
   return true
endfunction
function sa__Table_create takes nothing returns boolean

        local integer this= (LoadInteger(Table___ht, ((Table___listK)), (0))) // INLINED!!
        if this == 0 then
            set this=Table___more + 1
            set Table___more=this
        else
            call SaveInteger(Table___ht, ((Table___listK)), (0), ( (LoadInteger(Table___ht, ((Table___listK)), (this))))) // INLINED!!
            call RemoveSavedInteger(Table___ht, ((Table___listK)), (this)) //Clear hashed memory // INLINED!!
        endif
set f__result_integer= this
   return true
endfunction
function sa__Table_destroy takes nothing returns boolean
local integer this=f__arg_this
        call FlushChildHashtable(Table___ht, (this)) // INLINED!!
        call SaveInteger(Table___ht, ((Table___listK)), (this), ( (LoadInteger(Table___ht, ((Table___listK)), (0))))) // INLINED!!
        call SaveInteger(Table___ht, ((Table___listK)), (0), ( this)) // INLINED!!
   return true
endfunction
function sa__Table___fogstates__setindex takes nothing returns boolean
local integer this=f__arg_this
local integer key=f__arg_integer1
local fogstate value=f__arg_fogstate1
        call SaveFogStateHandle(Table___ht, this, key, value)
   return true
endfunction
function sa__Table___units__getindex takes nothing returns boolean
local integer this=f__arg_this
local integer key=f__arg_integer1
set f__result_unit= LoadUnitHandle(Table___ht, this, key)
   return true
endfunction
function sa__Table___units__setindex takes nothing returns boolean
    call SaveUnitHandle(Table___ht, (f__arg_this), (f__arg_integer1), (f__arg_unit1)) // INLINED!!
   return true
endfunction
function sa__Table___widgets__getindex takes nothing returns boolean
local integer this=f__arg_this
local integer key=f__arg_integer1
set f__result_widget= LoadWidgetHandle(Table___ht, this, key)
   return true
endfunction
function sa__Table___strings__getindex takes nothing returns boolean
local integer this=f__arg_this
local integer key=f__arg_integer1
set f__result_string= LoadStr(Table___ht, this, key)
   return true
endfunction
function sa__Table___strings__setindex takes nothing returns boolean
local integer this=f__arg_this
local integer key=f__arg_integer1
local string value=f__arg_string1
        call SaveStr(Table___ht, this, key, value)
   return true
endfunction
function sa__Table___booleans__getindex takes nothing returns boolean
local integer this=f__arg_this
local integer key=f__arg_integer1
set f__result_boolean= LoadBoolean(Table___ht, this, key)
   return true
endfunction
function sa__Table___booleans__setindex takes nothing returns boolean
local integer this=f__arg_this
local integer key=f__arg_integer1
local boolean value=f__arg_boolean1
        call SaveBoolean(Table___ht, this, key, value)
   return true
endfunction
function sa__Table___reals__getindex takes nothing returns boolean
local integer this=f__arg_this
local integer key=f__arg_integer1
set f__result_real= LoadReal(Table___ht, this, key)
   return true
endfunction
function sa__Table___reals__setindex takes nothing returns boolean
local integer this=f__arg_this
local integer key=f__arg_integer1
local real value=f__arg_real1
        call SaveReal(Table___ht, this, key, value)
   return true
endfunction
function sa__HeroImage_destroy takes nothing returns boolean
local integer this=f__arg_this
            local integer i= s__HeroImage_copiesCount[this] - 1
            loop
                exitwhen i < 0
                call RemoveSavedInteger(Table___ht, (s__HeroImage_copies), ((GetHandleId((LoadUnitHandle(Table___ht, (((s__HeroImage_copyUnits[this]))), (i))))))) // INLINED!!
                call RemoveUnit((LoadUnitHandle(Table___ht, (((s__HeroImage_copyUnits[this]))), (i)))) // INLINED!!
                call RemoveSavedInteger(Table___ht, (s__HeroImage_copyUnits[this]), (i)) // INLINED!!
                set i=i - 1
            endloop
            call RemoveSavedInteger(Table___ht, (s__HeroImage_originals), ((GetHandleId(s__HeroImage_original[this])))) // INLINED!!
            set s__HeroImage_imagesCount=s__HeroImage_imagesCount - 1
            set s__HeroImage_images[s__HeroImage_spot[this]]=s__HeroImage_images[s__HeroImage_imagesCount]
            set s__HeroImage_images[s__HeroImage_imagesCount]=0
   return true
endfunction
function sa___prototype3_s__GameStart__Init_run takes nothing returns boolean

            local integer thread= s__Thread_create()
            call s__Thread_sync(thread)
            call s__Thread_wait(thread)
            call s__Thread_destroy(thread)
            set GameStart__gameStarted=true
    return true
endfunction
function sa___prototype3_s__vJassTTInteract_onShowUI takes nothing returns boolean

    return true
endfunction
function sa___prototype3_s__vJassTTInteract_onHideUI takes nothing returns boolean

    return true
endfunction
function sa___prototype3_s__vJassTTInteract_onHover takes nothing returns boolean

    return true
endfunction
function sa___prototype3_s__vJassTTInteract_onClick takes nothing returns boolean

        if s__vJassTTInteract_attachedData < 200 and s__vJassTTInteract_attachedData != - 1 then
            call s__VJassTalentTree_showUI(s__vJassTTInteract_interactingPlayer , s__vJassTTInteract_attachedData)
        endif
        call print(I2S(s__vJassTTInteract_attachedData))
    return true
endfunction

function jasshelper__initstructs5190200 takes nothing returns nothing
    set st__Quest_refreshDescription=CreateTrigger()
    call TriggerAddCondition(st__Quest_refreshDescription,Condition( function sa__Quest_refreshDescription))
    set st__Button_create=CreateTrigger()
    call TriggerAddCondition(st__Button_create,Condition( function sa__Button_create))
    set st__Button_addData=CreateTrigger()
    call TriggerAddCondition(st__Button_addData,Condition( function sa__Button_addData))
    set st__Button_isMenu=CreateTrigger()
    call TriggerAddCondition(st__Button_isMenu,Condition( function sa__Button_isMenu))
    set st__Button_createLink=CreateTrigger()
    call TriggerAddCondition(st__Button_createLink,Condition( function sa__Button_createLink))
    set st__Button_push=CreateTrigger()
    call TriggerAddCondition(st__Button_push,Condition( function sa__Button_push))
    set st__Button_reCreate=CreateTrigger()
    call TriggerAddCondition(st__Button_reCreate,Condition( function sa__Button_reCreate))
    set st__Heroes__get_raw=CreateTrigger()
    call TriggerAddCondition(st__Heroes__get_raw,Condition( function sa__Heroes__get_raw))
    set st__Heroes__get_count=CreateTrigger()
    call TriggerAddCondition(st__Heroes__get_count,Condition( function sa__Heroes__get_count))
    set st__Heroes__get_id=CreateTrigger()
    call TriggerAddCondition(st__Heroes__get_id,Condition( function sa__Heroes__get_id))
    set st__ItemRoots_get=CreateTrigger()
    call TriggerAddCondition(st__ItemRoots_get,Condition( function sa__ItemRoots_get))
    set st__PhoenixBarrage_launch=CreateTrigger()
    call TriggerAddCondition(st__PhoenixBarrage_launch,Condition( function sa__PhoenixBarrage_launch))
    set st__FlameConjuration_T32Interface___expire=CreateTrigger()
    call TriggerAddCondition(st__FlameConjuration_T32Interface___expire,Condition( function sa__FlameConjuration_T32Interface___expire))
    set st__Pressure_T32Interface___expire=CreateTrigger()
    call TriggerAddCondition(st__Pressure_T32Interface___expire,Condition( function sa__Pressure_T32Interface___expire))
    set st__FlameWave_T32Interface___expire=CreateTrigger()
    call TriggerAddCondition(st__FlameWave_T32Interface___expire,Condition( function sa__FlameWave_T32Interface___expire))
    set st__BurningSoul_T32Interface___expire=CreateTrigger()
    call TriggerAddCondition(st__BurningSoul_T32Interface___expire,Condition( function sa__BurningSoul_T32Interface___expire))
    set st__BurningSoul_onLoop=CreateTrigger()
    call TriggerAddCondition(st__BurningSoul_onLoop,Condition( function sa__BurningSoul_onLoop))
    set st__BurningSoul_onExpire=CreateTrigger()
    call TriggerAddCondition(st__BurningSoul_onExpire,Condition( function sa__BurningSoul_onExpire))
    set st__BurningSoul_create=CreateTrigger()
    call TriggerAddCondition(st__BurningSoul_create,Condition( function sa__BurningSoul_create))
    set st__WitchFirstSpells__BathMain_expire=CreateTrigger()
    call TriggerAddCondition(st__WitchFirstSpells__BathMain_expire,Condition( function sa__WitchFirstSpells__BathMain_expire))
    set st__WitchFirstSpells__BathMain_onLoop=CreateTrigger()
    call TriggerAddCondition(st__WitchFirstSpells__BathMain_onLoop,Condition( function sa__WitchFirstSpells__BathMain_onLoop))
    set st__WitchFirstSpells__ChampTimer_T32Interface___expire=CreateTrigger()
    call TriggerAddCondition(st__WitchFirstSpells__ChampTimer_T32Interface___expire,Condition( function sa__WitchFirstSpells__ChampTimer_T32Interface___expire))
    set st__WitchFirstSpells__ChampTimer_onLoop=CreateTrigger()
    call TriggerAddCondition(st__WitchFirstSpells__ChampTimer_onLoop,Condition( function sa__WitchFirstSpells__ChampTimer_onLoop))
    set st__WitchFirstSpells__ChampTimer_onExpire=CreateTrigger()
    call TriggerAddCondition(st__WitchFirstSpells__ChampTimer_onExpire,Condition( function sa__WitchFirstSpells__ChampTimer_onExpire))
    set st__VJassTalentTree_hideUI=CreateTrigger()
    call TriggerAddCondition(st__VJassTalentTree_hideUI,Condition( function sa__VJassTalentTree_hideUI))
    set st__VJassTalentTree_showUI=CreateTrigger()
    call TriggerAddCondition(st__VJassTalentTree_showUI,Condition( function sa__VJassTalentTree_showUI))
    set st__StatHandler_addUnitBonus=CreateTrigger()
    call TriggerAddCondition(st__StatHandler_addUnitBonus,Condition( function sa__StatHandler_addUnitBonus))
    set st__StatHandler_r_compile=CreateTrigger()
    call TriggerAddCondition(st__StatHandler_r_compile,Condition( function sa__StatHandler_r_compile))
    set st__StatHandler_removeUnitBonus=CreateTrigger()
    call TriggerAddCondition(st__StatHandler_removeUnitBonus,Condition( function sa__StatHandler_removeUnitBonus))
    set st__StatHandler_getUnitBonus=CreateTrigger()
    call TriggerAddCondition(st__StatHandler_getUnitBonus,Condition( function sa__StatHandler_getUnitBonus))
    set st__StatHandler_getUnitResistance=CreateTrigger()
    call TriggerAddCondition(st__StatHandler_getUnitResistance,Condition( function sa__StatHandler_getUnitResistance))
    set st__Listener_interactCondition=CreateTrigger()
    call TriggerAddCondition(st__Listener_interactCondition,Condition( function sa__Listener_interactCondition))
    set st__CustomInventory_setOnRecipe=CreateTrigger()
    call TriggerAddCondition(st__CustomInventory_setOnRecipe,Condition( function sa__CustomInventory_setOnRecipe))
    set st__CustomInventory_linkItemTraitData=CreateTrigger()
    call TriggerAddCondition(st__CustomInventory_linkItemTraitData,Condition( function sa__CustomInventory_linkItemTraitData))
    set st__CustomInventory_getItemTraitData=CreateTrigger()
    call TriggerAddCondition(st__CustomInventory_getItemTraitData,Condition( function sa__CustomInventory_getItemTraitData))
    set st__CustomInventory_doesUnitHaveItemInEq=CreateTrigger()
    call TriggerAddCondition(st__CustomInventory_doesUnitHaveItemInEq,Condition( function sa__CustomInventory_doesUnitHaveItemInEq))
    set st__CustomInventory_gather=CreateTrigger()
    call TriggerAddCondition(st__CustomInventory_gather,Condition( function sa__CustomInventory_gather))
    set st__CustomInventory_wipeSelected=CreateTrigger()
    call TriggerAddCondition(st__CustomInventory_wipeSelected,Condition( function sa__CustomInventory_wipeSelected))
    set st__CustomInventory_wipeHovered=CreateTrigger()
    call TriggerAddCondition(st__CustomInventory_wipeHovered,Condition( function sa__CustomInventory_wipeHovered))
    set st__CustomInventory_moveFromRecipe=CreateTrigger()
    call TriggerAddCondition(st__CustomInventory_moveFromRecipe,Condition( function sa__CustomInventory_moveFromRecipe))
    set st__CustomInventory_removeEqWithoutAdd=CreateTrigger()
    call TriggerAddCondition(st__CustomInventory_removeEqWithoutAdd,Condition( function sa__CustomInventory_removeEqWithoutAdd))
    set st__CustomInventory_generateNewItem=CreateTrigger()
    call TriggerAddCondition(st__CustomInventory_generateNewItem,Condition( function sa__CustomInventory_generateNewItem))
    set st__CustomInventory_initsiesss=CreateTrigger()
    call TriggerAddCondition(st__CustomInventory_initsiesss,Condition( function sa__CustomInventory_initsiesss))
    set st__CustomInventory_register=CreateTrigger()
    call TriggerAddCondition(st__CustomInventory_register,Condition( function sa__CustomInventory_register))
    set st__Recipe2_create=CreateTrigger()
    call TriggerAddCondition(st__Recipe2_create,Condition( function sa__Recipe2_create))
    set st__Recipe2_check=CreateTrigger()
    call TriggerAddCondition(st__Recipe2_check,Condition( function sa__Recipe2_check))
    set st__RecipeGroup_add=CreateTrigger()
    call TriggerAddCondition(st__RecipeGroup_add,Condition( function sa__RecipeGroup_add))
    set st__Set_addItem=CreateTrigger()
    call TriggerAddCondition(st__Set_addItem,Condition( function sa__Set_addItem))
    set st__InventoryButton_removeItem=CreateTrigger()
    call TriggerAddCondition(st__InventoryButton_removeItem,Condition( function sa__InventoryButton_removeItem))
    set st__InventoryButton_noTooltip=CreateTrigger()
    call TriggerAddCondition(st__InventoryButton_noTooltip,Condition( function sa__InventoryButton_noTooltip))
    set st__InventoryButton_desc=CreateTrigger()
    call TriggerAddCondition(st__InventoryButton_desc,Condition( function sa__InventoryButton_desc))
    set st__T2InvB_create=CreateTrigger()
    call TriggerAddCondition(st__T2InvB_create,Condition( function sa__T2InvB_create))
    set st__Item_addSet=CreateTrigger()
    call TriggerAddCondition(st__Item_addSet,Condition( function sa__Item_addSet))
    set st__Item_addRecipe=CreateTrigger()
    call TriggerAddCondition(st__Item_addRecipe,Condition( function sa__Item_addRecipe))
    set st__Item_addTrait=CreateTrigger()
    call TriggerAddCondition(st__Item_addTrait,Condition( function sa__Item_addTrait))
    set st__Item_addReq=CreateTrigger()
    call TriggerAddCondition(st__Item_addReq,Condition( function sa__Item_addReq))
    set st__Item_getTrait=CreateTrigger()
    call TriggerAddCondition(st__Item_getTrait,Condition( function sa__Item_getTrait))
    set st__Item_getReq=CreateTrigger()
    call TriggerAddCondition(st__Item_getReq,Condition( function sa__Item_getReq))
    set st__ICI_getTraitDescription=CreateTrigger()
    call TriggerAddCondition(st__ICI_getTraitDescription,Condition( function sa__ICI_getTraitDescription))
    set st__ICI_displaySetData=CreateTrigger()
    call TriggerAddCondition(st__ICI_displaySetData,Condition( function sa__ICI_displaySetData))
    set st__QuestInstance_create=CreateTrigger()
    call TriggerAddCondition(st__QuestInstance_create,Condition( function sa__QuestInstance_create))
    set st__QuestInstance_containsPlayer=CreateTrigger()
    call TriggerAddCondition(st__QuestInstance_containsPlayer,Condition( function sa__QuestInstance_containsPlayer))
    set st__QuestInstance_getStage=CreateTrigger()
    call TriggerAddCondition(st__QuestInstance_getStage,Condition( function sa__QuestInstance_getStage))
    set st__QuestInstance_start=CreateTrigger()
    call TriggerAddCondition(st__QuestInstance_start,Condition( function sa__QuestInstance_start))
    set st__QuestInstance_nextStage=CreateTrigger()
    call TriggerAddCondition(st__QuestInstance_nextStage,Condition( function sa__QuestInstance_nextStage))
    set st__QuestInstance_notifyClosure=CreateTrigger()
    call TriggerAddCondition(st__QuestInstance_notifyClosure,Condition( function sa__QuestInstance_notifyClosure))
    set st__QuestInstance_finish=CreateTrigger()
    call TriggerAddCondition(st__QuestInstance_finish,Condition( function sa__QuestInstance_finish))
    set st__QuestInstance_triggerFulfill=CreateTrigger()
    call TriggerAddCondition(st__QuestInstance_triggerFulfill,Condition( function sa__QuestInstance_triggerFulfill))
    set st__QuestInteractListener_create=CreateTrigger()
    call TriggerAddCondition(st__QuestInteractListener_create,Condition( function sa__QuestInteractListener_create))
    set st__QuestInteractListener_setLevel=CreateTrigger()
    call TriggerAddCondition(st__QuestInteractListener_setLevel,Condition( function sa__QuestInteractListener_setLevel))
    set st__QuestInteractListener_enable=CreateTrigger()
    call TriggerAddCondition(st__QuestInteractListener_enable,Condition( function sa__QuestInteractListener_enable))
    set st__QuestInteractListener_reset=CreateTrigger()
    call TriggerAddCondition(st__QuestInteractListener_reset,Condition( function sa__QuestInteractListener_reset))
    set st__QuestAPI_triggerRun=CreateTrigger()
    call TriggerAddCondition(st__QuestAPI_triggerRun,Condition( function sa__QuestAPI_triggerRun))
    set st__GameStart__Init_run=CreateTrigger()
    call TriggerAddCondition(st__GameStart__Init_run,Condition( function sa__GameStart__Init_run))
    call TriggerAddAction(st__GameStart__Init_run, function sa__GameStart__Init_run)
    set st__UnitIndexer__set_enabled=CreateTrigger()
    call TriggerAddCondition(st__UnitIndexer__set_enabled,Condition( function sa__UnitIndexer__set_enabled))
    set st__StatBoard__ConstantLoop_T32Interface___expire=CreateTrigger()
    call TriggerAddCondition(st__StatBoard__ConstantLoop_T32Interface___expire,Condition( function sa__StatBoard__ConstantLoop_T32Interface___expire))
    set st__StatBoard__ConstantLoop_onLoop=CreateTrigger()
    call TriggerAddCondition(st__StatBoard__ConstantLoop_onLoop,Condition( function sa__StatBoard__ConstantLoop_onLoop))
    set st__StatBoard__ConstantLoop_onExpire=CreateTrigger()
    call TriggerAddCondition(st__StatBoard__ConstantLoop_onExpire,Condition( function sa__StatBoard__ConstantLoop_onExpire))
    set st__ShadowTrail_remove=CreateTrigger()
    call TriggerAddCondition(st__ShadowTrail_remove,Condition( function sa__ShadowTrail_remove))
    set st__ShadowTrail_setEffect=CreateTrigger()
    call TriggerAddCondition(st__ShadowTrail_setEffect,Condition( function sa__ShadowTrail_setEffect))
    set st__ShadowTrail_setColor=CreateTrigger()
    call TriggerAddCondition(st__ShadowTrail_setColor,Condition( function sa__ShadowTrail_setColor))
    set st__ShadowTrail_setAnimationIndex=CreateTrigger()
    call TriggerAddCondition(st__ShadowTrail_setAnimationIndex,Condition( function sa__ShadowTrail_setAnimationIndex))
    set st__ShadowTrail_setFadeRate=CreateTrigger()
    call TriggerAddCondition(st__ShadowTrail_setFadeRate,Condition( function sa__ShadowTrail_setFadeRate))
    set st__ShadowTrail_setupMovingTrail=CreateTrigger()
    call TriggerAddCondition(st__ShadowTrail_setupMovingTrail,Condition( function sa__ShadowTrail_setupMovingTrail))
    set st__ShadowTrail_add=CreateTrigger()
    call TriggerAddCondition(st__ShadowTrail_add,Condition( function sa__ShadowTrail_add))
    set st__FFS_BurstCounter_T32Interface___expire=CreateTrigger()
    call TriggerAddCondition(st__FFS_BurstCounter_T32Interface___expire,Condition( function sa__FFS_BurstCounter_T32Interface___expire))
    set st__FFS_BurstCounter_onLoop=CreateTrigger()
    call TriggerAddCondition(st__FFS_BurstCounter_onLoop,Condition( function sa__FFS_BurstCounter_onLoop))
    set st__FFS_BurstCounter_onExpire=CreateTrigger()
    call TriggerAddCondition(st__FFS_BurstCounter_onExpire,Condition( function sa__FFS_BurstCounter_onExpire))
    set st__FFS_Banish_T32Interface___expire=CreateTrigger()
    call TriggerAddCondition(st__FFS_Banish_T32Interface___expire,Condition( function sa__FFS_Banish_T32Interface___expire))
    set st__FFS_Banish_onLoop=CreateTrigger()
    call TriggerAddCondition(st__FFS_Banish_onLoop,Condition( function sa__FFS_Banish_onLoop))
    set st__FFS_Banish_onExpire=CreateTrigger()
    call TriggerAddCondition(st__FFS_Banish_onExpire,Condition( function sa__FFS_Banish_onExpire))
    set st__FFS_Banish_cancel=CreateTrigger()
    call TriggerAddCondition(st__FFS_Banish_cancel,Condition( function sa__FFS_Banish_cancel))
    set st__FFS_Banish_onCollide=CreateTrigger()
    call TriggerAddCondition(st__FFS_Banish_onCollide,Condition( function sa__FFS_Banish_onCollide))
    set st__FFS_WhirlingWrath_T32Interface___expire=CreateTrigger()
    call TriggerAddCondition(st__FFS_WhirlingWrath_T32Interface___expire,Condition( function sa__FFS_WhirlingWrath_T32Interface___expire))
    set st__FFS_WhirlingWrath_onLoop=CreateTrigger()
    call TriggerAddCondition(st__FFS_WhirlingWrath_onLoop,Condition( function sa__FFS_WhirlingWrath_onLoop))
    set st__FFS_WhirlingWrath_onExpire=CreateTrigger()
    call TriggerAddCondition(st__FFS_WhirlingWrath_onExpire,Condition( function sa__FFS_WhirlingWrath_onExpire))
    set st__Catalog_create=CreateTrigger()
    call TriggerAddCondition(st__Catalog_create,Condition( function sa__Catalog_create))
    set st__Catalog_add=CreateTrigger()
    call TriggerAddCondition(st__Catalog_add,Condition( function sa__Catalog_add))
    set st__Catalog_addCatalog=CreateTrigger()
    call TriggerAddCondition(st__Catalog_addCatalog,Condition( function sa__Catalog_addCatalog))
    set st__TableArray__staticgetindex=CreateTrigger()
    call TriggerAddCondition(st__TableArray__staticgetindex,Condition( function sa__TableArray__staticgetindex))
    set st__TableArray__getindex=CreateTrigger()
    call TriggerAddCondition(st__TableArray__getindex,Condition( function sa__TableArray__getindex))
    set st__Table__get_real=CreateTrigger()
    call TriggerAddCondition(st__Table__get_real,Condition( function sa__Table__get_real))
    set st__Table__get_boolean=CreateTrigger()
    call TriggerAddCondition(st__Table__get_boolean,Condition( function sa__Table__get_boolean))
    set st__Table__get_string=CreateTrigger()
    call TriggerAddCondition(st__Table__get_string,Condition( function sa__Table__get_string))
    set st__Table__get_widget=CreateTrigger()
    call TriggerAddCondition(st__Table__get_widget,Condition( function sa__Table__get_widget))
    set st__Table__get_unit=CreateTrigger()
    call TriggerAddCondition(st__Table__get_unit,Condition( function sa__Table__get_unit))
    set st__Table__get_fogstate=CreateTrigger()
    call TriggerAddCondition(st__Table__get_fogstate,Condition( function sa__Table__get_fogstate))
    set st__Table__getindex=CreateTrigger()
    call TriggerAddCondition(st__Table__getindex,Condition( function sa__Table__getindex))
    set st__Table__setindex=CreateTrigger()
    call TriggerAddCondition(st__Table__setindex,Condition( function sa__Table__setindex))
    set st__Table_has=CreateTrigger()
    call TriggerAddCondition(st__Table_has,Condition( function sa__Table_has))
    set st__Table_remove=CreateTrigger()
    call TriggerAddCondition(st__Table_remove,Condition( function sa__Table_remove))
    set st__Table_create=CreateTrigger()
    call TriggerAddCondition(st__Table_create,Condition( function sa__Table_create))
    set st__Table_destroy=CreateTrigger()
    call TriggerAddCondition(st__Table_destroy,Condition( function sa__Table_destroy))
    set st__Table___fogstates__setindex=CreateTrigger()
    call TriggerAddCondition(st__Table___fogstates__setindex,Condition( function sa__Table___fogstates__setindex))
    set st__Table___units__getindex=CreateTrigger()
    call TriggerAddCondition(st__Table___units__getindex,Condition( function sa__Table___units__getindex))
    set st__Table___units__setindex=CreateTrigger()
    call TriggerAddCondition(st__Table___units__setindex,Condition( function sa__Table___units__setindex))
    set st__Table___widgets__getindex=CreateTrigger()
    call TriggerAddCondition(st__Table___widgets__getindex,Condition( function sa__Table___widgets__getindex))
    set st__Table___strings__getindex=CreateTrigger()
    call TriggerAddCondition(st__Table___strings__getindex,Condition( function sa__Table___strings__getindex))
    set st__Table___strings__setindex=CreateTrigger()
    call TriggerAddCondition(st__Table___strings__setindex,Condition( function sa__Table___strings__setindex))
    set st__Table___booleans__getindex=CreateTrigger()
    call TriggerAddCondition(st__Table___booleans__getindex,Condition( function sa__Table___booleans__getindex))
    set st__Table___booleans__setindex=CreateTrigger()
    call TriggerAddCondition(st__Table___booleans__setindex,Condition( function sa__Table___booleans__setindex))
    set st__Table___reals__getindex=CreateTrigger()
    call TriggerAddCondition(st__Table___reals__getindex,Condition( function sa__Table___reals__getindex))
    set st__Table___reals__setindex=CreateTrigger()
    call TriggerAddCondition(st__Table___reals__setindex,Condition( function sa__Table___reals__setindex))
    set st__HeroImage_destroy=CreateTrigger()
    call TriggerAddCondition(st__HeroImage_destroy,Condition( function sa__HeroImage_destroy))
    set st___prototype3[1]=CreateTrigger()
    call TriggerAddAction(st___prototype3[1],function sa___prototype3_s__GameStart__Init_run)
    call TriggerAddCondition(st___prototype3[1],Condition(function sa___prototype3_s__GameStart__Init_run))
    set st___prototype3[2]=CreateTrigger()
    call TriggerAddAction(st___prototype3[2],function sa___prototype3_s__vJassTTInteract_onShowUI)
    call TriggerAddCondition(st___prototype3[2],Condition(function sa___prototype3_s__vJassTTInteract_onShowUI))
    set st___prototype3[3]=CreateTrigger()
    call TriggerAddAction(st___prototype3[3],function sa___prototype3_s__vJassTTInteract_onHideUI)
    call TriggerAddCondition(st___prototype3[3],Condition(function sa___prototype3_s__vJassTTInteract_onHideUI))
    set st___prototype3[4]=CreateTrigger()
    call TriggerAddAction(st___prototype3[4],function sa___prototype3_s__vJassTTInteract_onHover)
    call TriggerAddCondition(st___prototype3[4],Condition(function sa___prototype3_s__vJassTTInteract_onHover))
    set st___prototype3[5]=CreateTrigger()
    call TriggerAddAction(st___prototype3[5],function sa___prototype3_s__vJassTTInteract_onClick)
    call TriggerAddCondition(st___prototype3[5],Condition(function sa___prototype3_s__vJassTTInteract_onClick))


call ExecuteFunc("s__Ascii__Inits_Ascii__Init___onInit")











call ExecuteFunc("s__ClosestWidget_GetClosestWidget___Init___onInit")



call ExecuteFunc("s__Party_PartyLib__init___onInit")

call ExecuteFunc("s__PartyInvitationRequest_PartyLib__init2___onInit")

call ExecuteFunc("s__SaveCodeToHD__InitS_SaveCodeToHD__Init___onInit")


















































call ExecuteFunc("s__WorldBounds_WorldBounds___WorldBoundInit___onInit")


call ExecuteFunc("s__Base_Base__Init___onInit")

call ExecuteFunc("s__Catalog___S_Catalog___N___onInit")




call ExecuteFunc("s__FFS_WhirlingWrath_T32Interface___onInit")

call ExecuteFunc("s__FFS_Banish_T32Interface___onInit")

call ExecuteFunc("s__FFS_BurstCounter_T32Interface___onInit")


call ExecuteFunc("s__GetItemOwner___ItemLoc_GetItemOwner___init___onInit")

call ExecuteFunc("s__GetUnitCollision___init_GetUnitCollision___Initializer___onInit")

call ExecuteFunc("s__ShadowTrail___Alpha_CTLEnd___onInit")

call ExecuteFunc("s__ShadowTrail_CTLEnd___onInit")


call ExecuteFunc("s__StatBoard__ConstantLoop_T32Interface___onInit")



call ExecuteFunc("s__Track_Track___Init___onInit")



call ExecuteFunc("s__UnitIndexer_UnitIndexer___UnitIndexerInit___onInit")

call ExecuteFunc("s__UnitEvent_UnitIndexer___UnitEventInits___onInit")

call ExecuteFunc("s__BigInt_BigInt__Init___onInit")

call ExecuteFunc("s__Bonus___O_Bonus___I___onInit")

call ExecuteFunc("s__GameStart__Init_GameStart__InitMod___onInit")

call ExecuteFunc("s__LearnedAbilities_GetLearnedAbilities__M___onInit")


call ExecuteFunc("s__LifeSaver___Index_LifeSaver___Init___onInit")
call ExecuteFunc("s__LifeSaver___Index_UnitIndexStruct___onInit")


call ExecuteFunc("s__PriorityEvent_PriorityEvent___PriorityEventMod___onInit")










call ExecuteFunc("s__DDS_DamageEventModification___OnDeath_DDS_DamageEventModification___Init___onInit")

call ExecuteFunc("s__DDS_DamageEventModification___Deindex_UnitIndexStruct___onInit")






call ExecuteFunc("s__DDS_TriggerRefresh___TriggerRefreshInit_DDS_TriggerRefresh___TriggerRefreshInitModule___onInit")

call ExecuteFunc("s__DDS___DDS_Init_DDS___DDS_Init_Module___onInit")

call ExecuteFunc("s__GroupVersionCatalog__GroupFilter_GroupVersionCatalog__GroupFilterInit___onInit")


call ExecuteFunc("s__GroupVersionCatalog_GroupVersionCatalog__ItemCatalogInit___onInit")

call ExecuteFunc("s__ICI_ICI_init___onInit")











call ExecuteFunc("s__MissileList_LinkedList___onInit")

call ExecuteFunc("s__Missile_LinkedList___onInit")

call ExecuteFunc("s__NumberStack_NumberStack__NumberStackInit___onInit")

call ExecuteFunc("s__Listener_QuestListenerModule___onInit")

call ExecuteFunc("s__Scrambler__Inits_Scrambler__Init___onInit")


call ExecuteFunc("s__VJassTalentTree_fuuulibrary__initModule___onInit")

call ExecuteFunc("s__EncryptNumber__N_EncryptNumber__I___onInit")

call ExecuteFunc("s__LevelGroupSlotVersionCatalog__GroupFilter_LevelGroupSlotVersionCatalog__GroupFilterInit___onInit")




call ExecuteFunc("s__LevelGroupSlotVersionCatalog_LevelGroupSlotVersionCatalog__LevelGroupSlotVersionCatalogInit___onInit")

call ExecuteFunc("s__LevelGroupVersionCatalog__GroupFilter_LevelGroupVersionCatalog__GroupFilterInit___onInit")


call ExecuteFunc("s__LevelGroupVersionCatalog_LevelGroupVersionCatalog__LevelGroupVersionCatalogInit___onInit")

call ExecuteFunc("s__SpellChargedBolt__CB_MissileStruct___onInit")

call ExecuteFunc("s__WitchFirstSpells__MissileHandler_MissileStruct___onInit")

call ExecuteFunc("s__WitchFirstSpells__ChampTimer_T32Interface___onInit")


call ExecuteFunc("s__BurningSoul_T32Interface___onInit")

call ExecuteFunc("s__Firebomb_MissileStruct___onInit")

call ExecuteFunc("s__FlameWave_StructAttach___onInit")
call ExecuteFunc("s__FlameWave_T32Interface___onInit")
call ExecuteFunc("s__FlameWave_MissileStruct___onInit")


call ExecuteFunc("s__Pressure_T32Interface___onInit")

call ExecuteFunc("s__FlameConjuration_T32Interface___onInit")

call ExecuteFunc("s__PhoenixBarrage_MissileStruct___onInit")








call ExecuteFunc("s__Heroes_Catalog___onInit")










call ExecuteFunc("s__vJassTTInteract_VJassTT___onInit")

call ExecuteFunc("s__Test_DDS___DAMAGE_EVENT_INTERFACE___onInit")

call ExecuteFunc("s__UnitRespawn_UnitIndexStruct___onInit")

    call ExecuteFunc("s__ShadowTrail_onInit")
    call ExecuteFunc("s__StringSize_onInit")
    call ExecuteFunc("s__Thread_onInit")
    call ExecuteFunc("s__QuestAPI_onInit")
    call ExecuteFunc("s__QuestMain_onInit")
    call ExecuteFunc("s__SpellChargedBolt__CB_onInit")
    call ExecuteFunc("s__WitchFirstSpells__BathMain_onInit")
    call ExecuteFunc("s__Demo_onInit")
    call ExecuteFunc("s__ItemRoots_onInit")
    call ExecuteFunc("s__Heroes_onInit")
    call ExecuteFunc("s__Borders_onInit")
    call ExecuteFunc("s__vJassTTInteract_onInit")
    call ExecuteFunc("s__UnitRespawn_onInit")
endfunction
